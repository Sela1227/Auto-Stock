"""
å€‹äººæŠ•è³‡è¨˜éŒ„ API è·¯ç”±
ğŸ”§ P0ä¿®å¾©ï¼šä½¿ç”¨çµ±ä¸€èªè­‰æ¨¡çµ„
"""
from datetime import date, datetime
from typing import Optional, List
from pydantic import BaseModel, Field
import logging
import json
import csv
import io

from fastapi import APIRouter, Depends, HTTPException, Request, Query
from fastapi.responses import StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession

from app.database import get_async_session
from app.services.portfolio_service import PortfolioService
from app.services.exchange_rate_service import get_exchange_rate, set_exchange_rate
from app.models.user import User

# ğŸ”§ ä½¿ç”¨çµ±ä¸€èªè­‰æ¨¡çµ„
from app.dependencies import get_current_user

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/portfolio", tags=["å€‹äººæŠ•è³‡è¨˜éŒ„"])


# ============================================================
# Pydantic Schemas
# ============================================================

class TransactionCreate(BaseModel):
    """æ–°å¢äº¤æ˜“è«‹æ±‚"""
    symbol: str = Field(..., min_length=1, max_length=20, description="è‚¡ç¥¨ä»£ç¢¼")
    name: Optional[str] = Field(None, max_length=100, description="è‚¡ç¥¨åç¨±")
    market: str = Field(..., pattern="^(tw|us)$", description="å¸‚å ´ (tw/us)")
    transaction_type: str = Field(..., pattern="^(buy|sell)$", description="äº¤æ˜“é¡å‹ (buy/sell)")
    quantity: int = Field(..., gt=0, description="è‚¡æ•¸ï¼ˆå°è‚¡ï¼šå¼µÃ—1000 + é›¶è‚¡ï¼‰")
    price: float = Field(..., gt=0, description="æˆäº¤åƒ¹")
    fee: Optional[float] = Field(0, ge=0, description="æ‰‹çºŒè²»")
    tax: Optional[float] = Field(0, ge=0, description="äº¤æ˜“ç¨…")
    transaction_date: date = Field(..., description="äº¤æ˜“æ—¥æœŸ")
    note: Optional[str] = Field(None, max_length=500, description="å‚™è¨»")
    broker_id: Optional[int] = Field(None, description="åˆ¸å•† ID")


class TransactionUpdate(BaseModel):
    """æ›´æ–°äº¤æ˜“è«‹æ±‚"""
    symbol: Optional[str] = Field(None, min_length=1, max_length=20)
    name: Optional[str] = Field(None, max_length=100)
    market: Optional[str] = Field(None, pattern="^(tw|us)$")
    transaction_type: Optional[str] = Field(None, pattern="^(buy|sell)$")
    quantity: Optional[int] = Field(None, gt=0)
    price: Optional[float] = Field(None, gt=0)
    fee: Optional[float] = Field(None, ge=0)
    tax: Optional[float] = Field(None, ge=0)
    transaction_date: Optional[date] = None
    note: Optional[str] = Field(None, max_length=500)
    broker_id: Optional[int] = None


class ExchangeRateUpdate(BaseModel):
    """æ›´æ–°åŒ¯ç‡è«‹æ±‚"""
    rate: float = Field(..., gt=0, description="USD/TWD åŒ¯ç‡")


class TransactionImportItem(BaseModel):
    symbol: str
    name: Optional[str] = None
    market: str = "tw"
    transaction_type: str = "buy"
    quantity: int
    price: float
    fee: Optional[float] = 0
    tax: Optional[float] = 0
    transaction_date: str  # YYYY-MM-DD format
    note: Optional[str] = None


class TransactionImportRequest(BaseModel):
    items: List[TransactionImportItem]


# ============================================================
# åŒ¯å‡ºåŒ¯å…¥ API
# ============================================================

@router.get("/export", summary="åŒ¯å‡ºäº¤æ˜“è¨˜éŒ„")
async def export_transactions(
    format: str = "json",
    market: Optional[str] = Query(None, pattern="^(tw|us)$"),
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    åŒ¯å‡ºç”¨æˆ¶çš„äº¤æ˜“è¨˜éŒ„
    
    - format: json æˆ– csv
    - market: é¸æ“‡æ€§ç¯©é¸å¸‚å ´ (tw/us)
    """
    logger.info(f"API: åŒ¯å‡ºäº¤æ˜“è¨˜éŒ„ - user_id={user.id}, format={format}, market={market}")

    try:
        service = PortfolioService(db)
        transactions = await service.get_transactions(
            user_id=user.id,
            market=market,
            limit=9999,
            offset=0,
        )

        if not transactions:
            raise HTTPException(status_code=404, detail="äº¤æ˜“è¨˜éŒ„ç‚ºç©º")

        # æº–å‚™åŒ¯å‡ºè³‡æ–™
        export_data = []
        for t in transactions:
            export_data.append({
                "symbol": t.symbol,
                "name": t.name or "",
                "market": t.market,
                "transaction_type": t.transaction_type,
                "quantity": t.quantity,
                "price": float(t.price),
                "fee": float(t.fee) if t.fee else 0,
                "tax": float(t.tax) if t.tax else 0,
                "transaction_date": t.transaction_date.isoformat() if t.transaction_date else "",
                "note": t.note or "",
            })

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        market_suffix = f"_{market}" if market else ""

        if format.lower() == "csv":
            # CSV æ ¼å¼
            output = io.StringIO()
            fieldnames = ["symbol", "name", "market", "transaction_type", "quantity", 
                         "price", "fee", "tax", "transaction_date", "note"]
            writer = csv.DictWriter(output, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(export_data)
            
            return StreamingResponse(
                iter([output.getvalue()]),
                media_type="text/csv",
                headers={
                    "Content-Disposition": f"attachment; filename=portfolio{market_suffix}_{timestamp}.csv"
                }
            )
        else:
            # JSON æ ¼å¼
            json_str = json.dumps({
                "export_time": datetime.now().isoformat(),
                "market": market,
                "total": len(export_data),
                "items": export_data
            }, ensure_ascii=False, indent=2)
            
            return StreamingResponse(
                iter([json_str]),
                media_type="application/json",
                headers={
                    "Content-Disposition": f"attachment; filename=portfolio{market_suffix}_{timestamp}.json"
                }
            )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"åŒ¯å‡ºäº¤æ˜“è¨˜éŒ„å¤±æ•—: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/import", summary="åŒ¯å…¥äº¤æ˜“è¨˜éŒ„")
async def import_transactions(
    data: TransactionImportRequest,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    åŒ¯å…¥äº¤æ˜“è¨˜éŒ„
    
    - é€ç­†æ–°å¢äº¤æ˜“è¨˜éŒ„
    - è¿”å›æˆåŠŸ/å¤±æ•—çš„çµ±è¨ˆ
    """
    logger.info(f"API: åŒ¯å…¥äº¤æ˜“è¨˜éŒ„ - user_id={user.id}, items={len(data.items)}")

    try:
        service = PortfolioService(db)
        added = []
        errors = []

        for item in data.items:
            try:
                # è§£ææ—¥æœŸ
                trans_date = datetime.strptime(item.transaction_date, "%Y-%m-%d").date()
                
                transaction = await service.create_transaction(
                    user_id=user.id,
                    symbol=item.symbol.upper().strip(),
                    name=item.name,
                    market=item.market,
                    transaction_type=item.transaction_type,
                    quantity=item.quantity,
                    price=item.price,
                    fee=item.fee or 0,
                    tax=item.tax or 0,
                    transaction_date=trans_date,
                    note=item.note,
                )
                added.append({
                    "id": transaction.id,
                    "symbol": transaction.symbol,
                    "transaction_type": transaction.transaction_type,
                })
            except Exception as e:
                errors.append({
                    "symbol": item.symbol,
                    "date": item.transaction_date,
                    "error": str(e)
                })

        return {
            "success": True,
            "message": f"åŒ¯å…¥å®Œæˆï¼šæˆåŠŸ {len(added)} ç­†ï¼Œå¤±æ•— {len(errors)} ç­†",
            "data": {
                "added": added,
                "errors": errors,
                "total_added": len(added),
                "total_errors": len(errors),
            }
        }

    except Exception as e:
        logger.error(f"åŒ¯å…¥äº¤æ˜“è¨˜éŒ„å¤±æ•—: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================
# åŒ¯ç‡ API
# ============================================================

@router.get("/exchange-rate", summary="å–å¾—åŒ¯ç‡")
async def get_rate(
    db: AsyncSession = Depends(get_async_session),
):
    """å–å¾—ç›®å‰çš„ USD/TWD åŒ¯ç‡"""
    rate_info = await get_exchange_rate(db)
    return {
        "success": True,
        "data": rate_info,
    }


@router.put("/exchange-rate", summary="è¨­å®šåŒ¯ç‡")
async def update_rate(
    data: ExchangeRateUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """æ‰‹å‹•è¨­å®š USD/TWD åŒ¯ç‡"""
    rate_info = await set_exchange_rate(db, data.rate)
    return {
        "success": True,
        "message": "åŒ¯ç‡å·²æ›´æ–°",
        "data": rate_info,
    }


# ============================================================
# äº¤æ˜“ç´€éŒ„ API
# ============================================================

@router.post("/transactions", summary="æ–°å¢äº¤æ˜“ç´€éŒ„")
async def create_transaction(
    data: TransactionCreate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    æ–°å¢ä¸€ç­†è‚¡ç¥¨äº¤æ˜“ç´€éŒ„
    
    - **symbol**: è‚¡ç¥¨ä»£ç¢¼ï¼ˆå¦‚ AAPLã€2330ï¼‰
    - **market**: å¸‚å ´é¡å‹ï¼ˆtw=å°è‚¡, us=ç¾è‚¡ï¼‰
    - **transaction_type**: buy=è²·å…¥, sell=è³£å‡º
    - **quantity**: ç¸½è‚¡æ•¸ï¼ˆå°è‚¡ï¼šå¼µÃ—1000 + é›¶è‚¡ï¼‰
    - **price**: æˆäº¤åƒ¹
    - **fee**: æ‰‹çºŒè²»ï¼ˆå¯é¸ï¼‰
    - **tax**: äº¤æ˜“ç¨…ï¼ˆå¯é¸ï¼Œè³£å‡ºæ™‚ï¼‰
    """
    logger.info(f"æ–°å¢äº¤æ˜“: user={user.id}, {data.transaction_type} {data.quantity} {data.symbol}")
    
    try:
        service = PortfolioService(db)
        transaction = await service.create_transaction(
            user_id=user.id,
            symbol=data.symbol,
            name=data.name,
            market=data.market,
            transaction_type=data.transaction_type,
            quantity=data.quantity,
            price=data.price,
            fee=data.fee or 0,
            tax=data.tax or 0,
            transaction_date=data.transaction_date,
            note=data.note,
        )
        
        return {
            "success": True,
            "message": "äº¤æ˜“ç´€éŒ„å·²æ–°å¢",
            "data": transaction.to_dict(),
        }
        
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"æ–°å¢äº¤æ˜“å¤±æ•—: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="æ–°å¢äº¤æ˜“å¤±æ•—")


@router.get("/transactions", summary="å–å¾—äº¤æ˜“ç´€éŒ„")
async def get_transactions(
    market: Optional[str] = Query(None, pattern="^(tw|us)$", description="ç¯©é¸å¸‚å ´"),
    symbol: Optional[str] = Query(None, description="ç¯©é¸è‚¡ç¥¨"),
    limit: int = Query(100, ge=1, le=500, description="ç­†æ•¸ä¸Šé™"),
    offset: int = Query(0, ge=0, description="åç§»é‡"),
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """å–å¾—ç”¨æˆ¶çš„äº¤æ˜“ç´€éŒ„åˆ—è¡¨"""
    try:
        service = PortfolioService(db)
        transactions = await service.get_transactions(
            user_id=user.id,
            market=market,
            symbol=symbol,
            limit=limit,
            offset=offset,
        )
        
        return {
            "success": True,
            "data": [t.to_dict() for t in transactions],
            "total": len(transactions),
        }
        
    except Exception as e:
        logger.error(f"å–å¾—äº¤æ˜“ç´€éŒ„å¤±æ•—: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="å–å¾—äº¤æ˜“ç´€éŒ„å¤±æ•—")


@router.get("/transactions/{transaction_id}", summary="å–å¾—å–®ç­†äº¤æ˜“")
async def get_transaction(
    transaction_id: int,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """å–å¾—å–®ç­†äº¤æ˜“ç´€éŒ„è©³æƒ…"""
    service = PortfolioService(db)
    transaction = await service.get_transaction(transaction_id, user.id)
    
    if not transaction:
        raise HTTPException(status_code=404, detail="æ‰¾ä¸åˆ°äº¤æ˜“ç´€éŒ„")
    
    return {
        "success": True,
        "data": transaction.to_dict(),
    }


@router.put("/transactions/{transaction_id}", summary="æ›´æ–°äº¤æ˜“ç´€éŒ„")
async def update_transaction(
    transaction_id: int,
    data: TransactionUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """æ›´æ–°äº¤æ˜“ç´€éŒ„"""
    logger.info(f"æ›´æ–°äº¤æ˜“: user={user.id}, id={transaction_id}")
    
    try:
        service = PortfolioService(db)
        
        # åªå‚³å…¥æœ‰å€¼çš„æ¬„ä½
        update_data = {k: v for k, v in data.dict().items() if v is not None}
        
        transaction = await service.update_transaction(
            transaction_id=transaction_id,
            user_id=user.id,
            **update_data,
        )
        
        if not transaction:
            raise HTTPException(status_code=404, detail="æ‰¾ä¸åˆ°äº¤æ˜“ç´€éŒ„")
        
        return {
            "success": True,
            "message": "äº¤æ˜“ç´€éŒ„å·²æ›´æ–°",
            "data": transaction.to_dict(),
        }
        
    except HTTPException:
        raise
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"æ›´æ–°äº¤æ˜“å¤±æ•—: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="æ›´æ–°äº¤æ˜“å¤±æ•—")


@router.delete("/transactions/{transaction_id}", summary="åˆªé™¤äº¤æ˜“ç´€éŒ„")
async def delete_transaction(
    transaction_id: int,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """åˆªé™¤äº¤æ˜“ç´€éŒ„"""
    logger.info(f"åˆªé™¤äº¤æ˜“: user={user.id}, id={transaction_id}")
    
    service = PortfolioService(db)
    success = await service.delete_transaction(transaction_id, user.id)
    
    if not success:
        raise HTTPException(status_code=404, detail="æ‰¾ä¸åˆ°äº¤æ˜“ç´€éŒ„")
    
    return {
        "success": True,
        "message": "äº¤æ˜“ç´€éŒ„å·²åˆªé™¤",
    }


# ============================================================
# æŒè‚¡ API
# ============================================================

@router.get("/holdings", summary="å–å¾—æŒè‚¡ç¸½è¦½")
async def get_holdings(
    market: Optional[str] = Query(None, pattern="^(tw|us)$", description="ç¯©é¸å¸‚å ´"),
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    å–å¾—ç”¨æˆ¶çš„æŒè‚¡åˆ—è¡¨ï¼ˆå«ç¾åƒ¹å’Œæç›Šï¼‰
    
    - ç¾åƒ¹ä¾†è‡ªåƒ¹æ ¼å¿«å–
    - åŒ…å«æœªå¯¦ç¾æç›Šè¨ˆç®—
    """
    try:
        service = PortfolioService(db)
        holdings = await service.get_holdings_with_prices(user.id, market)
        
        # åˆ†é¡
        tw_holdings = [h for h in holdings if h['market'] == 'tw' and h['total_shares'] > 0]
        us_holdings = [h for h in holdings if h['market'] == 'us' and h['total_shares'] > 0]
        
        return {
            "success": True,
            "data": {
                "tw": tw_holdings,
                "us": us_holdings,
            },
            "total": len(tw_holdings) + len(us_holdings),
        }
        
    except Exception as e:
        logger.error(f"å–å¾—æŒè‚¡å¤±æ•—: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="å–å¾—æŒè‚¡å¤±æ•—")


@router.get("/summary", summary="å–å¾—æŠ•è³‡æ‘˜è¦")
async def get_summary(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    å–å¾—æŠ•è³‡çµ„åˆæ‘˜è¦çµ±è¨ˆ
    
    åŒ…å«ï¼š
    - åŒ¯ç‡è³‡è¨Š
    - å°è‚¡çµ±è¨ˆ
    - ç¾è‚¡çµ±è¨ˆ
    - ç¸½è¨ˆï¼ˆæ›ç®— TWDï¼‰
    """
    try:
        service = PortfolioService(db)
        summary = await service.get_summary(user.id)
        
        return {
            "success": True,
            "data": summary,
        }
        
    except Exception as e:
        logger.error(f"å–å¾—æŠ•è³‡æ‘˜è¦å¤±æ•—: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="å–å¾—æŠ•è³‡æ‘˜è¦å¤±æ•—")
