"""
å¸‚å ´æœå‹™
è™•ç†ä¸‰å¤§æŒ‡æ•¸ã€å¸‚å ´æƒ…ç·’çš„è³‡æ–™å­˜å–
"""
import pandas as pd
from datetime import datetime, date, timedelta
from typing import Optional, Dict, Any, List
from sqlalchemy.orm import Session
from sqlalchemy import select, and_, desc
import logging

from app.models.index_price import IndexPrice, INDEX_SYMBOLS
from app.models.market_sentiment import MarketSentiment
from app.models.dividend_history import DividendHistory
from app.models.stock_price import StockPrice
from app.data_sources.yahoo_finance import yahoo_finance
from app.data_sources.fear_greed import fear_greed

logger = logging.getLogger(__name__)


class MarketService:
    """å¸‚å ´æœå‹™"""
    
    def __init__(self, db: Session):
        self.db = db
    
    # ==================== ä¸‰å¤§æŒ‡æ•¸ ====================
    
    def get_latest_indices(self) -> Dict[str, Any]:
        """å–å¾—ä¸‰å¤§æŒ‡æ•¸æœ€æ–°è³‡æ–™ï¼Œå›žå‚³å­—å…¸æ ¼å¼"""
        result = {}
        
        for symbol, info in INDEX_SYMBOLS.items():
            try:
                stmt = (
                    select(IndexPrice)
                    .where(IndexPrice.symbol == symbol)
                    .order_by(desc(IndexPrice.date))
                    .limit(1)
                )
                latest = self.db.execute(stmt).scalar_one_or_none()
                
                if latest:
                    result[symbol] = latest.to_dict()
                    continue
            except Exception as e:
                logger.warning(f"å¾žè³‡æ–™åº«å–å¾— {symbol} å¤±æ•—: {e}")
            
            # Fallback: å¾ž Yahoo Finance API å–å¾—
            try:
                df = yahoo_finance.get_index_data(symbol, period="5d")
                if df is not None and not df.empty:
                    row = df.iloc[-1]
                    result[symbol] = {
                        "symbol": symbol,
                        "name": info["name"],
                        "name_zh": info["name_zh"],
                        "date": str(row["date"]),
                        "close": float(row["close"]),
                        "change": float(row["change"]) if pd.notna(row.get("change")) else None,
                        "change_pct": float(row["change_pct"]) if pd.notna(row.get("change_pct")) else None,
                    }
                    logger.info(f"å¾ž API å–å¾— {symbol}: {result[symbol]['close']}")
            except Exception as e:
                logger.error(f"å¾ž API å–å¾— {symbol} å¤±æ•—: {e}")
        
        return result
    
    def get_index_history(
        self,
        symbol: str,
        days: int = 365,
    ) -> List[Dict[str, Any]]:
        """å–å¾—æŒ‡æ•¸æ­·å²è³‡æ–™"""
        start_date = date.today() - timedelta(days=days)
        
        stmt = (
            select(IndexPrice)
            .where(
                and_(
                    IndexPrice.symbol == symbol,
                    IndexPrice.date >= start_date,
                )
            )
            .order_by(IndexPrice.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        return [r.to_dict() for r in results]
    
    def save_index_data(self, df: pd.DataFrame, symbol: str) -> int:
        """
        å„²å­˜æŒ‡æ•¸è³‡æ–™åˆ°è³‡æ–™åº«
        
        Returns:
            å„²å­˜çš„ç­†æ•¸
        """
        import math
        
        def clean_value(val):
            """æ¸…ç†å€¼ï¼Œå°‡ NaN/Inf è½‰ç‚º None"""
            if val is None:
                return None
            if pd.isna(val):
                return None
            try:
                f = float(val)
                if math.isnan(f) or math.isinf(f):
                    return None
                return f
            except (ValueError, TypeError):
                return None
        
        if df is None or df.empty:
            return 0
        
        count = 0
        index_info = INDEX_SYMBOLS.get(symbol, {})
        
        for _, row in df.iterrows():
            # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
            stmt = select(IndexPrice).where(
                and_(
                    IndexPrice.symbol == symbol,
                    IndexPrice.date == row["date"],
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if existing:
                # æ›´æ–°ç¾æœ‰è³‡æ–™
                existing.open = clean_value(row.get("open"))
                existing.high = clean_value(row.get("high"))
                existing.low = clean_value(row.get("low"))
                existing.close = clean_value(row.get("close"))
                existing.volume = row.get("volume")
                existing.change = clean_value(row.get("change"))
                existing.change_pct = clean_value(row.get("change_pct"))
            else:
                # æ–°å¢žè³‡æ–™
                price = IndexPrice(
                    symbol=symbol,
                    name=index_info.get("name", symbol),
                    date=row["date"],
                    open=clean_value(row.get("open")),
                    high=clean_value(row.get("high")),
                    low=clean_value(row.get("low")),
                    close=clean_value(row.get("close")),
                    volume=row.get("volume"),
                    change=clean_value(row.get("change")),
                    change_pct=clean_value(row.get("change_pct")),
                )
                self.db.add(price)
                count += 1
        
        self.db.commit()
        return count
    
    def fetch_and_save_all_indices(self, period: str = "10y") -> Dict[str, int]:
        """
        æŠ“å–ä¸¦å„²å­˜æ‰€æœ‰ä¸‰å¤§æŒ‡æ•¸è³‡æ–™
        
        Returns:
            {symbol: å„²å­˜ç­†æ•¸}
        """
        result = {}
        
        for symbol in INDEX_SYMBOLS.keys():
            logger.info(f"æŠ“å–æŒ‡æ•¸è³‡æ–™: {symbol}")
            df = yahoo_finance.get_index_data(symbol, period=period)
            
            if df is not None:
                count = self.save_index_data(df, symbol)
                result[symbol] = count
                logger.info(f"{symbol} æ–°å¢ž {count} ç­†è³‡æ–™")
            else:
                result[symbol] = 0
                logger.warning(f"{symbol} æŠ“å–å¤±æ•—")
        
        return result
    
    # ==================== å¸‚å ´æƒ…ç·’ ====================
    
    def get_latest_sentiment(self) -> Dict[str, Any]:
        """
        å–å¾—æœ€æ–°çš„å¸‚å ´æƒ…ç·’
        
        ðŸ”§ ä¿®å¾©ç‰ˆæœ¬ï¼š
        - å„ªå…ˆå¾žè³‡æ–™åº«è®€å–ï¼ˆæ¯«ç§’ç´šï¼‰
        - æª¢æŸ¥è³‡æ–™æ–°é®®åº¦ï¼ˆè¶…éŽ 1 å¤©æ‰é‡æ–°æŠ“å–ï¼‰
        - è³‡æ–™åº«æ²’æœ‰æ™‚æ‰å‘¼å«å¤–éƒ¨ API
        - å¾ž API å–å¾—å¾Œæœƒå­˜å…¥è³‡æ–™åº«
        """
        result = {}
        today = date.today()
        
        for market in ["stock", "crypto"]:
            # 1. å…ˆæŸ¥è³‡æ–™åº«
            stmt = (
                select(MarketSentiment)
                .where(MarketSentiment.market == market)
                .order_by(desc(MarketSentiment.date))
                .limit(1)
            )
            latest = self.db.execute(stmt).scalar_one_or_none()
            
            if latest:
                # 2. æª¢æŸ¥è³‡æ–™æ–°é®®åº¦ï¼ˆä»Šå¤©æˆ–æ˜¨å¤©çš„è³‡æ–™éƒ½å¯æŽ¥å—ï¼‰
                if latest.date >= today - timedelta(days=1):
                    result[market] = latest.to_dict()
                    logger.debug(f"[Sentiment] {market} å¾žè³‡æ–™åº«è®€å–: {latest.value}")
                    continue
                else:
                    logger.info(f"[Sentiment] {market} è³‡æ–™éŽæœŸ (date={latest.date}), å˜—è©¦æ›´æ–°...")
            else:
                logger.info(f"[Sentiment] {market} è³‡æ–™åº«ç„¡è³‡æ–™, å˜—è©¦å¾ž API æŠ“å–...")
            
            # 3. è³‡æ–™éŽæœŸæˆ–ä¸å­˜åœ¨ï¼Œå¾ž API æŠ“å–
            try:
                if market == "crypto":
                    data = fear_greed.get_crypto_fear_greed()
                else:
                    data = fear_greed.get_stock_fear_greed()
                
                if data and not data.get("is_fallback"):
                    # ðŸ†• å­˜å…¥è³‡æ–™åº«ï¼ˆä¸‹æ¬¡å°±ä¸ç”¨å†æŠ“äº†ï¼‰
                    self.save_sentiment(market, data["value"])
                    result[market] = data
                    logger.info(f"[Sentiment] {market} å¾ž API æ›´æ–°æˆåŠŸ: {data['value']}")
                elif latest:
                    # API å¤±æ•—ä½†æœ‰èˆŠè³‡æ–™ï¼Œè¿”å›žèˆŠè³‡æ–™
                    result[market] = latest.to_dict()
                    logger.warning(f"[Sentiment] {market} API å¤±æ•—ï¼Œä½¿ç”¨èˆŠè³‡æ–™")
                elif data:
                    # å®Œå…¨æ²’è³‡æ–™ï¼Œè¿”å›ž API çµæžœï¼ˆå¯èƒ½æ˜¯ fallbackï¼‰
                    result[market] = data
            except Exception as e:
                logger.error(f"[Sentiment] {market} æŠ“å–å¤±æ•—: {e}")
                if latest:
                    result[market] = latest.to_dict()
        
        return result


    def get_sentiment_history(
        self,
        market: str,
        days: int = 365,
    ) -> List[Dict[str, Any]]:
        """å–å¾—æƒ…ç·’æ­·å²è³‡æ–™"""
        start_date = date.today() - timedelta(days=days)
        
        stmt = (
            select(MarketSentiment)
            .where(
                and_(
                    MarketSentiment.market == market,
                    MarketSentiment.date >= start_date,
                )
            )
            .order_by(MarketSentiment.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        return [r.to_dict() for r in results]
    
    def save_sentiment(
        self,
        market: str,
        value: int,
        target_date: Optional[date] = None,
    ) -> bool:
        """
        å„²å­˜å¸‚å ´æƒ…ç·’è³‡æ–™
        """
        if target_date is None:
            target_date = date.today()
        
        # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
        stmt = select(MarketSentiment).where(
            and_(
                MarketSentiment.market == market,
                MarketSentiment.date == target_date,
            )
        )
        existing = self.db.execute(stmt).scalar_one_or_none()
        
        classification = MarketSentiment.get_classification(value)
        
        if existing:
            existing.value = value
            existing.classification = classification
        else:
            sentiment = MarketSentiment(
                date=target_date,
                market=market,
                value=value,
                classification=classification,
            )
            self.db.add(sentiment)
        
        self.db.commit()
        return True
    
    def fetch_and_save_crypto_history(self, days: int = 365) -> int:
        """
        æŠ“å–ä¸¦å„²å­˜å¹£åœˆæƒ…ç·’æ­·å²è³‡æ–™
        
        Returns:
            å„²å­˜çš„ç­†æ•¸
        """
        logger.info(f"æŠ“å–å¹£åœˆæƒ…ç·’æ­·å²: {days} å¤©")
        history = fear_greed.get_crypto_fear_greed_history(days)
        
        count = 0
        for item in history:
            try:
                target_date = datetime.strptime(item["date"], "%Y-%m-%d").date()
                
                # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                stmt = select(MarketSentiment).where(
                    and_(
                        MarketSentiment.market == "crypto",
                        MarketSentiment.date == target_date,
                    )
                )
                existing = self.db.execute(stmt).scalar_one_or_none()
                
                if not existing:
                    sentiment = MarketSentiment(
                        date=target_date,
                        market="crypto",
                        value=item["value"],
                        classification=item["classification"],
                    )
                    self.db.add(sentiment)
                    count += 1
            except Exception as e:
                logger.error(f"å„²å­˜æƒ…ç·’è³‡æ–™å¤±æ•—: {e}")
        
        self.db.commit()
        logger.info(f"å¹£åœˆæƒ…ç·’æ­·å²æ–°å¢ž {count} ç­†")
        return count
    
    def update_today_sentiment(self) -> Dict[str, bool]:
        """
        æ›´æ–°ä»Šæ—¥çš„å¸‚å ´æƒ…ç·’
        
        Returns:
            {market: success}
        """
        result = {}
        
        # ç¾Žè‚¡æƒ…ç·’
        stock_data = fear_greed.get_stock_fear_greed()
        if stock_data and not stock_data.get("is_fallback"):
            result["stock"] = self.save_sentiment("stock", stock_data["value"])
        else:
            result["stock"] = False
        
        # å¹£åœˆæƒ…ç·’
        crypto_data = fear_greed.get_crypto_fear_greed()
        if crypto_data and not crypto_data.get("is_fallback"):
            result["crypto"] = self.save_sentiment("crypto", crypto_data["value"])
        else:
            result["crypto"] = False
        
        return result
    
    # ==================== é…æ¯è³‡æ–™ ====================
    
    def save_dividends(self, df: pd.DataFrame) -> int:
        """
        å„²å­˜é…æ¯è³‡æ–™
        
        Returns:
            å„²å­˜çš„ç­†æ•¸
        """
        if df is None or df.empty:
            return 0
        
        count = 0
        for _, row in df.iterrows():
            # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
            stmt = select(DividendHistory).where(
                and_(
                    DividendHistory.symbol == row["symbol"],
                    DividendHistory.date == row["date"],
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if not existing:
                dividend = DividendHistory(
                    symbol=row["symbol"],
                    date=row["date"],
                    amount=row["amount"],
                )
                self.db.add(dividend)
                count += 1
        
        self.db.commit()
        return count
    
    def fetch_and_save_dividends(self, symbol: str, period: str = "10y") -> int:
        """
        æŠ“å–ä¸¦å„²å­˜é…æ¯è³‡æ–™
        """
        logger.info(f"æŠ“å–é…æ¯è³‡æ–™: {symbol}")
        df = yahoo_finance.get_dividends(symbol, period=period)
        
        if df is not None:
            count = self.save_dividends(df)
            logger.info(f"{symbol} é…æ¯æ–°å¢ž {count} ç­†")
            return count
        
        return 0
    
    def get_dividends(
        self,
        symbol: str,
        years: int = 10,
    ) -> List[Dict[str, Any]]:
        """å–å¾—é…æ¯æ­·å²"""
        start_date = date.today() - timedelta(days=years * 365)
        
        stmt = (
            select(DividendHistory)
            .where(
                and_(
                    DividendHistory.symbol == symbol.upper(),
                    DividendHistory.date >= start_date,
                )
            )
            .order_by(DividendHistory.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        return [r.to_dict() for r in results]
