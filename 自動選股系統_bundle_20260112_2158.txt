======================================================================
# 專案：自動選股系統
# 整合時間：2026-01-12 21:58:13
# 檔案數量：67
======================================================================

## 📂 目錄結構

```
自動選股系統/
├── app/
│   ├── data_sources/
│   │   ├── __init__.py
│   │   ├── coingecko.py
│   │   ├── fear_greed.py
│   │   └── yahoo_finance.py
│   ├── models/
│   │   ├── __init__.py
│   │   ├── comparison.py
│   │   ├── crypto_price.py
│   │   ├── dividend_history.py
│   │   ├── index_price.py
│   │   ├── market_sentiment.py
│   │   ├── notification.py
│   │   ├── price_cache.py
│   │   ├── stock_price.py
│   │   ├── user.py
│   │   ├── user_settings.py
│   │   └── watchlist.py
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── admin.py
│   │   ├── auth.py
│   │   ├── compare.py
│   │   ├── crypto.py
│   │   ├── market.py
│   │   ├── settings.py
│   │   ├── stock.py
│   │   ├── watchlist.py
│   │   └── watchlist_cache_api.py
│   ├── schemas/
│   │   ├── __init__.py
│   │   └── schemas.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── auth_service.py
│   │   ├── chart_service.py
│   │   ├── compare_service.py
│   │   ├── crypto_service.py
│   │   ├── indicator_service.py
│   │   ├── line_notify_service.py
│   │   ├── market_service.py
│   │   ├── notification_service.py
│   │   ├── price_cache_service.py
│   │   ├── signal_service.py
│   │   ├── stock_service.py
│   │   └── watchlist_service.py
│   ├── tasks/
│   │   ├── __init__.py
│   │   ├── price_cache_task.py
│   │   └── scheduler.py
│   ├── __init__.py
│   ├── cli.py
│   ├── config.py
│   ├── database.py
│   ├── logging_config.py
│   └── main.py
├── frontend/
│   └── watchlist_with_cache.js
├── migrations/
├── scripts/
│   └── 匯整子程式.py
├── static/
│   ├── admin.html
│   ├── compare-nav.js
│   ├── compare.html
│   ├── dashboard-mobile.html
│   ├── dashboard.html
│   ├── index.html
│   ├── logo.png
│   └── SELA-Bug修復記錄.md
├── 更新檔/
├── .gitignore
├── CHANGELOG.md
├── Procfile
├── railway.json
├── RAILWAY_SETUP.md
├── README.md
├── requirements.txt
├── runtime.txt
├── 匯整專案 V2 .py
└── 自動選股系統_bundle_20260112_2158.txt
```

======================================================================
## 📑 檔案索引

| 層級 | 檔案 | 說明 | 重要度 |
|------|------|------|--------|
| 📋 | `CHANGELOG.md` | Changelog | ⭐⭐⭐ |
| 📋 | `README.md` | 🚀 價格快取功能 - 完整整合包 | ⭐⭐⭐ |
| ⚙️ | `app/config.py` | 應用程式設定檔 | ⭐⭐ |
| ⚙️ | `app/routers/settings.py` | 設定管理 API 路由 | ⭐⭐ |
| ⚙️ | `Procfile` |  | ⭐⭐ |
| ⚙️ | `requirements.txt` | Core Framework | ⭐⭐⭐ |
| 🚀 | `app/main.py` | FastAPI 主程式 | ⭐⭐⭐ |
| 🌐 | `app/routers/__init__.py` | API 路由模組 | ⭐⭐⭐ |
| 🌐 | `app/routers/admin.py` | 管理員 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/auth.py` | 認證 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/compare.py` | 報酬率比較 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/crypto.py` | 加密貨幣和市場情緒 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/market.py` | 市場資料 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/stock.py` | 股票查詢 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/watchlist.py` | 追蹤清單 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/watchlist_cache_api.py` | 追蹤清單 API - 含價格快取版本 | ⭐⭐⭐ |
| 📦 | `app/database.py` | 資料庫連線與 Session 管理 | ⭐⭐ |
| 📦 | `app/models/__init__.py` | 資料模型 | ⭐⭐ |
| 📦 | `app/models/comparison.py` | 報酬率比較組合 Model | ⭐⭐ |
| 📦 | `app/models/crypto_price.py` | 加密貨幣價格歷史資料模型 | ⭐⭐ |
| 📦 | `app/models/dividend_history.py` | 股票配息歷史資料模型 | ⭐⭐ |
| 📦 | `app/models/index_price.py` | 市場指數價格歷史資料模型 | ⭐⭐ |
| 📦 | `app/models/market_sentiment.py` | 市場情緒指數資料模型 | ⭐⭐ |
| 📦 | `app/models/notification.py` | 通知記錄資料模型 | ⭐⭐ |
| 📦 | `app/models/price_cache.py` | 股票價格快取 Model | ⭐⭐ |
| 📦 | `app/models/stock_price.py` | 股票價格歷史資料模型 | ⭐⭐ |
| 📦 | `app/models/user.py` | 用戶資料模型 | ⭐⭐ |
| 📦 | `app/models/user_settings.py` | 用戶設定資料模型 | ⭐⭐ |
| 📦 | `app/models/watchlist.py` | 追蹤清單資料模型 | ⭐⭐ |
| 📦 | `app/schemas/__init__.py` | Pydantic Schemas | ⭐⭐ |
| 📦 | `app/schemas/schemas.py` | Pydantic Schemas | ⭐⭐ |
| 🧠 | `app/services/__init__.py` | 商業邏輯服務模組 | ⭐⭐⭐ |
| 🧠 | `app/services/auth_service.py` | 認證服務 | ⭐⭐⭐ |
| 🧠 | `app/services/chart_service.py` | 圖表繪製服務 | ⭐⭐⭐ |
| 🧠 | `app/services/compare_service.py` | 報酬率比較服務 | ⭐⭐⭐ |
| 🧠 | `app/services/crypto_service.py` | 加密貨幣服務 | ⭐⭐⭐ |
| 🧠 | `app/services/indicator_service.py` | 技術指標計算服務 | ⭐⭐⭐ |
| 🧠 | `app/services/line_notify_service.py` | LINE Messaging API 推播服務 | ⭐⭐⭐ |
| 🧠 | `app/services/market_service.py` | 市場服務 | ⭐⭐⭐ |
| 🧠 | `app/services/notification_service.py` | 通知管理服務 | ⭐⭐⭐ |
| 🧠 | `app/services/price_cache_service.py` | 價格快取服務 | ⭐⭐⭐ |
| 🧠 | `app/services/signal_service.py` | 訊號偵測服務 | ⭐⭐⭐ |
| 🧠 | `app/services/stock_service.py` | 股票服務 | ⭐⭐⭐ |
| 🧠 | `app/services/watchlist_service.py` | 追蹤清單服務 (Async 版本) | ⭐⭐⭐ |
| 🎨 | `frontend/watchlist_with_cache.js` | ========== 追蹤清單 - 使用快取版本 ========== | ⭐ |
| 🎨 | `static/admin.html` |  | ⭐ |
| 🎨 | `static/compare-nav.js` | * | ⭐ |
| 🎨 | `static/compare.html` |  | ⭐ |
| 🎨 | `static/dashboard-mobile.html` |  | ⭐ |
| 🎨 | `static/dashboard.html` |  | ⭐ |
| 🎨 | `static/index.html` |  | ⭐ |
| 🎨 | `static/SELA-Bug修復記錄.md` | SELA 選股系統 - Bug 修復記錄 | ⭐ |
| 📁 | `app/__init__.py` | Stock Analysis System | ⭐ |
| 📁 | `app/cli.py` | 股票分析系統 CLI | ⭐ |
| 📁 | `app/data_sources/__init__.py` | 外部資料來源模組 | ⭐ |
| 📁 | `app/data_sources/coingecko.py` | CoinGecko API 資料來源 | ⭐ |
| 📁 | `app/data_sources/fear_greed.py` | 市場情緒指數資料來源 | ⭐ |
| 📁 | `app/data_sources/yahoo_finance.py` | Yahoo Finance è³‡æ–™ä¾†æº | ⭐ |
| 📁 | `app/logging_config.py` | 日誌設定 | ⭐ |
| 📁 | `app/tasks/__init__.py` | 排程任務模組 | ⭐ |
| 📁 | `app/tasks/price_cache_task.py` | 價格快取排程任務 | ⭐ |
| 📁 | `app/tasks/scheduler.py` | 排程任務服務 | ⭐ |
| 📁 | `railway.json` |  | ⭐ |
| 📁 | `RAILWAY_SETUP.md` | Railway PostgreSQL 設定指南 | ⭐ |
| 📁 | `runtime.txt` |  | ⭐ |
| 📁 | `scripts/匯整子程式.py` | 專案整合工具 - 把資料夾結構和程式碼整合成單一檔案 | ⭐ |
| 📁 | `匯整專案 V2 .py` | 專案整合工具 v2 - 智能分層整理 | ⭐ |


======================================================================
## 📋 專案概述
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 CHANGELOG.md  ⭐⭐⭐
> Changelog
──────────────────────────────────────────────────────────────────────

```md
# Changelog

所有重要的變更都會記錄在此文件中。

格式基於 [Keep a Changelog](https://keepachangelog.com/zh-TW/1.0.0/)，
版本號遵循 [Semantic Versioning](https://semver.org/lang/zh-TW/)。

## [Unreleased]

### Planned
- Phase 5: 錯誤回報系統
- Phase 6: 會員權限系統

## [0.8.2] - 2025-01-08

### Added
- **訊號偵測引擎 (signal_service.py)**
  - 均線訊號：黃金交叉、死亡交叉、接近突破/跌破
  - RSI 訊號：超買 (>70)、超賣 (<30)
  - MACD 訊號：黃金交叉、死亡交叉
  - KD 訊號：黃金交叉、死亡交叉
  - 布林通道訊號：突破上軌、跌破下軌
  - 成交量訊號：量比暴增 (>2 倍)
  - 市場情緒訊號：極度恐懼 (<20)、極度貪婪 (>80)

- **LINE 推播通知服務 (line_notify_service.py)**
  - LINE Messaging API 整合
  - 單一用戶推播 (push_text_message)
  - 多用戶推播 (multicast_text_message，最多 500 人)
  - Flex Message 支援（卡片式訊號通知）
  - 每日訊號彙整報告格式

- **排程任務整合 (scheduler.py)**
  - 訊號偵測整合到每日更新任務
  - 根據用戶追蹤清單偵測訊號
  - 根據用戶通知設定過濾訊號
  - 24 小時內不重複通知同一訊號
  - 通知記錄儲存至 notifications 表

- **管理後台訊號功能**
  - POST /api/admin/signal/detect - 手動偵測訊號（測試）
  - POST /api/admin/signal/notify - 手動發送通知
  - POST /api/admin/signal/test-push - 測試 LINE 推播
  - GET /api/admin/signal/status - 通知系統狀態
  - GET /api/admin/notifications - 通知記錄查詢

- **管理後台登入統計**
  - 顯示總登入次數
  - 顯示每個用戶的登入次數

### Changed
- **年化報酬率簡化**
  - Yahoo Finance 歷史價格為除權息調整後價格
  - 移除重複的「含配息」「配息再投入」計算
  - 只顯示單一「CAGR (年化報酬率)」
  - 前端 UI 簡化為大字顯示 CAGR
  - API 回傳欄位從 price_return/total_return/reinvested_return 改為 cagr

### Fixed
- 修正年化報酬率因使用調整後價格導致的重複計算問題

### Added
- **Phase 3: 走勢比較功能**
  - 新增「走勢比較」頁面
  - 支援最多 5 支股票/指數同時比較
  - 價格正規化為起始日 = 100%
  - 快速選擇按鈕（四大指數、熱門美股、台股、加密貨幣）
  - 時間範圍選擇：1M / 3M / 6M / 1Y
  - 比較結果表格顯示起始價、最新價、漲跌幅
  - API: GET /api/stock/compare/history

- **Phase 4: 年化報酬率計算**
  - 股票查詢結果新增「年化報酬率」按鈕
  - 計算 1Y / 3Y / 5Y / 10Y 年化報酬率
  - 三種計算方式：
    - 價格報酬：純股價漲跌
    - 含配息：股價 + 配息（不再投入）
    - 配息再投入：配息以除息日股價買入更多股數
  - 顯示配息次數、年均殖利率
  - API: GET /api/stock/{symbol}/returns

- **儀表板新增台股加權指數**
  - 支援 ^TWII 台灣加權股價指數
  - 儀表板指數卡片從 3 個增加到 4 個
  - 走勢比較快速選擇新增台積電、鴻海

- **管理後台登入統計**
  - 統計卡片新增「總登入次數」
  - 用戶列表新增「登入次數」欄位
  - API: /api/admin/stats 新增 total_logins
  - API: /api/admin/users 新增 login_count

### Fixed
- **重要：修復歷史股價使用調整後價格的問題**
  - yfinance 預設回傳 auto_adjust=True（配息調整後價格）
  - 改為 auto_adjust=False 取得原始收盤價
  - 影響：年化報酬率、殖利率計算現在使用正確的歷史價格
- 修復指數歷史 API 的 NaN 值 JSON 序列化錯誤
- IndexPrice model to_dict() 加入 NaN/Infinity 檢查
- market_service save_index_data() 儲存前清理無效數值
- 修復走勢比較圖表需要 chartjs-adapter-date-fns
- 修復年化報酬率 yearly_detail 變數未定義錯誤

## [0.7.0] - 2025-01-07

### Added
- **Phase 2: 前端顯示功能**
  - 儀表板頂部三大指數卡片（S&P 500、道瓊工業、納斯達克）
  - 點擊指數卡片開啟全螢幕走勢圖（Modal 視窗）
  - 指數走勢支援 1M/3M/1Y/5Y 時間範圍切換
  - 恐懼貪婪指數點擊開啟全螢幕歷史走勢圖
  - 情緒走勢支援 1M/3M/6M/1Y 時間範圍切換
  - **管理後台市場資料管理區塊**
    - 初始化歷史資料按鈕
    - 更新三大指數按鈕
    - 更新恐懼貪婪指數按鈕
    - 執行每日更新按鈕

### Changed
- 「情緒指數」更名為「恐懼貪婪指數」
- 圖表改為 Modal 全螢幕顯示，解決卡片內嵌顯示問題
- 圖表邊距增加，改善觸控體驗

### Fixed
- 修復 get_latest_indices 回傳格式（List → Dict）
- 加強資料庫錯誤處理，自動 fallback 到 Yahoo Finance API
- 修復指數/情緒走勢圖無法正常顯示的問題

## [0.6.1] - 2025-01-07

### Fixed
- **用戶身份驗證強化**
  - 登入時清除所有舊的 localStorage/sessionStorage 資料，避免 A 用戶看到 B 用戶資料
  - JWT Token 驗證增加 LINE ID 一致性檢查
  - 前端 checkAuth 增加本地與伺服器用戶 ID 比對
  - 所有 API 請求改用統一的 apiRequest 函數，自動帶入驗證
  - **UserResponse schema 加入 is_admin 欄位**（修復管理員權限消失問題）

- **追蹤清單安全性**
  - 追蹤清單刪除時增加 user_id 二次驗證
  - 所有追蹤清單操作加入詳細 log 記錄
  - 前端操作前檢查 currentUser 是否存在

- **日誌系統強化**
  - 新增 logging_config.py 統一日誌設定
  - 認證服務 (auth_service) 完整登入流程 log
  - 追蹤清單服務 (watchlist_service) 操作 log
  - 日誌檔案按日期分類存放於 logs/ 目錄
  - 分離 auth、watchlist 專用日誌檔

### Changed
- auth_service.py: login_with_line() 加入完整 log 記錄
- auth_service.py: get_user_from_token() 加入 LINE ID 一致性驗證
- watchlist_service.py: 所有操作加入詳細 log
- watchlist.py router: 所有端點加入 log 記錄
- dashboard.html: 新增 apiRequest() 統一 API 請求函數
- dashboard.html: 新增 clearAllUserData() 清除用戶資料函數
- main.py: 使用 logging_config.py 初始化日誌系統
- schemas.py: UserResponse 加入 is_admin 欄位

### Added
- app/logging_config.py: 日誌設定模組

## [0.6.0] - 2025-01-07

### Added
- **資料基礎建設 (Phase 1)**
  - 三大指數支援
    - S&P 500 (^GSPC)
    - 道瓊工業 (^DJI)
    - 納斯達克 (^IXIC)
    - IndexPrice 資料模型
    - 10 年歷史資料支援
  - 配息資料
    - DividendHistory 資料模型
    - yfinance 配息抓取
  - 情緒指數歷史
    - 幣圈情緒 365 天歷史抓取
    - 美股情緒每日累積
  - 排程任務服務 (scheduler.py)
    - 每日自動更新股價
    - 每日更新三大指數
    - 每日更新市場情緒
    - 初始化歷史資料功能
  - 市場服務 (market_service.py)
    - 指數資料存取
    - 情緒資料存取
    - 配息資料存取
  - 市場 API 端點 (/api/market)
    - GET /indices - 取得三大指數
    - GET /indices/{symbol}/history - 指數歷史
    - GET /sentiment - 市場情緒
    - GET /sentiment/{market}/history - 情緒歷史
    - POST /admin/update - 手動觸發更新
    - POST /admin/initialize - 初始化歷史資料
    - POST /admin/update-indices - 更新指數
    - POST /admin/update-sentiment - 更新情緒
    - POST /admin/init-crypto-sentiment - 初始化幣圈情緒

### Changed
- stock_service.py 支援 10 年歷史資料
- yahoo_finance.py 新增指數和配息抓取方法
- fear_greed.py 新增歷史資料抓取

## [0.5.3] - 2025-01-06

### Fixed
- 可折疊指標區塊在桌面版無法運作
- 追蹤清單缺少即時價格資訊
- 模板選擇無視覺回饋
- 設定頁面顯示 LINE ID（隱私問題）

### Changed
- 追蹤清單卡片增加即時價格和漲跌幅
- 模板按鈕選中狀態樣式
- 設定頁面改顯示會員等級

## [0.3.0] - 2025-01-05

### Added
- 用戶系統
  - LINE Login 整合
  - JWT Token 認證
  - 用戶資料管理
- 追蹤清單功能
  - 新增/移除追蹤標的
  - 自訂備註
  - 追蹤清單總覽 (含即時價格)
- 個人化設定
  - 指標顯示設定
  - 通知設定
  - 指標參數調整
  - 預設模板 (極簡/標準/完整/短線)
- FastAPI Web API
  - 認證路由 (/auth)
  - 股票查詢 (/api/stock)
  - 加密貨幣查詢 (/api/crypto)
  - 追蹤清單管理 (/api/watchlist)
  - 設定管理 (/api/settings)
  - 市場情緒 (/api/market/sentiment)
  - Swagger 文件 (/docs)
- 資料模型
  - User (用戶)
  - Watchlist (追蹤清單)
  - UserIndicatorSettings (指標設定)
  - UserAlertSettings (通知設定)
  - UserIndicatorParams (參數設定)
  - Notification (通知記錄)

## [0.2.0] - 2025-01-05

### Added
- 圖表繪製服務 (chart_service.py)
  - 價格走勢圖 + 均線 + 布林通道
  - 成交量柱狀圖
  - RSI、MACD、KD 子圖
  - 均線交叉點標記
  - K線圖支援
- 加密貨幣支援
  - CoinGecko API 整合
  - BTC、ETH 價格追蹤
  - 幣圈技術指標 (MA7/25/99)
- 市場情緒指數
  - CNN Fear & Greed Index (美股)
  - Alternative.me (加密貨幣)
- CLI 新增指令
  - `sentiment` - 查詢市場情緒
  - `chart` - 生成技術分析圖表
  - 支援加密貨幣查詢 (BTC, ETH)

### Changed
- CLI 互動模式提示符改為 `代號>`
- 支援同時查詢股票和加密貨幣

## [0.1.0] - 2025-01-05

### Added
- 專案初始化
- Yahoo Finance 股價資料抓取
- SQLite 本地快取機制
- 技術指標計算引擎
  - 移動平均線 (MA20, MA50, MA200)
  - RSI 相對強弱指標
  - MACD 指數平滑異同移動平均
  - KD 隨機指標
  - 布林通道
  - OBV 能量潮指標
  - 成交量分析
- 訊號偵測系統
  - 均線黃金交叉/死亡交叉
  - 接近突破/跌破預警
  - RSI 超買超賣
  - MACD/KD 交叉
- 綜合評分系統
- CLI 命令列查詢介面
  - 互動模式
  - 單次查詢指令
  - 強制更新選項
```

──────────────────────────────────────────────────────────────────────
### 📄 README.md  ⭐⭐⭐
> 🚀 價格快取功能 - 完整整合包
──────────────────────────────────────────────────────────────────────

```md
# 🚀 價格快取功能 - 完整整合包

## 效果

| 優化前 | 優化後 |
|--------|--------|
| 追蹤 5 支股票載入 50-150 秒 | **< 1 秒** |

---

## 整合方式：直接覆蓋檔案

**不需要手動修改任何程式碼，直接覆蓋即可！**

| 檔案 | 動作 |
|------|------|
| `app/main.py` | 覆蓋 |
| `app/models/__init__.py` | 覆蓋 |
| `app/models/price_cache.py` | 新增 |
| `app/services/price_cache_service.py` | 新增 |
| `app/routers/watchlist.py` | 覆蓋 |
| `static/dashboard.html` | 覆蓋 |

---

## 確認 requirements.txt

確保有以下套件：

```
apscheduler>=3.10.0
```

---

## 部署後

1. 重新部署
2. 資料表 `stock_price_cache` 會自動建立
3. 排程會自動啟動，每 10 分鐘更新價格
4. 追蹤清單會從快取讀取價格，秒速載入

---

## 驗證

部署後訪問：

```
https://你的網域/api/watchlist/cache-status
```

應該看到：
```json
{
  "success": true,
  "total_cached": 5,
  "tw_stocks": 3,
  "us_stocks": 2,
  "crypto": 0,
  "market_status": {
    "tw_open": true,
    "us_open": false,
    "crypto_open": true
  }
}
```

---

## 排程時間（台灣時間）

| 排程 | 執行時間 | 說明 |
|------|----------|------|
| 每 10 分鐘 | 全天 | 只更新開盤中的市場 |
| 台股收盤 | 13:35 | 確保有最終收盤價 |
| 美股收盤 | 05:05 | 確保有最終收盤價 |

---

## 新增功能

1. ✅ **追蹤清單秒速載入** - 從快取讀取價格
2. ✅ **儀表板快覽顯示價格** - 首頁追蹤清單顯示價格和漲跌
3. ✅ **報酬率比較連結** - 側邊欄已加入
```

======================================================================
## ⚙️ 設定檔
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/config.py  ⭐⭐
> 應用程式設定檔
──────────────────────────────────────────────────────────────────────

```py
"""
應用程式設定檔
"""
from pydantic_settings import BaseSettings
from pathlib import Path
from typing import Optional, List


class Settings(BaseSettings):
    """應用程式設定"""
    
    # 應用程式
    APP_NAME: str = "SELA 自動選股系統"
    APP_VERSION: str = "0.8.2"  # Phase 4 訊號偵測 + LINE 推播
    APP_ENV: str = "development"
    DEBUG: bool = True
    
    # 資料庫
    DATABASE_URL: str = "sqlite+aiosqlite:///./stock_analysis.db"
    
    # LINE Login (階段四)
    LINE_LOGIN_CHANNEL_ID: Optional[str] = None
    LINE_LOGIN_CHANNEL_SECRET: Optional[str] = None
    LINE_LOGIN_CALLBACK_URL: Optional[str] = None
    
    # LINE Messaging (階段六)
    LINE_MESSAGING_CHANNEL_ACCESS_TOKEN: Optional[str] = None
    
    # JWT (階段四)
    JWT_SECRET_KEY: str = "your-secret-key-change-in-production"
    JWT_EXPIRE_DAYS: int = 7
    
    # 管理員設定
    # 初始管理員的 LINE User ID（用逗號分隔多個）
    ADMIN_LINE_USER_IDS: str = "U0f094e89838337e64ba0ca2f68161f3a"
    
    # 資料更新設定
    STOCK_DATA_CACHE_HOURS: int = 4  # 股價資料快取時間（小時）
    CRYPTO_DATA_CACHE_MINUTES: int = 15  # 幣價資料快取時間（分鐘）
    HISTORY_DEFAULT_YEARS: int = 10  # 歷史資料預設年數
    
    # 技術指標預設參數
    MA_SHORT: int = 20
    MA_MID: int = 50
    MA_LONG: int = 200
    RSI_PERIOD: int = 14
    RSI_OVERBOUGHT: int = 70
    RSI_OVERSOLD: int = 30
    MACD_FAST: int = 12
    MACD_SLOW: int = 26
    MACD_SIGNAL: int = 9
    KD_PERIOD: int = 9
    BOLLINGER_PERIOD: int = 20
    BOLLINGER_STD: float = 2.0
    
    # 通知設定
    BREAKOUT_THRESHOLD: float = 2.0  # 突破預警門檻 (%)
    VOLUME_ALERT_RATIO: float = 2.0  # 量比警戒倍數
    
    def get_admin_line_ids(self) -> List[str]:
        """取得管理員 LINE User ID 列表"""
        if not self.ADMIN_LINE_USER_IDS:
            return []
        return [x.strip() for x in self.ADMIN_LINE_USER_IDS.split(",") if x.strip()]
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"


# 全域設定實例
settings = Settings()

# 專案路徑
BASE_DIR = Path(__file__).resolve().parent.parent
DATA_DIR = BASE_DIR / "data"
CHARTS_DIR = BASE_DIR / "charts"

# 確保目錄存在
DATA_DIR.mkdir(exist_ok=True)
CHARTS_DIR.mkdir(exist_ok=True)
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/settings.py  ⭐⭐
> 設定管理 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
設定管理 API 路由
"""
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.database import get_async_session
from app.services.auth_service import AuthService
from app.models.user import User
from app.models.user_settings import (
    UserIndicatorSettings,
    UserAlertSettings,
    UserIndicatorParams,
)
from app.schemas.schemas import (
    IndicatorSettingsUpdate,
    IndicatorSettingsResponse,
    AlertSettingsUpdate,
    AlertSettingsResponse,
    IndicatorParamsUpdate,
    IndicatorParamsResponse,
    ResponseBase,
)

router = APIRouter(prefix="/api/settings", tags=["設定"])


async def get_current_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
) -> User:
    """依賴注入：取得當前用戶"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(
            status_code=401,
            detail="未提供認證 Token"
        )
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        raise HTTPException(
            status_code=401,
            detail="無效的 Token"
        )
    
    return user


# ==================== 指標顯示設定 ====================

@router.get("/indicators", summary="取得指標顯示設定", response_model=IndicatorSettingsResponse)
async def get_indicator_settings(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶的指標顯示設定
    """
    stmt = select(UserIndicatorSettings).where(
        UserIndicatorSettings.user_id == user.id
    )
    result = await db.execute(stmt)
    settings = result.scalar_one_or_none()
    
    if not settings:
        # 建立預設設定
        settings = UserIndicatorSettings.create_default(user.id)
        db.add(settings)
        await db.commit()
        await db.refresh(settings)
    
    return IndicatorSettingsResponse(
        success=True,
        data=settings.to_dict(),
    )


@router.put("/indicators", summary="更新指標顯示設定", response_model=IndicatorSettingsResponse)
async def update_indicator_settings(
    data: IndicatorSettingsUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    更新用戶的指標顯示設定
    """
    stmt = select(UserIndicatorSettings).where(
        UserIndicatorSettings.user_id == user.id
    )
    result = await db.execute(stmt)
    settings = result.scalar_one_or_none()
    
    if not settings:
        settings = UserIndicatorSettings.create_default(user.id)
        db.add(settings)
    
    # 更新設定
    update_data = data.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(settings, key, value)
    
    await db.commit()
    await db.refresh(settings)
    
    return IndicatorSettingsResponse(
        success=True,
        message="設定已更新",
        data=settings.to_dict(),
    )


# ==================== 通知設定 ====================

@router.get("/alerts", summary="取得通知設定", response_model=AlertSettingsResponse)
async def get_alert_settings(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶的通知設定
    """
    stmt = select(UserAlertSettings).where(
        UserAlertSettings.user_id == user.id
    )
    result = await db.execute(stmt)
    settings = result.scalar_one_or_none()
    
    if not settings:
        settings = UserAlertSettings.create_default(user.id)
        db.add(settings)
        await db.commit()
        await db.refresh(settings)
    
    return AlertSettingsResponse(
        success=True,
        data=settings.to_dict(),
    )


@router.put("/alerts", summary="更新通知設定", response_model=AlertSettingsResponse)
async def update_alert_settings(
    data: AlertSettingsUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    更新用戶的通知設定
    """
    stmt = select(UserAlertSettings).where(
        UserAlertSettings.user_id == user.id
    )
    result = await db.execute(stmt)
    settings = result.scalar_one_or_none()
    
    if not settings:
        settings = UserAlertSettings.create_default(user.id)
        db.add(settings)
    
    # 更新設定
    update_data = data.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(settings, key, value)
    
    await db.commit()
    await db.refresh(settings)
    
    return AlertSettingsResponse(
        success=True,
        message="設定已更新",
        data=settings.to_dict(),
    )


# ==================== 指標參數設定 ====================

@router.get("/params", summary="取得指標參數", response_model=IndicatorParamsResponse)
async def get_indicator_params(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶的指標參數設定
    """
    stmt = select(UserIndicatorParams).where(
        UserIndicatorParams.user_id == user.id
    )
    result = await db.execute(stmt)
    params = result.scalar_one_or_none()
    
    if not params:
        params = UserIndicatorParams.create_default(user.id)
        db.add(params)
        await db.commit()
        await db.refresh(params)
    
    return IndicatorParamsResponse(
        success=True,
        data=params.to_dict(),
    )


@router.put("/params", summary="更新指標參數", response_model=IndicatorParamsResponse)
async def update_indicator_params(
    data: IndicatorParamsUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    更新用戶的指標參數設定
    
    可自訂參數包括：
    - 均線週期 (ma_short, ma_mid, ma_long)
    - RSI 參數 (rsi_period, rsi_overbought, rsi_oversold)
    - MACD 參數 (macd_fast, macd_slow, macd_signal)
    - KD 週期 (kd_period)
    - 布林通道 (bollinger_period, bollinger_std)
    - 警戒值 (breakout_threshold, volume_alert_ratio)
    """
    stmt = select(UserIndicatorParams).where(
        UserIndicatorParams.user_id == user.id
    )
    result = await db.execute(stmt)
    params = result.scalar_one_or_none()
    
    if not params:
        params = UserIndicatorParams.create_default(user.id)
        db.add(params)
    
    # 更新參數
    update_data = data.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(params, key, value)
    
    await db.commit()
    await db.refresh(params)
    
    return IndicatorParamsResponse(
        success=True,
        message="參數已更新",
        data=params.to_dict(),
    )


# ==================== 預設模板 ====================

TEMPLATES = {
    "minimal": {
        "indicators": {
            "show_ma": True,
            "show_rsi": False,
            "show_macd": False,
            "show_kd": False,
            "show_bollinger": False,
            "show_obv": False,
            "show_volume": True,
        },
        "alerts": {
            "alert_ma_cross": True,
            "alert_ma_breakout": True,
            "alert_rsi": False,
            "alert_macd": False,
            "alert_kd": False,
            "alert_bollinger": False,
            "alert_volume": False,
            "alert_sentiment": False,
        },
    },
    "standard": {
        "indicators": {
            "show_ma": True,
            "show_rsi": True,
            "show_macd": True,
            "show_kd": False,
            "show_bollinger": True,
            "show_obv": False,
            "show_volume": True,
        },
        "alerts": {
            "alert_ma_cross": True,
            "alert_ma_breakout": True,
            "alert_rsi": True,
            "alert_macd": True,
            "alert_kd": False,
            "alert_bollinger": False,
            "alert_volume": False,
            "alert_sentiment": True,
        },
    },
    "full": {
        "indicators": {
            "show_ma": True,
            "show_rsi": True,
            "show_macd": True,
            "show_kd": True,
            "show_bollinger": True,
            "show_obv": True,
            "show_volume": True,
        },
        "alerts": {
            "alert_ma_cross": True,
            "alert_ma_breakout": True,
            "alert_rsi": True,
            "alert_macd": True,
            "alert_kd": True,
            "alert_bollinger": True,
            "alert_volume": True,
            "alert_sentiment": True,
        },
    },
    "short_term": {
        "indicators": {
            "show_ma": True,
            "show_rsi": True,
            "show_macd": True,
            "show_kd": True,
            "show_bollinger": True,
            "show_obv": False,
            "show_volume": True,
        },
        "alerts": {
            "alert_ma_cross": True,
            "alert_ma_breakout": True,
            "alert_rsi": True,
            "alert_macd": True,
            "alert_kd": True,
            "alert_bollinger": True,
            "alert_volume": True,
            "alert_sentiment": False,
        },
        "params": {
            "ma_short": 5,
            "ma_mid": 10,
            "ma_long": 20,
        },
    },
}


@router.post("/template/{template_name}", summary="套用預設模板", response_model=ResponseBase)
async def apply_template(
    template_name: str,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    套用預設設定模板
    
    可用模板：
    - **minimal**: 極簡 (只顯示均線和成交量)
    - **standard**: 標準 (預設，含主要指標)
    - **full**: 完整 (顯示所有指標)
    - **short_term**: 短線 (使用較短的均線週期)
    """
    if template_name not in TEMPLATES:
        raise HTTPException(
            status_code=400,
            detail=f"不存在的模板: {template_name}"
        )
    
    template = TEMPLATES[template_name]
    
    # 更新指標設定
    if "indicators" in template:
        stmt = select(UserIndicatorSettings).where(
            UserIndicatorSettings.user_id == user.id
        )
        result = await db.execute(stmt)
        ind_settings = result.scalar_one_or_none()
        if not ind_settings:
            ind_settings = UserIndicatorSettings.create_default(user.id)
            db.add(ind_settings)
        
        for key, value in template["indicators"].items():
            setattr(ind_settings, key, value)
    
    # 更新通知設定
    if "alerts" in template:
        stmt = select(UserAlertSettings).where(
            UserAlertSettings.user_id == user.id
        )
        result = await db.execute(stmt)
        alert_settings = result.scalar_one_or_none()
        if not alert_settings:
            alert_settings = UserAlertSettings.create_default(user.id)
            db.add(alert_settings)
        
        for key, value in template["alerts"].items():
            setattr(alert_settings, key, value)
    
    # 更新參數設定
    if "params" in template:
        stmt = select(UserIndicatorParams).where(
            UserIndicatorParams.user_id == user.id
        )
        result = await db.execute(stmt)
        params = result.scalar_one_or_none()
        if not params:
            params = UserIndicatorParams.create_default(user.id)
            db.add(params)
        
        for key, value in template["params"].items():
            setattr(params, key, value)
    
    await db.commit()
    
    return ResponseBase(
        success=True,
        message=f"已套用模板: {template_name}",
    )
```

──────────────────────────────────────────────────────────────────────
### 📄 Procfile  ⭐⭐
──────────────────────────────────────────────────────────────────────

```text
web: uvicorn app.main:app --host 0.0.0.0 --port $PORT
```

──────────────────────────────────────────────────────────────────────
### 📄 requirements.txt  ⭐⭐⭐
> Core Framework
──────────────────────────────────────────────────────────────────────

```text
# Core Framework
fastapi>=0.109.0
uvicorn[standard]>=0.27.0
python-dotenv>=1.0.0

# Database
sqlalchemy>=2.0.0
aiosqlite>=0.19.0
greenlet>=3.0.0
asyncpg>=0.29.0        # PostgreSQL async driver
psycopg2-binary>=2.9.9  # PostgreSQL sync driver

# Data Sources
yfinance>=0.2.36
requests>=2.31.0

# Data Processing
pandas>=2.2.0
numpy>=1.26.0
# pandas-ta>=0.3.14b  # 已在 indicator_service.py 手動實作指標計算

# Chart Generation
matplotlib>=3.8.0
mplfinance>=0.12.9b7

# Authentication
python-jose[cryptography]>=3.3.0
httpx>=0.26.0

# Utilities
pydantic>=2.5.0
pydantic-settings>=2.1.0
rich>=13.7.0  # CLI 美化輸出

# Testing
pytest>=8.0.0
pytest-asyncio>=0.23.0
apscheduler>=3.10.0
```

======================================================================
## 🚀 程式進入點
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/main.py  ⭐⭐⭐
> FastAPI 主程式
──────────────────────────────────────────────────────────────────────

```py
"""
FastAPI 主程式
股票技術分析系統 API
"""
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import RedirectResponse
import logging
import os

from app.config import settings
from app.database import init_db
from app.logging_config import setup_logging

# 初始化日誌系統（在其他 import 之前）
setup_logging(
    log_level="DEBUG" if settings.DEBUG else "INFO",
    log_to_file=True
)

# 確保所有 models 被載入，這樣 Base.metadata 才會包含所有表格
from app.models import (
    User, Watchlist, StockPrice, CryptoPrice, 
    MarketSentiment, Notification,
    UserIndicatorSettings, UserAlertSettings, UserIndicatorParams,
    IndexPrice, DividendHistory,
    Comparison,
    StockPriceCache,  # 🆕 價格快取
)
from app.models.user import LoginLog, TokenBlacklist, SystemConfig

from app.routers import (
    auth_router,
    stock_router,
    crypto_router,
    watchlist_router,
    settings_router,
    admin_router,
    compare_router,
)
from app.routers.market import router as market_router

# 🆕 排程器
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

logger = logging.getLogger(__name__)

# 🆕 建立排程器
scheduler = AsyncIOScheduler()


# 🆕 價格快取更新函數
def update_price_cache():
    """排程任務：更新價格快取（每 10 分鐘）"""
    from app.database import SyncSessionLocal
    from app.services.price_cache_service import PriceCacheService
    
    logger.info("[排程] 開始更新價格快取...")
    db = SyncSessionLocal()
    try:
        service = PriceCacheService(db)
        result = service.update_all(force=False)
        logger.info(f"[排程] 價格快取更新完成: {result['total_updated']} 筆")
    except Exception as e:
        logger.error(f"[排程] 價格快取更新失敗: {e}")
    finally:
        db.close()


def update_price_cache_force():
    """強制更新所有價格（啟動時 / 收盤後）"""
    from app.database import SyncSessionLocal
    from app.services.price_cache_service import PriceCacheService
    
    logger.info("[排程] 強制更新所有價格快取...")
    db = SyncSessionLocal()
    try:
        service = PriceCacheService(db)
        result = service.update_all(force=True)
        logger.info(f"[排程] 價格快取強制更新完成: {result['total_updated']} 筆")
    except Exception as e:
        logger.error(f"[排程] 價格快取強制更新失敗: {e}")
    finally:
        db.close()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """應用程式生命週期管理"""
    # 啟動時
    logger.info(f"Starting {settings.APP_NAME} v{settings.APP_VERSION}")
    
    # ★★★ 診斷資料庫連線 ★★★
    from app.database import database_url, is_postgres
    db_type = "PostgreSQL" if is_postgres(database_url) else "SQLite"
    logger.info(f"★★★ Database Type: {db_type} ★★★")
    if is_postgres(database_url):
        # 隱藏密碼
        safe_url = database_url.split("@")[-1] if "@" in database_url else database_url
        logger.info(f"★★★ Database Host: {safe_url} ★★★")
    else:
        logger.warning("⚠️ 使用 SQLite！資料會在重新部署後遺失！")
        logger.warning("⚠️ 請設定 DATABASE_URL 環境變數指向 PostgreSQL")
    
    await init_db()
    logger.info("Database initialized")
    
    # 🆕 設定價格快取排程
    # 每 10 分鐘執行（自動判斷開盤時間）
    scheduler.add_job(
        update_price_cache,
        'interval',
        minutes=10,
        id='price_cache_update',
        name='價格快取更新(每10分鐘)',
    )
    
    # 台股收盤後（週一到週五 13:35）
    scheduler.add_job(
        update_price_cache_force,
        CronTrigger(day_of_week='mon-fri', hour=13, minute=35),
        id='tw_close_update',
        name='台股收盤更新',
    )
    
    # 美股收盤後（週二到週六 05:05）
    scheduler.add_job(
        update_price_cache_force,
        CronTrigger(day_of_week='tue-sat', hour=5, minute=5),
        id='us_close_update',
        name='美股收盤更新',
    )
    
    # 啟動排程器
    scheduler.start()
    logger.info("價格快取排程器已啟動")
    
    # 啟動時執行一次強制更新
    try:
        update_price_cache_force()
    except Exception as e:
        logger.error(f"啟動時更新價格快取失敗: {e}")
    
    yield
    
    # 關閉時
    scheduler.shutdown()
    logger.info("Shutting down...")


# 建立 FastAPI 應用程式
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="""
## 📈 SELA 自動選股系統 API

多用戶股票與加密貨幣技術分析平台

### 功能特色

- **技術指標**: MA, RSI, MACD, KD, 布林通道, OBV
- **智能訊號**: 黃金交叉、死亡交叉、超買超賣、突破預警
- **綜合評分**: 多指標共振分析
- **市場情緒**: CNN Fear & Greed / Alternative.me
- **圖表生成**: 完整技術分析圖表
- **報酬率比較**: 多標的年化報酬率 (CAGR) 比較 🆕

### 認證方式

使用 LINE Login 登入，取得 JWT Token 後在 Header 帶入：
```
Authorization: Bearer {token}
```
    """,
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan,
)

# CORS 設定
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 正式環境應限制來源
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 註冊路由
app.include_router(auth_router)
app.include_router(stock_router)
app.include_router(crypto_router)
app.include_router(watchlist_router)
app.include_router(settings_router)
app.include_router(admin_router)
app.include_router(market_router)
app.include_router(compare_router)

# 掛載靜態檔案
static_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "static")
if os.path.exists(static_path):
    app.mount("/static", StaticFiles(directory=static_path, html=True), name="static")


# 根路徑 - 重導向到登入頁
@app.get("/", tags=["系統"])
async def root():
    """重導向到首頁"""
    return RedirectResponse(url="/static/index.html")


# API 狀態
@app.get("/api", tags=["系統"])
async def api_root():
    """API 根路徑"""
    return {
        "name": settings.APP_NAME,
        "version": settings.APP_VERSION,
        "status": "running",
        "docs": "/docs",
    }


# 健康檢查
@app.get("/health", tags=["系統"])
async def health_check():
    """健康檢查"""
    return {
        "status": "healthy",
        "version": settings.APP_VERSION,
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.DEBUG,
    )
```

======================================================================
## 🌐 API / 路由
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/__init__.py  ⭐⭐⭐
> API 路由模組
──────────────────────────────────────────────────────────────────────

```py
"""
API 路由模組
"""
from app.routers.auth import router as auth_router
from app.routers.stock import router as stock_router
from app.routers.crypto import router as crypto_router
from app.routers.watchlist import router as watchlist_router
from app.routers.settings import router as settings_router
from app.routers.admin import router as admin_router
from app.routers.compare import router as compare_router  # 🆕 新增：報酬率比較

__all__ = [
    "auth_router",
    "stock_router",
    "crypto_router",
    "watchlist_router",
    "settings_router",
    "admin_router",
    "compare_router",  # 🆕 新增
]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/admin.py  ⭐⭐⭐
> 管理員 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
管理員 API 路由
"""
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, update, delete
from sqlalchemy.orm import selectinload
from typing import Optional
from datetime import datetime, timedelta
import logging

from app.database import get_async_session
from app.models.user import User, LoginLog, TokenBlacklist, SystemConfig
from app.services.auth_service import AuthService
from app.config import settings

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/admin", tags=["管理員"])


async def get_admin_user(request: Request, db: AsyncSession = Depends(get_async_session)) -> User:
    """驗證管理員身份"""
    # 從 Header 取得 Token
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="未提供認證 Token")
    
    token = auth_header.split(" ")[1]
    
    # 驗證 Token 並取得用戶
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        raise HTTPException(status_code=401, detail="無效的 Token")
    
    # 檢查是否為管理員
    if not user.is_admin:
        # 檢查是否在環境變數的初始管理員名單中
        admin_ids = settings.get_admin_line_ids()
        if user.line_user_id not in admin_ids:
            raise HTTPException(status_code=403, detail="需要管理員權限")
        
        # 自動設定為管理員
        user.is_admin = True
        await db.commit()
        logger.info(f"Auto-promoted user {user.id} to admin")
    
    return user


@router.get("/stats", summary="系統統計")
async def get_stats(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得系統統計資料"""
    # 用戶統計
    total_users = await db.scalar(select(func.count(User.id)))
    active_users = await db.scalar(select(func.count(User.id)).where(User.is_active == True))
    blocked_users = await db.scalar(select(func.count(User.id)).where(User.is_blocked == True))
    admin_users = await db.scalar(select(func.count(User.id)).where(User.is_admin == True))
    
    # 總登入次數
    total_logins = await db.scalar(
        select(func.count(LoginLog.id))
        .where(LoginLog.action == "login")
    )
    
    # 今日登入
    today = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
    today_logins = await db.scalar(
        select(func.count(LoginLog.id))
        .where(LoginLog.action == "login")
        .where(LoginLog.created_at >= today)
    )
    
    # 近 7 天活躍用戶
    week_ago = datetime.utcnow() - timedelta(days=7)
    weekly_active = await db.scalar(
        select(func.count(func.distinct(LoginLog.user_id)))
        .where(LoginLog.created_at >= week_ago)
    )
    
    return {
        "success": True,
        "stats": {
            "total_users": total_users or 0,
            "active_users": active_users or 0,
            "blocked_users": blocked_users or 0,
            "admin_users": admin_users or 0,
            "total_logins": total_logins or 0,
            "today_logins": today_logins or 0,
            "weekly_active_users": weekly_active or 0,
        }
    }


@router.get("/users", summary="用戶列表")
async def list_users(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    search: Optional[str] = None,
    blocked_only: bool = False,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得用戶列表（含登入次數）"""
    query = select(User).order_by(User.last_login.desc())
    
    # 搜尋
    if search:
        query = query.where(
            (User.display_name.ilike(f"%{search}%")) |
            (User.email.ilike(f"%{search}%")) |
            (User.line_user_id.ilike(f"%{search}%"))
        )
    
    # 只顯示封鎖用戶
    if blocked_only:
        query = query.where(User.is_blocked == True)
    
    # 計算總數
    count_query = select(func.count()).select_from(query.subquery())
    total = await db.scalar(count_query)
    
    # 分頁
    query = query.offset((page - 1) * page_size).limit(page_size)
    result = await db.execute(query)
    users = result.scalars().all()
    
    # 取得每個用戶的登入次數
    user_ids = [u.id for u in users]
    login_counts = {}
    if user_ids:
        login_count_result = await db.execute(
            select(LoginLog.user_id, func.count(LoginLog.id).label('count'))
            .where(LoginLog.user_id.in_(user_ids))
            .where(LoginLog.action == "login")
            .group_by(LoginLog.user_id)
        )
        for row in login_count_result:
            login_counts[row.user_id] = row.count
    
    # 組合結果
    users_data = []
    for u in users:
        user_dict = u.to_dict()
        user_dict["login_count"] = login_counts.get(u.id, 0)
        users_data.append(user_dict)
    
    return {
        "success": True,
        "users": users_data,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total": total or 0,
            "total_pages": ((total or 0) + page_size - 1) // page_size,
        }
    }


@router.get("/users/{user_id}", summary="用戶詳情")
async def get_user_detail(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得用戶詳細資訊"""
    result = await db.execute(
        select(User).where(User.id == user_id)
    )
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    # 取得最近登入記錄
    logs_result = await db.execute(
        select(LoginLog)
        .where(LoginLog.user_id == user_id)
        .order_by(LoginLog.created_at.desc())
        .limit(20)
    )
    logs = logs_result.scalars().all()
    
    return {
        "success": True,
        "user": user.to_dict(),
        "recent_logs": [log.to_dict() for log in logs],
    }


@router.get("/logs", summary="登入日誌")
async def list_logs(
    page: int = Query(1, ge=1),
    page_size: int = Query(50, ge=1, le=100),
    user_id: Optional[int] = None,
    action: Optional[str] = None,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得登入日誌"""
    query = select(LoginLog).order_by(LoginLog.created_at.desc())
    
    if user_id:
        query = query.where(LoginLog.user_id == user_id)
    
    if action:
        query = query.where(LoginLog.action == action)
    
    # 計算總數
    count_query = select(func.count()).select_from(query.subquery())
    total = await db.scalar(count_query)
    
    # 分頁
    query = query.offset((page - 1) * page_size).limit(page_size)
    result = await db.execute(query)
    logs = result.scalars().all()
    
    # 取得用戶名稱
    user_ids = list(set(log.user_id for log in logs))
    if user_ids:
        users_result = await db.execute(
            select(User).where(User.id.in_(user_ids))
        )
        users_map = {u.id: u.display_name for u in users_result.scalars().all()}
    else:
        users_map = {}
    
    logs_data = []
    for log in logs:
        log_dict = log.to_dict()
        log_dict["user_name"] = users_map.get(log.user_id, "Unknown")
        logs_data.append(log_dict)
    
    return {
        "success": True,
        "logs": logs_data,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total": total or 0,
            "total_pages": ((total or 0) + page_size - 1) // page_size,
        }
    }


@router.post("/users/{user_id}/block", summary="封鎖用戶")
async def block_user(
    user_id: int,
    reason: str = Query("", description="封鎖原因"),
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """封鎖用戶"""
    if user_id == admin.id:
        raise HTTPException(status_code=400, detail="不能封鎖自己")
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    user.is_blocked = True
    user.blocked_reason = reason
    user.blocked_at = datetime.utcnow()
    
    # 記錄日誌
    log = LoginLog(
        user_id=user_id,
        action="blocked",
        ip_address=f"by_admin:{admin.id}",
    )
    db.add(log)
    
    await db.commit()
    
    logger.info(f"User {user_id} blocked by admin {admin.id}, reason: {reason}")
    
    return {"success": True, "message": f"已封鎖用戶 {user.display_name}"}


@router.post("/users/{user_id}/unblock", summary="解除封鎖")
async def unblock_user(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """解除用戶封鎖"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    user.is_blocked = False
    user.blocked_reason = None
    user.blocked_at = None
    
    # 記錄日誌
    log = LoginLog(
        user_id=user_id,
        action="unblocked",
        ip_address=f"by_admin:{admin.id}",
    )
    db.add(log)
    
    await db.commit()
    
    logger.info(f"User {user_id} unblocked by admin {admin.id}")
    
    return {"success": True, "message": f"已解除封鎖 {user.display_name}"}


@router.post("/users/{user_id}/set-admin", summary="設為管理員")
async def set_admin(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """設定用戶為管理員"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    user.is_admin = True
    await db.commit()
    
    logger.info(f"User {user_id} promoted to admin by {admin.id}")
    
    return {"success": True, "message": f"已將 {user.display_name} 設為管理員"}


@router.post("/users/{user_id}/remove-admin", summary="移除管理員")
async def remove_admin(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """移除管理員權限"""
    if user_id == admin.id:
        raise HTTPException(status_code=400, detail="不能移除自己的管理員權限")
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    user.is_admin = False
    await db.commit()
    
    logger.info(f"User {user_id} admin removed by {admin.id}")
    
    return {"success": True, "message": f"已移除 {user.display_name} 的管理員權限"}


@router.post("/users/{user_id}/kick", summary="踢出用戶")
async def kick_user(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """踢出單一用戶（使其 Token 失效）"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    # 增加 token 版本，使舊 token 失效
    # 這裡我們用時間戳記錄
    config_key = f"user_token_version:{user_id}"
    result = await db.execute(
        select(SystemConfig).where(SystemConfig.key == config_key)
    )
    config = result.scalar_one_or_none()
    
    if config:
        config.value = str(int(datetime.utcnow().timestamp()))
    else:
        config = SystemConfig(
            key=config_key,
            value=str(int(datetime.utcnow().timestamp())),
            description=f"Token version for user {user_id}"
        )
        db.add(config)
    
    # 記錄日誌
    log = LoginLog(
        user_id=user_id,
        action="kicked",
        ip_address=f"by_admin:{admin.id}",
    )
    db.add(log)
    
    await db.commit()
    
    logger.info(f"User {user_id} kicked by admin {admin.id}")
    
    return {"success": True, "message": f"已踢出用戶 {user.display_name}"}


@router.post("/kick-all", summary="踢出所有用戶")
async def kick_all_users(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """踢出所有用戶（使所有 Token 失效）"""
    # 設定全域 token 版本
    config_key = "global_token_version"
    result = await db.execute(
        select(SystemConfig).where(SystemConfig.key == config_key)
    )
    config = result.scalar_one_or_none()
    
    new_version = str(int(datetime.utcnow().timestamp()))
    
    if config:
        config.value = new_version
    else:
        config = SystemConfig(
            key=config_key,
            value=new_version,
            description="Global token version for kick-all"
        )
        db.add(config)
    
    # 記錄日誌
    log = LoginLog(
        user_id=admin.id,
        action="kick_all",
        ip_address=f"admin:{admin.id}",
    )
    db.add(log)
    
    await db.commit()
    
    logger.warning(f"All users kicked by admin {admin.id}")
    
    return {
        "success": True,
        "message": "已踢出所有用戶，所有人需要重新登入",
        "new_version": new_version
    }


@router.delete("/users/{user_id}", summary="刪除用戶")
async def delete_user(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """刪除用戶（危險操作）"""
    if user_id == admin.id:
        raise HTTPException(status_code=400, detail="不能刪除自己")
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    display_name = user.display_name
    
    await db.delete(user)
    await db.commit()
    
    logger.warning(f"User {user_id} ({display_name}) deleted by admin {admin.id}")
    
    return {"success": True, "message": f"已刪除用戶 {display_name}"}


@router.get("/debug/watchlists", summary="診斷追蹤清單")
async def debug_watchlists(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    診斷追蹤清單（查看所有用戶的追蹤清單數量）
    """
    from app.models.watchlist import Watchlist
    
    # 統計每個用戶的追蹤清單數量
    result = await db.execute(
        select(
            Watchlist.user_id,
            func.count(Watchlist.id).label('count')
        ).group_by(Watchlist.user_id)
    )
    user_counts = result.all()
    
    # 取得用戶資訊
    user_data = []
    for user_id, count in user_counts:
        user_result = await db.execute(select(User).where(User.id == user_id))
        user = user_result.scalar_one_or_none()
        user_data.append({
            "user_id": user_id,
            "display_name": user.display_name if user else "未知",
            "line_user_id": user.line_user_id[:10] + "..." if user else "未知",
            "watchlist_count": count
        })
    
    # 總數
    total = await db.scalar(select(func.count(Watchlist.id)))
    
    return {
        "success": True,
        "total_watchlist_items": total,
        "users": user_data
    }


# ============== 訊號檢查與推播 ==============

@router.post("/signals/check", summary="執行訊號檢查")
async def run_signal_check(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    手動執行訊號檢查
    
    檢查所有用戶追蹤的股票，偵測技術指標訊號並發送 LINE 通知
    """
    from app.services.notification_service import notification_service
    
    try:
        result = await notification_service.run_signal_check(db)
        
        return {
            "success": True,
            "message": "訊號檢查完成",
            "result": result
        }
    except Exception as e:
        logger.error(f"訊號檢查失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/signals/test/{symbol}", summary="測試單一股票訊號")
async def test_signal_detection(
    symbol: str,
    admin: User = Depends(get_admin_user),
):
    """
    測試單一股票的訊號偵測（不發送通知）
    """
    from app.services.signal_service import signal_service
    from app.services.indicator_service import indicator_service
    from app.data_sources.yahoo_finance import yahoo_finance
    
    symbol = symbol.upper()
    
    try:
        # 取得股價資料
        df = yahoo_finance.get_stock_history(symbol, period="6mo")
        
        if df is None or df.empty:
            raise HTTPException(status_code=404, detail=f"找不到股票: {symbol}")
        
        # 計算技術指標
        indicators = indicator_service.calculate_all_indicators(df)
        
        if not indicators:
            raise HTTPException(status_code=500, detail="無法計算技術指標")
        
        # 偵測訊號
        signals = signal_service.detect_signals(symbol, indicators, "stock")
        
        # 格式化輸出
        signals_data = []
        for s in signals:
            signals_data.append({
                "type": s.signal_type.value,
                "indicator": s.indicator,
                "message": s.message,
                "price": s.price,
                "details": s.details,
            })
        
        return {
            "success": True,
            "symbol": symbol,
            "current_price": indicators.get("current_price"),
            "signals_count": len(signals),
            "signals": signals_data,
            "indicators_summary": {
                "ma20": indicators.get("ma", {}).get("ma20"),
                "ma50": indicators.get("ma", {}).get("ma50"),
                "rsi": indicators.get("rsi", {}).get("value"),
                "macd_status": indicators.get("macd", {}).get("status"),
                "kd_k": indicators.get("kd", {}).get("k"),
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"測試訊號偵測失敗 {symbol}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/notify/test", summary="測試 LINE 推播")
async def test_line_push(
    message: str = Query("這是測試訊息", description="測試訊息內容"),
    admin: User = Depends(get_admin_user),
):
    """
    測試 LINE 推播功能（發送給管理員自己）
    """
    from app.services.line_notify_service import line_notify_service
    
    if not line_notify_service.enabled:
        raise HTTPException(
            status_code=400, 
            detail="LINE Messaging API 未設定，請設定 LINE_MESSAGING_CHANNEL_ACCESS_TOKEN 環境變數"
        )
    
    try:
        test_message = f"🔔 SELA 系統測試\n\n{message}\n\n⏰ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        success = await line_notify_service.push_text_message(
            admin.line_user_id,
            test_message
        )
        
        if success:
            return {
                "success": True,
                "message": "測試訊息已發送，請檢查 LINE"
            }
        else:
            raise HTTPException(status_code=500, detail="LINE 推播失敗")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"測試 LINE 推播失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/notifications", summary="通知記錄")
async def list_notifications(
    page: int = Query(1, ge=1),
    page_size: int = Query(50, ge=1, le=100),
    user_id: Optional[int] = None,
    symbol: Optional[str] = None,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得通知記錄"""
    from app.models.notification import Notification
    
    query = select(Notification).order_by(Notification.triggered_at.desc())
    
    if user_id:
        query = query.where(Notification.user_id == user_id)
    
    if symbol:
        query = query.where(Notification.symbol == symbol.upper())
    
    # 計算總數
    count_query = select(func.count()).select_from(query.subquery())
    total = await db.scalar(count_query)
    
    # 分頁
    query = query.offset((page - 1) * page_size).limit(page_size)
    result = await db.execute(query)
    notifications = result.scalars().all()
    
    # 取得用戶名稱
    user_ids = list(set(n.user_id for n in notifications))
    if user_ids:
        users_result = await db.execute(
            select(User).where(User.id.in_(user_ids))
        )
        users_map = {u.id: u.display_name for u in users_result.scalars().all()}
    else:
        users_map = {}
    
    notifications_data = []
    for n in notifications:
        n_dict = n.to_dict()
        n_dict["user_name"] = users_map.get(n.user_id, "Unknown")
        notifications_data.append(n_dict)
    
    return {
        "success": True,
        "notifications": notifications_data,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total": total or 0,
            "total_pages": ((total or 0) + page_size - 1) // page_size,
        }
    }


@router.post("/signal/detect", summary="偵測訊號（測試）")
async def detect_signals(
    admin: User = Depends(get_admin_user),
):
    """
    手動執行訊號偵測（不發送通知）
    用於測試訊號偵測功能
    """
    from app.tasks.scheduler import scheduler_service
    
    try:
        result = scheduler_service.run_signal_detection_only()
        
        return {
            "success": True,
            "signals_count": len(result.get("signals", [])),
            "by_symbol": result.get("by_symbol", {}),
            "message": f"偵測到 {len(result.get('signals', []))} 個交叉訊號"
        }
    except Exception as e:
        logger.error(f"訊號偵測失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/signal/notify", summary="發送訊號通知")
async def send_signal_notifications(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    手動執行訊號偵測並發送通知
    會偵測所有追蹤股票的交叉訊號，並發送 LINE 推播給相關用戶
    """
    from app.tasks.scheduler import scheduler_service
    
    try:
        # 使用同步 session
        sync_db = scheduler_service._get_db()
        result = scheduler_service._detect_and_notify(sync_db)
        sync_db.close()
        
        return {
            "success": True,
            "signals_detected": result.get("signals_count", 0),
            "notifications_sent": result.get("notifications_sent", 0),
            "errors": result.get("errors", []),
            "message": f"偵測到 {result.get('signals_count', 0)} 個訊號，發送 {result.get('notifications_sent', 0)} 則通知"
        }
    except Exception as e:
        logger.error(f"訊號通知失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/signal/test-push", summary="測試 LINE 推播")
async def test_line_push(
    message: str = Query("這是測試訊息", description="測試訊息內容"),
    admin: User = Depends(get_admin_user),
):
    """
    測試 LINE 推播功能
    發送測試訊息給管理員自己
    """
    from app.services.line_notify_service import line_notify_service
    
    if not line_notify_service.enabled:
        return {
            "success": False,
            "message": "LINE Messaging API 未啟用，請設定 LINE_MESSAGING_CHANNEL_ACCESS_TOKEN"
        }
    
    try:
        test_message = f"📊 SELA 系統測試\n\n{message}\n\n⏰ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        success = await line_notify_service.push_text_message(admin.line_user_id, test_message)
        
        return {
            "success": success,
            "message": "測試訊息已發送" if success else "發送失敗",
            "line_user_id": admin.line_user_id[:10] + "..."
        }
    except Exception as e:
        logger.error(f"測試推播失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/signal/status", summary="通知系統狀態")
async def get_signal_status(
    admin: User = Depends(get_admin_user),
):
    """
    取得訊號通知系統狀態
    """
    from app.services.line_notify_service import line_notify_service
    from app.tasks.scheduler import scheduler_service
    from app.config import settings
    
    return {
        "success": True,
        "status": {
            "line_messaging_enabled": line_notify_service.enabled,
            "line_messaging_token_set": bool(settings.LINE_MESSAGING_CHANNEL_ACCESS_TOKEN),
            "scheduler_last_run": scheduler_service.last_run.isoformat() if scheduler_service.last_run else None,
            "scheduler_last_result": scheduler_service.last_result,
        }
    }


@router.post("/signal/detect", summary="手動偵測訊號")
async def detect_signals_manual(
    admin: User = Depends(get_admin_user),
):
    """
    手動執行訊號偵測（不發送通知）
    用於測試訊號偵測邏輯
    """
    from app.tasks.scheduler import scheduler_service
    
    try:
        result = scheduler_service.run_signal_detection_only()
        
        return {
            "success": True,
            "message": f"偵測完成，共 {len(result.get('signals', []))} 個訊號",
            "signals_by_symbol": result.get("by_symbol", {}),
            "total_signals": len(result.get("signals", [])),
        }
    except Exception as e:
        logger.error(f"訊號偵測失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/signal/notify", summary="手動發送通知")
async def send_notifications_manual(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    手動執行訊號偵測並發送通知
    等同於每日排程任務
    """
    from app.tasks.scheduler import scheduler_service
    
    try:
        result = scheduler_service.run_daily_update()
        
        return {
            "success": result.get("success", False),
            "message": "每日更新任務已執行",
            "result": {
                "stocks_updated": result.get("stocks_updated", 0),
                "signals_detected": result.get("signals_detected", 0),
                "notifications_sent": result.get("notifications_sent", 0),
                "errors": result.get("errors", []),
            }
        }
    except Exception as e:
        logger.error(f"通知任務失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/notifications", summary="通知記錄")
async def list_notifications(
    page: int = Query(1, ge=1),
    page_size: int = Query(50, ge=1, le=100),
    user_id: Optional[int] = None,
    symbol: Optional[str] = None,
    sent_only: bool = False,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得通知記錄
    """
    from app.models.notification import Notification
    
    query = select(Notification).order_by(Notification.triggered_at.desc())
    
    if user_id:
        query = query.where(Notification.user_id == user_id)
    
    if symbol:
        query = query.where(Notification.symbol == symbol.upper())
    
    if sent_only:
        query = query.where(Notification.sent == True)
    
    # 計算總數
    count_query = select(func.count()).select_from(query.subquery())
    total = await db.scalar(count_query)
    
    # 分頁
    query = query.offset((page - 1) * page_size).limit(page_size)
    result = await db.execute(query)
    notifications = result.scalars().all()
    
    # 取得用戶名稱
    user_ids = list(set(n.user_id for n in notifications))
    users_map = {}
    if user_ids:
        users_result = await db.execute(select(User).where(User.id.in_(user_ids)))
        users_map = {u.id: u.display_name for u in users_result.scalars().all()}
    
    notifications_data = []
    for n in notifications:
        n_dict = n.to_dict()
        n_dict["user_name"] = users_map.get(n.user_id, "Unknown")
        notifications_data.append(n_dict)
    
    return {
        "success": True,
        "notifications": notifications_data,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total": total or 0,
            "total_pages": ((total or 0) + page_size - 1) // page_size,
        }
    }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/auth.py  ⭐⭐⭐
> 認證 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
認證 API 路由
LINE Login 整合
"""
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
import secrets
import hashlib
import hmac
import time
import urllib.parse
import logging

from app.database import get_async_session
from app.services.auth_service import AuthService
from app.schemas.schemas import LoginResponse, UserResponse, ErrorResponse
from app.config import settings

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/auth", tags=["認證"])

# 版本標識
AUTH_VERSION = "2.0.0-hmac"


@router.get("/version", summary="認證模組版本")
async def auth_version():
    """回傳認證模組版本，用於確認部署"""
    return {
        "auth_version": AUTH_VERSION,
        "state_method": "HMAC",
        "jwt_key_set": bool(settings.JWT_SECRET_KEY and settings.JWT_SECRET_KEY != "your-secret-key-change-in-production"),
    }


def create_state_token() -> str:
    """建立 state token (HMAC 簽名，有效期 10 分鐘)"""
    # 格式: timestamp.nonce.signature
    timestamp = str(int(time.time()))
    nonce = secrets.token_hex(8)  # 16 字元
    
    # 簽名
    message = f"{timestamp}.{nonce}"
    signature = hmac.new(
        settings.JWT_SECRET_KEY.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()[:16]  # 只取前 16 字元
    
    state = f"{timestamp}.{nonce}.{signature}"
    logger.info(f"Created state: {state}")
    return state


def verify_state_token(state: str) -> bool:
    """驗證 state token"""
    logger.info(f"Verifying state: {state}")
    try:
        parts = state.split(".")
        logger.info(f"State parts count: {len(parts)}")
        
        if len(parts) != 3:
            logger.warning(f"Invalid state format, expected 3 parts, got {len(parts)}")
            return False
        
        timestamp, nonce, signature = parts
        logger.info(f"timestamp={timestamp}, nonce={nonce}, signature={signature}")
        
        # 檢查是否過期 (10 分鐘)
        time_diff = int(time.time()) - int(timestamp)
        logger.info(f"Time difference: {time_diff} seconds")
        if time_diff > 600:
            logger.warning(f"State expired, time_diff={time_diff}")
            return False
        
        # 驗證簽名
        message = f"{timestamp}.{nonce}"
        expected_signature = hmac.new(
            settings.JWT_SECRET_KEY.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()[:16]
        
        logger.info(f"Expected signature: {expected_signature}")
        result = hmac.compare_digest(signature, expected_signature)
        logger.info(f"Signature match: {result}")
        
        return result
    except Exception as e:
        logger.error(f"State verification error: {e}")
        return False


@router.get("/line", summary="LINE 登入")
async def line_login():
    """
    導向 LINE 登入授權頁面
    """
    if not settings.LINE_LOGIN_CHANNEL_ID:
        raise HTTPException(
            status_code=500,
            detail="LINE Login 尚未設定"
        )
    
    # 產生 state
    state = create_state_token()
    
    # URL encode callback URL
    callback_url = urllib.parse.quote(settings.LINE_LOGIN_CALLBACK_URL, safe='')
    
    # 建立授權 URL
    auth_url = (
        "https://access.line.me/oauth2/v2.1/authorize"
        f"?response_type=code"
        f"&client_id={settings.LINE_LOGIN_CHANNEL_ID}"
        f"&redirect_uri={callback_url}"
        f"&state={state}"
        f"&scope=profile%20openid%20email"
    )
    
    logger.info(f"Redirecting to LINE with state: {state}")
    
    return RedirectResponse(url=auth_url)


@router.get("/line/callback", summary="LINE 登入回調")
async def line_callback(
    request: Request,
    code: str = Query(..., description="授權碼"),
    state: str = Query(..., description="State"),
    db: AsyncSession = Depends(get_async_session),
):
    """
    LINE 登入回調處理
    
    - 驗證 state
    - 用 code 換取 access token
    - 取得用戶資料
    - 建立/更新用戶
    - 回傳 HTML 頁面儲存 Token 並跳轉
    """
    from fastapi.responses import HTMLResponse
    
    # 驗證 state (使用 JWT 驗證)
    if not verify_state_token(state):
        raise HTTPException(
            status_code=400,
            detail="Invalid state"
        )
    
    # 取得客戶端資訊
    client_ip = request.client.host if request.client else None
    user_agent = request.headers.get("user-agent")
    
    # 執行登入流程
    auth_service = AuthService(db)
    result = await auth_service.login_with_line(code, client_ip, user_agent)
    
    if not result:
        # 可能是被封鎖的用戶
        html_content = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>SELA 自動選股系統</title>
            <style>
                body {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 100vh;
                    margin: 0;
                    background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                }
                .card {
                    background: white;
                    padding: 3rem;
                    border-radius: 1rem;
                    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
                    text-align: center;
                }
                h2 { color: #dc2626; margin: 0 0 1rem; }
                p { color: #64748b; margin: 0; }
                a { color: #3b82f6; }
            </style>
        </head>
        <body>
            <div class="card">
                <h2>⚠️ 登入失敗</h2>
                <p>您的帳號已被停用或登入過程發生錯誤</p>
                <p style="margin-top: 1rem;"><a href="/static/index.html">返回首頁</a></p>
            </div>
        </body>
        </html>
        """
        return HTMLResponse(content=html_content, status_code=403)
    
    # 回傳 HTML 頁面，將 Token 存入 localStorage 並跳轉到儀表板
    token = result["token"]
    user = result["user"]
    
    # 記錄登入成功的 log
    logger.info(f"=== 登入成功，準備跳轉 ===")
    logger.info(f"用戶 ID: {user.id}, LINE ID: {user.line_user_id}, 名稱: {user.display_name}")
    
    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>SELA 自動選股系統</title>
        <style>
            body {{
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                margin: 0;
                background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }}
            .card {{
                background: white;
                padding: 3rem;
                border-radius: 1rem;
                box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
                text-align: center;
            }}
            .logo {{
                background-color: #FA7A35;
                color: white;
                font-weight: bold;
                font-size: 1.5rem;
                padding: 0.5rem 1rem;
                border-radius: 0.5rem;
                display: inline-block;
                margin-bottom: 1.5rem;
            }}
            .spinner {{
                width: 50px;
                height: 50px;
                border: 4px solid #e2e8f0;
                border-top: 4px solid #FA7A35;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin: 0 auto 1.5rem;
            }}
            @keyframes spin {{
                0% {{ transform: rotate(0deg); }}
                100% {{ transform: rotate(360deg); }}
            }}
            h2 {{ color: #1e293b; margin: 0 0 0.5rem; }}
            p {{ color: #64748b; margin: 0; }}
        </style>
    </head>
    <body>
        <div class="card">
            <div class="logo">SELA</div>
            <div class="spinner"></div>
            <h2>登入成功！</h2>
            <p>歡迎回來，{user.display_name}</p>
        </div>
        <script>
            // ★★★ 重要：先清除所有舊資料，避免 A 用戶看到 B 用戶的資料 ★★★
            localStorage.clear();
            sessionStorage.clear();
            
            // 設定新的用戶資料
            localStorage.setItem('token', '{token}');
            localStorage.setItem('user', JSON.stringify({{
                id: {user.id},
                display_name: "{user.display_name}",
                picture_url: "{user.picture_url or ''}",
                line_user_id: "{user.line_user_id}",
                is_admin: {'true' if getattr(user, 'is_admin', False) else 'false'}
            }}));
            localStorage.setItem('login_time', new Date().toISOString());
            
            console.log('登入成功: 用戶 ID = {user.id}, LINE ID = {user.line_user_id}');
            
            setTimeout(function() {{
                window.location.href = '/static/dashboard.html';
            }}, 1500);
        </script>
    </body>
    </html>
    """
    
    return HTMLResponse(content=html_content)


@router.post("/logout", summary="登出")
async def logout():
    """
    登出（前端清除 Token 即可）
    """
    return {"success": True, "message": "已登出"}


@router.get("/me", summary="取得當前用戶", response_model=UserResponse)
async def get_current_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得當前登入用戶資訊
    
    需要在 Header 帶入 Authorization: Bearer {token}
    """
    # 從 Header 取得 Token
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(
            status_code=401,
            detail="未提供認證 Token"
        )
    
    token = auth_header.split(" ")[1]
    
    # 驗證 Token 並取得用戶
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        raise HTTPException(
            status_code=401,
            detail="無效的 Token"
        )
    
    return UserResponse.model_validate(user)
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/compare.py  ⭐⭐⭐
> 報酬率比較 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
報酬率比較 API 路由
"""
from typing import List, Optional
from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException, Query, Request
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession
import logging

from app.database import get_async_session
from app.services.compare_service import compare_service, ComparisonCRUD
from app.services.auth_service import AuthService
from app.models.user import User

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/compare", tags=["Compare"])


# ==================== 認證依賴 ====================

async def get_current_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
) -> User:
    """依賴注入：取得當前用戶"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        logger.warning("Compare API: 未提供認證 Token")
        raise HTTPException(
            status_code=401,
            detail="未提供認證 Token"
        )
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        logger.warning("Compare API: Token 驗證失敗")
        raise HTTPException(
            status_code=401,
            detail="無效的 Token"
        )
    
    return user


async def get_optional_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
) -> Optional[User]:
    """依賴注入：取得當前用戶（可選，未登入返回 None）"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        return None
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    return user


# ==================== Schemas ====================

class CompareRequest(BaseModel):
    """比較請求"""
    symbols: List[str] = Field(..., min_length=1, max_length=5, description="標的代號列表")
    periods: List[str] = Field(default=["1y", "3y", "5y", "10y"], description="時間週期")
    custom_range: Optional[dict] = Field(default=None, description="自訂區間 {start, end}")
    benchmark: str = Field(default="^GSPC", description="基準指數")
    sort_by: str = Field(default="5y", description="排序依據")
    sort_order: str = Field(default="desc", pattern="^(asc|desc)$", description="排序方向")


class SaveComparisonRequest(BaseModel):
    """儲存比較組合請求"""
    name: str = Field(..., min_length=1, max_length=100, description="組合名稱")
    symbols: List[str] = Field(..., min_length=1, max_length=5, description="標的代號列表")
    benchmark: str = Field(default="^GSPC", description="基準指數")


class UpdateComparisonRequest(BaseModel):
    """更新比較組合請求"""
    name: Optional[str] = Field(default=None, max_length=100)
    symbols: Optional[List[str]] = Field(default=None, max_length=5)
    benchmark: Optional[str] = Field(default=None)


# ==================== 公開 API ====================

@router.post("/cagr", summary="計算年化報酬率比較")
async def compare_cagr(request: CompareRequest):
    """
    比較多個標的的年化報酬率 (CAGR)
    
    - 支援股票、加密貨幣、指數混合比較
    - 最多 5 個標的
    - 可選時間週期：1年、3年、5年、10年、自訂區間
    """
    result = await compare_service.compare_cagr(
        symbols=request.symbols,
        periods=request.periods,
        custom_range=request.custom_range,
        benchmark=request.benchmark,
        sort_by=request.sort_by,
        sort_order=request.sort_order,
    )
    
    if not result.get("success"):
        raise HTTPException(status_code=400, detail=result.get("error", "比較失敗"))
    
    return result


@router.get("/presets", summary="取得預設組合列表")
async def get_presets():
    """取得所有預設比較組合"""
    presets = compare_service.get_presets()
    return {
        "success": True,
        "presets": presets,
    }


@router.get("/presets/{preset_id}", summary="取得預設組合詳情")
async def get_preset_detail(preset_id: str):
    """取得預設組合的詳細內容"""
    preset = compare_service.get_preset_detail(preset_id)
    
    if not preset:
        raise HTTPException(status_code=404, detail="找不到該預設組合")
    
    return {
        "success": True,
        "preset": preset,
    }


@router.get("/benchmarks", summary="取得基準指數選項")
async def get_benchmarks():
    """取得可用的基準指數選項"""
    benchmarks = compare_service.get_benchmark_options()
    return {
        "success": True,
        "benchmarks": [
            {"symbol": k, "name": v}
            for k, v in benchmarks.items()
        ],
    }


# ==================== 用戶儲存的組合 API ====================

@router.get("/saved", summary="取得我的比較組合")
async def get_saved_comparisons(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得當前用戶儲存的所有比較組合"""
    crud = ComparisonCRUD(db)
    comparisons = await crud.get_user_comparisons(user.id)
    
    return {
        "success": True,
        "comparisons": [c.to_dict() for c in comparisons],
    }


@router.post("/saved", summary="儲存比較組合")
async def save_comparison(
    request: SaveComparisonRequest,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """儲存新的比較組合"""
    crud = ComparisonCRUD(db)
    
    # 檢查用戶已有的組合數量（限制最多 10 個）
    existing = await crud.get_user_comparisons(user.id)
    if len(existing) >= 10:
        raise HTTPException(status_code=400, detail="最多只能儲存 10 個比較組合")
    
    # 正規化 symbols
    symbols = [s.upper().strip() for s in request.symbols]
    
    comparison = await crud.create_comparison(
        user_id=user.id,
        name=request.name,
        symbols=symbols,
        benchmark=request.benchmark,
    )
    
    return {
        "success": True,
        "message": "比較組合已儲存",
        "comparison": comparison.to_dict(),
    }


@router.get("/saved/{comparison_id}", summary="取得單一比較組合")
async def get_saved_comparison(
    comparison_id: int,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得單一比較組合詳情"""
    crud = ComparisonCRUD(db)
    comparison = await crud.get_comparison(comparison_id, user.id)
    
    if not comparison:
        raise HTTPException(status_code=404, detail="找不到該比較組合")
    
    return {
        "success": True,
        "comparison": comparison.to_dict(),
    }


@router.put("/saved/{comparison_id}", summary="更新比較組合")
async def update_saved_comparison(
    comparison_id: int,
    request: UpdateComparisonRequest,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """更新儲存的比較組合"""
    crud = ComparisonCRUD(db)
    
    # 正規化 symbols
    symbols = None
    if request.symbols:
        symbols = [s.upper().strip() for s in request.symbols]
    
    comparison = await crud.update_comparison(
        comparison_id=comparison_id,
        user_id=user.id,
        name=request.name,
        symbols=symbols,
        benchmark=request.benchmark,
    )
    
    if not comparison:
        raise HTTPException(status_code=404, detail="找不到該比較組合")
    
    return {
        "success": True,
        "message": "比較組合已更新",
        "comparison": comparison.to_dict(),
    }


@router.delete("/saved/{comparison_id}", summary="刪除比較組合")
async def delete_saved_comparison(
    comparison_id: int,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """刪除儲存的比較組合"""
    crud = ComparisonCRUD(db)
    deleted = await crud.delete_comparison(comparison_id, user.id)
    
    if not deleted:
        raise HTTPException(status_code=404, detail="找不到該比較組合")
    
    return {
        "success": True,
        "message": "比較組合已刪除",
    }


# ==================== 快速比較 (結合 preset + 計算) ====================

@router.get("/quick/{preset_id}", summary="快速比較預設組合")
async def quick_compare_preset(
    preset_id: str,
    benchmark: str = Query(default="^GSPC", description="基準指數"),
    sort_by: str = Query(default="5y", description="排序依據"),
):
    """
    快速比較預設組合
    直接載入預設組合並計算 CAGR
    """
    preset = compare_service.get_preset_detail(preset_id)
    
    if not preset:
        raise HTTPException(status_code=404, detail="找不到該預設組合")
    
    result = await compare_service.compare_cagr(
        symbols=preset["symbols"],
        periods=["1y", "3y", "5y", "10y"],
        benchmark=benchmark,
        sort_by=sort_by,
        sort_order="desc",
    )
    
    result["preset"] = preset
    return result
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/crypto.py  ⭐⭐⭐
> 加密貨幣和市場情緒 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
加密貨幣和市場情緒 API 路由
"""
from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import FileResponse
import pandas as pd
import logging

from app.schemas.schemas import MarketSentimentResponse

router = APIRouter(tags=["加密貨幣"])
logger = logging.getLogger(__name__)

# 加密貨幣對應的 Yahoo Finance 代號
CRYPTO_YAHOO_MAP = {
    "BTC": "BTC-USD",
    "ETH": "ETH-USD",
    "BITCOIN": "BTC-USD",
    "ETHEREUM": "ETH-USD",
}


@router.get("/api/crypto/{symbol}", summary="查詢加密貨幣")
async def get_crypto_analysis(
    symbol: str,
    refresh: bool = Query(False, description="是否強制更新資料"),
):
    """
    查詢單一加密貨幣的技術分析報告
    
    - **symbol**: 加密貨幣代號 (BTC, ETH)
    - **refresh**: 是否強制更新資料
    """
    from app.data_sources.coingecko import coingecko
    from app.data_sources.yahoo_finance import yahoo_finance
    from app.services.indicator_service import indicator_service
    
    symbol = symbol.upper()
    logger.info(f"開始查詢加密貨幣: {symbol}")
    
    # 驗證代號
    yahoo_symbol = CRYPTO_YAHOO_MAP.get(symbol)
    if not yahoo_symbol and not coingecko.validate_symbol(symbol):
        logger.warning(f"不支援的加密貨幣: {symbol}")
        raise HTTPException(
            status_code=400,
            detail=f"不支援的加密貨幣: {symbol}，目前僅支援 BTC 和 ETH"
        )
    
    df = None
    info = None
    data_source = None
    
    # 優先嘗試 CoinGecko
    try:
        logger.info(f"嘗試從 CoinGecko 取得 {symbol} 資料...")
        df = coingecko.get_ohlc(symbol, days=365)
        if df is not None and not df.empty:
            info = coingecko.get_coin_info(symbol)
            data_source = "CoinGecko"
            logger.info(f"成功從 CoinGecko 取得 {len(df)} 筆資料")
    except Exception as e:
        logger.warning(f"CoinGecko API 失敗: {e}")
    
    # 如果 CoinGecko 失敗，使用 Yahoo Finance 備用
    if df is None or df.empty:
        yahoo_symbol = CRYPTO_YAHOO_MAP.get(symbol, f"{symbol}-USD")
        logger.info(f"CoinGecko 失敗，嘗試 Yahoo Finance: {yahoo_symbol}")
        
        try:
            df = yahoo_finance.get_stock_history(yahoo_symbol, period="1y")
            if df is not None and not df.empty:
                data_source = "Yahoo Finance"
                logger.info(f"成功從 Yahoo Finance 取得 {len(df)} 筆資料")
                # 從 Yahoo Finance 取得基本資訊
                try:
                    yf_info = yahoo_finance.get_stock_info(yahoo_symbol)
                    if yf_info:
                        info = {
                            "name": yf_info.get("shortName") or yf_info.get("name") or symbol,
                            "market_cap": yf_info.get("market_cap") or yf_info.get("marketCap"),
                            "total_volume": yf_info.get("total_volume"),
                        }
                except Exception as e:
                    logger.warning(f"取得 Yahoo Finance info 失敗: {e}")
                    info = {"name": symbol}
        except Exception as e:
            logger.error(f"Yahoo Finance 也失敗: {e}")
    
    # 如果兩個都失敗
    if df is None or df.empty:
        raise HTTPException(
            status_code=503,
            detail=f"無法取得 {symbol} 資料。CoinGecko 和 Yahoo Finance 都無法連接。請稍後再試。"
        )
    
    logger.info(f"使用 {data_source} 資料，共 {len(df)} 筆")
    
    # 確保有必要的欄位 (在 try 塊外面先處理)
    if 'volume' not in df.columns:
        df['volume'] = 0
        logger.warning(f"{symbol} 沒有 volume 資料，已填入 0")
    
    # 確保 volume 不是 None 或 NaN
    df['volume'] = df['volume'].fillna(0).astype(float)
    
    try:
        # 計算技術指標
        df = indicator_service.calculate_all_indicators(df)
        
        # 取得最新資料
        latest = df.iloc[-1]
        current_price = float(latest['close'])
        
        # 漲跌幅計算
        def calc_change(days):
            try:
                if len(df) > days:
                    old_price = float(df.iloc[-days-1]['close'])
                    return round((current_price - old_price) / old_price * 100, 2)
            except:
                pass
            return None
        
        # 均線資訊 (加密貨幣用 MA7/25/99)
        ma7 = float(df['close'].tail(7).mean()) if len(df) >= 7 else None
        ma25 = float(df['close'].tail(25).mean()) if len(df) >= 25 else None
        ma99 = float(df['close'].tail(99).mean()) if len(df) >= 99 else None
        
        # 判斷均線排列
        alignment = "neutral"
        if ma7 and ma25 and ma99:
            if current_price > ma7 > ma25 > ma99:
                alignment = "bullish"
            elif current_price < ma7 < ma25 < ma99:
                alignment = "bearish"
        
        # RSI (小寫: rsi)
        rsi_value = float(latest.get('rsi', 50)) if 'rsi' in latest else 50
        rsi_status = "overbought" if rsi_value > 70 else "oversold" if rsi_value < 30 else "neutral"
        
        # MACD (小寫: macd_dif, macd_dea)
        macd_dif = float(latest.get('macd_dif', 0)) if 'macd_dif' in latest else 0
        macd_dea = float(latest.get('macd_dea', 0)) if 'macd_dea' in latest else 0
        macd_status = "bullish" if macd_dif > macd_dea else "bearish"
        
        # 綜合評分
        buy_score = 0
        sell_score = 0
        
        if alignment == "bullish":
            buy_score += 1
        elif alignment == "bearish":
            sell_score += 1
        
        if rsi_value < 30:
            buy_score += 1
        elif rsi_value > 70:
            sell_score += 1
        
        if macd_status == "bullish":
            buy_score += 1
        else:
            sell_score += 1
        
        rating = "bullish" if buy_score > sell_score else "bearish" if sell_score > buy_score else "neutral"
        
        return {
            "success": True,
            "symbol": symbol,
            "name": info.get("name", symbol) if info else symbol,
            "asset_type": "crypto",
            "price": {
                "current": current_price,
                "ath": info.get("ath") if info else None,
                "from_ath_pct": info.get("ath_change_percentage") if info else None,
            },
            "change": {
                "day": calc_change(1),
                "week": calc_change(7),
                "month": calc_change(30),
                "year": calc_change(365),
            },
            "market": {
                "market_cap": info.get("market_cap") if info else None,
                "market_cap_rank": info.get("market_cap_rank") if info else None,
                "volume_24h": info.get("total_volume") if info else None,
            },
            "indicators": {
                "ma": {
                    "ma7": ma7,
                    "ma25": ma25,
                    "ma99": ma99,
                    "alignment": alignment,
                    "price_vs_ma7": "above" if ma7 and current_price > ma7 else "below",
                    "price_vs_ma25": "above" if ma25 and current_price > ma25 else "below",
                    "price_vs_ma99": "above" if ma99 and current_price > ma99 else "below",
                },
                "rsi": {
                    "value": rsi_value,
                    "period": 14,
                    "status": rsi_status,
                },
                "macd": {
                    "dif": macd_dif,
                    "macd": macd_dea,
                    "status": macd_status,
                },
            },
            "score": {
                "buy": buy_score,
                "sell": sell_score,
                "rating": rating,
            },
            "chart_data": {
                "dates": [str(d) for d in df['date'].tail(365).tolist()] if 'date' in df.columns else [],
                "prices": [float(p) for p in df['close'].tail(365).tolist()] if 'close' in df.columns else [],
                "ma20": [float(v) if not pd.isna(v) else None for v in df['ma20'].tail(365).tolist()] if 'ma20' in df.columns else [],
                "ma50": [float(v) if not pd.isna(v) else None for v in df['ma50'].tail(365).tolist()] if 'ma50' in df.columns else [],
                "ma200": [float(v) if not pd.isna(v) else None for v in df['ma200'].tail(365).tolist()] if 'ma200' in df.columns else [],
                "ma250": [float(v) if not pd.isna(v) else None for v in df['ma250'].tail(365).tolist()] if 'ma250' in df.columns else [],
            },
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"查詢 {symbol} 時發生錯誤: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"查詢失敗: {str(e)}"
        )


@router.get("/api/crypto/{symbol}/chart", summary="取得加密貨幣圖表")
async def get_crypto_chart(
    symbol: str,
    days: int = Query(120, ge=30, le=365, description="顯示天數"),
):
    """
    生成加密貨幣技術分析圖表
    
    - **symbol**: 加密貨幣代號 (BTC, ETH)
    - **days**: 顯示天數 (30-365)
    
    回傳 PNG 圖片
    """
    from app.data_sources.coingecko import coingecko
    from app.services.chart_service import chart_service
    
    symbol = symbol.upper()
    
    df = coingecko.get_ohlc(symbol, days=days)
    
    if df is None or df.empty:
        raise HTTPException(
            status_code=404,
            detail=f"找不到加密貨幣: {symbol}"
        )
    
    # 取得名稱
    info = coingecko.get_coin_info(symbol)
    name = info.get("name", "") if info else ""
    
    # 生成圖表
    chart_path = chart_service.plot_stock_analysis(
        df,
        symbol=symbol,
        name=name,
        days=days,
        show_kd=False,
    )
    
    return FileResponse(
        chart_path,
        media_type="image/png",
        filename=f"{symbol}_chart.png",
    )


@router.get("/api/market/sentiment", summary="取得市場情緒", response_model=MarketSentimentResponse)
async def get_market_sentiment(
    market: str = Query("all", description="市場類型 (stock, crypto, all)"),
):
    """
    取得市場情緒指數
    
    - **market**: 市場類型
      - `stock`: 美股 CNN Fear & Greed Index
      - `crypto`: 加密貨幣 Alternative.me
      - `all`: 兩者都取得
    
    情緒指數範圍 0-100：
    - 0-25: 極度恐懼
    - 26-45: 恐懼
    - 46-55: 中性
    - 56-75: 貪婪
    - 76-100: 極度貪婪
    """
    from app.data_sources.fear_greed import fear_greed
    
    result = {}
    
    if market in ("all", "stock"):
        stock_sentiment = fear_greed.get_stock_fear_greed()
        if stock_sentiment:
            result["stock"] = stock_sentiment
    
    if market in ("all", "crypto"):
        crypto_sentiment = fear_greed.get_crypto_fear_greed()
        if crypto_sentiment:
            result["crypto"] = crypto_sentiment
    
    return MarketSentimentResponse(
        success=True,
        stock=result.get("stock"),
        crypto=result.get("crypto"),
    )
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/market.py  ⭐⭐⭐
> 市場資料 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
市場資料 API 路由
三大指數、市場情緒、排程任務
"""
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from sqlalchemy.orm import Session
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
import logging

from app.database import get_db, get_async_session
from app.services.market_service import MarketService
from app.services.auth_service import AuthService
from app.tasks.scheduler import scheduler_service
from app.models.index_price import INDEX_SYMBOLS

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/market", tags=["market"])


# ==================== 認證依賴 ====================

async def get_current_user_optional(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
):
    """取得當前用戶（選擇性，未登入返回 None）"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        return None
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    return user


async def get_current_admin(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
):
    """取得當前管理員（必須是管理員）"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="未提供認證 Token")
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        raise HTTPException(status_code=401, detail="無效的 Token")
    
    if not user.is_admin:
        raise HTTPException(status_code=403, detail="需要管理員權限")
    
    return user


# ==================== 三大指數 ====================

@router.get("/indices")
async def get_indices(
    db: Session = Depends(get_db),
):
    """
    取得三大指數最新資料
    
    Returns:
        - S&P 500 (^GSPC)
        - 道瓊工業 (^DJI)
        - 納斯達克 (^IXIC)
    """
    try:
        market_service = MarketService(db)
        indices = market_service.get_latest_indices()
        
        return {
            "success": True,
            "data": {
                "indices": indices,
                "symbols": INDEX_SYMBOLS,
            }
        }
    except Exception as e:
        logger.error(f"取得指數失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/indices/{symbol}/history")
async def get_index_history(
    symbol: str,
    days: int = Query(default=365, ge=1, le=3650),
    db: Session = Depends(get_db),
):
    """
    取得指數歷史資料
    
    Args:
        symbol: 指數代號 (^GSPC, ^DJI, ^IXIC)
        days: 天數 (預設 365，最多 3650)
    """
    # 驗證 symbol
    if symbol not in INDEX_SYMBOLS:
        raise HTTPException(
            status_code=400,
            detail=f"無效的指數代號，可用: {list(INDEX_SYMBOLS.keys())}"
        )
    
    try:
        market_service = MarketService(db)
        history = market_service.get_index_history(symbol, days)
        
        return {
            "success": True,
            "data": {
                "symbol": symbol,
                "name": INDEX_SYMBOLS[symbol]["name"],
                "name_zh": INDEX_SYMBOLS[symbol]["name_zh"],
                "days": days,
                "count": len(history),
                "history": history,
            }
        }
    except Exception as e:
        logger.error(f"取得指數歷史失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ==================== 市場情緒 ====================

@router.get("/sentiment")
async def get_sentiment(
    db: Session = Depends(get_db),
):
    """
    取得市場情緒（美股 + 幣圈）
    """
    try:
        market_service = MarketService(db)
        sentiment = market_service.get_latest_sentiment()
        
        return {
            "success": True,
            "data": sentiment,
        }
    except Exception as e:
        logger.error(f"取得情緒失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/sentiment/{market}/history")
async def get_sentiment_history(
    market: str,
    days: int = Query(default=365, ge=1, le=365),
    db: Session = Depends(get_db),
):
    """
    取得情緒歷史資料
    
    Args:
        market: 市場類型 (stock, crypto)
        days: 天數 (預設 365，最多 365)
    """
    if market not in ["stock", "crypto"]:
        raise HTTPException(
            status_code=400,
            detail="無效的市場類型，可用: stock, crypto"
        )
    
    try:
        market_service = MarketService(db)
        history = market_service.get_sentiment_history(market, days)
        
        return {
            "success": True,
            "data": {
                "market": market,
                "days": days,
                "count": len(history),
                "history": history,
            }
        }
    except Exception as e:
        logger.error(f"取得情緒歷史失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ==================== 管理員功能：排程任務 ====================

@router.post("/admin/update")
async def trigger_daily_update(
    current_user = Depends(get_current_admin),
    db: Session = Depends(get_db),
):
    """
    [管理員] 手動觸發每日更新
    """
    try:
        result = scheduler_service.run_daily_update()
        
        return {
            "success": result.get("success", False),
            "data": result,
        }
    except Exception as e:
        logger.error(f"執行更新失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/admin/initialize")
async def initialize_historical_data(
    years: int = Query(default=10, ge=1, le=10),
    current_user = Depends(get_current_admin),
    db: Session = Depends(get_db),
):
    """
    [管理員] 初始化歷史資料
    
    首次部署時執行，抓取：
    - 三大指數 N 年歷史
    - 幣圈情緒 365 天歷史
    """
    try:
        result = scheduler_service.initialize_historical_data(years=years)
        
        return {
            "success": result.get("success", False),
            "data": result,
        }
    except Exception as e:
        logger.error(f"初始化失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/admin/update-indices")
async def update_indices(
    period: str = Query(default="5d", pattern="^(5d|1mo|3mo|1y|5y|10y)$"),
    current_user = Depends(get_current_admin),
    db: Session = Depends(get_db),
):
    """
    [管理員] 更新三大指數資料
    """
    try:
        market_service = MarketService(db)
        result = market_service.fetch_and_save_all_indices(period=period)
        
        return {
            "success": True,
            "data": {
                "period": period,
                "indices": result,
            }
        }
    except Exception as e:
        logger.error(f"更新指數失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/admin/update-sentiment")
async def update_sentiment(
    current_user = Depends(get_current_admin),
    db: Session = Depends(get_db),
):
    """
    [管理員] 更新今日市場情緒
    """
    try:
        market_service = MarketService(db)
        result = market_service.update_today_sentiment()
        
        return {
            "success": True,
            "data": result,
        }
    except Exception as e:
        logger.error(f"更新情緒失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/admin/init-crypto-sentiment")
async def init_crypto_sentiment(
    days: int = Query(default=365, ge=1, le=365),
    current_user = Depends(get_current_admin),
    db: Session = Depends(get_db),
):
    """
    [管理員] 初始化幣圈情緒歷史
    """
    try:
        market_service = MarketService(db)
        count = market_service.fetch_and_save_crypto_history(days=days)
        
        return {
            "success": True,
            "data": {
                "days_requested": days,
                "records_added": count,
            }
        }
    except Exception as e:
        logger.error(f"初始化幣圈情緒失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/admin/scheduler-status")
async def get_scheduler_status(
    current_user = Depends(get_current_admin),
):
    """
    [管理員] 取得排程狀態
    """
    return {
        "success": True,
        "data": scheduler_service.get_status(),
    }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/stock.py  ⭐⭐⭐
> 股票查詢 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
股票查詢 API 路由

修復: 台股代號自動轉換 (0050 → 0050.TW)
"""
from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import FileResponse
import logging
import pandas as pd
from datetime import datetime

from app.schemas.schemas import StockAnalysisResponse

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/stock", tags=["股票"])


def normalize_tw_symbol(symbol: str) -> str:
    """
    標準化台股代號
    - 純數字 4-6 位 → 自動加 .TW
    - 已有後綴 → 保持不變
    """
    symbol = symbol.strip().upper()
    
    # 如果已經有後綴，不處理
    if '.' in symbol or symbol.startswith('^'):
        return symbol
    
    # 台股代號：4-6 位純數字
    if symbol.isdigit() and 4 <= len(symbol) <= 6:
        return f"{symbol}.TW"
    
    return symbol


@router.get("/{symbol}", summary="查詢股票")
async def get_stock_analysis(
    symbol: str,
    refresh: bool = Query(False, description="是否強制更新資料"),
):
    """
    查詢單一股票的技術分析報告
    """
    from app.data_sources.yahoo_finance import yahoo_finance
    from app.services.indicator_service import indicator_service
    
    # 台股代號自動轉換
    symbol = normalize_tw_symbol(symbol)
    original_symbol = symbol
    logger.info(f"開始查詢股票: {symbol}")
    
    try:
        # 取得股票資料 (抓取 10 年以計算長期 CAGR)
        logger.info(f"正在從 Yahoo Finance 取得 {symbol} 資料...")
        df = yahoo_finance.get_stock_history(symbol, period="10y")
        
        # 如果 .TW 找不到，嘗試 .TWO (上櫃股票)
        if (df is None or df.empty) and symbol.endswith('.TW'):
            two_symbol = symbol.replace('.TW', '.TWO')
            logger.info(f"{symbol} 找不到，嘗試上櫃股票: {two_symbol}")
            df = yahoo_finance.get_stock_history(two_symbol, period="10y")
            if df is not None and not df.empty:
                symbol = two_symbol
                logger.info(f"成功找到上櫃股票: {two_symbol}")
        
        if df is None or df.empty:
            logger.warning(f"找不到股票資料: {original_symbol}")
            raise HTTPException(
                status_code=404,
                detail=f"找不到股票: {original_symbol}（已嘗試上市 .TW 和上櫃 .TWO）"
            )
        
        logger.info(f"取得 {len(df)} 筆資料，正在計算技術指標...")
        
        # 取得股票資訊
        info = yahoo_finance.get_stock_info(symbol)
        
        # 保存原始收盤價（用於顯示）
        df['close_raw'] = df['close'].copy()
        
        # 使用調整後價格計算技術指標（處理分割和配息）
        # 這樣 MA 線和圖表才不會有斷崖
        if 'adj_close' in df.columns:
            df['close'] = df['adj_close']
            logger.info(f"{symbol} 使用調整後價格計算指標")
        
        # 計算技術指標（基於調整後價格）
        df = indicator_service.calculate_all_indicators(df)
        
        # 取得最新資料
        latest = df.iloc[-1]
        # 顯示用原始價格（用戶習慣看的價格）
        current_price = float(latest['close_raw'])
        
        logger.info(f"{symbol} 現價: {current_price}")
        
        # 價格資訊（用原始價格顯示 52 週高低）
        high_52w = float(df['close_raw'].tail(252).max()) if len(df) >= 252 else float(df['close_raw'].max())
        low_52w = float(df['close_raw'].tail(252).min()) if len(df) >= 252 else float(df['close_raw'].min())
        
        # 漲跌幅計算（用調整後價格計算，反映真實報酬）
        current_price_adj = float(latest['close'])  # 調整後現價
        def calc_change(days):
            if len(df) > days:
                old_price_adj = float(df.iloc[-days-1]['close'])  # 調整後歷史價格
                return round((current_price_adj - old_price_adj) / old_price_adj * 100, 2)
            return None
        
        # 均線資訊 (indicator_service 用小寫: ma20, ma50, ma200)
        ma20 = float(latest.get('ma20', 0)) if 'ma20' in latest else None
        ma50 = float(latest.get('ma50', 0)) if 'ma50' in latest else None
        ma200 = float(latest.get('ma200', 0)) if 'ma200' in latest else None
        
        # 判斷均線排列（用調整後價格比較）
        alignment = "neutral"
        if ma20 and ma50 and ma200:
            if current_price_adj > ma20 > ma50 > ma200:
                alignment = "bullish"
            elif current_price_adj < ma20 < ma50 < ma200:
                alignment = "bearish"
        
        # RSI (小寫: rsi)
        rsi_value = float(latest.get('rsi', 50)) if 'rsi' in latest else 50
        rsi_status = "overbought" if rsi_value > 70 else "oversold" if rsi_value < 30 else "neutral"
        
        # MACD (小寫: macd_dif, macd_dea, macd_hist)
        macd_dif = float(latest.get('macd_dif', 0)) if 'macd_dif' in latest else 0
        macd_dea = float(latest.get('macd_dea', 0)) if 'macd_dea' in latest else 0
        macd_hist = float(latest.get('macd_hist', 0)) if 'macd_hist' in latest else 0
        macd_status = "bullish" if macd_dif > macd_dea else "bearish"
        
        # 成交量
        volume_today = int(latest['volume']) if 'volume' in latest else 0
        volume_avg = int(df['volume'].tail(20).mean()) if 'volume' in df.columns else 0
        volume_ratio = round(volume_today / volume_avg, 2) if volume_avg > 0 else 1.0
        
        # 綜合評分
        buy_score = 0
        sell_score = 0
        
        if alignment == "bullish":
            buy_score += 1
        elif alignment == "bearish":
            sell_score += 1
        
        if rsi_value < 30:
            buy_score += 1
        elif rsi_value > 70:
            sell_score += 1
        
        if macd_status == "bullish":
            buy_score += 1
        else:
            sell_score += 1
        
        rating = "bullish" if buy_score > sell_score else "bearish" if sell_score > buy_score else "neutral"
        
        logger.info(f"{symbol} 查詢完成，評分: {rating}")
        
        # 確保 name 正確獲取
        stock_name = ""
        if info:
            stock_name = info.get("name", "")
        if not stock_name:
            # 再次嘗試從本地映射表獲取
            from app.data_sources.yahoo_finance import TAIWAN_STOCK_NAMES
            stock_code = symbol.replace(".TW", "").replace(".TWO", "")
            stock_name = TAIWAN_STOCK_NAMES.get(stock_code, symbol)
        
        return {
            "success": True,
            "symbol": symbol,
            "name": stock_name,
            "asset_type": "stock",
            "price": {
                "current": current_price,
                "high_52w": high_52w,
                "low_52w": low_52w,
                "from_high_pct": round((current_price - high_52w) / high_52w * 100, 2),
                "from_low_pct": round((current_price - low_52w) / low_52w * 100, 2),
            },
            "change": {
                "day": calc_change(1),
                "week": calc_change(5),
                "month": calc_change(20),
                "quarter": calc_change(60),
                "year": calc_change(250),
            },
            "volume": {
                "today": volume_today,
                "avg_20d": volume_avg,
                "ratio": volume_ratio,
            },
            "indicators": {
                "ma": {
                    "ma20": ma20,
                    "ma50": ma50,
                    "ma200": ma200,
                    "alignment": alignment,
                    "price_vs_ma20": "above" if ma20 and current_price > ma20 else "below" if ma20 else None,
                    "price_vs_ma50": "above" if ma50 and current_price > ma50 else "below" if ma50 else None,
                    "price_vs_ma200": "above" if ma200 and current_price > ma200 else "below" if ma200 else None,
                },
                "rsi": {
                    "value": rsi_value,
                    "period": 14,
                    "status": rsi_status,
                },
                "macd": {
                    "dif": macd_dif,
                    "macd": macd_dea,
                    "histogram": macd_hist,
                    "status": macd_status,
                },
            },
            "score": {
                "buy": buy_score,
                "sell": sell_score,
                "rating": rating,
            },
            # 添加圖表數據 (最近 1500 天，支援 5 年範圍)
            "chart_data": {
                "dates": [str(d) for d in df['date'].tail(1500).tolist()],
                "prices": [float(p) for p in df['close'].tail(1500).tolist()],
                "ma20": [float(v) if not pd.isna(v) else None for v in df['ma20'].tail(1500).tolist()] if 'ma20' in df.columns else [],
                "ma50": [float(v) if not pd.isna(v) else None for v in df['ma50'].tail(1500).tolist()] if 'ma50' in df.columns else [],
                "ma200": [float(v) if not pd.isna(v) else None for v in df['ma200'].tail(1500).tolist()] if 'ma200' in df.columns else [],
                "ma250": [float(v) if not pd.isna(v) else None for v in df['ma250'].tail(1500).tolist()] if 'ma250' in df.columns else [],
            },
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"查詢 {symbol} 時發生錯誤: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"查詢失敗: {str(e)}"
        )


@router.get("/{symbol}/chart", summary="取得股票圖表")
async def get_stock_chart(
    symbol: str,
    days: int = Query(120, ge=30, le=365, description="顯示天數"),
):
    """
    生成股票技術分析圖表
    """
    from app.data_sources.yahoo_finance import yahoo_finance
    from app.services.chart_service import chart_service
    
    # 台股代號自動轉換
    symbol = normalize_tw_symbol(symbol)
    
    df = yahoo_finance.get_stock_history(symbol, period="1y")
    
    # 如果 .TW 找不到，嘗試 .TWO
    if (df is None or df.empty) and symbol.endswith('.TW'):
        two_symbol = symbol.replace('.TW', '.TWO')
        df = yahoo_finance.get_stock_history(two_symbol, period="1y")
        if df is not None and not df.empty:
            symbol = two_symbol
    
    if df is None or df.empty:
        raise HTTPException(
            status_code=404,
            detail=f"找不到股票: {symbol}"
        )
    
    # 取得股票名稱
    info = yahoo_finance.get_stock_info(symbol)
    name = info.get("name", "") if info else ""
    
    # 生成圖表
    chart_path = chart_service.plot_stock_analysis(
        df,
        symbol=symbol,
        name=name,
        days=days,
        show_kd=False,
    )
    
    return FileResponse(
        chart_path,
        media_type="image/png",
        filename=f"{symbol}_chart.png",
    )


@router.get("/compare/history", summary="走勢比較")
async def compare_stocks(
    symbols: str = Query(..., description="股票代號，逗號分隔，最多 5 個"),
    days: int = Query(90, ge=7, le=365, description="比較天數"),
):
    """
    取得多支股票的正規化走勢資料（用於比較圖表）
    
    - 價格會正規化為起始日 = 100%
    - 回傳各股票的日期、正規化價格
    """
    from app.data_sources.yahoo_finance import yahoo_finance
    import math
    
    # 解析 symbols，並自動轉換台股代號
    symbol_list = [normalize_tw_symbol(s.strip()) for s in symbols.split(",") if s.strip()]
    
    if len(symbol_list) < 1:
        raise HTTPException(status_code=400, detail="請至少輸入一個代號")
    
    if len(symbol_list) > 5:
        raise HTTPException(status_code=400, detail="最多比較 5 個標的")
    
    logger.info(f"走勢比較: {symbol_list}, {days} 天")
    
    result = {}
    common_dates = None
    
    for symbol in symbol_list:
        try:
            # 判斷是指數還是股票
            if symbol.startswith("^"):
                df = yahoo_finance.get_index_data(symbol, period="2y")
            else:
                df = yahoo_finance.get_stock_history(symbol, period="2y")
                
                # 如果 .TW 找不到，嘗試 .TWO
                if (df is None or df.empty) and symbol.endswith('.TW'):
                    two_symbol = symbol.replace('.TW', '.TWO')
                    df = yahoo_finance.get_stock_history(two_symbol, period="2y")
                    if df is not None and not df.empty:
                        symbol = two_symbol
            
            if df is None or df.empty:
                logger.warning(f"找不到資料: {symbol}")
                continue
            
            # 取最近 N 天
            df = df.tail(days).copy()
            
            if len(df) < 5:
                logger.warning(f"{symbol} 資料不足")
                continue
            
            # 正規化：起始價格 = 100（使用調整後價格以處理分割）
            # 如果沒有 adj_close，用 close
            price_col = "adj_close" if "adj_close" in df.columns else "close"
            start_price = df.iloc[0][price_col]
            if start_price == 0 or pd.isna(start_price):
                continue
            
            df["normalized"] = (df[price_col] / start_price) * 100
            
            # 清理 NaN
            df = df.dropna(subset=["normalized"])
            
            # 取得名稱
            if symbol.startswith("^"):
                from app.models.index_price import INDEX_SYMBOLS
                info = INDEX_SYMBOLS.get(symbol, {})
                name = info.get("name_zh", symbol)
            else:
                info = yahoo_finance.get_stock_info(symbol)
                name = info.get("name", symbol) if info else symbol
            
            # 轉為列表
            history = []
            for _, row in df.iterrows():
                val = row["normalized"]
                # 檢查 NaN/Inf
                if math.isnan(val) or math.isinf(val):
                    continue
                history.append({
                    "date": row["date"].isoformat() if hasattr(row["date"], "isoformat") else str(row["date"]),
                    "value": round(val, 2),
                    "price": round(float(row["close"]), 2),  # 顯示用原始價格
                })
            
            if history:
                end_price_adj = float(df.iloc[-1][price_col])
                result[symbol] = {
                    "symbol": symbol,
                    "name": name,
                    "start_price": round(float(df.iloc[0]["close"]), 2),  # 顯示用原始價格
                    "end_price": round(float(df.iloc[-1]["close"]), 2),   # 顯示用原始價格
                    "change_pct": round((end_price_adj / start_price - 1) * 100, 2),  # 計算用調整後價格
                    "data": history,
                }
                
                # 記錄日期用於對齊
                dates = set(h["date"] for h in history)
                if common_dates is None:
                    common_dates = dates
                else:
                    common_dates = common_dates.intersection(dates)
        
        except Exception as e:
            logger.error(f"處理 {symbol} 失敗: {e}")
            continue
    
    if not result:
        raise HTTPException(status_code=404, detail="找不到任何有效資料")
    
    return {
        "success": True,
        "data": {
            "symbols": list(result.keys()),
            "days": days,
            "stocks": result,
        }
    }


@router.get("/{symbol}/returns", summary="年化報酬率")
async def get_stock_returns(
    symbol: str,
):
    """
    計算股票的歷史年化報酬率 (CAGR)
    
    計算方式：含配息再投入的總報酬率
    - 分割調整：已處理
    - 配息還原：在計算時將配息加回
    
    回傳 1Y, 3Y, 5Y, 10Y 的 CAGR
    """
    from app.data_sources.yahoo_finance import yahoo_finance
    from datetime import date, timedelta
    import math
    
    # 台股代號自動轉換
    symbol = normalize_tw_symbol(symbol)
    original_symbol = symbol
    logger.info(f"計算年化報酬率: {symbol}")
    
    try:
        # 取得 10 年股價歷史
        df = yahoo_finance.get_stock_history(symbol, period="10y")
        
        # 如果 .TW 找不到，嘗試 .TWO
        if (df is None or df.empty) and symbol.endswith('.TW'):
            two_symbol = symbol.replace('.TW', '.TWO')
            df = yahoo_finance.get_stock_history(two_symbol, period="10y")
            if df is not None and not df.empty:
                symbol = two_symbol
        
        if df is None or df.empty:
            raise HTTPException(status_code=404, detail=f"找不到股票: {original_symbol}")
        
        # 確保有 date 欄位
        if 'date' not in df.columns:
            df = df.reset_index()
            if 'Date' in df.columns:
                df = df.rename(columns={'Date': 'date'})
        
        df['date'] = pd.to_datetime(df['date']).dt.date
        df = df.sort_values('date').reset_index(drop=True)
        
        # 取得配息歷史
        dividends_df = yahoo_finance.get_dividends(symbol, period="10y")
        
        # 建立配息字典 {date: amount}
        dividends = {}
        if dividends_df is not None and not dividends_df.empty:
            for _, row in dividends_df.iterrows():
                div_date = row['date']
                if isinstance(div_date, str):
                    div_date = datetime.strptime(div_date, '%Y-%m-%d').date()
                dividends[div_date] = float(row['amount'])
        
        logger.info(f"{symbol} 配息記錄: {len(dividends)} 筆")
        
        # 取得股票名稱
        info = yahoo_finance.get_stock_info(symbol)
        stock_name = info.get("name", symbol) if info else symbol
        
        # 現價（顯示用，用原始收盤價）
        current_price_display = float(df.iloc[-1]['close'])
        current_date = df.iloc[-1]['date']
        
        # ===== 計算含息調整價格（用於報酬率計算） =====
        # 從最新日期往前，每遇到一次配息就調整之前的價格
        df['adj_close_with_div'] = df['adj_close'].astype(float)
        date_to_idx = {row['date']: idx for idx, row in df.iterrows()}
        
        # 找出在資料範圍內的配息
        min_date = df['date'].min()
        max_date = df['date'].max()
        relevant_divs = [(d, amt) for d, amt in dividends.items() 
                        if min_date < d <= max_date]
        
        if relevant_divs:
            # 從最新到最舊處理配息
            for div_date, div_amount in sorted(relevant_divs, reverse=True):
                if div_date in date_to_idx:
                    ex_idx = date_to_idx[div_date]
                    if ex_idx > 0:
                        # 除息前一天的價格
                        prev_price = df.loc[ex_idx - 1, 'adj_close_with_div']
                        if prev_price > div_amount and div_amount > 0:
                            # 還原因子
                            adjustment_factor = prev_price / (prev_price - div_amount)
                            # 調整除息日之前的所有價格
                            df.loc[:ex_idx-1, 'adj_close_with_div'] = df.loc[:ex_idx-1, 'adj_close_with_div'] / adjustment_factor
        
        # 含息調整後現價
        current_price_adj = float(df.iloc[-1]['adj_close_with_div'])
        
        # 計算不同期間的報酬率
        periods = [
            ("1Y", 1),
            ("3Y", 3),
            ("5Y", 5),
            ("10Y", 10),
        ]
        
        results = {}
        
        for period_name, years in periods:
            target_date = current_date - timedelta(days=years * 365)
            
            # 找到最接近目標日期的股價
            past_df = df[df['date'] <= target_date]
            
            if past_df.empty or len(past_df) < 10:
                results[period_name] = None
                continue
            
            start_row = past_df.iloc[-1]
            # 使用含息調整後價格計算報酬率
            start_price_adj = float(start_row['adj_close_with_div'])
            start_date = start_row['date']
            
            if start_price_adj <= 0:
                results[period_name] = None
                continue
            
            # 實際年數（更精確）
            actual_days = (current_date - start_date).days
            actual_years = actual_days / 365.25
            
            if actual_years < 0.5:
                results[period_name] = None
                continue
            
            # CAGR 計算（含息調整後價格）
            cagr = (current_price_adj / start_price_adj) ** (1 / actual_years) - 1
            
            # 計算期間內的配息統計（參考用）
            period_dividends = {d: amt for d, amt in dividends.items() 
                              if start_date < d <= current_date}
            
            total_dividends_per_share = sum(period_dividends.values())
            
            logger.info(f"{symbol} {period_name}: 起始日={start_date}, 起始價(含息調整)={start_price_adj:.2f}, 現價(含息調整)={current_price_adj:.2f}, CAGR={cagr*100:.2f}%")
            
            # 檢查數值有效性
            def safe_pct(val):
                if val is None or math.isnan(val) or math.isinf(val):
                    return None
                return round(val * 100, 2)
            
            results[period_name] = {
                "years": round(actual_years, 1),
                "start_date": start_date.isoformat(),
                "start_price": round(float(start_row['close']), 2),  # 顯示原始起始價
                "end_price": round(current_price_display, 2),  # 顯示原始現價
                "cagr": safe_pct(cagr),
                "dividend_count": len(period_dividends),
                "total_dividends": round(total_dividends_per_share, 4),
            }
        
        return {
            "success": True,
            "data": {
                "symbol": symbol,
                "name": stock_name,
                "current_price": round(current_price_display, 2),
                "current_date": current_date.isoformat(),
                "returns": results,
                "note": "CAGR 已包含分割調整及配息再投入效果"
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"計算年化報酬率失敗 {symbol}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{symbol}/debug-prices", summary="Debug: 查看價格調整資訊")
async def debug_prices(
    symbol: str,
    years: int = Query(5, description="查詢年數"),
):
    """
    Debug 用：查看原始價格、分割調整、配息資訊
    """
    from app.data_sources.yahoo_finance import yahoo_finance
    from datetime import date, timedelta
    import yfinance as yf
    
    # 台股代號自動轉換
    symbol = normalize_tw_symbol(symbol)
    
    # 如果 .TW 找不到，嘗試 .TWO
    df = yahoo_finance.get_stock_history(symbol, period=f"{years}y")
    if (df is None or df.empty) and symbol.endswith('.TW'):
        two_symbol = symbol.replace('.TW', '.TWO')
        df = yahoo_finance.get_stock_history(two_symbol, period=f"{years}y")
        if df is not None and not df.empty:
            symbol = two_symbol
    
    try:
        if df is None or df.empty:
            raise HTTPException(status_code=404, detail=f"找不到股票: {symbol}")
        
        # 取得配息記錄
        ticker = yf.Ticker(symbol)
        dividends = ticker.dividends
        div_records = []
        total_div = 0
        if dividends is not None and len(dividends) > 0:
            for date_idx, amount in dividends.items():
                div_date = date_idx.date() if hasattr(date_idx, 'date') else pd.to_datetime(date_idx).date()
                div_records.append({
                    "date": str(div_date),
                    "amount": round(float(amount), 4)
                })
                total_div += float(amount)
        
        # 取得分割記錄
        splits = ticker.splits
        split_records = []
        if splits is not None and len(splits) > 0:
            for date_idx, ratio in splits.items():
                split_records.append({
                    "date": str(date_idx.date()),
                    "ratio": float(ratio)
                })
        
        # 取樣價格比較
        sample_prices = []
        indices = [0]
        for y in range(years, 0, -1):
            target_date = date.today() - timedelta(days=y*365)
            closest = df[df['date'] <= target_date]
            if not closest.empty:
                indices.append(closest.index[-1])
        indices.append(len(df) - 1)
        indices = sorted(set(indices))
        
        for idx in indices:
            if idx < len(df):
                row = df.iloc[idx]
                sample_prices.append({
                    "date": str(row['date']),
                    "close_raw": round(float(row['close']), 2),
                    "close_split_adj": round(float(row['adj_close']), 2),
                })
        
        # 計算報酬率比較
        first_raw = float(df.iloc[0]['close'])
        first_adj = float(df.iloc[0]['adj_close'])
        last_raw = float(df.iloc[-1]['close'])
        last_adj = float(df.iloc[-1]['adj_close'])
        
        raw_return = (last_raw / first_raw - 1) * 100 if first_raw > 0 else 0
        split_adj_return = (last_adj / first_adj - 1) * 100 if first_adj > 0 else 0
        
        return {
            "success": True,
            "symbol": symbol,
            "total_records": len(df),
            "date_range": {
                "start": str(df.iloc[0]['date']),
                "end": str(df.iloc[-1]['date'])
            },
            "splits": split_records,
            "dividends": div_records[-10:] if len(div_records) > 10 else div_records,  # 最近 10 筆
            "dividend_count": len(div_records),
            "total_dividends": round(total_div, 4),
            "sample_prices": sample_prices,
            "returns": {
                "raw_return_pct": round(raw_return, 2),
                "split_adj_return_pct": round(split_adj_return, 2),
            },
            "note": "close_raw=原始價格, close_split_adj=分割調整後(圖表用), 年化報酬另含配息還原"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Debug prices 失敗 {symbol}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/watchlist.py  ⭐⭐⭐
> 追蹤清單 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
追蹤清單 API 路由
包含價格快取功能
"""
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import List
import logging

from app.database import get_async_session
from app.services.auth_service import AuthService
from app.services.watchlist_service import WatchlistService
from app.schemas.schemas import (
    WatchlistAdd,
    WatchlistUpdate,
    WatchlistItem,
    WatchlistResponse,
    WatchlistListResponse,
    WatchlistOverviewResponse,
    ResponseBase,
)
from app.models.user import User
from app.models.watchlist import Watchlist
from app.models.price_cache import StockPriceCache

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/watchlist", tags=["追蹤清單"])


async def get_current_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
) -> User:
    """依賴注入：取得當前用戶"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        logger.warning("Watchlist API: 未提供認證 Token")
        raise HTTPException(
            status_code=401,
            detail="未提供認證 Token"
        )
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        logger.warning("Watchlist API: Token 驗證失敗")
        raise HTTPException(
            status_code=401,
            detail="無效的 Token"
        )
    
    logger.debug(f"Watchlist API: 驗證成功 user_id={user.id}, line_id={user.line_user_id}")
    return user


# ============================================================
# 🆕 價格快取 API
# ============================================================

@router.get("/with-prices", summary="追蹤清單（含即時價格）")
async def get_watchlist_with_prices(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶追蹤清單，包含即時價格（從快取讀取）
    
    - 價格來自 stock_price_cache 表
    - 每 10 分鐘由排程更新
    - 回應時間：毫秒級
    """
    logger.info(f"API: 追蹤清單(含價格) - user_id={user.id}")
    
    try:
        # 1. 取得用戶的追蹤清單
        stmt = (
            select(Watchlist)
            .where(Watchlist.user_id == user.id)
            .order_by(Watchlist.added_at.desc())
        )
        result = await db.execute(stmt)
        watchlist_items = list(result.scalars().all())
        
        if not watchlist_items:
            return {
                "success": True,
                "data": [],
                "total": 0,
            }
        
        # 2. 取得所有 symbol
        symbols = [item.symbol for item in watchlist_items]
        
        # 3. 從快取批次取得價格
        cache_stmt = select(StockPriceCache).where(
            StockPriceCache.symbol.in_(symbols)
        )
        cache_result = await db.execute(cache_stmt)
        cached_prices = {r.symbol: r for r in cache_result.scalars().all()}
        
        # 4. 組合資料
        data = []
        for item in watchlist_items:
            cache = cached_prices.get(item.symbol)
            
            data.append({
                "id": item.id,
                "symbol": item.symbol,
                "asset_type": item.asset_type,
                "note": item.note,
                "added_at": item.added_at.isoformat() if item.added_at else None,
                # 價格資訊（從快取）
                "name": cache.name if cache else None,
                "price": float(cache.price) if cache and cache.price else None,
                "change": float(cache.change) if cache and cache.change else None,
                "change_pct": float(cache.change_pct) if cache and cache.change_pct else None,
                "price_updated_at": cache.updated_at.isoformat() if cache and cache.updated_at else None,
            })
        
        return {
            "success": True,
            "data": data,
            "total": len(data),
        }
        
    except Exception as e:
        logger.error(f"取得追蹤清單(含價格)失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/cache-status", summary="快取狀態")
async def get_cache_status(
    db: AsyncSession = Depends(get_async_session),
):
    """查看價格快取狀態"""
    try:
        from app.services.price_cache_service import get_market_status
        
        stmt = select(StockPriceCache)
        result = await db.execute(stmt)
        all_cache = list(result.scalars().all())
        
        if not all_cache:
            return {
                "success": True,
                "total_cached": 0,
                "message": "快取為空，請等待排程更新",
                "market_status": get_market_status(),
            }
        
        updates = [c.updated_at for c in all_cache if c.updated_at]
        tw_stocks = [c for c in all_cache if c.symbol.endswith(('.TW', '.TWO'))]
        us_stocks = [c for c in all_cache if c.asset_type == 'stock' and not c.symbol.endswith(('.TW', '.TWO'))]
        crypto = [c for c in all_cache if c.asset_type == 'crypto']
        
        return {
            "success": True,
            "total_cached": len(all_cache),
            "tw_stocks": len(tw_stocks),
            "us_stocks": len(us_stocks),
            "crypto": len(crypto),
            "oldest_update": min(updates).isoformat() if updates else None,
            "newest_update": max(updates).isoformat() if updates else None,
            "market_status": get_market_status(),
        }
        
    except Exception as e:
        logger.error(f"查詢快取狀態失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================
# 原有的端點
# ============================================================

@router.get("", summary="取得追蹤清單", response_model=WatchlistListResponse)
async def get_watchlist(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶的追蹤清單
    """
    logger.info(f"API: 取得追蹤清單 - user_id={user.id}, line_id={user.line_user_id}")
    
    service = WatchlistService(db)
    items = await service.get_watchlist(user.id)
    
    return WatchlistListResponse(
        success=True,
        data=[WatchlistItem.model_validate(item) for item in items],
        total=len(items),
    )


@router.post("", summary="新增追蹤", response_model=WatchlistResponse)
async def add_to_watchlist(
    data: WatchlistAdd,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    新增標的到追蹤清單
    
    - **symbol**: 股票代號 (如 AAPL) 或加密貨幣 (如 BTC)
    - **note**: 自訂備註（選填）
    """
    logger.info(f"API: 新增追蹤 - user_id={user.id}, line_id={user.line_user_id}, symbol={data.symbol}")
    
    service = WatchlistService(db)
    result = await service.add_to_watchlist(
        user_id=user.id,
        symbol=data.symbol,
        note=data.note,
    )
    
    if not result["success"]:
        raise HTTPException(
            status_code=400,
            detail=result["message"]
        )
    
    return WatchlistResponse(
        success=True,
        message=result["message"],
        data=WatchlistItem.model_validate(result["watchlist"]),
    )


@router.delete("/{symbol}", summary="移除追蹤", response_model=ResponseBase)
async def remove_from_watchlist(
    symbol: str,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    從追蹤清單移除標的
    """
    logger.info(f"API: 移除追蹤 - user_id={user.id}, line_id={user.line_user_id}, symbol={symbol}")
    
    service = WatchlistService(db)
    result = await service.remove_from_watchlist(
        user_id=user.id,
        symbol=symbol,
    )
    
    if not result["success"]:
        raise HTTPException(
            status_code=404,
            detail=result["message"]
        )
    
    return ResponseBase(
        success=True,
        message=result["message"],
    )


@router.put("/{symbol}", summary="更新備註", response_model=ResponseBase)
async def update_watchlist_note(
    symbol: str,
    data: WatchlistUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    更新追蹤標的的備註
    """
    logger.info(f"API: 更新備註 - user_id={user.id}, symbol={symbol}")
    
    service = WatchlistService(db)
    result = await service.update_note(
        user_id=user.id,
        symbol=symbol,
        note=data.note,
    )
    
    if not result["success"]:
        raise HTTPException(
            status_code=404,
            detail=result["message"]
        )
    
    return ResponseBase(
        success=True,
        message=result["message"],
    )


@router.get("/overview", summary="追蹤清單總覽")
async def get_watchlist_overview(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得追蹤清單總覽
    
    包含所有追蹤標的的基本資訊
    """
    logger.info(f"API: 追蹤清單總覽 - user_id={user.id}, line_id={user.line_user_id}")
    
    service = WatchlistService(db)
    items = await service.get_watchlist(user.id)
    
    return {
        "success": True,
        "data": [
            {
                "id": item.id,
                "symbol": item.symbol,
                "asset_type": item.asset_type,
                "note": item.note,
                "added_at": item.added_at.isoformat() if item.added_at else None,
            }
            for item in items
        ],
        "total": len(items),
    }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/watchlist_cache_api.py  ⭐⭐⭐
> 追蹤清單 API - 含價格快取版本
──────────────────────────────────────────────────────────────────────

```py
"""
追蹤清單 API - 含價格快取版本

============================================================
注意：這個檔案是範例程式碼
請將下方的端點整合到你現有的 app/routers/watchlist.py
============================================================

新增端點：
- GET /api/watchlist/with-prices  從快取取得追蹤清單（含即時價格）
- POST /api/watchlist/refresh-cache  手動觸發快取更新
- GET /api/watchlist/cache-status  查看快取狀態
"""
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Session
from sqlalchemy import select
from typing import List, Dict, Any
import logging

# ============================================================
# 以下 import 需要根據你的專案結構調整
# ============================================================
from app.database import get_async_session, get_db
from app.models.user import User
from app.models.watchlist import Watchlist
from app.models.price_cache import StockPriceCache  # 新增的 model
from app.services.price_cache_service import PriceCacheService  # 新增的 service

logger = logging.getLogger(__name__)


# ============================================================
# 整合到現有的 watchlist.py
# 
# 1. 加入上方的 import
# 2. 複製下方三個端點到 watchlist.py
# 3. 將 get_current_user 替換成你現有的驗證函數
# ============================================================


# ---------- 端點 1: 追蹤清單（含價格） ----------

"""
@router.get("/with-prices", summary="追蹤清單（含即時價格）")
async def get_watchlist_with_prices(
    user: User = Depends(get_current_user),  # 用你現有的驗證函數
    db: AsyncSession = Depends(get_async_session),
):
    '''
    取得用戶追蹤清單，包含即時價格（從快取讀取）
    
    - 價格來自 stock_price_cache 表
    - 每 10 分鐘由排程更新
    - 回應時間：毫秒級
    '''
    logger.info(f"API: 追蹤清單(含價格) - user_id={user.id}")
    
    try:
        # 1. 取得用戶的追蹤清單
        stmt = (
            select(Watchlist)
            .where(Watchlist.user_id == user.id)
            .order_by(Watchlist.added_at.desc())
        )
        result = await db.execute(stmt)
        watchlist_items = list(result.scalars().all())
        
        if not watchlist_items:
            return {
                "success": True,
                "data": [],
                "total": 0,
                "cache_info": None,
            }
        
        # 2. 取得所有 symbol
        symbols = [item.symbol for item in watchlist_items]
        
        # 3. 從快取批次取得價格
        cache_stmt = select(StockPriceCache).where(
            StockPriceCache.symbol.in_(symbols)
        )
        cache_result = await db.execute(cache_stmt)
        cached_prices = {r.symbol: r for r in cache_result.scalars().all()}
        
        # 4. 組合資料
        data = []
        oldest_update = None
        
        for item in watchlist_items:
            cache = cached_prices.get(item.symbol)
            
            item_data = {
                "id": item.id,
                "symbol": item.symbol,
                "asset_type": item.asset_type,
                "note": item.note,
                "added_at": item.added_at.isoformat() if item.added_at else None,
                # 價格資訊（從快取）
                "name": cache.name if cache else None,
                "price": float(cache.price) if cache and cache.price else None,
                "change": float(cache.change) if cache and cache.change else None,
                "change_pct": float(cache.change_pct) if cache and cache.change_pct else None,
                "volume": cache.volume if cache else None,
                "price_updated_at": cache.updated_at.isoformat() if cache and cache.updated_at else None,
            }
            data.append(item_data)
            
            # 記錄最舊的更新時間
            if cache and cache.updated_at:
                if oldest_update is None or cache.updated_at < oldest_update:
                    oldest_update = cache.updated_at
        
        return {
            "success": True,
            "data": data,
            "total": len(data),
            "cache_info": {
                "oldest_update": oldest_update.isoformat() if oldest_update else None,
                "symbols_with_price": len(cached_prices),
                "symbols_without_price": len(symbols) - len(cached_prices),
            },
        }
        
    except Exception as e:
        logger.error(f"取得追蹤清單(含價格)失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
"""


# ---------- 端點 2: 手動更新快取 ----------

"""
@router.post("/refresh-cache", summary="手動更新價格快取")
async def refresh_price_cache(
    user: User = Depends(get_current_user),  # 用你現有的驗證函數
    db: Session = Depends(get_db),  # 使用同步 session
):
    '''
    手動觸發價格快取更新
    
    注意：這會對 Yahoo Finance 發送請求，請勿頻繁呼叫
    '''
    # 可選：加上管理員權限檢查
    # if not user.is_admin:
    #     raise HTTPException(status_code=403, detail="需要管理員權限")
    
    logger.info(f"手動更新價格快取 - by user_id={user.id}")
    
    try:
        service = PriceCacheService(db)
        result = service.update_all_tracked_prices(force=True)
        
        return {
            "success": True,
            "message": f"已更新 {result['total_updated']} 筆價格",
            "detail": result,
        }
        
    except Exception as e:
        logger.error(f"手動更新價格快取失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
"""


# ---------- 端點 3: 快取狀態（公開） ----------

"""
@router.get("/cache-status", summary="快取狀態")
async def get_cache_status(
    db: AsyncSession = Depends(get_async_session),
):
    '''
    查看價格快取狀態（公開 API，用於監控）
    '''
    from app.services.price_cache_service import get_market_status
    
    try:
        stmt = select(StockPriceCache)
        result = await db.execute(stmt)
        all_cache = list(result.scalars().all())
        
        if not all_cache:
            return {
                "success": True,
                "total_cached": 0,
                "market_status": get_market_status(),
            }
        
        tw_stocks = [c for c in all_cache if c.symbol.endswith(('.TW', '.TWO'))]
        us_stocks = [c for c in all_cache if c.asset_type == 'stock' and not c.symbol.endswith(('.TW', '.TWO'))]
        crypto = [c for c in all_cache if c.asset_type == "crypto"]
        
        updates = [c.updated_at for c in all_cache if c.updated_at]
        
        return {
            "success": True,
            "total_cached": len(all_cache),
            "tw_stocks": len(tw_stocks),
            "us_stocks": len(us_stocks),
            "crypto": len(crypto),
            "oldest_update": min(updates).isoformat() if updates else None,
            "newest_update": max(updates).isoformat() if updates else None,
            "market_status": get_market_status(),
        }
        
    except Exception as e:
        logger.error(f"查詢快取狀態失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))
"""

```

======================================================================
## 📦 資料模型
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/database.py  ⭐⭐
> 資料庫連線與 Session 管理
──────────────────────────────────────────────────────────────────────

```py
"""
資料庫連線與 Session 管理
支援 SQLite (開發) 和 PostgreSQL (生產)
"""
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import NullPool

from app.config import settings


def get_async_url(url: str) -> str:
    """將一般的資料庫 URL 轉換為 async 格式"""
    if url.startswith("sqlite:///") and "+aiosqlite" not in url:
        return url.replace("sqlite:///", "sqlite+aiosqlite:///")
    elif url.startswith("postgresql://") and "+asyncpg" not in url:
        return url.replace("postgresql://", "postgresql+asyncpg://")
    elif url.startswith("postgres://"):
        # Railway 使用 postgres:// 但 SQLAlchemy 需要 postgresql://
        return url.replace("postgres://", "postgresql+asyncpg://")
    return url


def get_sync_url(url: str) -> str:
    """確保是同步格式的 URL"""
    url = url.replace("+aiosqlite", "").replace("+asyncpg", "")
    # 修正 Railway 的 postgres:// 格式
    if url.startswith("postgres://"):
        url = url.replace("postgres://", "postgresql://")
    return url


def is_postgres(url: str) -> bool:
    """檢查是否為 PostgreSQL"""
    return "postgresql" in url or "postgres" in url


# 取得資料庫 URL
database_url = settings.DATABASE_URL

# 非同步引擎 (FastAPI 用)
async_database_url = get_async_url(database_url)

# PostgreSQL 需要特別的連線池設定
if is_postgres(database_url):
    async_engine = create_async_engine(
        async_database_url,
        echo=settings.DEBUG,
        poolclass=NullPool,  # Railway 建議使用 NullPool
    )
else:
    async_engine = create_async_engine(
        async_database_url,
        echo=settings.DEBUG,
    )

# 非同步 Session
AsyncSessionLocal = async_sessionmaker(
    bind=async_engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

# 同步引擎 (CLI 用)
sync_database_url = get_sync_url(database_url)

if is_postgres(database_url):
    sync_engine = create_engine(
        sync_database_url,
        echo=settings.DEBUG,
        poolclass=NullPool,
    )
else:
    sync_engine = create_engine(
        sync_database_url,
        echo=settings.DEBUG,
    )

# 同步 Session
SyncSessionLocal = sessionmaker(
    bind=sync_engine,
    autocommit=False,
    autoflush=False,
)

# ORM Base
Base = declarative_base()


async def get_async_session():
    """FastAPI 依賴注入用"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()


def get_sync_session():
    """CLI 用同步 Session"""
    session = SyncSessionLocal()
    try:
        return session
    except Exception:
        session.close()
        raise


async def init_db():
    """初始化資料庫（建立所有表格）"""
    async with async_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


def init_db_sync():
    """同步初始化資料庫"""
    Base.metadata.create_all(bind=sync_engine)


# FastAPI 依賴注入用（同步版本，用於某些 API）
def get_db():
    """FastAPI 依賴注入用（同步 Session）"""
    db = SyncSessionLocal()
    try:
        yield db
    finally:
        db.close()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/__init__.py  ⭐⭐
> 資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
資料模型
"""
from app.models.stock_price import StockPrice
from app.models.crypto_price import CryptoPrice
from app.models.market_sentiment import MarketSentiment
from app.models.user import User, LoginLog, TokenBlacklist, SystemConfig
from app.models.watchlist import Watchlist
from app.models.user_settings import (
    UserIndicatorSettings,
    UserAlertSettings,
    UserIndicatorParams,
)
from app.models.notification import Notification
from app.models.index_price import IndexPrice, INDEX_SYMBOLS
from app.models.dividend_history import DividendHistory
from app.models.comparison import Comparison
from app.models.price_cache import StockPriceCache  # 🆕 價格快取

__all__ = [
    "StockPrice",
    "CryptoPrice", 
    "MarketSentiment",
    "User",
    "LoginLog",
    "TokenBlacklist",
    "SystemConfig",
    "Watchlist",
    "UserIndicatorSettings",
    "UserAlertSettings",
    "UserIndicatorParams",
    "Notification",
    "IndexPrice",
    "INDEX_SYMBOLS",
    "DividendHistory",
    "Comparison",
    "StockPriceCache",  # 🆕 價格快取
]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/comparison.py  ⭐⭐
> 報酬率比較組合 Model
──────────────────────────────────────────────────────────────────────

```py
"""
報酬率比較組合 Model
儲存用戶的自訂比較組合
"""
from datetime import datetime
from typing import List, Optional
import json

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship

from app.database import Base


class Comparison(Base):
    """用戶儲存的比較組合"""
    __tablename__ = "comparisons"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    name = Column(String(100), nullable=False)  # 組合名稱
    symbols_json = Column(Text, nullable=False)  # JSON 格式儲存 ["AAPL","MSFT"]
    benchmark = Column(String(20), nullable=True, default="^GSPC")  # 基準指數
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 關聯
    user = relationship("User", backref="comparisons")
    
    @property
    def symbols(self) -> List[str]:
        """取得標的列表"""
        try:
            return json.loads(self.symbols_json)
        except (json.JSONDecodeError, TypeError):
            return []
    
    @symbols.setter
    def symbols(self, value: List[str]):
        """設定標的列表"""
        self.symbols_json = json.dumps(value)
    
    def to_dict(self) -> dict:
        """轉換為字典"""
        return {
            "id": self.id,
            "user_id": self.user_id,
            "name": self.name,
            "symbols": self.symbols,
            "benchmark": self.benchmark,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
    
    def __repr__(self):
        return f"<Comparison(id={self.id}, name='{self.name}', symbols={self.symbols})>"
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/crypto_price.py  ⭐⭐
> 加密貨幣價格歷史資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
加密貨幣價格歷史資料模型
"""
from sqlalchemy import Column, Integer, String, Date, Numeric, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


class CryptoPrice(Base):
    """加密貨幣價格歷史"""
    
    __tablename__ = "crypto_prices"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(10), nullable=False, index=True)  # BTC, ETH
    date = Column(Date, nullable=False, index=True)
    price = Column(Numeric(18, 8))  # USD 價格
    volume_24h = Column(Numeric(18, 2))  # 24 小時成交量
    market_cap = Column(Numeric(18, 2))  # 市值
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_crypto_symbol_date', 'symbol', 'date', unique=True),
    )
    
    def __repr__(self):
        return f"<CryptoPrice(symbol={self.symbol}, date={self.date}, price={self.price})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "symbol": self.symbol,
            "date": self.date.isoformat() if self.date else None,
            "price": float(self.price) if self.price else None,
            "volume_24h": float(self.volume_24h) if self.volume_24h else None,
            "market_cap": float(self.market_cap) if self.market_cap else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/dividend_history.py  ⭐⭐
> 股票配息歷史資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
股票配息歷史資料模型
用於計算含息年化報酬率
"""
from sqlalchemy import Column, Integer, String, Date, Numeric, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


class DividendHistory(Base):
    """股票配息歷史"""
    
    __tablename__ = "dividend_history"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(10), nullable=False, index=True)
    date = Column(Date, nullable=False, index=True)  # 除息日
    amount = Column(Numeric(10, 4), nullable=False)  # 每股配息金額
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_dividend_symbol_date', 'symbol', 'date', unique=True),
    )
    
    def __repr__(self):
        return f"<DividendHistory(symbol={self.symbol}, date={self.date}, amount={self.amount})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "symbol": self.symbol,
            "date": self.date.isoformat() if self.date else None,
            "amount": float(self.amount) if self.amount else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/index_price.py  ⭐⭐
> 市場指數價格歷史資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
市場指數價格歷史資料模型
支援 S&P 500, 道瓊, 納斯達克, 台股加權
"""
from sqlalchemy import Column, Integer, String, Date, Numeric, BigInteger, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


# 指數代號對照
INDEX_SYMBOLS = {
    "^GSPC": {"name": "S&P 500", "name_zh": "標普500"},
    "^DJI": {"name": "Dow Jones", "name_zh": "道瓊工業"},
    "^IXIC": {"name": "NASDAQ", "name_zh": "納斯達克"},
    "^TWII": {"name": "TAIEX", "name_zh": "台股加權"},
}


class IndexPrice(Base):
    """市場指數價格歷史"""
    
    __tablename__ = "index_prices"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(10), nullable=False, index=True)  # ^GSPC, ^DJI, ^IXIC
    name = Column(String(50))  # S&P 500, Dow Jones, NASDAQ
    date = Column(Date, nullable=False, index=True)
    open = Column(Numeric(12, 2))
    high = Column(Numeric(12, 2))
    low = Column(Numeric(12, 2))
    close = Column(Numeric(12, 2))
    volume = Column(BigInteger)
    change = Column(Numeric(10, 2))  # 漲跌點數
    change_pct = Column(Numeric(6, 2))  # 漲跌幅 %
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_index_symbol_date', 'symbol', 'date', unique=True),
    )
    
    def __repr__(self):
        return f"<IndexPrice(symbol={self.symbol}, date={self.date}, close={self.close})>"
    
    @property
    def name_zh(self) -> str:
        """取得中文名稱"""
        info = INDEX_SYMBOLS.get(self.symbol, {})
        return info.get("name_zh", self.name or self.symbol)
    
    def to_dict(self):
        def safe_float(val):
            """安全轉換 float，處理 NaN 和 Infinity"""
            if val is None:
                return None
            try:
                f = float(val)
                # 檢查 NaN 和 Infinity
                import math
                if math.isnan(f) or math.isinf(f):
                    return None
                return f
            except (ValueError, TypeError):
                return None
        
        return {
            "id": self.id,
            "symbol": self.symbol,
            "name": self.name,
            "name_zh": self.name_zh,
            "date": self.date.isoformat() if self.date else None,
            "open": safe_float(self.open),
            "high": safe_float(self.high),
            "low": safe_float(self.low),
            "close": safe_float(self.close),
            "volume": self.volume,
            "change": safe_float(self.change),
            "change_pct": safe_float(self.change_pct),
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/market_sentiment.py  ⭐⭐
> 市場情緒指數資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
市場情緒指數資料模型
"""
from sqlalchemy import Column, Integer, String, Date, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


class MarketSentiment(Base):
    """市場情緒指數"""
    
    __tablename__ = "market_sentiment"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    date = Column(Date, nullable=False, index=True)
    market = Column(String(10), nullable=False)  # stock / crypto
    value = Column(Integer)  # 0-100
    classification = Column(String(20))  # extreme_fear, fear, neutral, greed, extreme_greed
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_sentiment_market_date', 'market', 'date', unique=True),
    )
    
    def __repr__(self):
        return f"<MarketSentiment(market={self.market}, date={self.date}, value={self.value})>"
    
    @staticmethod
    def get_classification(value: int) -> str:
        """根據數值取得分類"""
        if value <= 25:
            return "extreme_fear"
        elif value <= 45:
            return "fear"
        elif value <= 55:
            return "neutral"
        elif value <= 75:
            return "greed"
        else:
            return "extreme_greed"
    
    @staticmethod
    def get_classification_zh(value: int) -> str:
        """根據數值取得中文分類"""
        if value <= 25:
            return "極度恐懼"
        elif value <= 45:
            return "恐懼"
        elif value <= 55:
            return "中性"
        elif value <= 75:
            return "貪婪"
        else:
            return "極度貪婪"
    
    def to_dict(self):
        return {
            "id": self.id,
            "date": self.date.isoformat() if self.date else None,
            "market": self.market,
            "value": self.value,
            "classification": self.classification,
            "classification_zh": self.get_classification_zh(self.value) if self.value else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/notification.py  ⭐⭐
> 通知記錄資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
通知記錄資料模型
"""
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean, Numeric, Text, Index
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.database import Base


class Notification(Base):
    """通知記錄"""
    
    __tablename__ = "notifications"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    symbol = Column(String(10), nullable=False)
    asset_type = Column(String(10), nullable=False)  # stock / crypto
    alert_type = Column(String(30), nullable=False)  # 通知類型
    indicator = Column(String(20))  # 相關指標
    message = Column(Text)  # 通知內容
    price_at_trigger = Column(Numeric(18, 8))  # 觸發時價格
    triggered_at = Column(DateTime, server_default=func.now())
    sent = Column(Boolean, default=False)  # 是否已發送
    sent_at = Column(DateTime)  # 發送時間
    
    # 關聯
    user = relationship("User")
    
    __table_args__ = (
        Index('idx_notification_user', 'user_id'),
        Index('idx_notification_symbol', 'symbol'),
        Index('idx_notification_triggered', 'triggered_at'),
    )
    
    # 通知類型常數
    ALERT_TYPES = {
        "ma_golden_cross": "均線黃金交叉",
        "ma_death_cross": "均線死亡交叉",
        "approaching_breakout": "接近向上突破",
        "approaching_breakdown": "接近向下跌破",
        "breakout": "已突破",
        "breakdown": "已跌破",
        "rsi_overbought": "RSI 超買",
        "rsi_oversold": "RSI 超賣",
        "macd_golden_cross": "MACD 黃金交叉",
        "macd_death_cross": "MACD 死亡交叉",
        "kd_golden_cross": "KD 黃金交叉",
        "kd_death_cross": "KD 死亡交叉",
        "bollinger_breakout": "布林上軌突破",
        "bollinger_breakdown": "布林下軌跌破",
        "volume_surge": "成交量暴增",
        "sentiment_extreme_fear": "極度恐懼",
        "sentiment_extreme_greed": "極度貪婪",
    }
    
    def __repr__(self):
        return f"<Notification(user_id={self.user_id}, symbol={self.symbol}, alert_type={self.alert_type})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "symbol": self.symbol,
            "asset_type": self.asset_type,
            "alert_type": self.alert_type,
            "alert_type_zh": self.ALERT_TYPES.get(self.alert_type, self.alert_type),
            "indicator": self.indicator,
            "message": self.message,
            "price_at_trigger": float(self.price_at_trigger) if self.price_at_trigger else None,
            "triggered_at": self.triggered_at.isoformat() if self.triggered_at else None,
            "sent": self.sent,
            "sent_at": self.sent_at.isoformat() if self.sent_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/price_cache.py  ⭐⭐
> 股票價格快取 Model
──────────────────────────────────────────────────────────────────────

```py
"""
股票價格快取 Model
用於追蹤清單的即時價格顯示（全系統共用）
"""
from sqlalchemy import Column, String, Numeric, BigInteger, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


class StockPriceCache(Base):
    """
    股票即時價格快取
    
    - 全系統共用，不分用戶
    - 每 10 分鐘由排程批次更新
    - 追蹤清單頁面直接從這裡讀取
    """
    
    __tablename__ = "stock_price_cache"
    
    # 主鍵：股票代號（如 0050.TW, AAPL）
    symbol = Column(String(20), primary_key=True)
    
    # 股票名稱
    name = Column(String(100))
    
    # 價格資訊
    price = Column(Numeric(12, 4))           # 最新價格
    prev_close = Column(Numeric(12, 4))      # 前收盤價（用於計算漲跌）
    change = Column(Numeric(12, 4))          # 漲跌金額
    change_pct = Column(Numeric(8, 4))       # 漲跌幅 %
    
    # 成交量
    volume = Column(BigInteger)
    
    # 資產類型：stock / crypto
    asset_type = Column(String(10), default="stock")
    
    # 更新時間
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_cache_asset_type', 'asset_type'),
        Index('idx_cache_updated', 'updated_at'),
    )
    
    def __repr__(self):
        return f"<StockPriceCache(symbol={self.symbol}, price={self.price}, change_pct={self.change_pct}%)>"
    
    def to_dict(self):
        return {
            "symbol": self.symbol,
            "name": self.name,
            "price": float(self.price) if self.price else None,
            "prev_close": float(self.prev_close) if self.prev_close else None,
            "change": float(self.change) if self.change else None,
            "change_pct": float(self.change_pct) if self.change_pct else None,
            "volume": self.volume,
            "asset_type": self.asset_type,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/stock_price.py  ⭐⭐
> 股票價格歷史資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
股票價格歷史資料模型
"""
from sqlalchemy import Column, Integer, String, Date, Numeric, BigInteger, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


class StockPrice(Base):
    """美股價格歷史"""
    
    __tablename__ = "stock_prices"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(10), nullable=False, index=True)
    date = Column(Date, nullable=False, index=True)
    open = Column(Numeric(12, 4))
    high = Column(Numeric(12, 4))
    low = Column(Numeric(12, 4))
    close = Column(Numeric(12, 4))
    volume = Column(BigInteger)
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_stock_symbol_date', 'symbol', 'date', unique=True),
    )
    
    def __repr__(self):
        return f"<StockPrice(symbol={self.symbol}, date={self.date}, close={self.close})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "symbol": self.symbol,
            "date": self.date.isoformat() if self.date else None,
            "open": float(self.open) if self.open else None,
            "high": float(self.high) if self.high else None,
            "low": float(self.low) if self.low else None,
            "close": float(self.close) if self.close else None,
            "volume": self.volume,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/user.py  ⭐⭐
> 用戶資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
用戶資料模型
"""
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.database import Base


class User(Base):
    """用戶資料"""
    
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    line_user_id = Column(String(50), unique=True, nullable=False, index=True)
    display_name = Column(String(100))
    picture_url = Column(String(500))
    email = Column(String(200))
    is_active = Column(Boolean, default=True)
    is_admin = Column(Boolean, default=False)  # 管理員
    is_blocked = Column(Boolean, default=False)  # 封鎖
    blocked_reason = Column(String(200))  # 封鎖原因
    blocked_at = Column(DateTime)  # 封鎖時間
    created_at = Column(DateTime, server_default=func.now())
    last_login = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # 關聯
    watchlists = relationship("Watchlist", back_populates="user", cascade="all, delete-orphan")
    indicator_settings = relationship("UserIndicatorSettings", back_populates="user", uselist=False, cascade="all, delete-orphan")
    alert_settings = relationship("UserAlertSettings", back_populates="user", uselist=False, cascade="all, delete-orphan")
    login_logs = relationship("LoginLog", back_populates="user", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<User(id={self.id}, line_user_id={self.line_user_id}, display_name={self.display_name})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "line_user_id": self.line_user_id,
            "display_name": self.display_name,
            "picture_url": self.picture_url,
            "email": self.email,
            "is_active": self.is_active,
            "is_admin": self.is_admin,
            "is_blocked": self.is_blocked,
            "blocked_reason": self.blocked_reason,
            "blocked_at": self.blocked_at.isoformat() if self.blocked_at else None,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "last_login": self.last_login.isoformat() if self.last_login else None,
        }


class LoginLog(Base):
    """登入日誌"""
    
    __tablename__ = "login_logs"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    action = Column(String(20), nullable=False)  # login, logout, token_refresh
    ip_address = Column(String(50))
    user_agent = Column(String(500))
    created_at = Column(DateTime, server_default=func.now())
    
    # 關聯
    user = relationship("User", back_populates="login_logs")
    
    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "action": self.action,
            "ip_address": self.ip_address,
            "user_agent": self.user_agent,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }


class TokenBlacklist(Base):
    """Token 黑名單（用於踢出用戶）"""
    
    __tablename__ = "token_blacklist"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    token_jti = Column(String(100), unique=True, nullable=False, index=True)  # JWT ID
    user_id = Column(Integer, index=True)
    reason = Column(String(100))  # kicked, logout, blocked
    created_at = Column(DateTime, server_default=func.now())
    expires_at = Column(DateTime)  # Token 過期時間（過期後可清理）
    
    def to_dict(self):
        return {
            "id": self.id,
            "token_jti": self.token_jti,
            "user_id": self.user_id,
            "reason": self.reason,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }


class SystemConfig(Base):
    """系統設定"""
    
    __tablename__ = "system_config"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    key = Column(String(50), unique=True, nullable=False, index=True)
    value = Column(Text)
    description = Column(String(200))
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    def to_dict(self):
        return {
            "id": self.id,
            "key": self.key,
            "value": self.value,
            "description": self.description,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/user_settings.py  ⭐⭐
> 用戶設定資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
用戶設定資料模型
包含指標顯示設定、通知設定、參數設定
"""
from sqlalchemy import Column, Integer, Boolean, ForeignKey, Numeric
from sqlalchemy.orm import relationship
from app.database import Base


class UserIndicatorSettings(Base):
    """用戶指標顯示設定"""
    
    __tablename__ = "user_indicator_settings"
    
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), primary_key=True)
    show_ma = Column(Boolean, default=True)
    show_rsi = Column(Boolean, default=True)
    show_macd = Column(Boolean, default=True)
    show_kd = Column(Boolean, default=False)
    show_bollinger = Column(Boolean, default=True)
    show_obv = Column(Boolean, default=False)
    show_volume = Column(Boolean, default=True)
    
    # 關聯
    user = relationship("User", back_populates="indicator_settings")
    
    def __repr__(self):
        return f"<UserIndicatorSettings(user_id={self.user_id})>"
    
    def to_dict(self):
        return {
            "show_ma": self.show_ma,
            "show_rsi": self.show_rsi,
            "show_macd": self.show_macd,
            "show_kd": self.show_kd,
            "show_bollinger": self.show_bollinger,
            "show_obv": self.show_obv,
            "show_volume": self.show_volume,
        }
    
    @classmethod
    def create_default(cls, user_id: int):
        """建立預設設定"""
        return cls(user_id=user_id)


class UserAlertSettings(Base):
    """用戶通知設定"""
    
    __tablename__ = "user_alert_settings"
    
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), primary_key=True)
    alert_ma_cross = Column(Boolean, default=True)      # 均線交叉通知
    alert_ma_breakout = Column(Boolean, default=True)   # 均線突破通知
    alert_rsi = Column(Boolean, default=True)           # RSI 超買超賣通知
    alert_macd = Column(Boolean, default=True)          # MACD 交叉通知
    alert_kd = Column(Boolean, default=False)           # KD 交叉通知
    alert_bollinger = Column(Boolean, default=False)    # 布林突破通知
    alert_volume = Column(Boolean, default=False)       # 量能異常通知
    alert_sentiment = Column(Boolean, default=True)     # 情緒極端通知
    
    # 關聯
    user = relationship("User", back_populates="alert_settings")
    
    def __repr__(self):
        return f"<UserAlertSettings(user_id={self.user_id})>"
    
    def to_dict(self):
        return {
            "alert_ma_cross": self.alert_ma_cross,
            "alert_ma_breakout": self.alert_ma_breakout,
            "alert_rsi": self.alert_rsi,
            "alert_macd": self.alert_macd,
            "alert_kd": self.alert_kd,
            "alert_bollinger": self.alert_bollinger,
            "alert_volume": self.alert_volume,
            "alert_sentiment": self.alert_sentiment,
        }
    
    @classmethod
    def create_default(cls, user_id: int):
        """建立預設設定"""
        return cls(user_id=user_id)


class UserIndicatorParams(Base):
    """用戶指標參數設定"""
    
    __tablename__ = "user_indicator_params"
    
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), primary_key=True)
    
    # 均線
    ma_short = Column(Integer, default=20)
    ma_mid = Column(Integer, default=50)
    ma_long = Column(Integer, default=200)
    
    # RSI
    rsi_period = Column(Integer, default=14)
    rsi_overbought = Column(Integer, default=70)
    rsi_oversold = Column(Integer, default=30)
    
    # MACD
    macd_fast = Column(Integer, default=12)
    macd_slow = Column(Integer, default=26)
    macd_signal = Column(Integer, default=9)
    
    # KD
    kd_period = Column(Integer, default=9)
    
    # 布林通道
    bollinger_period = Column(Integer, default=20)
    bollinger_std = Column(Numeric(3, 1), default=2.0)
    
    # 警戒值
    breakout_threshold = Column(Numeric(4, 2), default=2.00)  # 突破預警門檻 (%)
    volume_alert_ratio = Column(Numeric(3, 1), default=2.0)   # 量比警戒倍數
    
    # 關聯
    user = relationship("User")
    
    def __repr__(self):
        return f"<UserIndicatorParams(user_id={self.user_id})>"
    
    def to_dict(self):
        return {
            "ma_short": self.ma_short,
            "ma_mid": self.ma_mid,
            "ma_long": self.ma_long,
            "rsi_period": self.rsi_period,
            "rsi_overbought": self.rsi_overbought,
            "rsi_oversold": self.rsi_oversold,
            "macd_fast": self.macd_fast,
            "macd_slow": self.macd_slow,
            "macd_signal": self.macd_signal,
            "kd_period": self.kd_period,
            "bollinger_period": self.bollinger_period,
            "bollinger_std": float(self.bollinger_std) if self.bollinger_std else 2.0,
            "breakout_threshold": float(self.breakout_threshold) if self.breakout_threshold else 2.0,
            "volume_alert_ratio": float(self.volume_alert_ratio) if self.volume_alert_ratio else 2.0,
        }
    
    @classmethod
    def create_default(cls, user_id: int):
        """建立預設設定"""
        return cls(user_id=user_id)
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/watchlist.py  ⭐⭐
> 追蹤清單資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
追蹤清單資料模型
"""
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Index
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.database import Base


class Watchlist(Base):
    """用戶追蹤清單"""
    
    __tablename__ = "watchlists"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    symbol = Column(String(10), nullable=False)
    asset_type = Column(String(10), nullable=False)  # stock / crypto
    note = Column(String(200))  # 自訂備註
    added_at = Column(DateTime, server_default=func.now())
    
    # 關聯
    user = relationship("User", back_populates="watchlists")
    
    __table_args__ = (
        Index('idx_watchlist_user', 'user_id'),
        Index('idx_watchlist_unique', 'user_id', 'symbol', 'asset_type', unique=True),
    )
    
    def __repr__(self):
        return f"<Watchlist(user_id={self.user_id}, symbol={self.symbol}, asset_type={self.asset_type})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "symbol": self.symbol,
            "asset_type": self.asset_type,
            "note": self.note,
            "added_at": self.added_at.isoformat() if self.added_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/schemas/__init__.py  ⭐⭐
> Pydantic Schemas
──────────────────────────────────────────────────────────────────────

```py
"""
Pydantic Schemas
"""
from app.schemas.schemas import *
```

──────────────────────────────────────────────────────────────────────
### 📄 app/schemas/schemas.py  ⭐⭐
> Pydantic Schemas
──────────────────────────────────────────────────────────────────────

```py
"""
Pydantic Schemas
API 請求/回應資料模型
"""
from pydantic import BaseModel, Field
from typing import Optional, List, Any, Dict
from datetime import datetime


# ==================== 通用 ====================

class ResponseBase(BaseModel):
    """基礎回應"""
    success: bool = True
    message: Optional[str] = None


class ErrorResponse(BaseModel):
    """錯誤回應"""
    success: bool = False
    error: Dict[str, str]


# ==================== 用戶 ====================

class UserBase(BaseModel):
    """用戶基本資訊"""
    display_name: Optional[str] = None
    picture_url: Optional[str] = None
    email: Optional[str] = None


class UserResponse(UserBase):
    """用戶回應"""
    id: int
    line_user_id: str
    is_active: bool
    is_admin: bool = False  # 管理員權限
    created_at: Optional[datetime] = None
    last_login: Optional[datetime] = None
    
    class Config:
        from_attributes = True


class LoginResponse(ResponseBase):
    """登入回應"""
    token: str
    user: UserResponse
    is_new_user: bool = False


# ==================== 追蹤清單 ====================

class WatchlistAdd(BaseModel):
    """新增追蹤清單請求"""
    symbol: str = Field(..., min_length=1, max_length=10)
    note: Optional[str] = Field(None, max_length=200)


class WatchlistUpdate(BaseModel):
    """更新追蹤清單請求"""
    note: Optional[str] = Field(None, max_length=200)


class WatchlistItem(BaseModel):
    """追蹤清單項目"""
    id: int
    symbol: str
    asset_type: str
    note: Optional[str] = None
    added_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True


class WatchlistResponse(ResponseBase):
    """追蹤清單回應"""
    data: Optional[WatchlistItem] = None


class WatchlistListResponse(ResponseBase):
    """追蹤清單列表回應"""
    data: List[WatchlistItem] = []
    total: int = 0


class WatchlistOverviewItem(BaseModel):
    """追蹤清單總覽項目"""
    id: int
    symbol: str
    name: Optional[str] = None
    price: Optional[float] = None
    change_day: Optional[float] = None
    change_24h: Optional[float] = None
    ma_alignment: Optional[str] = None
    rsi: Optional[float] = None
    score: Optional[Dict[str, Any]] = None
    note: Optional[str] = None
    added_at: Optional[str] = None


class SentimentItem(BaseModel):
    """情緒指數項目"""
    value: int
    classification: str
    classification_zh: str
    timestamp: str
    market: str


class WatchlistOverviewResponse(ResponseBase):
    """追蹤清單總覽回應"""
    stocks: List[WatchlistOverviewItem] = []
    crypto: List[WatchlistOverviewItem] = []
    sentiment: Optional[Dict[str, SentimentItem]] = None
    total_count: int = 0


# ==================== 設定 ====================

class IndicatorSettingsUpdate(BaseModel):
    """指標顯示設定更新"""
    show_ma: Optional[bool] = None
    show_rsi: Optional[bool] = None
    show_macd: Optional[bool] = None
    show_kd: Optional[bool] = None
    show_bollinger: Optional[bool] = None
    show_obv: Optional[bool] = None
    show_volume: Optional[bool] = None


class IndicatorSettingsResponse(ResponseBase):
    """指標顯示設定回應"""
    data: Dict[str, bool] = {}


class AlertSettingsUpdate(BaseModel):
    """通知設定更新"""
    alert_ma_cross: Optional[bool] = None
    alert_ma_breakout: Optional[bool] = None
    alert_rsi: Optional[bool] = None
    alert_macd: Optional[bool] = None
    alert_kd: Optional[bool] = None
    alert_bollinger: Optional[bool] = None
    alert_volume: Optional[bool] = None
    alert_sentiment: Optional[bool] = None


class AlertSettingsResponse(ResponseBase):
    """通知設定回應"""
    data: Dict[str, bool] = {}


class IndicatorParamsUpdate(BaseModel):
    """指標參數更新"""
    ma_short: Optional[int] = Field(None, ge=5, le=50)
    ma_mid: Optional[int] = Field(None, ge=20, le=100)
    ma_long: Optional[int] = Field(None, ge=50, le=300)
    rsi_period: Optional[int] = Field(None, ge=5, le=30)
    rsi_overbought: Optional[int] = Field(None, ge=60, le=90)
    rsi_oversold: Optional[int] = Field(None, ge=10, le=40)
    macd_fast: Optional[int] = Field(None, ge=5, le=20)
    macd_slow: Optional[int] = Field(None, ge=15, le=40)
    macd_signal: Optional[int] = Field(None, ge=5, le=15)
    kd_period: Optional[int] = Field(None, ge=5, le=20)
    bollinger_period: Optional[int] = Field(None, ge=10, le=30)
    bollinger_std: Optional[float] = Field(None, ge=1.0, le=3.0)
    breakout_threshold: Optional[float] = Field(None, ge=0.5, le=5.0)
    volume_alert_ratio: Optional[float] = Field(None, ge=1.0, le=5.0)


class IndicatorParamsResponse(ResponseBase):
    """指標參數回應"""
    data: Dict[str, Any] = {}


# ==================== 股票/加密貨幣 ====================

class PriceInfo(BaseModel):
    """價格資訊"""
    current: float
    high_52w: Optional[float] = None
    low_52w: Optional[float] = None
    ath: Optional[float] = None
    from_high_pct: Optional[float] = None
    from_low_pct: Optional[float] = None
    from_ath_pct: Optional[float] = None


class ChangeInfo(BaseModel):
    """漲跌幅資訊"""
    day: Optional[float] = None
    week: Optional[float] = None
    month: Optional[float] = None
    quarter: Optional[float] = None
    year: Optional[float] = None


class VolumeInfo(BaseModel):
    """成交量資訊"""
    today: Optional[int] = None
    avg_20d: Optional[int] = None
    ratio: Optional[float] = None


class SignalItem(BaseModel):
    """訊號項目"""
    type: str
    indicator: str
    description: str


class ScoreInfo(BaseModel):
    """評分資訊"""
    buy_score: int = 0
    sell_score: int = 0
    rating: str = "neutral"
    details: List[str] = []


class StockAnalysisResponse(ResponseBase):
    """股票分析回應"""
    symbol: str
    name: str
    asset_type: str = "stock"
    price: PriceInfo
    change: ChangeInfo
    volume: Optional[VolumeInfo] = None
    indicators: Dict[str, Any] = {}
    signals: List[SignalItem] = []
    score: ScoreInfo
    updated_at: Optional[str] = None


class CryptoAnalysisResponse(ResponseBase):
    """加密貨幣分析回應"""
    symbol: str
    name: str
    asset_type: str = "crypto"
    price: PriceInfo
    change: ChangeInfo
    market: Optional[Dict[str, Any]] = None
    indicators: Dict[str, Any] = {}
    signals: List[SignalItem] = []
    score: ScoreInfo
    updated_at: Optional[str] = None


# ==================== 市場情緒 ====================

class MarketSentimentResponse(ResponseBase):
    """市場情緒回應"""
    stock: Optional[SentimentItem] = None
    crypto: Optional[SentimentItem] = None
```

======================================================================
## 🧠 核心邏輯
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/services/__init__.py  ⭐⭐⭐
> 商業邏輯服務模組
──────────────────────────────────────────────────────────────────────

```py
"""
商業邏輯服務模組
"""
from app.services.indicator_service import indicator_service, IndicatorService
from app.services.stock_service import StockService
from app.services.crypto_service import CryptoService
from app.services.chart_service import chart_service, ChartService
from app.services.auth_service import AuthService, AuthServiceSync
from app.services.watchlist_service import WatchlistService
from app.services.market_service import MarketService
from app.services.signal_service import signal_service, SignalService, SignalType
from app.services.line_notify_service import line_notify_service, LineNotifyService

__all__ = [
    "indicator_service",
    "IndicatorService",
    "StockService",
    "CryptoService",
    "chart_service",
    "ChartService",
    "AuthService",
    "AuthServiceSync",
    "WatchlistService",
    "MarketService",
    "signal_service",
    "SignalService",
    "SignalType",
    "line_notify_service",
    "LineNotifyService",
]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/auth_service.py  ⭐⭐⭐
> 認證服務
──────────────────────────────────────────────────────────────────────

```py
"""
認證服務
LINE Login 整合 + JWT Token 管理
"""
import httpx
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from jose import jwt, JWTError
from sqlalchemy.orm import Session
from sqlalchemy import select
import logging
import secrets
import uuid

from app.config import settings
from app.models.user import User, LoginLog, SystemConfig
from app.models.user_settings import UserIndicatorSettings, UserAlertSettings, UserIndicatorParams

logger = logging.getLogger(__name__)

# JWT 設定
JWT_ALGORITHM = "HS256"


class AuthService:
    """認證服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    # ==================== LINE Login ====================
    
    def get_line_auth_url(self, state: str = None) -> str:
        """
        取得 LINE 授權 URL
        
        Args:
            state: 防 CSRF 的隨機字串
            
        Returns:
            LINE 授權頁面 URL
        """
        if not state:
            state = secrets.token_urlsafe(32)
        
        params = {
            "response_type": "code",
            "client_id": settings.LINE_LOGIN_CHANNEL_ID,
            "redirect_uri": settings.LINE_LOGIN_CALLBACK_URL,
            "state": state,
            "scope": "profile openid email",
        }
        
        query_string = "&".join(f"{k}={v}" for k, v in params.items())
        return f"https://access.line.me/oauth2/v2.1/authorize?{query_string}"
    
    async def exchange_code_for_token(self, code: str) -> Optional[Dict[str, Any]]:
        """
        用 authorization code 換取 access token
        
        Args:
            code: LINE 回傳的 authorization code
            
        Returns:
            包含 access_token, id_token 等的字典
        """
        url = "https://api.line.me/oauth2/v2.1/token"
        
        data = {
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": settings.LINE_LOGIN_CALLBACK_URL,
            "client_id": settings.LINE_LOGIN_CHANNEL_ID,
            "client_secret": settings.LINE_LOGIN_CHANNEL_SECRET,
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(url, data=data)
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error(f"LINE token 交換失敗: {e}")
            return None
    
    async def get_line_profile(self, access_token: str) -> Optional[Dict[str, Any]]:
        """
        用 access token 取得 LINE 用戶資料
        
        Args:
            access_token: LINE access token
            
        Returns:
            用戶資料字典 (userId, displayName, pictureUrl, statusMessage)
        """
        url = "https://api.line.me/v2/profile"
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    url,
                    headers={"Authorization": f"Bearer {access_token}"}
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error(f"取得 LINE 用戶資料失敗: {e}")
            return None
    
    async def verify_id_token(self, id_token: str) -> Optional[Dict[str, Any]]:
        """
        驗證 LINE ID Token
        
        Args:
            id_token: LINE ID Token
            
        Returns:
            解碼後的 token payload
        """
        url = "https://api.line.me/oauth2/v2.1/verify"
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    url,
                    data={
                        "id_token": id_token,
                        "client_id": settings.LINE_LOGIN_CHANNEL_ID,
                    }
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error(f"LINE ID Token 驗證失敗: {e}")
            return None
    
    # ==================== 用戶管理 ====================
    
    async def get_user_by_line_id(self, line_user_id: str) -> Optional[User]:
        """根據 LINE User ID 取得用戶"""
        stmt = select(User).where(User.line_user_id == line_user_id)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_user_by_id(self, user_id: int) -> Optional[User]:
        """根據 ID 取得用戶"""
        stmt = select(User).where(User.id == user_id)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def create_user(
        self,
        line_user_id: str,
        display_name: str = None,
        picture_url: str = None,
        email: str = None,
    ) -> User:
        """
        建立新用戶
        
        會自動建立預設設定，並檢查是否為初始管理員
        """
        # 檢查是否為初始管理員
        admin_ids = settings.get_admin_line_ids()
        is_admin = line_user_id in admin_ids
        
        user = User(
            line_user_id=line_user_id,
            display_name=display_name,
            picture_url=picture_url,
            email=email,
            is_admin=is_admin,
        )
        self.db.add(user)
        await self.db.flush()  # 取得 user.id
        
        # 建立預設設定
        indicator_settings = UserIndicatorSettings.create_default(user.id)
        alert_settings = UserAlertSettings.create_default(user.id)
        params = UserIndicatorParams.create_default(user.id)
        
        self.db.add(indicator_settings)
        self.db.add(alert_settings)
        self.db.add(params)
        
        await self.db.commit()
        await self.db.refresh(user)
        
        logger.info(f"新用戶建立: {user.id} ({display_name}), admin={is_admin}")
        return user
    
    async def update_user_login(self, user: User, display_name: str = None, picture_url: str = None):
        """更新用戶登入資訊"""
        if display_name:
            user.display_name = display_name
        if picture_url:
            user.picture_url = picture_url
        user.last_login = datetime.utcnow()
        
        # 檢查是否需要升級為管理員（使用 getattr 和 setattr 避免欄位不存在的錯誤）
        try:
            if not getattr(user, 'is_admin', False):
                admin_ids = settings.get_admin_line_ids()
                if user.line_user_id in admin_ids:
                    user.is_admin = True
                    logger.info(f"用戶 {user.id} 升級為管理員")
        except Exception as e:
            logger.warning(f"is_admin check failed: {e}")
        
        await self.db.commit()
    
    async def log_login(self, user_id: int, action: str = "login", ip_address: str = None, user_agent: str = None):
        """記錄登入日誌"""
        try:
            log = LoginLog(
                user_id=user_id,
                action=action,
                ip_address=ip_address,
                user_agent=user_agent[:500] if user_agent else None,
            )
            self.db.add(log)
            await self.db.commit()
        except Exception as e:
            # 如果 login_logs 表不存在，忽略錯誤
            logger.warning(f"log_login failed (table may not exist): {e}")
    
    async def login_with_line(self, code: str, ip_address: str = None, user_agent: str = None) -> Optional[Dict[str, Any]]:
        """
        LINE Login 完整流程
        
        Args:
            code: LINE 回傳的 authorization code
            
        Returns:
            {
                "user": User,
                "token": str,
                "is_new_user": bool
            }
        """
        logger.info(f"=== LINE Login 開始 ===")
        logger.info(f"IP: {ip_address}, UA: {user_agent[:100] if user_agent else 'N/A'}")
        
        # 1. 換取 access token
        token_data = await self.exchange_code_for_token(code)
        if not token_data:
            logger.error("LINE token 交換失敗")
            return None
        
        access_token = token_data.get("access_token")
        logger.info(f"LINE token 交換成功")
        
        # 2. 取得用戶資料
        profile = await self.get_line_profile(access_token)
        if not profile:
            logger.error("取得 LINE 用戶資料失敗")
            return None
        
        line_user_id = profile.get("userId")
        display_name = profile.get("displayName")
        picture_url = profile.get("pictureUrl")
        
        logger.info(f"LINE 用戶資料: line_id={line_user_id}, name={display_name}")
        
        # 3. 檢查用戶是否存在
        user = await self.get_user_by_line_id(line_user_id)
        is_new_user = False
        
        if user:
            logger.info(f"既有用戶登入: db_id={user.id}, line_id={user.line_user_id}, name={user.display_name}")
            
            # 檢查是否被封鎖（使用 getattr 避免欄位不存在的錯誤）
            if getattr(user, 'is_blocked', False):
                logger.warning(f"封鎖用戶嘗試登入: {user.id} ({display_name})")
                return None
            
            # 更新登入資訊
            await self.update_user_login(user, display_name, picture_url)
            logger.info(f"用戶登入資訊已更新: db_id={user.id}")
        else:
            # 建立新用戶
            logger.info(f"建立新用戶: line_id={line_user_id}, name={display_name}")
            
            # 嘗試從 ID token 取得 email
            email = None
            if token_data.get("id_token"):
                id_token_data = await self.verify_id_token(token_data["id_token"])
                if id_token_data:
                    email = id_token_data.get("email")
            
            user = await self.create_user(
                line_user_id=line_user_id,
                display_name=display_name,
                picture_url=picture_url,
                email=email,
            )
            is_new_user = True
            logger.info(f"新用戶建立成功: db_id={user.id}, line_id={user.line_user_id}")
        
        # 4. 記錄登入日誌
        await self.log_login(user.id, "login", ip_address, user_agent)
        logger.info(f"登入日誌已記錄: user_id={user.id}")
        
        # 5. 產生 JWT Token
        jwt_token = self.create_jwt_token(user)
        
        logger.info(f"=== LINE Login 完成 ===")
        logger.info(f"用戶: db_id={user.id}, line_id={user.line_user_id}, name={user.display_name}, is_new={is_new_user}")
        
        return {
            "user": user,
            "token": jwt_token,
            "is_new_user": is_new_user,
        }
    
    # ==================== JWT Token ====================
    
    def create_jwt_token(self, user: User) -> str:
        """
        建立 JWT Token
        
        Args:
            user: 用戶物件
            
        Returns:
            JWT Token 字串
        """
        expire = datetime.utcnow() + timedelta(days=settings.JWT_EXPIRE_DAYS)
        issued_at = datetime.utcnow()
        
        payload = {
            "sub": str(user.id),
            "line_user_id": user.line_user_id,
            "display_name": user.display_name,
            "is_admin": getattr(user, 'is_admin', False),
            "exp": expire,
            "iat": issued_at,
            "jti": str(uuid.uuid4()),  # 唯一 Token ID
        }
        
        token = jwt.encode(payload, settings.JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    
    def verify_jwt_token(self, token: str) -> Optional[Dict[str, Any]]:
        """
        驗證 JWT Token
        
        Args:
            token: JWT Token 字串
            
        Returns:
            Token payload 或 None
        """
        try:
            payload = jwt.decode(
                token,
                settings.JWT_SECRET_KEY,
                algorithms=[JWT_ALGORITHM]
            )
            return payload
        except JWTError as e:
            logger.warning(f"JWT 驗證失敗: {e}")
            return None
    
    async def check_token_valid(self, user_id: int, issued_at: int) -> bool:
        """
        檢查 Token 是否仍然有效（未被踢出）
        
        Args:
            user_id: 用戶 ID
            issued_at: Token 簽發時間戳
            
        Returns:
            True 如果 Token 有效
        """
        try:
            # 檢查全域 token 版本
            result = await self.db.execute(
                select(SystemConfig).where(SystemConfig.key == "global_token_version")
            )
            global_config = result.scalar_one_or_none()
            
            if global_config and global_config.value:
                global_version = int(global_config.value)
                if issued_at < global_version:
                    return False
            
            # 檢查用戶 token 版本
            result = await self.db.execute(
                select(SystemConfig).where(SystemConfig.key == f"user_token_version:{user_id}")
            )
            user_config = result.scalar_one_or_none()
            
            if user_config and user_config.value:
                user_version = int(user_config.value)
                if issued_at < user_version:
                    return False
        except Exception as e:
            # 如果 system_config 表不存在，忽略錯誤，預設 token 有效
            logger.warning(f"check_token_valid error (table may not exist): {e}")
        
        return True
    
    async def get_user_from_token(self, token: str) -> Optional[User]:
        """
        從 JWT Token 取得用戶
        
        Args:
            token: JWT Token 字串
            
        Returns:
            User 物件或 None
        """
        payload = self.verify_jwt_token(token)
        if not payload:
            logger.warning("Token 驗證失敗: payload 為空")
            return None
        
        user_id = payload.get("sub")
        token_line_user_id = payload.get("line_user_id")
        
        if not user_id:
            logger.warning("Token 驗證失敗: 缺少 user_id")
            return None
        
        user_id = int(user_id)
        
        # 檢查 Token 是否被踢出
        issued_at = payload.get("iat")
        if issued_at:
            if isinstance(issued_at, datetime):
                issued_at = int(issued_at.timestamp())
            
            is_valid = await self.check_token_valid(user_id, issued_at)
            if not is_valid:
                logger.info(f"Token 已被踢出: user_id={user_id}")
                return None
        
        user = await self.get_user_by_id(user_id)
        
        if not user:
            logger.warning(f"Token 驗證失敗: 用戶不存在 user_id={user_id}")
            return None
        
        # ★★★ 重要：驗證 Token 中的 line_user_id 與資料庫一致 ★★★
        if token_line_user_id and user.line_user_id != token_line_user_id:
            logger.error(f"Token 驗證失敗: LINE ID 不一致! token={token_line_user_id}, db={user.line_user_id}")
            return None
        
        # 檢查用戶是否被封鎖（使用 getattr 避免欄位不存在的錯誤）
        if getattr(user, 'is_blocked', False):
            logger.info(f"封鎖用戶嘗試存取: user_id={user_id}")
            return None
        
        logger.debug(f"Token 驗證成功: user_id={user_id}, line_id={user.line_user_id}")
        return user


# ==================== 同步版本（CLI 用）====================

class AuthServiceSync:
    """同步版認證服務（CLI 用）"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def get_user_by_id(self, user_id: int) -> Optional[User]:
        """根據 ID 取得用戶"""
        stmt = select(User).where(User.id == user_id)
        return self.db.execute(stmt).scalar_one_or_none()
    
    def get_user_by_line_id(self, line_user_id: str) -> Optional[User]:
        """根據 LINE User ID 取得用戶"""
        stmt = select(User).where(User.line_user_id == line_user_id)
        return self.db.execute(stmt).scalar_one_or_none()
    
    def create_demo_user(self, name: str = "Demo User") -> User:
        """建立測試用戶（開發用）"""
        demo_line_id = f"demo_{secrets.token_hex(8)}"
        
        user = User(
            line_user_id=demo_line_id,
            display_name=name,
        )
        self.db.add(user)
        self.db.flush()
        
        # 建立預設設定
        self.db.add(UserIndicatorSettings.create_default(user.id))
        self.db.add(UserAlertSettings.create_default(user.id))
        self.db.add(UserIndicatorParams.create_default(user.id))
        
        self.db.commit()
        self.db.refresh(user)
        return user
    
    def verify_jwt_token(self, token: str) -> Optional[Dict[str, Any]]:
        """驗證 JWT Token"""
        try:
            payload = jwt.decode(
                token,
                settings.JWT_SECRET_KEY,
                algorithms=[JWT_ALGORITHM]
            )
            return payload
        except JWTError:
            return None
    
    def get_user_from_token(self, token: str) -> Optional[User]:
        """從 JWT Token 取得用戶"""
        payload = self.verify_jwt_token(token)
        if not payload:
            return None
        user_id = payload.get("sub")
        if not user_id:
            return None
        return self.get_user_by_id(int(user_id))
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/chart_service.py  ⭐⭐⭐
> 圖表繪製服務
──────────────────────────────────────────────────────────────────────

```py
"""
圖表繪製服務
使用 matplotlib + mplfinance 繪製技術分析圖表
"""
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.patches import Circle
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple
import logging

from app.config import settings, CHARTS_DIR

logger = logging.getLogger(__name__)

# 設定中文字體
plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS', 'DejaVu Sans']
plt.rcParams['axes.unicode_minus'] = False

# 顏色定義
COLORS = {
    "price": "#2196F3",      # 價格線 - 藍色
    "ma_short": "#FF9800",   # MA20 - 橙色
    "ma_mid": "#9C27B0",     # MA50 - 紫色
    "ma_long": "#F44336",    # MA200 - 紅色
    "volume_up": "#4CAF50",  # 上漲成交量 - 綠色
    "volume_down": "#F44336", # 下跌成交量 - 紅色
    "bb_fill": "#E3F2FD",    # 布林通道填充 - 淺藍
    "bb_line": "#90CAF9",    # 布林通道線 - 藍色
    "rsi": "#673AB7",        # RSI - 深紫
    "macd_dif": "#2196F3",   # MACD DIF - 藍色
    "macd_dea": "#FF9800",   # MACD DEA - 橙色
    "macd_hist_pos": "#4CAF50",  # MACD 正柱 - 綠色
    "macd_hist_neg": "#F44336",  # MACD 負柱 - 紅色
    "kd_k": "#2196F3",       # K 線 - 藍色
    "kd_d": "#FF9800",       # D 線 - 橙色
    "golden_cross": "#4CAF50",   # 黃金交叉 - 綠色
    "death_cross": "#F44336",    # 死亡交叉 - 紅色
    "grid": "#E0E0E0",       # 網格線
    "overbought": "#FFCDD2", # 超買區 - 淺紅
    "oversold": "#C8E6C9",   # 超賣區 - 淺綠
}


class ChartService:
    """圖表繪製服務"""
    
    def __init__(self, output_dir: Path = None):
        self.output_dir = output_dir or CHARTS_DIR
        self.output_dir.mkdir(exist_ok=True)
    
    def plot_stock_analysis(
        self,
        df: pd.DataFrame,
        symbol: str,
        name: str = "",
        show_ma: bool = True,
        show_bollinger: bool = True,
        show_volume: bool = True,
        show_rsi: bool = True,
        show_macd: bool = True,
        show_kd: bool = False,
        show_signals: bool = True,
        days: int = 120,
        save_path: Optional[str] = None,
    ) -> str:
        """
        繪製完整股票分析圖表
        
        Args:
            df: 含有價格和指標的 DataFrame
            symbol: 股票代號
            name: 股票名稱
            show_ma: 顯示均線
            show_bollinger: 顯示布林通道
            show_volume: 顯示成交量
            show_rsi: 顯示 RSI
            show_macd: 顯示 MACD
            show_kd: 顯示 KD
            show_signals: 標記交叉訊號
            days: 顯示天數
            save_path: 儲存路徑（不指定則自動生成）
            
        Returns:
            圖表檔案路徑
        """
        # 只取最近 N 天資料
        if len(df) > days:
            df = df.tail(days).copy()
        else:
            df = df.copy()
        
        # 確保 date 欄位正確
        if 'date' in df.columns:
            df['date'] = pd.to_datetime(df['date'])
            df = df.set_index('date')
        
        # 計算子圖數量
        n_subplots = 1  # 主圖
        if show_volume:
            n_subplots += 1
        if show_rsi:
            n_subplots += 1
        if show_macd:
            n_subplots += 1
        if show_kd:
            n_subplots += 1
        
        # 設定子圖高度比例
        height_ratios = [3]  # 主圖
        if show_volume:
            height_ratios.append(1)
        if show_rsi:
            height_ratios.append(1)
        if show_macd:
            height_ratios.append(1.2)
        if show_kd:
            height_ratios.append(1)
        
        # 建立圖表
        fig, axes = plt.subplots(
            n_subplots, 1,
            figsize=(14, 3 + n_subplots * 2),
            gridspec_kw={'height_ratios': height_ratios},
            sharex=True,
        )
        
        if n_subplots == 1:
            axes = [axes]
        
        ax_idx = 0
        
        # === 主圖：價格 + 均線 + 布林通道 ===
        ax_main = axes[ax_idx]
        ax_idx += 1
        
        self._plot_price(ax_main, df, show_ma, show_bollinger, show_signals)
        
        # 標題
        title = f"{symbol}"
        if name:
            title += f" - {name}"
        title += f"\n最後更新: {df.index[-1].strftime('%Y-%m-%d')} | 收盤: ${df['close'].iloc[-1]:.2f}"
        ax_main.set_title(title, fontsize=14, fontweight='bold', pad=10)
        
        # === 成交量 ===
        if show_volume:
            self._plot_volume(axes[ax_idx], df)
            ax_idx += 1
        
        # === RSI ===
        if show_rsi and 'rsi' in df.columns:
            self._plot_rsi(axes[ax_idx], df)
            ax_idx += 1
        
        # === MACD ===
        if show_macd and 'macd_dif' in df.columns:
            self._plot_macd(axes[ax_idx], df)
            ax_idx += 1
        
        # === KD ===
        if show_kd and 'kd_k' in df.columns:
            self._plot_kd(axes[ax_idx], df)
            ax_idx += 1
        
        # 調整布局
        plt.tight_layout()
        
        # 儲存圖表
        if not save_path:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            save_path = self.output_dir / f"{symbol}_{timestamp}.png"
        
        plt.savefig(save_path, dpi=150, bbox_inches='tight', facecolor='white')
        plt.close(fig)
        
        logger.info(f"圖表已儲存: {save_path}")
        return str(save_path)
    
    def _plot_price(
        self,
        ax: plt.Axes,
        df: pd.DataFrame,
        show_ma: bool,
        show_bollinger: bool,
        show_signals: bool,
    ):
        """繪製價格主圖"""
        # 布林通道（先畫，作為背景）
        if show_bollinger and 'bb_upper' in df.columns:
            ax.fill_between(
                df.index,
                df['bb_lower'],
                df['bb_upper'],
                color=COLORS['bb_fill'],
                alpha=0.5,
                label='布林通道',
            )
            ax.plot(df.index, df['bb_middle'], color=COLORS['bb_line'], 
                   linewidth=0.8, linestyle='--', alpha=0.7)
        
        # 價格線
        ax.plot(df.index, df['close'], color=COLORS['price'], 
               linewidth=1.5, label='收盤價')
        
        # 均線
        if show_ma:
            ma_short = f"ma{settings.MA_SHORT}"
            ma_mid = f"ma{settings.MA_MID}"
            ma_long = f"ma{settings.MA_LONG}"
            
            if ma_short in df.columns:
                ax.plot(df.index, df[ma_short], color=COLORS['ma_short'],
                       linewidth=1, label=f'MA{settings.MA_SHORT}')
            if ma_mid in df.columns:
                ax.plot(df.index, df[ma_mid], color=COLORS['ma_mid'],
                       linewidth=1, label=f'MA{settings.MA_MID}')
            if ma_long in df.columns:
                ax.plot(df.index, df[ma_long], color=COLORS['ma_long'],
                       linewidth=1, label=f'MA{settings.MA_LONG}')
        
        # 標記交叉訊號
        if show_signals and show_ma:
            self._mark_crossovers(ax, df)
        
        # 設定
        ax.set_ylabel('價格 ($)', fontsize=10)
        ax.legend(loc='upper left', fontsize=8)
        ax.grid(True, color=COLORS['grid'], linestyle='-', linewidth=0.5, alpha=0.7)
        ax.set_xlim(df.index[0], df.index[-1])
    
    def _mark_crossovers(self, ax: plt.Axes, df: pd.DataFrame):
        """標記均線交叉點"""
        ma_short = f"ma{settings.MA_SHORT}"
        ma_mid = f"ma{settings.MA_MID}"
        
        if ma_short not in df.columns or ma_mid not in df.columns:
            return
        
        for i in range(1, len(df)):
            # 黃金交叉
            if (df[ma_short].iloc[i-1] < df[ma_mid].iloc[i-1] and 
                df[ma_short].iloc[i] > df[ma_mid].iloc[i]):
                ax.scatter(df.index[i], df['close'].iloc[i], 
                          color=COLORS['golden_cross'], s=100, marker='^', 
                          zorder=5, edgecolors='white', linewidths=1)
            
            # 死亡交叉
            elif (df[ma_short].iloc[i-1] > df[ma_mid].iloc[i-1] and 
                  df[ma_short].iloc[i] < df[ma_mid].iloc[i]):
                ax.scatter(df.index[i], df['close'].iloc[i], 
                          color=COLORS['death_cross'], s=100, marker='v', 
                          zorder=5, edgecolors='white', linewidths=1)
    
    def _plot_volume(self, ax: plt.Axes, df: pd.DataFrame):
        """繪製成交量"""
        colors = []
        for i in range(len(df)):
            if i == 0:
                colors.append(COLORS['volume_up'])
            elif df['close'].iloc[i] >= df['close'].iloc[i-1]:
                colors.append(COLORS['volume_up'])
            else:
                colors.append(COLORS['volume_down'])
        
        ax.bar(df.index, df['volume'], color=colors, alpha=0.7, width=0.8)
        
        # 20日均量線
        if 'volume_ma20' in df.columns:
            ax.plot(df.index, df['volume_ma20'], color='orange', 
                   linewidth=1, label='20日均量')
            ax.legend(loc='upper left', fontsize=8)
        
        ax.set_ylabel('成交量', fontsize=10)
        ax.grid(True, color=COLORS['grid'], linestyle='-', linewidth=0.5, alpha=0.7)
        
        # 格式化 Y 軸
        ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'{x/1e6:.1f}M'))
    
    def _plot_rsi(self, ax: plt.Axes, df: pd.DataFrame):
        """繪製 RSI"""
        # 超買超賣區域
        ax.axhspan(settings.RSI_OVERBOUGHT, 100, color=COLORS['overbought'], alpha=0.3)
        ax.axhspan(0, settings.RSI_OVERSOLD, color=COLORS['oversold'], alpha=0.3)
        
        # 中線
        ax.axhline(y=50, color='gray', linestyle='--', linewidth=0.8, alpha=0.5)
        ax.axhline(y=settings.RSI_OVERBOUGHT, color='red', linestyle='--', linewidth=0.8, alpha=0.5)
        ax.axhline(y=settings.RSI_OVERSOLD, color='green', linestyle='--', linewidth=0.8, alpha=0.5)
        
        # RSI 線
        ax.plot(df.index, df['rsi'], color=COLORS['rsi'], linewidth=1.2, label='RSI')
        
        # 設定
        ax.set_ylabel('RSI', fontsize=10)
        ax.set_ylim(0, 100)
        ax.legend(loc='upper left', fontsize=8)
        ax.grid(True, color=COLORS['grid'], linestyle='-', linewidth=0.5, alpha=0.7)
        
        # 標記最新值
        latest_rsi = df['rsi'].iloc[-1]
        if not pd.isna(latest_rsi):
            ax.annotate(f'{latest_rsi:.1f}', 
                       xy=(df.index[-1], latest_rsi),
                       xytext=(5, 0), textcoords='offset points',
                       fontsize=9, color=COLORS['rsi'])
    
    def _plot_macd(self, ax: plt.Axes, df: pd.DataFrame):
        """繪製 MACD"""
        # 零軸
        ax.axhline(y=0, color='gray', linestyle='-', linewidth=0.8)
        
        # MACD 柱狀圖
        colors = [COLORS['macd_hist_pos'] if v >= 0 else COLORS['macd_hist_neg'] 
                 for v in df['macd_hist']]
        ax.bar(df.index, df['macd_hist'], color=colors, alpha=0.6, width=0.8)
        
        # DIF 和 DEA 線
        ax.plot(df.index, df['macd_dif'], color=COLORS['macd_dif'], 
               linewidth=1.2, label='DIF')
        ax.plot(df.index, df['macd_dea'], color=COLORS['macd_dea'], 
               linewidth=1.2, label='DEA')
        
        # 標記交叉點
        for i in range(1, len(df)):
            if pd.isna(df['macd_dif'].iloc[i]) or pd.isna(df['macd_dea'].iloc[i]):
                continue
            # 黃金交叉
            if (df['macd_dif'].iloc[i-1] < df['macd_dea'].iloc[i-1] and 
                df['macd_dif'].iloc[i] > df['macd_dea'].iloc[i]):
                ax.scatter(df.index[i], df['macd_dif'].iloc[i], 
                          color=COLORS['golden_cross'], s=50, marker='^', zorder=5)
            # 死亡交叉
            elif (df['macd_dif'].iloc[i-1] > df['macd_dea'].iloc[i-1] and 
                  df['macd_dif'].iloc[i] < df['macd_dea'].iloc[i]):
                ax.scatter(df.index[i], df['macd_dif'].iloc[i], 
                          color=COLORS['death_cross'], s=50, marker='v', zorder=5)
        
        # 設定
        ax.set_ylabel('MACD', fontsize=10)
        ax.legend(loc='upper left', fontsize=8)
        ax.grid(True, color=COLORS['grid'], linestyle='-', linewidth=0.5, alpha=0.7)
    
    def _plot_kd(self, ax: plt.Axes, df: pd.DataFrame):
        """繪製 KD"""
        # 超買超賣區域
        ax.axhspan(80, 100, color=COLORS['overbought'], alpha=0.3)
        ax.axhspan(0, 20, color=COLORS['oversold'], alpha=0.3)
        
        # 中線
        ax.axhline(y=50, color='gray', linestyle='--', linewidth=0.8, alpha=0.5)
        ax.axhline(y=80, color='red', linestyle='--', linewidth=0.8, alpha=0.5)
        ax.axhline(y=20, color='green', linestyle='--', linewidth=0.8, alpha=0.5)
        
        # K 和 D 線
        ax.plot(df.index, df['kd_k'], color=COLORS['kd_k'], linewidth=1.2, label='K')
        ax.plot(df.index, df['kd_d'], color=COLORS['kd_d'], linewidth=1.2, label='D')
        
        # 設定
        ax.set_ylabel('KD', fontsize=10)
        ax.set_ylim(0, 100)
        ax.legend(loc='upper left', fontsize=8)
        ax.grid(True, color=COLORS['grid'], linestyle='-', linewidth=0.5, alpha=0.7)
        ax.set_xlabel('日期', fontsize=10)
    
    def plot_candlestick(
        self,
        df: pd.DataFrame,
        symbol: str,
        name: str = "",
        days: int = 60,
        save_path: Optional[str] = None,
    ) -> str:
        """
        繪製 K 線圖（使用 mplfinance）
        
        Args:
            df: OHLCV DataFrame
            symbol: 股票代號
            name: 股票名稱
            days: 顯示天數
            save_path: 儲存路徑
            
        Returns:
            圖表檔案路徑
        """
        try:
            import mplfinance as mpf
        except ImportError:
            logger.warning("mplfinance 未安裝，使用替代方案")
            return self._plot_candlestick_fallback(df, symbol, name, days, save_path)
        
        # 準備資料
        if len(df) > days:
            df = df.tail(days).copy()
        else:
            df = df.copy()
        
        # 確保索引為 DatetimeIndex
        if 'date' in df.columns:
            df['date'] = pd.to_datetime(df['date'])
            df = df.set_index('date')
        
        # 確保欄位名稱正確（mplfinance 需要大寫）
        df = df.rename(columns={
            'open': 'Open',
            'high': 'High',
            'low': 'Low',
            'close': 'Close',
            'volume': 'Volume',
        })
        
        # 準備均線
        ma_short = f"ma{settings.MA_SHORT}"
        ma_mid = f"ma{settings.MA_MID}"
        ma_long = f"ma{settings.MA_LONG}"
        
        addplots = []
        if ma_short in df.columns:
            addplots.append(mpf.make_addplot(df[ma_short], color=COLORS['ma_short']))
        if ma_mid in df.columns:
            addplots.append(mpf.make_addplot(df[ma_mid], color=COLORS['ma_mid']))
        if ma_long in df.columns:
            addplots.append(mpf.make_addplot(df[ma_long], color=COLORS['ma_long']))
        
        # 設定樣式
        mc = mpf.make_marketcolors(
            up='#4CAF50',
            down='#F44336',
            edge='inherit',
            wick='inherit',
            volume='inherit',
        )
        style = mpf.make_mpf_style(
            marketcolors=mc,
            gridstyle='-',
            gridcolor=COLORS['grid'],
        )
        
        # 儲存路徑
        if not save_path:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            save_path = self.output_dir / f"{symbol}_kline_{timestamp}.png"
        
        # 標題
        title = f"{symbol}"
        if name:
            title += f" - {name}"
        
        # 繪製
        mpf.plot(
            df,
            type='candle',
            style=style,
            title=title,
            ylabel='價格 ($)',
            ylabel_lower='成交量',
            volume=True,
            addplot=addplots if addplots else None,
            figsize=(14, 8),
            savefig=str(save_path),
        )
        
        logger.info(f"K線圖已儲存: {save_path}")
        return str(save_path)
    
    def _plot_candlestick_fallback(
        self,
        df: pd.DataFrame,
        symbol: str,
        name: str,
        days: int,
        save_path: Optional[str],
    ) -> str:
        """當 mplfinance 不可用時的替代 K 線圖"""
        if len(df) > days:
            df = df.tail(days).copy()
        else:
            df = df.copy()
        
        if 'date' in df.columns:
            df['date'] = pd.to_datetime(df['date'])
            df = df.set_index('date')
        
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 8), 
                                        gridspec_kw={'height_ratios': [3, 1]},
                                        sharex=True)
        
        # K 線
        width = 0.6
        width2 = 0.1
        
        up = df[df['close'] >= df['open']]
        down = df[df['close'] < df['open']]
        
        # 上漲 K 線
        ax1.bar(up.index, up['close'] - up['open'], width, bottom=up['open'], 
               color='#4CAF50', edgecolor='#4CAF50')
        ax1.bar(up.index, up['high'] - up['close'], width2, bottom=up['close'], 
               color='#4CAF50')
        ax1.bar(up.index, up['low'] - up['open'], width2, bottom=up['open'], 
               color='#4CAF50')
        
        # 下跌 K 線
        ax1.bar(down.index, down['close'] - down['open'], width, bottom=down['open'], 
               color='#F44336', edgecolor='#F44336')
        ax1.bar(down.index, down['high'] - down['open'], width2, bottom=down['open'], 
               color='#F44336')
        ax1.bar(down.index, down['low'] - down['close'], width2, bottom=down['close'], 
               color='#F44336')
        
        # 標題
        title = f"{symbol}"
        if name:
            title += f" - {name}"
        ax1.set_title(title, fontsize=14, fontweight='bold')
        ax1.set_ylabel('價格 ($)')
        ax1.grid(True, alpha=0.3)
        
        # 成交量
        colors = ['#4CAF50' if df['close'].iloc[i] >= df['open'].iloc[i] 
                 else '#F44336' for i in range(len(df))]
        ax2.bar(df.index, df['volume'], color=colors, alpha=0.7)
        ax2.set_ylabel('成交量')
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if not save_path:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            save_path = self.output_dir / f"{symbol}_kline_{timestamp}.png"
        
        plt.savefig(save_path, dpi=150, bbox_inches='tight', facecolor='white')
        plt.close(fig)
        
        return str(save_path)


# 建立預設實例
chart_service = ChartService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/compare_service.py  ⭐⭐⭐
> 報酬率比較服務
──────────────────────────────────────────────────────────────────────

```py
"""
報酬率比較服務
計算並比較多個標的的年化報酬率 (CAGR)

修復：
1. 台股代號自動加 .TW / .TWO
2. 使用調整後價格(adj_close)計算，避免分割影響
3. 加入配息還原，反映真實報酬
"""
import logging
from datetime import datetime, date, timedelta
from typing import List, Dict, Any, Optional, Tuple
import json
import math

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
import pandas as pd

from app.models.comparison import Comparison
from app.data_sources.yahoo_finance import yahoo_finance
from app.data_sources.coingecko import coingecko, CRYPTO_MAP

logger = logging.getLogger(__name__)


# 預設比較組合
PRESET_GROUPS = {
    "us_tech": {
        "name": "美國科技股",
        "symbols": ["AAPL", "MSFT", "GOOGL", "AMZN", "NVDA"],
        "description": "美國五大科技巨頭"
    },
    "crypto_major": {
        "name": "主流加密貨幣",
        "symbols": ["BTC", "ETH", "SOL", "BNB", "XRP"],
        "description": "市值前五大加密貨幣"
    },
    "index": {
        "name": "大盤指數",
        "symbols": ["^GSPC", "^IXIC", "^DJI"],
        "description": "美國三大指數"
    },
    "etf_popular": {
        "name": "熱門 ETF",
        "symbols": ["SPY", "QQQ", "VOO", "VTI", "IWM"],
        "description": "最受歡迎的 ETF"
    },
    "dividend": {
        "name": "高股息股票",
        "symbols": ["JNJ", "PG", "KO", "PEP", "VZ"],
        "description": "穩定配息的藍籌股"
    },
    "tw_etf": {
        "name": "台股 ETF",
        "symbols": ["0050", "0056", "00878", "00919", "006208"],
        "description": "台灣熱門 ETF"
    },
    "tw_tech": {
        "name": "台灣科技股",
        "symbols": ["2330", "2454", "2317", "3711", "2308"],
        "description": "台灣科技權值股"
    }
}

# 基準指數選項
BENCHMARK_OPTIONS = {
    "^GSPC": "S&P 500",
    "^IXIC": "納斯達克",
    "^DJI": "道瓊工業",
    "": "無"
}

# 支援的加密貨幣
SUPPORTED_CRYPTO = set(k for k in CRYPTO_MAP.keys() if k not in ("BITCOIN", "ETHEREUM"))


class CompareService:
    """報酬率比較服務"""
    
    def __init__(self):
        self.max_symbols = 5  # 最多比較 5 個
    
    def _normalize_symbol(self, symbol: str) -> str:
        """
        標準化股票代號
        - 台股代號（純數字 4-6 位）自動加 .TW
        - 其他保持原樣
        """
        symbol = symbol.strip().upper()
        
        # 如果已經有後綴，不處理
        if '.' in symbol or symbol.startswith('^'):
            return symbol
        
        # 檢查是否為加密貨幣
        if symbol in SUPPORTED_CRYPTO:
            return symbol
        
        # 台股代號：4-6 位純數字
        if symbol.isdigit() and 4 <= len(symbol) <= 6:
            return f"{symbol}.TW"
        
        return symbol
    
    def _get_asset_type(self, symbol: str) -> str:
        """判斷資產類型"""
        symbol_upper = symbol.upper()
        
        # 先檢查原始代號是否為加密貨幣
        base_symbol = symbol_upper.replace('.TW', '').replace('.TWO', '')
        if base_symbol in SUPPORTED_CRYPTO:
            return "crypto"
        
        if symbol_upper.startswith("^"):
            return "index"
        elif symbol_upper.endswith(".TW") or symbol_upper.endswith(".TWO"):
            return "tw_stock"
        else:
            return "stock"
    
    def _get_period_days(self, period: str) -> int:
        """取得時間週期對應的天數"""
        period_map = {
            "1y": 365,
            "3y": 365 * 3,
            "5y": 365 * 5,
            "10y": 365 * 10,
        }
        return period_map.get(period, 365)
    
    async def _fetch_price_data(
        self,
        symbol: str,
        days: int = 3650,  # 預設抓 10 年
    ) -> Tuple[Optional[pd.DataFrame], Optional[Dict]]:
        """
        抓取價格資料
        
        Returns:
            (DataFrame, info_dict) 或 (None, None)
        """
        asset_type = self._get_asset_type(symbol)
        
        try:
            if asset_type == "crypto":
                # 加密貨幣用 CoinGecko
                df = coingecko.get_crypto_history(symbol, days=days)
                info = coingecko.get_crypto_info(symbol)
                if info:
                    info_dict = {
                        "name": info.get("name", symbol),
                        "type": "crypto",
                        "current_price": info.get("current_price"),
                    }
                else:
                    info_dict = {"name": symbol, "type": "crypto", "current_price": None}
                return df, info_dict
            else:
                # 股票/指數/ETF 用 Yahoo Finance
                period = "10y" if days >= 3650 else ("5y" if days >= 1825 else "1y")
                df = yahoo_finance.get_stock_history(symbol, period=period)
                
                # 如果 .TW 找不到，嘗試 .TWO (上櫃股票)
                if (df is None or df.empty) and symbol.endswith('.TW'):
                    two_symbol = symbol.replace('.TW', '.TWO')
                    logger.info(f"{symbol} 找不到，嘗試上櫃股票: {two_symbol}")
                    df = yahoo_finance.get_stock_history(two_symbol, period=period)
                    if df is not None and not df.empty:
                        symbol = two_symbol
                        logger.info(f"成功找到上櫃股票: {two_symbol}")
                
                info = yahoo_finance.get_stock_info(symbol)
                
                # 取得現價（用原始收盤價）
                current_price = None
                if df is not None and not df.empty:
                    current_price = float(df['close'].iloc[-1])
                
                if info:
                    info_dict = {
                        "name": info.get("name", symbol),
                        "type": asset_type,
                        "current_price": current_price or info.get("current_price"),
                        "symbol": symbol,  # 可能已經改成 .TWO
                    }
                else:
                    info_dict = {
                        "name": symbol, 
                        "type": asset_type, 
                        "current_price": current_price,
                        "symbol": symbol,
                    }
                
                return df, info_dict
            
        except Exception as e:
            logger.error(f"抓取 {symbol} 資料失敗: {e}")
            return None, None
    
    def _calculate_cagr_with_dividends(
        self,
        symbol: str,
        df: pd.DataFrame,
        years: int,
    ) -> Optional[float]:
        """
        計算含配息調整的 CAGR
        
        使用 adj_close（分割調整）+ 配息還原
        這和股票查詢頁面的計算方式一致
        """
        if df is None or df.empty:
            return None
        
        try:
            # 確保有 date 欄位
            if 'date' not in df.columns:
                df = df.reset_index()
                if 'Date' in df.columns:
                    df = df.rename(columns={'Date': 'date'})
            
            df['date'] = pd.to_datetime(df['date']).dt.date
            df = df.sort_values('date').reset_index(drop=True)
            
            current_date = df['date'].iloc[-1]
            target_date = current_date - timedelta(days=years * 365)
            
            # 找到目標日期之前的資料
            past_df = df[df['date'] <= target_date]
            
            if past_df.empty or len(past_df) < 10:
                return None
            
            # 優先使用 adj_close，沒有則用 close
            price_col = 'adj_close' if 'adj_close' in df.columns else 'close'
            
            start_row = past_df.iloc[-1]
            start_price = float(start_row[price_col])
            start_date = start_row['date']
            
            current_price = float(df.iloc[-1][price_col])
            
            if start_price <= 0:
                return None
            
            # 取得配息資料並調整
            try:
                dividends_df = yahoo_finance.get_dividends(symbol, period=f"{years + 1}y")
                
                if dividends_df is not None and not dividends_df.empty:
                    # 建立含配息調整的價格序列
                    df_adj = df.copy()
                    df_adj['adj_with_div'] = df_adj[price_col].astype(float)
                    
                    date_to_idx = {row['date']: idx for idx, row in df_adj.iterrows()}
                    
                    # 篩選在計算範圍內的配息
                    min_date = df_adj['date'].min()
                    max_date = df_adj['date'].max()
                    
                    dividends = {}
                    for _, row in dividends_df.iterrows():
                        div_date = row['date']
                        if isinstance(div_date, str):
                            div_date = datetime.strptime(div_date, '%Y-%m-%d').date()
                        elif hasattr(div_date, 'date'):
                            div_date = div_date.date()
                        if min_date < div_date <= max_date:
                            dividends[div_date] = float(row['amount'])
                    
                    # 從最新到最舊處理配息（配息還原調整）
                    for div_date, div_amount in sorted(dividends.items(), reverse=True):
                        if div_date in date_to_idx:
                            ex_idx = date_to_idx[div_date]
                            if ex_idx > 0:
                                prev_price = df_adj.loc[ex_idx - 1, 'adj_with_div']
                                if prev_price > div_amount and div_amount > 0:
                                    adjustment_factor = prev_price / (prev_price - div_amount)
                                    df_adj.loc[:ex_idx-1, 'adj_with_div'] = df_adj.loc[:ex_idx-1, 'adj_with_div'] / adjustment_factor
                    
                    # 使用調整後的價格計算
                    start_price = float(df_adj[df_adj['date'] <= target_date].iloc[-1]['adj_with_div'])
                    current_price = float(df_adj.iloc[-1]['adj_with_div'])
                    
                    logger.debug(f"{symbol} 配息調整: 找到 {len(dividends)} 筆配息")
                    
            except Exception as e:
                logger.warning(f"{symbol} 配息調整失敗，使用基本計算: {e}")
            
            # 實際年數（更精確）
            actual_days = (current_date - start_date).days
            actual_years = actual_days / 365.25
            
            if actual_years < 0.5:
                return None
            
            # CAGR 公式
            cagr = (current_price / start_price) ** (1 / actual_years) - 1
            
            # 檢查有效性
            if math.isnan(cagr) or math.isinf(cagr):
                return None
            
            return round(cagr * 100, 2)
            
        except Exception as e:
            logger.error(f"計算 {symbol} CAGR 失敗: {e}")
            return None
    
    def _calculate_custom_cagr(
        self,
        df: pd.DataFrame,
        start_date: date,
        end_date: date,
    ) -> Optional[float]:
        """計算自訂區間的 CAGR"""
        if df is None or df.empty:
            return None
        
        try:
            # 確保日期欄位
            if 'date' in df.columns:
                df = df.set_index('date')
            
            # 篩選日期範圍
            mask = (df.index >= pd.Timestamp(start_date)) & (df.index <= pd.Timestamp(end_date))
            filtered_df = df[mask]
            
            if len(filtered_df) < 2:
                return None
            
            # 優先使用 adj_close
            price_col = 'adj_close' if 'adj_close' in filtered_df.columns else 'close'
            
            start_price = float(filtered_df[price_col].iloc[0])
            end_price = float(filtered_df[price_col].iloc[-1])
            
            # 計算年數
            days = (end_date - start_date).days
            years = days / 365.0
            
            if years <= 0 or start_price <= 0:
                return None
            
            # CAGR 公式
            cagr = (end_price / start_price) ** (1 / years) - 1
            return round(cagr * 100, 2)
            
        except Exception as e:
            logger.error(f"計算自訂 CAGR 失敗: {e}")
            return None
    
    async def compare_cagr(
        self,
        symbols: List[str],
        periods: List[str] = None,
        custom_range: Dict[str, str] = None,
        benchmark: str = "^GSPC",
        sort_by: str = "5y",
        sort_order: str = "desc",
    ) -> Dict[str, Any]:
        """
        比較多個標的的年化報酬率
        
        Args:
            symbols: 標的代號列表 (最多 5 個)
            periods: 時間週期 ["1y", "3y", "5y", "10y"]
            custom_range: 自訂區間 {"start": "2020-01-01", "end": "2024-12-31"}
            benchmark: 基準指數
            sort_by: 排序依據
            sort_order: 排序方向 "asc" / "desc"
            
        Returns:
            比較結果
        """
        # 驗證
        if not symbols:
            return {"success": False, "error": "請至少選擇一個標的"}
        
        if len(symbols) > self.max_symbols:
            return {"success": False, "error": f"最多只能比較 {self.max_symbols} 個標的"}
        
        if periods is None:
            periods = ["1y", "3y", "5y"]
        
        # 正規化代號（處理台股等）
        symbols = [self._normalize_symbol(s) for s in symbols]
        logger.info(f"標準化後的代號: {symbols}")
        
        # 計算需要的天數
        max_days = 3650  # 10 年
        if custom_range:
            try:
                start_date = datetime.strptime(custom_range["start"], "%Y-%m-%d").date()
                end_date = datetime.strptime(custom_range["end"], "%Y-%m-%d").date()
                custom_days = (date.today() - start_date).days
                max_days = max(max_days, custom_days)
            except (ValueError, KeyError):
                custom_range = None
        
        results = []
        
        # 處理每個標的
        for symbol in symbols:
            df, info = await self._fetch_price_data(symbol, max_days)
            
            # 如果有 symbol 更新（例如 .TW -> .TWO），使用更新後的
            actual_symbol = info.get("symbol", symbol) if info else symbol
            
            if df is None or info is None:
                results.append({
                    "symbol": actual_symbol,
                    "name": actual_symbol,
                    "type": self._get_asset_type(actual_symbol),
                    "current_price": None,
                    "cagr": {p: None for p in periods},
                    "error": "無法取得資料"
                })
                continue
            
            # 計算各週期 CAGR（使用含配息的計算）
            cagr_results = {}
            for period in periods:
                period_years = {"1y": 1, "3y": 3, "5y": 5, "10y": 10}.get(period)
                if period_years:
                    cagr_results[period] = self._calculate_cagr_with_dividends(
                        actual_symbol, df, period_years
                    )
            
            # 自訂區間
            if custom_range:
                cagr_results["custom"] = self._calculate_custom_cagr(
                    df, start_date, end_date
                )
            
            results.append({
                "symbol": actual_symbol,
                "name": info.get("name", actual_symbol),
                "type": info.get("type", "stock"),
                "current_price": info.get("current_price"),
                "cagr": cagr_results,
            })
        
        # 計算基準指數
        benchmark_data = None
        if benchmark:
            benchmark_df, benchmark_info = await self._fetch_price_data(benchmark, max_days)
            if benchmark_df is not None:
                benchmark_cagr = {}
                for period in periods:
                    period_years = {"1y": 1, "3y": 3, "5y": 5, "10y": 10}.get(period)
                    if period_years:
                        benchmark_cagr[period] = self._calculate_cagr_with_dividends(
                            benchmark, benchmark_df, period_years
                        )
                
                benchmark_data = {
                    "symbol": benchmark,
                    "name": BENCHMARK_OPTIONS.get(benchmark, benchmark),
                    "cagr": benchmark_cagr,
                }
                
                # 計算 vs benchmark
                for result in results:
                    result["vs_benchmark"] = {}
                    for period in periods:
                        result_cagr = result["cagr"].get(period)
                        bench_cagr = benchmark_cagr.get(period)
                        if result_cagr is not None and bench_cagr is not None:
                            result["vs_benchmark"][period] = round(result_cagr - bench_cagr, 2)
                        else:
                            result["vs_benchmark"][period] = None
        
        # 排序
        def get_sort_value(item):
            val = item.get("cagr", {}).get(sort_by)
            return val if val is not None else float('-inf')
        
        results.sort(key=get_sort_value, reverse=(sort_order == "desc"))
        
        # 加入排名
        for i, result in enumerate(results):
            result["rank"] = i + 1
        
        return {
            "success": True,
            "comparison": results,
            "benchmark": benchmark_data,
            "periods": periods + (["custom"] if custom_range else []),
            "custom_range": custom_range,
            "sort_by": sort_by,
            "generated_at": datetime.now().isoformat(),
            "note": "CAGR 已包含分割調整及配息再投入效果"
        }
    
    def get_presets(self) -> List[Dict[str, Any]]:
        """取得預設組合列表"""
        return [
            {
                "id": key,
                "name": value["name"],
                "description": value["description"],
                "symbols": value["symbols"],
                "count": len(value["symbols"]),
            }
            for key, value in PRESET_GROUPS.items()
        ]
    
    def get_preset_detail(self, preset_id: str) -> Optional[Dict[str, Any]]:
        """取得預設組合詳情"""
        if preset_id not in PRESET_GROUPS:
            return None
        
        preset = PRESET_GROUPS[preset_id]
        return {
            "id": preset_id,
            "name": preset["name"],
            "description": preset["description"],
            "symbols": preset["symbols"],
        }


class ComparisonCRUD:
    """比較組合 CRUD 操作"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_user_comparisons(self, user_id: int) -> List[Comparison]:
        """取得用戶的比較組合"""
        result = await self.db.execute(
            select(Comparison)
            .where(Comparison.user_id == user_id)
            .order_by(Comparison.updated_at.desc())
        )
        return result.scalars().all()
    
    async def get_comparison_by_id(self, comparison_id: int, user_id: int) -> Optional[Comparison]:
        """取得單一比較組合"""
        result = await self.db.execute(
            select(Comparison)
            .where(and_(Comparison.id == comparison_id, Comparison.user_id == user_id))
        )
        return result.scalar_one_or_none()
    
    async def create_comparison(
        self,
        user_id: int,
        name: str,
        symbols: List[str],
        benchmark: str = None,
    ) -> Comparison:
        """建立比較組合"""
        comparison = Comparison(
            user_id=user_id,
            name=name,
            _symbols=json.dumps(symbols),
            benchmark=benchmark,
        )
        self.db.add(comparison)
        await self.db.commit()
        await self.db.refresh(comparison)
        return comparison
    
    async def update_comparison(
        self,
        comparison: Comparison,
        name: str = None,
        symbols: List[str] = None,
        benchmark: str = None,
    ) -> Comparison:
        """更新比較組合"""
        if name is not None:
            comparison.name = name
        if symbols is not None:
            comparison._symbols = json.dumps(symbols)
        if benchmark is not None:
            comparison.benchmark = benchmark
        
        await self.db.commit()
        await self.db.refresh(comparison)
        return comparison
    
    async def delete_comparison(self, comparison: Comparison) -> bool:
        """刪除比較組合"""
        await self.db.delete(comparison)
        await self.db.commit()
        return True
    
    async def count_user_comparisons(self, user_id: int) -> int:
        """計算用戶的比較組合數量"""
        result = await self.db.execute(
            select(Comparison)
            .where(Comparison.user_id == user_id)
        )
        return len(result.scalars().all())


# 單例
compare_service = CompareService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/crypto_service.py  ⭐⭐⭐
> 加密貨幣服務
──────────────────────────────────────────────────────────────────────

```py
"""
加密貨幣服務
整合 CoinGecko 資料、快取和技術指標計算
"""
import pandas as pd
from datetime import datetime, date, timedelta
from typing import Optional, Dict, Any, List
from sqlalchemy.orm import Session
from sqlalchemy import select, and_
import logging

from app.models.crypto_price import CryptoPrice
from app.models.market_sentiment import MarketSentiment
from app.data_sources.coingecko import coingecko
from app.data_sources.fear_greed import fear_greed
from app.services.indicator_service import indicator_service, TrendDirection
from app.config import settings

logger = logging.getLogger(__name__)


class CryptoService:
    """加密貨幣服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def _is_cache_valid(self, symbol: str) -> bool:
        """檢查快取是否有效"""
        today = date.today()
        
        stmt = (
            select(CryptoPrice)
            .where(CryptoPrice.symbol == symbol.upper())
            .order_by(CryptoPrice.date.desc())
            .limit(1)
        )
        result = self.db.execute(stmt).scalar_one_or_none()
        
        if not result:
            return False
        
        # 加密貨幣市場 24/7，檢查更新時間
        if result.updated_at:
            cache_minutes = settings.CRYPTO_DATA_CACHE_MINUTES
            cache_deadline = datetime.now() - timedelta(minutes=cache_minutes)
            if result.updated_at > cache_deadline:
                return True
        
        return False
    
    def _save_prices_to_db(self, df: pd.DataFrame) -> int:
        """儲存價格資料到資料庫"""
        if df is None or df.empty:
            return 0
        
        count = 0
        for _, row in df.iterrows():
            stmt = select(CryptoPrice).where(
                and_(
                    CryptoPrice.symbol == row["symbol"],
                    CryptoPrice.date == row["date"],
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if existing:
                existing.price = row.get("price") or row.get("close")
                existing.volume_24h = row.get("volume_24h")
                existing.market_cap = row.get("market_cap")
            else:
                price = CryptoPrice(
                    symbol=row["symbol"],
                    date=row["date"],
                    price=row.get("price") or row.get("close"),
                    volume_24h=row.get("volume_24h"),
                    market_cap=row.get("market_cap"),
                )
                self.db.add(price)
                count += 1
        
        self.db.commit()
        return count
    
    def _load_prices_from_db(
        self,
        symbol: str,
        days: int = 365,
    ) -> Optional[pd.DataFrame]:
        """從資料庫載入價格資料"""
        start_date = date.today() - timedelta(days=days)
        
        stmt = (
            select(CryptoPrice)
            .where(
                and_(
                    CryptoPrice.symbol == symbol.upper(),
                    CryptoPrice.date >= start_date,
                )
            )
            .order_by(CryptoPrice.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        if not results:
            return None
        
        data = []
        for r in results:
            data.append({
                "symbol": r.symbol,
                "date": r.date,
                "close": float(r.price) if r.price else None,
                "price": float(r.price) if r.price else None,
                "volume": float(r.volume_24h) if r.volume_24h else 0,
                "volume_24h": float(r.volume_24h) if r.volume_24h else None,
                "market_cap": float(r.market_cap) if r.market_cap else None,
                # 加密貨幣沒有 OHLC，用 close 填充
                "open": float(r.price) if r.price else None,
                "high": float(r.price) if r.price else None,
                "low": float(r.price) if r.price else None,
            })
        
        return pd.DataFrame(data)
    
    def fetch_and_cache_crypto(self, symbol: str, days: int = 365) -> bool:
        """抓取加密貨幣資料並快取"""
        df = coingecko.get_market_chart(symbol, days=days)
        if df is None:
            return False
        
        # 轉換欄位名稱以符合資料庫
        df["close"] = df["price"]
        
        self._save_prices_to_db(df)
        return True
    
    def get_crypto_data(
        self,
        symbol: str,
        force_refresh: bool = False,
    ) -> Optional[pd.DataFrame]:
        """取得加密貨幣資料（優先使用快取）"""
        symbol = symbol.upper()
        
        if not coingecko.validate_symbol(symbol):
            logger.warning(f"不支援的加密貨幣: {symbol}")
            return None
        
        # 檢查快取
        if not force_refresh and self._is_cache_valid(symbol):
            logger.info(f"使用快取資料: {symbol}")
            df = self._load_prices_from_db(symbol)
        else:
            logger.info(f"從 CoinGecko 抓取: {symbol}")
            if not self.fetch_and_cache_crypto(symbol):
                df = self._load_prices_from_db(symbol)
                if df is None:
                    return None
            else:
                df = self._load_prices_from_db(symbol)
        
        if df is None or df.empty:
            return None
        
        # 計算技術指標（使用適合加密貨幣的參數）
        df = self._calculate_crypto_indicators(df)
        
        return df
    
    def _calculate_crypto_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """計算加密貨幣技術指標（使用幣圈常用參數）"""
        # 建立幣圈專用的指標服務（使用不同的 MA 週期）
        crypto_indicator = indicator_service.__class__(
            ma_short=7,    # 幣圈短均線
            ma_mid=25,     # 幣圈中均線
            ma_long=99,    # 幣圈長均線
        )
        
        df = crypto_indicator.add_ma_indicators(df)
        df = indicator_service.add_rsi_indicator(df)
        df = indicator_service.add_macd_indicator(df)
        df = indicator_service.add_kd_indicator(df)
        df = indicator_service.add_bollinger_indicator(df)
        
        # 加密貨幣通常沒有真正的成交量資料，跳過 OBV
        if 'volume' in df.columns and df['volume'].sum() > 0:
            df = indicator_service.add_obv_indicator(df)
        
        return df
    
    def get_crypto_analysis(
        self,
        symbol: str,
        force_refresh: bool = False,
    ) -> Optional[Dict[str, Any]]:
        """取得加密貨幣完整分析報告"""
        symbol = symbol.upper()
        
        # 取得資料
        df = self.get_crypto_data(symbol, force_refresh)
        if df is None:
            return None
        
        # 取得詳細資訊
        info = coingecko.get_coin_info(symbol)
        
        # 最新價格
        latest = df.iloc[-1]
        price = float(latest["close"])
        
        # 漲跌幅
        changes = self._calculate_changes(df, info)
        
        # 技術指標
        indicators = self._get_indicators_summary(df, latest)
        
        # 訊號
        signals = indicator_service.get_all_signals(df)
        
        # 評分
        score = indicator_service.calculate_score(df)
        
        return {
            "symbol": symbol,
            "name": info.get("name", symbol) if info else symbol,
            "asset_type": "crypto",
            "price": {
                "current": price,
                "ath": info.get("ath") if info else None,
                "atl": info.get("atl") if info else None,
                "from_ath_pct": info.get("ath_change_percentage") if info else None,
                "high_24h": info.get("high_24h") if info else None,
                "low_24h": info.get("low_24h") if info else None,
            },
            "change": changes,
            "market": {
                "market_cap": info.get("market_cap") if info else None,
                "market_cap_rank": info.get("market_cap_rank") if info else None,
                "volume_24h": info.get("total_volume") if info else None,
                "circulating_supply": info.get("circulating_supply") if info else None,
            },
            "indicators": indicators,
            "signals": [
                {
                    "type": s.type.value,
                    "indicator": s.indicator,
                    "description": s.description,
                }
                for s in signals
            ],
            "score": score,
            "updated_at": datetime.now().isoformat(),
        }
    
    def _calculate_changes(
        self,
        df: pd.DataFrame,
        info: Optional[Dict],
    ) -> Dict[str, float]:
        """計算漲跌幅"""
        changes = {}
        
        # 從 CoinGecko API 取得
        if info:
            changes["day"] = info.get("price_change_percentage_24h")
            changes["week"] = info.get("price_change_percentage_7d")
            changes["month"] = info.get("price_change_percentage_30d")
            changes["year"] = info.get("price_change_percentage_1y")
        
        # 從本地資料計算
        latest_close = df["close"].iloc[-1]
        
        def calc_change(days: int) -> Optional[float]:
            if len(df) <= days:
                return None
            old_close = df["close"].iloc[-(days + 1)]
            if old_close and old_close != 0:
                return round((latest_close - old_close) / old_close * 100, 2)
            return None
        
        # 補充缺失的資料
        if not changes.get("day"):
            changes["day"] = calc_change(1)
        if not changes.get("week"):
            changes["week"] = calc_change(7)
        if not changes.get("month"):
            changes["month"] = calc_change(30)
        
        return changes
    
    def _get_indicators_summary(
        self,
        df: pd.DataFrame,
        latest: pd.Series,
    ) -> Dict[str, Any]:
        """取得指標摘要"""
        price = float(latest["close"])
        
        # MA（幣圈週期）
        ma_info = {
            "ma7": round(latest.get("ma7", 0), 2) if not pd.isna(latest.get("ma7")) else None,
            "ma25": round(latest.get("ma25", 0), 2) if not pd.isna(latest.get("ma25")) else None,
            "ma99": round(latest.get("ma99", 0), 2) if not pd.isna(latest.get("ma99")) else None,
        }
        
        # 判斷均線排列
        ma7 = latest.get("ma7")
        ma25 = latest.get("ma25")
        ma99 = latest.get("ma99")
        
        if not any(pd.isna(x) for x in [ma7, ma25, ma99]):
            if price > ma7 > ma25 > ma99:
                ma_info["alignment"] = "bullish"
            elif price < ma7 < ma25 < ma99:
                ma_info["alignment"] = "bearish"
            else:
                ma_info["alignment"] = "neutral"
        else:
            ma_info["alignment"] = "unknown"
        
        # RSI
        rsi = latest.get("rsi")
        rsi_status, _ = indicator_service.get_rsi_status(rsi)
        rsi_info = {
            "value": round(rsi, 2) if not pd.isna(rsi) else None,
            "status": rsi_status,
        }
        
        # MACD
        macd_dif = latest.get("macd_dif")
        macd_dea = latest.get("macd_dea")
        macd_hist = latest.get("macd_hist")
        macd_info = {
            "dif": round(macd_dif, 4) if not pd.isna(macd_dif) else None,
            "dea": round(macd_dea, 4) if not pd.isna(macd_dea) else None,
            "histogram": round(macd_hist, 4) if not pd.isna(macd_hist) else None,
            "status": "bullish" if macd_hist and macd_hist > 0 else "bearish",
        }
        
        # Bollinger
        bb_upper = latest.get("bb_upper")
        bb_middle = latest.get("bb_middle")
        bb_lower = latest.get("bb_lower")
        bb_info = {
            "upper": round(bb_upper, 2) if not pd.isna(bb_upper) else None,
            "middle": round(bb_middle, 2) if not pd.isna(bb_middle) else None,
            "lower": round(bb_lower, 2) if not pd.isna(bb_lower) else None,
            "position": indicator_service.get_bollinger_position(price, bb_upper, bb_middle, bb_lower),
        }
        
        return {
            "ma": ma_info,
            "rsi": rsi_info,
            "macd": macd_info,
            "bollinger": bb_info,
        }
    
    # ==================== 市場情緒 ====================
    
    def get_market_sentiment(self, market: str = "all") -> Dict[str, Any]:
        """
        取得市場情緒指數
        
        Args:
            market: "stock", "crypto", or "all"
        """
        result = {}
        
        if market in ("all", "stock"):
            stock_sentiment = fear_greed.get_stock_fear_greed()
            if stock_sentiment:
                result["stock"] = stock_sentiment
                # 儲存到資料庫
                self._save_sentiment(stock_sentiment)
        
        if market in ("all", "crypto"):
            crypto_sentiment = fear_greed.get_crypto_fear_greed()
            if crypto_sentiment:
                result["crypto"] = crypto_sentiment
                # 儲存到資料庫
                self._save_sentiment(crypto_sentiment)
        
        return result
    
    def _save_sentiment(self, sentiment_data: Dict[str, Any]):
        """儲存情緒指數到資料庫"""
        try:
            market = sentiment_data.get("market")
            value = sentiment_data.get("value")
            timestamp = sentiment_data.get("timestamp")
            
            if not all([market, value, timestamp]):
                return
            
            sentiment_date = datetime.strptime(timestamp, "%Y-%m-%d").date()
            
            stmt = select(MarketSentiment).where(
                and_(
                    MarketSentiment.market == market,
                    MarketSentiment.date == sentiment_date,
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if existing:
                existing.value = value
                existing.classification = sentiment_data.get("classification")
            else:
                sentiment = MarketSentiment(
                    date=sentiment_date,
                    market=market,
                    value=value,
                    classification=sentiment_data.get("classification"),
                )
                self.db.add(sentiment)
            
            self.db.commit()
        except Exception as e:
            logger.error(f"儲存情緒指數失敗: {e}")
    
    def get_supported_cryptos(self) -> List[Dict[str, str]]:
        """取得支援的加密貨幣列表"""
        from app.data_sources.coingecko import CRYPTO_MAP
        return [
            {"symbol": symbol, "id": coin_id}
            for symbol, coin_id in CRYPTO_MAP.items()
            if symbol not in ("BITCOIN", "ETHEREUM")  # 排除別名
        ]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/indicator_service.py  ⭐⭐⭐
> 技術指標計算服務
──────────────────────────────────────────────────────────────────────

```py
"""
技術指標計算服務
包含 MA、RSI、MACD、KD、布林通道、OBV 等指標計算
"""
import pandas as pd
import numpy as np
from typing import Dict, Any, Optional, Tuple, List
from dataclasses import dataclass
from enum import Enum

from app.config import settings


class TrendDirection(Enum):
    """趨勢方向"""
    BULLISH = "bullish"      # 多頭
    BEARISH = "bearish"      # 空頭
    NEUTRAL = "neutral"      # 中性


class SignalType(Enum):
    """訊號類型"""
    GOLDEN_CROSS = "golden_cross"      # 黃金交叉
    DEATH_CROSS = "death_cross"        # 死亡交叉
    OVERBOUGHT = "overbought"          # 超買
    OVERSOLD = "oversold"              # 超賣
    BREAKOUT = "breakout"              # 突破
    BREAKDOWN = "breakdown"            # 跌破
    APPROACHING_BREAKOUT = "approaching_breakout"  # 接近突破
    APPROACHING_BREAKDOWN = "approaching_breakdown"  # 接近跌破


@dataclass
class Signal:
    """交易訊號"""
    type: SignalType
    indicator: str
    description: str
    value: Optional[float] = None
    date: Optional[str] = None


class IndicatorService:
    """技術指標計算服務"""
    
    def __init__(
        self,
        ma_short: int = None,
        ma_mid: int = None,
        ma_long: int = None,
        rsi_period: int = None,
        rsi_overbought: int = None,
        rsi_oversold: int = None,
        macd_fast: int = None,
        macd_slow: int = None,
        macd_signal: int = None,
        kd_period: int = None,
        bollinger_period: int = None,
        bollinger_std: float = None,
        breakout_threshold: float = None,
    ):
        """
        初始化指標參數
        若未指定，則使用 config 中的預設值
        """
        self.ma_short = ma_short or settings.MA_SHORT
        self.ma_mid = ma_mid or settings.MA_MID
        self.ma_long = ma_long or settings.MA_LONG
        self.rsi_period = rsi_period or settings.RSI_PERIOD
        self.rsi_overbought = rsi_overbought or settings.RSI_OVERBOUGHT
        self.rsi_oversold = rsi_oversold or settings.RSI_OVERSOLD
        self.macd_fast = macd_fast or settings.MACD_FAST
        self.macd_slow = macd_slow or settings.MACD_SLOW
        self.macd_signal = macd_signal or settings.MACD_SIGNAL
        self.kd_period = kd_period or settings.KD_PERIOD
        self.bollinger_period = bollinger_period or settings.BOLLINGER_PERIOD
        self.bollinger_std = bollinger_std or settings.BOLLINGER_STD
        self.breakout_threshold = breakout_threshold or settings.BREAKOUT_THRESHOLD
    
    # ==================== 移動平均線 (MA) ====================
    
    def calculate_ma(self, df: pd.DataFrame, period: int, column: str = "close") -> pd.Series:
        """計算簡單移動平均線 (SMA)"""
        return df[column].rolling(window=period).mean()
    
    def calculate_ema(self, df: pd.DataFrame, period: int, column: str = "close") -> pd.Series:
        """計算指數移動平均線 (EMA)"""
        return df[column].ewm(span=period, adjust=False).mean()
    
    def add_ma_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        新增移動平均線指標
        
        Returns:
            新增 ma20, ma50, ma200, ma250 欄位的 DataFrame
        """
        df = df.copy()
        df[f"ma{self.ma_short}"] = self.calculate_ma(df, self.ma_short)
        df[f"ma{self.ma_mid}"] = self.calculate_ma(df, self.ma_mid)
        df[f"ma{self.ma_long}"] = self.calculate_ma(df, self.ma_long)
        df["ma250"] = self.calculate_ma(df, 250)  # 添加 MA250
        return df
    
    def get_ma_alignment(self, df: pd.DataFrame) -> Tuple[TrendDirection, str]:
        """
        判斷均線排列
        
        Returns:
            (趨勢方向, 描述)
        """
        if len(df) < self.ma_long:
            return TrendDirection.NEUTRAL, "資料不足"
        
        latest = df.iloc[-1]
        ma_short = latest.get(f"ma{self.ma_short}")
        ma_mid = latest.get(f"ma{self.ma_mid}")
        ma_long = latest.get(f"ma{self.ma_long}")
        price = latest["close"]
        
        if pd.isna(ma_short) or pd.isna(ma_mid) or pd.isna(ma_long):
            return TrendDirection.NEUTRAL, "均線資料不足"
        
        # 多頭排列：價格 > 短均 > 中均 > 長均
        if price > ma_short > ma_mid > ma_long:
            return TrendDirection.BULLISH, "多頭排列"
        
        # 空頭排列：價格 < 短均 < 中均 < 長均
        if price < ma_short < ma_mid < ma_long:
            return TrendDirection.BEARISH, "空頭排列"
        
        return TrendDirection.NEUTRAL, "盤整"
    
    def check_ma_cross(self, df: pd.DataFrame, short_ma: str, long_ma: str) -> Optional[Signal]:
        """
        檢查均線交叉
        
        Args:
            df: 含有均線資料的 DataFrame
            short_ma: 短均線欄位名稱 (如 "ma20")
            long_ma: 長均線欄位名稱 (如 "ma50")
            
        Returns:
            Signal 物件或 None
        """
        if len(df) < 2:
            return None
        
        today = df.iloc[-1]
        yesterday = df.iloc[-2]
        
        short_today = today.get(short_ma)
        short_yesterday = yesterday.get(short_ma)
        long_today = today.get(long_ma)
        long_yesterday = yesterday.get(long_ma)
        
        if any(pd.isna(x) for x in [short_today, short_yesterday, long_today, long_yesterday]):
            return None
        
        # 黃金交叉：短均線由下往上穿越長均線
        if short_yesterday < long_yesterday and short_today > long_today:
            return Signal(
                type=SignalType.GOLDEN_CROSS,
                indicator=f"{short_ma}/{long_ma}",
                description=f"{short_ma.upper()} 黃金交叉 {long_ma.upper()}",
            )
        
        # 死亡交叉：短均線由上往下穿越長均線
        if short_yesterday > long_yesterday and short_today < long_today:
            return Signal(
                type=SignalType.DEATH_CROSS,
                indicator=f"{short_ma}/{long_ma}",
                description=f"{short_ma.upper()} 死亡交叉 {long_ma.upper()}",
            )
        
        return None
    
    def check_price_vs_ma(
        self,
        price: float,
        ma_value: float,
        ma_name: str,
    ) -> Optional[Signal]:
        """
        檢查價格與均線的關係（接近突破/跌破）
        
        Args:
            price: 當前價格
            ma_value: 均線值
            ma_name: 均線名稱 (如 "MA20")
            
        Returns:
            Signal 物件或 None
        """
        if pd.isna(ma_value):
            return None
        
        distance_pct = ((price - ma_value) / ma_value) * 100
        
        # 價格在均線下方，且距離小於門檻 -> 接近向上突破
        if -self.breakout_threshold < distance_pct < 0:
            return Signal(
                type=SignalType.APPROACHING_BREAKOUT,
                indicator=ma_name,
                description=f"接近突破 {ma_name} ({abs(distance_pct):.1f}%)",
                value=distance_pct,
            )
        
        # 價格在均線上方，且距離小於門檻 -> 接近向下跌破
        if 0 < distance_pct < self.breakout_threshold:
            return Signal(
                type=SignalType.APPROACHING_BREAKDOWN,
                indicator=ma_name,
                description=f"接近跌破 {ma_name} ({distance_pct:.1f}%)",
                value=distance_pct,
            )
        
        return None
    
    # ==================== RSI ====================
    
    def calculate_rsi(self, df: pd.DataFrame, period: int = None) -> pd.Series:
        """
        計算 RSI（相對強弱指標）
        
        RSI = 100 - (100 / (1 + RS))
        RS = 平均漲幅 / 平均跌幅
        """
        period = period or self.rsi_period
        
        delta = df["close"].diff()
        gain = delta.where(delta > 0, 0)
        loss = (-delta).where(delta < 0, 0)
        
        avg_gain = gain.rolling(window=period).mean()
        avg_loss = loss.rolling(window=period).mean()
        
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi
    
    def add_rsi_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增 RSI 指標"""
        df = df.copy()
        df["rsi"] = self.calculate_rsi(df)
        return df
    
    def get_rsi_status(self, rsi_value: float) -> Tuple[str, str]:
        """
        取得 RSI 狀態
        
        Returns:
            (狀態, 描述)
        """
        if pd.isna(rsi_value):
            return "unknown", "資料不足"
        
        if rsi_value >= self.rsi_overbought:
            return "overbought", f"超買 ({rsi_value:.1f})"
        elif rsi_value <= self.rsi_oversold:
            return "oversold", f"超賣 ({rsi_value:.1f})"
        else:
            return "neutral", f"中性 ({rsi_value:.1f})"
    
    def check_rsi_signal(self, df: pd.DataFrame) -> Optional[Signal]:
        """檢查 RSI 訊號"""
        if len(df) < 2 or "rsi" not in df.columns:
            return None
        
        rsi_today = df["rsi"].iloc[-1]
        rsi_yesterday = df["rsi"].iloc[-2]
        
        if pd.isna(rsi_today) or pd.isna(rsi_yesterday):
            return None
        
        # 進入超買區
        if rsi_yesterday < self.rsi_overbought <= rsi_today:
            return Signal(
                type=SignalType.OVERBOUGHT,
                indicator="RSI",
                description=f"RSI 進入超買區 ({rsi_today:.1f})",
                value=rsi_today,
            )
        
        # 進入超賣區
        if rsi_yesterday > self.rsi_oversold >= rsi_today:
            return Signal(
                type=SignalType.OVERSOLD,
                indicator="RSI",
                description=f"RSI 進入超賣區 ({rsi_today:.1f})",
                value=rsi_today,
            )
        
        return None
    
    # ==================== MACD ====================
    
    def calculate_macd(self, df: pd.DataFrame) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """
        計算 MACD
        
        Returns:
            (DIF, MACD/DEA, Histogram)
        """
        ema_fast = self.calculate_ema(df, self.macd_fast)
        ema_slow = self.calculate_ema(df, self.macd_slow)
        
        dif = ema_fast - ema_slow
        dea = dif.ewm(span=self.macd_signal, adjust=False).mean()
        histogram = dif - dea
        
        return dif, dea, histogram
    
    def add_macd_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增 MACD 指標"""
        df = df.copy()
        df["macd_dif"], df["macd_dea"], df["macd_hist"] = self.calculate_macd(df)
        return df
    
    def check_macd_signal(self, df: pd.DataFrame) -> Optional[Signal]:
        """檢查 MACD 交叉訊號"""
        if len(df) < 2:
            return None
        
        dif_today = df["macd_dif"].iloc[-1]
        dif_yesterday = df["macd_dif"].iloc[-2]
        dea_today = df["macd_dea"].iloc[-1]
        dea_yesterday = df["macd_dea"].iloc[-2]
        
        if any(pd.isna(x) for x in [dif_today, dif_yesterday, dea_today, dea_yesterday]):
            return None
        
        # 黃金交叉：DIF 由下往上穿越 DEA
        if dif_yesterday < dea_yesterday and dif_today > dea_today:
            position = "零軸上方" if dif_today > 0 else "零軸下方"
            return Signal(
                type=SignalType.GOLDEN_CROSS,
                indicator="MACD",
                description=f"MACD 黃金交叉 ({position})",
                value=dif_today,
            )
        
        # 死亡交叉：DIF 由上往下穿越 DEA
        if dif_yesterday > dea_yesterday and dif_today < dea_today:
            position = "零軸上方" if dif_today > 0 else "零軸下方"
            return Signal(
                type=SignalType.DEATH_CROSS,
                indicator="MACD",
                description=f"MACD 死亡交叉 ({position})",
                value=dif_today,
            )
        
        return None
    
    # ==================== KD ====================
    
    def calculate_kd(self, df: pd.DataFrame) -> Tuple[pd.Series, pd.Series]:
        """
        計算 KD（隨機指標）
        
        RSV = (今日收盤 - N日最低) / (N日最高 - N日最低) × 100
        K = 2/3 × 昨日K + 1/3 × RSV
        D = 2/3 × 昨日D + 1/3 × K
        
        Returns:
            (K, D)
        """
        period = self.kd_period
        
        lowest = df["low"].rolling(window=period).min()
        highest = df["high"].rolling(window=period).max()
        
        rsv = ((df["close"] - lowest) / (highest - lowest)) * 100
        
        # 初始化 K, D
        k = pd.Series(index=df.index, dtype=float)
        d = pd.Series(index=df.index, dtype=float)
        
        # 第一個有效值設為 50
        first_valid = rsv.first_valid_index()
        if first_valid is not None:
            idx = df.index.get_loc(first_valid)
            k.iloc[idx] = 50
            d.iloc[idx] = 50
            
            # 迭代計算
            for i in range(idx + 1, len(df)):
                k.iloc[i] = (2/3) * k.iloc[i-1] + (1/3) * rsv.iloc[i]
                d.iloc[i] = (2/3) * d.iloc[i-1] + (1/3) * k.iloc[i]
        
        return k, d
    
    def add_kd_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增 KD 指標"""
        df = df.copy()
        df["kd_k"], df["kd_d"] = self.calculate_kd(df)
        return df
    
    def check_kd_signal(self, df: pd.DataFrame) -> Optional[Signal]:
        """檢查 KD 交叉訊號"""
        if len(df) < 2:
            return None
        
        k_today = df["kd_k"].iloc[-1]
        k_yesterday = df["kd_k"].iloc[-2]
        d_today = df["kd_d"].iloc[-1]
        d_yesterday = df["kd_d"].iloc[-2]
        
        if any(pd.isna(x) for x in [k_today, k_yesterday, d_today, d_yesterday]):
            return None
        
        # 黃金交叉：K 由下往上穿越 D
        if k_yesterday < d_yesterday and k_today > d_today:
            zone = "超賣區" if k_today < 20 else ("超買區" if k_today > 80 else "中性區")
            return Signal(
                type=SignalType.GOLDEN_CROSS,
                indicator="KD",
                description=f"KD 黃金交叉 ({zone}, K={k_today:.1f})",
                value=k_today,
            )
        
        # 死亡交叉：K 由上往下穿越 D
        if k_yesterday > d_yesterday and k_today < d_today:
            zone = "超賣區" if k_today < 20 else ("超買區" if k_today > 80 else "中性區")
            return Signal(
                type=SignalType.DEATH_CROSS,
                indicator="KD",
                description=f"KD 死亡交叉 ({zone}, K={k_today:.1f})",
                value=k_today,
            )
        
        return None
    
    # ==================== 布林通道 ====================
    
    def calculate_bollinger(self, df: pd.DataFrame) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """
        計算布林通道
        
        Returns:
            (上軌, 中軌, 下軌)
        """
        middle = df["close"].rolling(window=self.bollinger_period).mean()
        std = df["close"].rolling(window=self.bollinger_period).std()
        
        upper = middle + (self.bollinger_std * std)
        lower = middle - (self.bollinger_std * std)
        
        return upper, middle, lower
    
    def add_bollinger_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增布林通道指標"""
        df = df.copy()
        df["bb_upper"], df["bb_middle"], df["bb_lower"] = self.calculate_bollinger(df)
        df["bb_width"] = (df["bb_upper"] - df["bb_lower"]) / df["bb_middle"]
        return df
    
    def get_bollinger_position(self, price: float, upper: float, middle: float, lower: float) -> str:
        """取得價格在布林通道中的位置"""
        if pd.isna(upper) or pd.isna(lower):
            return "unknown"
        
        if price >= upper:
            return "above_upper"
        elif price <= lower:
            return "below_lower"
        elif price >= middle:
            return "upper_half"
        else:
            return "lower_half"
    
    # ==================== OBV ====================
    
    def calculate_obv(self, df: pd.DataFrame) -> pd.Series:
        """
        計算 OBV（能量潮指標）
        
        若今日收盤 > 昨日收盤：OBV = 昨日 OBV + 今日成交量
        若今日收盤 < 昨日收盤：OBV = 昨日 OBV - 今日成交量
        若今日收盤 = 昨日收盤：OBV = 昨日 OBV
        """
        obv = pd.Series(index=df.index, dtype=float)
        obv.iloc[0] = df["volume"].iloc[0]
        
        for i in range(1, len(df)):
            if df["close"].iloc[i] > df["close"].iloc[i-1]:
                obv.iloc[i] = obv.iloc[i-1] + df["volume"].iloc[i]
            elif df["close"].iloc[i] < df["close"].iloc[i-1]:
                obv.iloc[i] = obv.iloc[i-1] - df["volume"].iloc[i]
            else:
                obv.iloc[i] = obv.iloc[i-1]
        
        return obv
    
    def add_obv_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增 OBV 指標"""
        df = df.copy()
        # 檢查是否有 volume 欄位
        if "volume" not in df.columns:
            df["obv"] = None
            return df
        df["obv"] = self.calculate_obv(df)
        return df
    
    def get_obv_trend(self, df: pd.DataFrame, lookback: int = 5) -> str:
        """
        判斷 OBV 趨勢
        
        Args:
            df: 含有 OBV 的 DataFrame
            lookback: 回顧天數
            
        Returns:
            趨勢字串 ("rising", "falling", "flat")
        """
        if "obv" not in df.columns or len(df) < lookback:
            return "unknown"
        
        obv_recent = df["obv"].iloc[-lookback:]
        
        if obv_recent.is_monotonic_increasing:
            return "rising"
        elif obv_recent.is_monotonic_decreasing:
            return "falling"
        else:
            # 比較首尾
            change_pct = (obv_recent.iloc[-1] - obv_recent.iloc[0]) / abs(obv_recent.iloc[0]) * 100
            if change_pct > 5:
                return "rising"
            elif change_pct < -5:
                return "falling"
            else:
                return "flat"
    
    # ==================== 成交量分析 ====================
    
    def calculate_volume_ratio(self, df: pd.DataFrame, ma_period: int = 20) -> pd.Series:
        """計算量比（今日成交量 / N日均量）"""
        avg_volume = df["volume"].rolling(window=ma_period).mean()
        return df["volume"] / avg_volume
    
    def add_volume_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增成交量指標"""
        df = df.copy()
        # 檢查是否有 volume 欄位
        if "volume" not in df.columns:
            df["volume_ma20"] = None
            df["volume_ratio"] = None
            return df
        df["volume_ma20"] = df["volume"].rolling(window=20).mean()
        df["volume_ratio"] = self.calculate_volume_ratio(df)
        return df
    
    # ==================== 綜合計算 ====================
    
    def calculate_all_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """計算所有技術指標"""
        df = self.add_ma_indicators(df)
        df = self.add_rsi_indicator(df)
        df = self.add_macd_indicator(df)
        df = self.add_kd_indicator(df)
        df = self.add_bollinger_indicator(df)
        df = self.add_obv_indicator(df)
        df = self.add_volume_indicator(df)
        return df
    
    def get_all_signals(self, df: pd.DataFrame) -> List[Signal]:
        """取得所有訊號"""
        signals = []
        
        # MA 交叉
        ma_cross_20_50 = self.check_ma_cross(df, f"ma{self.ma_short}", f"ma{self.ma_mid}")
        if ma_cross_20_50:
            signals.append(ma_cross_20_50)
        
        ma_cross_50_200 = self.check_ma_cross(df, f"ma{self.ma_mid}", f"ma{self.ma_long}")
        if ma_cross_50_200:
            signals.append(ma_cross_50_200)
        
        # RSI
        rsi_signal = self.check_rsi_signal(df)
        if rsi_signal:
            signals.append(rsi_signal)
        
        # MACD
        macd_signal = self.check_macd_signal(df)
        if macd_signal:
            signals.append(macd_signal)
        
        # KD
        kd_signal = self.check_kd_signal(df)
        if kd_signal:
            signals.append(kd_signal)
        
        # 價格接近均線
        if len(df) > 0:
            latest = df.iloc[-1]
            price = latest["close"]
            
            for ma_col in [f"ma{self.ma_short}", f"ma{self.ma_mid}", f"ma{self.ma_long}"]:
                if ma_col in df.columns:
                    signal = self.check_price_vs_ma(price, latest[ma_col], ma_col.upper())
                    if signal:
                        signals.append(signal)
        
        return signals
    
    def calculate_score(self, df: pd.DataFrame) -> Dict[str, Any]:
        """
        計算綜合評分
        
        Returns:
            {
                "buy_score": int,
                "sell_score": int,
                "rating": str,
                "details": list
            }
        """
        buy_score = 0
        sell_score = 0
        details = []
        
        if len(df) < self.ma_long:
            return {
                "buy_score": 0,
                "sell_score": 0,
                "rating": "insufficient_data",
                "details": ["資料不足，無法評分"],
            }
        
        latest = df.iloc[-1]
        
        # 1. 均線排列
        alignment, alignment_desc = self.get_ma_alignment(df)
        if alignment == TrendDirection.BULLISH:
            buy_score += 1
            details.append(f"✅ {alignment_desc}")
        elif alignment == TrendDirection.BEARISH:
            sell_score += 1
            details.append(f"❌ {alignment_desc}")
        
        # 2. RSI
        if "rsi" in df.columns:
            rsi = latest["rsi"]
            if not pd.isna(rsi):
                if rsi <= self.rsi_oversold:
                    buy_score += 1
                    details.append(f"✅ RSI 超賣 ({rsi:.1f})")
                elif rsi >= self.rsi_overbought:
                    sell_score += 1
                    details.append(f"❌ RSI 超買 ({rsi:.1f})")
        
        # 3. MACD
        if "macd_hist" in df.columns and len(df) >= 2:
            hist_today = latest["macd_hist"]
            hist_yesterday = df["macd_hist"].iloc[-2]
            if not pd.isna(hist_today) and not pd.isna(hist_yesterday):
                if hist_today > 0 and hist_today > hist_yesterday:
                    buy_score += 1
                    details.append("✅ MACD 動能增強")
                elif hist_today < 0 and hist_today < hist_yesterday:
                    sell_score += 1
                    details.append("❌ MACD 動能減弱")
        
        # 4. KD
        if "kd_k" in df.columns:
            k = latest["kd_k"]
            d = latest["kd_d"]
            if not pd.isna(k) and not pd.isna(d):
                if k < 20 and k > d:
                    buy_score += 1
                    details.append(f"✅ KD 低檔黃金交叉 (K={k:.1f})")
                elif k > 80 and k < d:
                    sell_score += 1
                    details.append(f"❌ KD 高檔死亡交叉 (K={k:.1f})")
        
        # 5. 布林通道
        if "bb_lower" in df.columns:
            price = latest["close"]
            bb_lower = latest["bb_lower"]
            bb_upper = latest["bb_upper"]
            bb_middle = latest["bb_middle"]
            
            if not pd.isna(bb_lower):
                if price <= bb_lower:
                    buy_score += 1
                    details.append("✅ 觸及布林下軌")
                elif price >= bb_upper:
                    sell_score += 1
                    details.append("❌ 觸及布林上軌")
                elif price < bb_middle and len(df) >= 2:
                    if df["close"].iloc[-2] >= bb_middle:
                        sell_score += 1
                        details.append("❌ 跌破布林中軌")
        
        # 6. 量能
        if "volume_ratio" in df.columns:
            vol_ratio = latest["volume_ratio"]
            if not pd.isna(vol_ratio):
                if vol_ratio >= 2.0:
                    details.append(f"📊 成交量爆增 (量比 {vol_ratio:.1f})")
        
        # 7. OBV
        if "obv" in df.columns:
            obv_trend = self.get_obv_trend(df)
            if obv_trend == "rising":
                buy_score += 1
                details.append("✅ OBV 上升趨勢")
            elif obv_trend == "falling":
                sell_score += 1
                details.append("❌ OBV 下降趨勢")
        
        # 計算評等
        if buy_score >= 5:
            rating = "strong_buy"
        elif buy_score >= 3:
            rating = "buy"
        elif sell_score >= 5:
            rating = "strong_sell"
        elif sell_score >= 3:
            rating = "sell"
        else:
            rating = "neutral"
        
        return {
            "buy_score": buy_score,
            "sell_score": sell_score,
            "rating": rating,
            "details": details,
        }
    
    # ==================== 年化報酬率（CAGR）計算 ====================
    
    def calculate_cagr(
        self,
        df: pd.DataFrame,
        years: float,
    ) -> Optional[float]:
        """
        計算年化複合成長率（CAGR）
        
        公式: CAGR = (終值/初值)^(1/年數) - 1
        
        Args:
            df: 股價 DataFrame（需有 'close' 欄位）
            years: 計算的年數
            
        Returns:
            年化報酬率（百分比），例如 15.5 表示 15.5%
            如果資料不足則返回 None
        """
        if df is None or df.empty:
            return None
        
        # 計算需要的天數（假設一年約 252 個交易日）
        trading_days = int(years * 252)
        
        if len(df) < trading_days:
            return None
        
        try:
            # 取得終值（最新價格）
            end_price = float(df['close'].iloc[-1])
            
            # 取得初值（N年前價格）
            start_price = float(df['close'].iloc[-trading_days])
            
            if start_price <= 0 or end_price <= 0:
                return None
            
            # 計算 CAGR
            cagr = (end_price / start_price) ** (1 / years) - 1
            
            # 轉換為百分比
            return round(cagr * 100, 2)
        except Exception:
            return None
    
    def calculate_all_cagr(
        self,
        df: pd.DataFrame,
    ) -> Dict[str, Optional[float]]:
        """
        計算所有時間範圍的年化報酬率
        
        Returns:
            {
                "cagr_1y": 15.5,   # 1 年年化
                "cagr_3y": 12.3,   # 3 年年化
                "cagr_5y": 18.7,   # 5 年年化
                "cagr_10y": 14.2,  # 10 年年化
            }
        """
        return {
            "cagr_1y": self.calculate_cagr(df, 1),
            "cagr_3y": self.calculate_cagr(df, 3),
            "cagr_5y": self.calculate_cagr(df, 5),
            "cagr_10y": self.calculate_cagr(df, 10),
        }
    
    def calculate_cagr_from_prices(
        self,
        start_price: float,
        end_price: float,
        years: float,
    ) -> Optional[float]:
        """
        從起始和結束價格計算 CAGR
        
        Args:
            start_price: 起始價格
            end_price: 結束價格
            years: 年數
            
        Returns:
            年化報酬率（百分比）
        """
        if start_price <= 0 or end_price <= 0 or years <= 0:
            return None
        
        try:
            cagr = (end_price / start_price) ** (1 / years) - 1
            return round(cagr * 100, 2)
        except Exception:
            return None


# 建立預設實例
indicator_service = IndicatorService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/line_notify_service.py  ⭐⭐⭐
> LINE Messaging API 推播服務
──────────────────────────────────────────────────────────────────────

```py
"""
LINE Messaging API 推播服務
發送技術訊號通知給用戶
"""
import httpx
import logging
from typing import List, Optional, Dict, Any
from datetime import datetime

from app.config import settings

logger = logging.getLogger(__name__)


class LineNotifyService:
    """LINE Messaging API 推播服務"""
    
    PUSH_URL = "https://api.line.me/v2/bot/message/push"
    MULTICAST_URL = "https://api.line.me/v2/bot/message/multicast"
    BROADCAST_URL = "https://api.line.me/v2/bot/message/broadcast"
    
    def __init__(self):
        self.channel_access_token = settings.LINE_MESSAGING_CHANNEL_ACCESS_TOKEN
        self.enabled = bool(self.channel_access_token)
        
        if not self.enabled:
            logger.warning("LINE Messaging API 未設定 Channel Access Token，推播功能停用")
    
    def _get_headers(self) -> Dict[str, str]:
        """取得 API 請求標頭"""
        return {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.channel_access_token}",
        }
    
    async def push_text_message(
        self, 
        user_id: str, 
        message: str
    ) -> bool:
        """
        推送文字訊息給單一用戶
        
        Args:
            user_id: LINE User ID
            message: 訊息內容
            
        Returns:
            是否成功
        """
        if not self.enabled:
            logger.warning("LINE 推播未啟用")
            return False
        
        if not user_id or not message:
            logger.warning("user_id 或 message 為空")
            return False
        
        payload = {
            "to": user_id,
            "messages": [
                {
                    "type": "text",
                    "text": message
                }
            ]
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.PUSH_URL,
                    headers=self._get_headers(),
                    json=payload,
                    timeout=10.0
                )
                
                if response.status_code == 200:
                    logger.info(f"LINE 推播成功: user={user_id[:10]}...")
                    return True
                else:
                    logger.error(f"LINE 推播失敗: {response.status_code} - {response.text}")
                    return False
                    
        except Exception as e:
            logger.error(f"LINE 推播例外: {e}")
            return False
    
    async def push_flex_message(
        self,
        user_id: str,
        alt_text: str,
        flex_content: Dict[str, Any]
    ) -> bool:
        """
        推送 Flex Message 給單一用戶
        
        Args:
            user_id: LINE User ID
            alt_text: 替代文字（手機通知顯示）
            flex_content: Flex Message 內容
            
        Returns:
            是否成功
        """
        if not self.enabled:
            logger.warning("LINE 推播未啟用")
            return False
        
        payload = {
            "to": user_id,
            "messages": [
                {
                    "type": "flex",
                    "altText": alt_text,
                    "contents": flex_content
                }
            ]
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.PUSH_URL,
                    headers=self._get_headers(),
                    json=payload,
                    timeout=10.0
                )
                
                if response.status_code == 200:
                    logger.info(f"LINE Flex 推播成功: user={user_id[:10]}...")
                    return True
                else:
                    logger.error(f"LINE Flex 推播失敗: {response.status_code} - {response.text}")
                    return False
                    
        except Exception as e:
            logger.error(f"LINE Flex 推播例外: {e}")
            return False
    
    async def multicast_text_message(
        self,
        user_ids: List[str],
        message: str
    ) -> bool:
        """
        推送文字訊息給多個用戶（最多 500 人）
        
        Args:
            user_ids: LINE User ID 列表
            message: 訊息內容
            
        Returns:
            是否成功
        """
        if not self.enabled:
            logger.warning("LINE 推播未啟用")
            return False
        
        if not user_ids or not message:
            return False
        
        # LINE API 限制最多 500 人
        if len(user_ids) > 500:
            logger.warning(f"用戶數超過 500，只推送前 500 人")
            user_ids = user_ids[:500]
        
        payload = {
            "to": user_ids,
            "messages": [
                {
                    "type": "text",
                    "text": message
                }
            ]
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.MULTICAST_URL,
                    headers=self._get_headers(),
                    json=payload,
                    timeout=30.0
                )
                
                if response.status_code == 200:
                    logger.info(f"LINE 群發成功: {len(user_ids)} 人")
                    return True
                else:
                    logger.error(f"LINE 群發失敗: {response.status_code} - {response.text}")
                    return False
                    
        except Exception as e:
            logger.error(f"LINE 群發例外: {e}")
            return False
    
    async def broadcast_text_message(self, message: str) -> bool:
        """
        廣播訊息給所有好友
        
        Args:
            message: 訊息內容
            
        Returns:
            是否成功
        """
        if not self.enabled:
            logger.warning("LINE 推播未啟用")
            return False
        
        payload = {
            "messages": [
                {
                    "type": "text",
                    "text": message
                }
            ]
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.BROADCAST_URL,
                    headers=self._get_headers(),
                    json=payload,
                    timeout=30.0
                )
                
                if response.status_code == 200:
                    logger.info("LINE 廣播成功")
                    return True
                else:
                    logger.error(f"LINE 廣播失敗: {response.status_code} - {response.text}")
                    return False
                    
        except Exception as e:
            logger.error(f"LINE 廣播例外: {e}")
            return False
    
    def create_signal_flex_message(
        self,
        symbol: str,
        signals: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        建立訊號通知的 Flex Message
        
        Args:
            symbol: 股票代號
            signals: 訊號列表
            
        Returns:
            Flex Message 內容
        """
        # 訊號顏色對照
        signal_colors = {
            "golden": "#00C853",  # 綠色
            "death": "#FF1744",   # 紅色
            "overbought": "#FF9800",  # 橙色
            "oversold": "#00C853",
            "breakout": "#00C853",
            "breakdown": "#FF1744",
            "surge": "#2196F3",   # 藍色
            "fear": "#FF9800",
            "greed": "#FF1744",
        }
        
        def get_color(signal_type: str) -> str:
            for key, color in signal_colors.items():
                if key in signal_type.lower():
                    return color
            return "#666666"
        
        # 建立訊號列表
        signal_boxes = []
        for s in signals:
            signal_type = s.get("signal_type", "")
            message = s.get("message", "")
            color = get_color(signal_type)
            
            signal_boxes.append({
                "type": "box",
                "layout": "horizontal",
                "contents": [
                    {
                        "type": "text",
                        "text": "●",
                        "size": "sm",
                        "color": color,
                        "flex": 0
                    },
                    {
                        "type": "text",
                        "text": message,
                        "size": "sm",
                        "color": "#333333",
                        "flex": 1,
                        "wrap": True
                    }
                ],
                "margin": "sm"
            })
        
        # Flex Message 結構
        flex_content = {
            "type": "bubble",
            "size": "kilo",
            "header": {
                "type": "box",
                "layout": "vertical",
                "contents": [
                    {
                        "type": "text",
                        "text": f"📊 {symbol}",
                        "weight": "bold",
                        "size": "lg",
                        "color": "#FFFFFF"
                    }
                ],
                "backgroundColor": "#FA7A35",
                "paddingAll": "15px"
            },
            "body": {
                "type": "box",
                "layout": "vertical",
                "contents": signal_boxes,
                "paddingAll": "15px"
            },
            "footer": {
                "type": "box",
                "layout": "vertical",
                "contents": [
                    {
                        "type": "text",
                        "text": datetime.now().strftime("%Y-%m-%d %H:%M"),
                        "size": "xs",
                        "color": "#999999",
                        "align": "end"
                    }
                ],
                "paddingAll": "10px"
            }
        }
        
        return flex_content


# 單例
line_notify_service = LineNotifyService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/market_service.py  ⭐⭐⭐
> 市場服務
──────────────────────────────────────────────────────────────────────

```py
"""
市場服務
處理三大指數、市場情緒的資料存取
"""
import pandas as pd
from datetime import datetime, date, timedelta
from typing import Optional, Dict, Any, List
from sqlalchemy.orm import Session
from sqlalchemy import select, and_, desc
import logging

from app.models.index_price import IndexPrice, INDEX_SYMBOLS
from app.models.market_sentiment import MarketSentiment
from app.models.dividend_history import DividendHistory
from app.models.stock_price import StockPrice
from app.data_sources.yahoo_finance import yahoo_finance
from app.data_sources.fear_greed import fear_greed

logger = logging.getLogger(__name__)


class MarketService:
    """市場服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    # ==================== 三大指數 ====================
    
    def get_latest_indices(self) -> Dict[str, Any]:
        """取得三大指數最新資料，回傳字典格式"""
        result = {}
        
        for symbol, info in INDEX_SYMBOLS.items():
            try:
                stmt = (
                    select(IndexPrice)
                    .where(IndexPrice.symbol == symbol)
                    .order_by(desc(IndexPrice.date))
                    .limit(1)
                )
                latest = self.db.execute(stmt).scalar_one_or_none()
                
                if latest:
                    result[symbol] = latest.to_dict()
                    continue
            except Exception as e:
                logger.warning(f"從資料庫取得 {symbol} 失敗: {e}")
            
            # Fallback: 從 Yahoo Finance API 取得
            try:
                df = yahoo_finance.get_index_data(symbol, period="5d")
                if df is not None and not df.empty:
                    row = df.iloc[-1]
                    result[symbol] = {
                        "symbol": symbol,
                        "name": info["name"],
                        "name_zh": info["name_zh"],
                        "date": str(row["date"]),
                        "close": float(row["close"]),
                        "change": float(row["change"]) if pd.notna(row.get("change")) else None,
                        "change_pct": float(row["change_pct"]) if pd.notna(row.get("change_pct")) else None,
                    }
                    logger.info(f"從 API 取得 {symbol}: {result[symbol]['close']}")
            except Exception as e:
                logger.error(f"從 API 取得 {symbol} 失敗: {e}")
        
        return result
    
    def get_index_history(
        self,
        symbol: str,
        days: int = 365,
    ) -> List[Dict[str, Any]]:
        """取得指數歷史資料"""
        start_date = date.today() - timedelta(days=days)
        
        stmt = (
            select(IndexPrice)
            .where(
                and_(
                    IndexPrice.symbol == symbol,
                    IndexPrice.date >= start_date,
                )
            )
            .order_by(IndexPrice.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        return [r.to_dict() for r in results]
    
    def save_index_data(self, df: pd.DataFrame, symbol: str) -> int:
        """
        儲存指數資料到資料庫
        
        Returns:
            儲存的筆數
        """
        import math
        
        def clean_value(val):
            """清理值，將 NaN/Inf 轉為 None"""
            if val is None:
                return None
            if pd.isna(val):
                return None
            try:
                f = float(val)
                if math.isnan(f) or math.isinf(f):
                    return None
                return f
            except (ValueError, TypeError):
                return None
        
        if df is None or df.empty:
            return 0
        
        count = 0
        index_info = INDEX_SYMBOLS.get(symbol, {})
        
        for _, row in df.iterrows():
            # 檢查是否已存在
            stmt = select(IndexPrice).where(
                and_(
                    IndexPrice.symbol == symbol,
                    IndexPrice.date == row["date"],
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if existing:
                # 更新現有資料
                existing.open = clean_value(row.get("open"))
                existing.high = clean_value(row.get("high"))
                existing.low = clean_value(row.get("low"))
                existing.close = clean_value(row.get("close"))
                existing.volume = row.get("volume")
                existing.change = clean_value(row.get("change"))
                existing.change_pct = clean_value(row.get("change_pct"))
            else:
                # 新增資料
                price = IndexPrice(
                    symbol=symbol,
                    name=index_info.get("name", symbol),
                    date=row["date"],
                    open=clean_value(row.get("open")),
                    high=clean_value(row.get("high")),
                    low=clean_value(row.get("low")),
                    close=clean_value(row.get("close")),
                    volume=row.get("volume"),
                    change=clean_value(row.get("change")),
                    change_pct=clean_value(row.get("change_pct")),
                )
                self.db.add(price)
                count += 1
        
        self.db.commit()
        return count
    
    def fetch_and_save_all_indices(self, period: str = "10y") -> Dict[str, int]:
        """
        抓取並儲存所有三大指數資料
        
        Returns:
            {symbol: 儲存筆數}
        """
        result = {}
        
        for symbol in INDEX_SYMBOLS.keys():
            logger.info(f"抓取指數資料: {symbol}")
            df = yahoo_finance.get_index_data(symbol, period=period)
            
            if df is not None:
                count = self.save_index_data(df, symbol)
                result[symbol] = count
                logger.info(f"{symbol} 新增 {count} 筆資料")
            else:
                result[symbol] = 0
                logger.warning(f"{symbol} 抓取失敗")
        
        return result
    
    # ==================== 市場情緒 ====================
    
    def get_latest_sentiment(self) -> Dict[str, Any]:
        """取得最新的市場情緒"""
        result = {}
        
        for market in ["stock", "crypto"]:
            stmt = (
                select(MarketSentiment)
                .where(MarketSentiment.market == market)
                .order_by(desc(MarketSentiment.date))
                .limit(1)
            )
            latest = self.db.execute(stmt).scalar_one_or_none()
            
            if latest:
                result[market] = latest.to_dict()
            else:
                # 從 API 取得
                if market == "crypto":
                    data = fear_greed.get_crypto_fear_greed()
                else:
                    data = fear_greed.get_stock_fear_greed()
                
                if data:
                    result[market] = data
        
        return result
    
    def get_sentiment_history(
        self,
        market: str,
        days: int = 365,
    ) -> List[Dict[str, Any]]:
        """取得情緒歷史資料"""
        start_date = date.today() - timedelta(days=days)
        
        stmt = (
            select(MarketSentiment)
            .where(
                and_(
                    MarketSentiment.market == market,
                    MarketSentiment.date >= start_date,
                )
            )
            .order_by(MarketSentiment.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        return [r.to_dict() for r in results]
    
    def save_sentiment(
        self,
        market: str,
        value: int,
        target_date: Optional[date] = None,
    ) -> bool:
        """
        儲存市場情緒資料
        """
        if target_date is None:
            target_date = date.today()
        
        # 檢查是否已存在
        stmt = select(MarketSentiment).where(
            and_(
                MarketSentiment.market == market,
                MarketSentiment.date == target_date,
            )
        )
        existing = self.db.execute(stmt).scalar_one_or_none()
        
        classification = MarketSentiment.get_classification(value)
        
        if existing:
            existing.value = value
            existing.classification = classification
        else:
            sentiment = MarketSentiment(
                date=target_date,
                market=market,
                value=value,
                classification=classification,
            )
            self.db.add(sentiment)
        
        self.db.commit()
        return True
    
    def fetch_and_save_crypto_history(self, days: int = 365) -> int:
        """
        抓取並儲存幣圈情緒歷史資料
        
        Returns:
            儲存的筆數
        """
        logger.info(f"抓取幣圈情緒歷史: {days} 天")
        history = fear_greed.get_crypto_fear_greed_history(days)
        
        count = 0
        for item in history:
            try:
                target_date = datetime.strptime(item["date"], "%Y-%m-%d").date()
                
                # 檢查是否已存在
                stmt = select(MarketSentiment).where(
                    and_(
                        MarketSentiment.market == "crypto",
                        MarketSentiment.date == target_date,
                    )
                )
                existing = self.db.execute(stmt).scalar_one_or_none()
                
                if not existing:
                    sentiment = MarketSentiment(
                        date=target_date,
                        market="crypto",
                        value=item["value"],
                        classification=item["classification"],
                    )
                    self.db.add(sentiment)
                    count += 1
            except Exception as e:
                logger.error(f"儲存情緒資料失敗: {e}")
        
        self.db.commit()
        logger.info(f"幣圈情緒歷史新增 {count} 筆")
        return count
    
    def update_today_sentiment(self) -> Dict[str, bool]:
        """
        更新今日的市場情緒
        
        Returns:
            {market: success}
        """
        result = {}
        
        # 美股情緒
        stock_data = fear_greed.get_stock_fear_greed()
        if stock_data and not stock_data.get("is_fallback"):
            result["stock"] = self.save_sentiment("stock", stock_data["value"])
        else:
            result["stock"] = False
        
        # 幣圈情緒
        crypto_data = fear_greed.get_crypto_fear_greed()
        if crypto_data and not crypto_data.get("is_fallback"):
            result["crypto"] = self.save_sentiment("crypto", crypto_data["value"])
        else:
            result["crypto"] = False
        
        return result
    
    # ==================== 配息資料 ====================
    
    def save_dividends(self, df: pd.DataFrame) -> int:
        """
        儲存配息資料
        
        Returns:
            儲存的筆數
        """
        if df is None or df.empty:
            return 0
        
        count = 0
        for _, row in df.iterrows():
            # 檢查是否已存在
            stmt = select(DividendHistory).where(
                and_(
                    DividendHistory.symbol == row["symbol"],
                    DividendHistory.date == row["date"],
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if not existing:
                dividend = DividendHistory(
                    symbol=row["symbol"],
                    date=row["date"],
                    amount=row["amount"],
                )
                self.db.add(dividend)
                count += 1
        
        self.db.commit()
        return count
    
    def fetch_and_save_dividends(self, symbol: str, period: str = "10y") -> int:
        """
        抓取並儲存配息資料
        """
        logger.info(f"抓取配息資料: {symbol}")
        df = yahoo_finance.get_dividends(symbol, period=period)
        
        if df is not None:
            count = self.save_dividends(df)
            logger.info(f"{symbol} 配息新增 {count} 筆")
            return count
        
        return 0
    
    def get_dividends(
        self,
        symbol: str,
        years: int = 10,
    ) -> List[Dict[str, Any]]:
        """取得配息歷史"""
        start_date = date.today() - timedelta(days=years * 365)
        
        stmt = (
            select(DividendHistory)
            .where(
                and_(
                    DividendHistory.symbol == symbol.upper(),
                    DividendHistory.date >= start_date,
                )
            )
            .order_by(DividendHistory.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        return [r.to_dict() for r in results]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/notification_service.py  ⭐⭐⭐
> 通知管理服務
──────────────────────────────────────────────────────────────────────

```py
"""
通知管理服務
整合訊號偵測、通知記錄、LINE 推播
"""
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Set
from sqlalchemy import select, and_, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.user import User
from app.models.watchlist import Watchlist
from app.models.notification import Notification
from app.models.user_settings import UserAlertSettings
from app.services.signal_service import Signal, SignalType, signal_service
from app.services.line_notify_service import line_notify_service
from app.services.indicator_service import indicator_service
from app.data_sources.yahoo_finance import yahoo_finance

logger = logging.getLogger(__name__)


class NotificationService:
    """通知管理服務"""
    
    # 訊號類型與通知設定的對應
    SIGNAL_TO_SETTING = {
        SignalType.MA_GOLDEN_CROSS: "alert_ma_cross",
        SignalType.MA_DEATH_CROSS: "alert_ma_cross",
        SignalType.APPROACHING_BREAKOUT: "alert_ma_breakout",
        SignalType.APPROACHING_BREAKDOWN: "alert_ma_breakout",
        SignalType.BREAKOUT: "alert_ma_breakout",
        SignalType.BREAKDOWN: "alert_ma_breakout",
        SignalType.RSI_OVERBOUGHT: "alert_rsi",
        SignalType.RSI_OVERSOLD: "alert_rsi",
        SignalType.MACD_GOLDEN_CROSS: "alert_macd",
        SignalType.MACD_DEATH_CROSS: "alert_macd",
        SignalType.KD_GOLDEN_CROSS: "alert_kd",
        SignalType.KD_DEATH_CROSS: "alert_kd",
        SignalType.BOLLINGER_BREAKOUT: "alert_bollinger",
        SignalType.BOLLINGER_BREAKDOWN: "alert_bollinger",
        SignalType.VOLUME_SURGE: "alert_volume",
        SignalType.SENTIMENT_EXTREME_FEAR: "alert_sentiment",
        SignalType.SENTIMENT_EXTREME_GREED: "alert_sentiment",
    }
    
    async def get_all_tracked_symbols(self, db: AsyncSession) -> Dict[str, Set[int]]:
        """
        取得所有用戶追蹤的股票（聯集）
        
        Returns:
            {symbol: set(user_ids)} 對應表
        """
        result = await db.execute(
            select(Watchlist.symbol, Watchlist.user_id, Watchlist.asset_type)
            .join(User, Watchlist.user_id == User.id)
            .where(User.is_active == True)
            .where(User.is_blocked == False)
        )
        rows = result.all()
        
        symbol_users = {}
        for symbol, user_id, asset_type in rows:
            key = f"{symbol}|{asset_type}"
            if key not in symbol_users:
                symbol_users[key] = {"symbol": symbol, "asset_type": asset_type, "users": set()}
            symbol_users[key]["users"].add(user_id)
        
        logger.info(f"共 {len(symbol_users)} 個追蹤標的")
        return symbol_users
    
    async def get_user_alert_settings(
        self, 
        db: AsyncSession, 
        user_id: int
    ) -> Dict[str, bool]:
        """取得用戶的通知設定"""
        result = await db.execute(
            select(UserAlertSettings).where(UserAlertSettings.user_id == user_id)
        )
        settings = result.scalar_one_or_none()
        
        if not settings:
            # 使用預設值（全部開啟）
            return {
                "alert_ma_cross": True,
                "alert_ma_breakout": True,
                "alert_rsi": True,
                "alert_macd": True,
                "alert_kd": False,
                "alert_bollinger": False,
                "alert_volume": False,
                "alert_sentiment": True,
            }
        
        return {
            "alert_ma_cross": settings.alert_ma_cross,
            "alert_ma_breakout": settings.alert_ma_breakout,
            "alert_rsi": settings.alert_rsi,
            "alert_macd": settings.alert_macd,
            "alert_kd": settings.alert_kd,
            "alert_bollinger": settings.alert_bollinger,
            "alert_volume": settings.alert_volume,
            "alert_sentiment": settings.alert_sentiment,
        }
    
    async def is_recently_notified(
        self,
        db: AsyncSession,
        user_id: int,
        symbol: str,
        signal_type: str,
        hours: int = 24
    ) -> bool:
        """
        檢查是否最近已通知過（防止重複）
        
        Args:
            user_id: 用戶 ID
            symbol: 股票代號
            signal_type: 訊號類型
            hours: 多少小時內不重複
            
        Returns:
            是否已通知過
        """
        since = datetime.utcnow() - timedelta(hours=hours)
        
        result = await db.execute(
            select(func.count(Notification.id))
            .where(and_(
                Notification.user_id == user_id,
                Notification.symbol == symbol,
                Notification.alert_type == signal_type,
                Notification.triggered_at >= since
            ))
        )
        count = result.scalar()
        return count > 0
    
    async def save_notification(
        self,
        db: AsyncSession,
        user_id: int,
        signal: Signal,
        sent: bool = False
    ) -> Notification:
        """儲存通知記錄"""
        notification = Notification(
            user_id=user_id,
            symbol=signal.symbol,
            asset_type=signal.asset_type,
            alert_type=signal.signal_type.value,
            indicator=signal.indicator,
            message=signal.message,
            price_at_trigger=signal.price if signal.price > 0 else None,
            triggered_at=signal.timestamp,
            sent=sent,
            sent_at=datetime.utcnow() if sent else None,
        )
        db.add(notification)
        await db.commit()
        return notification
    
    async def process_signals_for_user(
        self,
        db: AsyncSession,
        user_id: int,
        line_user_id: str,
        signals: List[Signal]
    ) -> Dict[str, Any]:
        """
        處理用戶的訊號通知
        
        Args:
            db: 資料庫 session
            user_id: 用戶 ID
            line_user_id: LINE User ID
            signals: 訊號列表
            
        Returns:
            處理結果
        """
        if not signals:
            return {"sent": 0, "skipped": 0, "filtered": 0}
        
        # 取得用戶通知設定
        alert_settings = await self.get_user_alert_settings(db, user_id)
        
        sent_count = 0
        skipped_count = 0
        filtered_count = 0
        signals_to_send = []
        
        for signal in signals:
            # 1. 檢查用戶是否開啟此類通知
            setting_key = self.SIGNAL_TO_SETTING.get(signal.signal_type)
            if setting_key and not alert_settings.get(setting_key, True):
                filtered_count += 1
                continue
            
            # 2. 檢查是否最近已通知過
            if await self.is_recently_notified(
                db, user_id, signal.symbol, signal.signal_type.value
            ):
                skipped_count += 1
                continue
            
            signals_to_send.append(signal)
        
        # 3. 發送 LINE 通知
        if signals_to_send and line_user_id:
            # 合併訊息發送
            message = signal_service.format_signals_summary(signals_to_send)
            
            success = await line_notify_service.push_text_message(
                line_user_id, message
            )
            
            # 4. 儲存通知記錄
            for signal in signals_to_send:
                await self.save_notification(db, user_id, signal, sent=success)
                if success:
                    sent_count += 1
        
        return {
            "sent": sent_count,
            "skipped": skipped_count,
            "filtered": filtered_count,
        }
    
    async def run_signal_check(self, db: AsyncSession) -> Dict[str, Any]:
        """
        執行訊號檢查（主要入口）
        
        流程：
        1. 取得所有追蹤的股票
        2. 計算技術指標
        3. 偵測訊號
        4. 根據用戶設定過濾並發送通知
        
        Returns:
            執行結果摘要
        """
        logger.info("=" * 50)
        logger.info("開始執行訊號檢查")
        logger.info("=" * 50)
        
        start_time = datetime.now()
        result = {
            "symbols_checked": 0,
            "signals_detected": 0,
            "notifications_sent": 0,
            "errors": [],
        }
        
        try:
            # 1. 取得所有追蹤的股票
            symbol_users = await self.get_all_tracked_symbols(db)
            
            if not symbol_users:
                logger.info("無追蹤標的，結束檢查")
                return result
            
            all_signals_by_symbol = {}  # {symbol: [signals]}
            
            # 2. 逐一計算指標並偵測訊號
            for key, info in symbol_users.items():
                symbol = info["symbol"]
                asset_type = info["asset_type"]
                
                try:
                    # 取得股價資料
                    if asset_type == "stock":
                        df = yahoo_finance.get_stock_history(symbol, period="6mo")
                    else:
                        # 加密貨幣處理
                        from app.services.crypto_service import crypto_service
                        df = await crypto_service.get_crypto_history(symbol, period="6mo")
                    
                    if df is None or df.empty:
                        logger.warning(f"{symbol} 無法取得資料")
                        continue
                    
                    # 計算技術指標
                    indicators = indicator_service.calculate_all_indicators(df)
                    
                    if not indicators:
                        continue
                    
                    # 偵測訊號
                    signals = signal_service.detect_signals(
                        symbol, indicators, asset_type
                    )
                    
                    if signals:
                        all_signals_by_symbol[key] = {
                            "signals": signals,
                            "users": info["users"],
                        }
                        result["signals_detected"] += len(signals)
                    
                    result["symbols_checked"] += 1
                    
                except Exception as e:
                    logger.error(f"處理 {symbol} 時發生錯誤: {e}")
                    result["errors"].append(f"{symbol}: {str(e)}")
            
            # 3. 發送通知給用戶
            for key, data in all_signals_by_symbol.items():
                signals = data["signals"]
                user_ids = data["users"]
                
                for user_id in user_ids:
                    try:
                        # 取得用戶 LINE ID
                        user_result = await db.execute(
                            select(User).where(User.id == user_id)
                        )
                        user = user_result.scalar_one_or_none()
                        
                        if not user or not user.line_user_id:
                            continue
                        
                        # 處理並發送通知
                        send_result = await self.process_signals_for_user(
                            db, user_id, user.line_user_id, signals
                        )
                        
                        result["notifications_sent"] += send_result["sent"]
                        
                    except Exception as e:
                        logger.error(f"發送通知給用戶 {user_id} 時發生錯誤: {e}")
                        result["errors"].append(f"user_{user_id}: {str(e)}")
            
            # 4. 檢查市場情緒
            try:
                from app.services.market_service import MarketService
                market_service = MarketService()
                sentiment = await market_service.get_current_sentiment()
                
                sentiment_signals = signal_service.detect_sentiment_signals(sentiment)
                
                if sentiment_signals:
                    result["signals_detected"] += len(sentiment_signals)
                    # 情緒訊號發送給所有開啟此通知的用戶
                    # （這裡簡化處理，實際可以更精細控制）
                    logger.info(f"偵測到 {len(sentiment_signals)} 個情緒訊號")
                    
            except Exception as e:
                logger.error(f"檢查市場情緒時發生錯誤: {e}")
            
        except Exception as e:
            logger.error(f"訊號檢查發生嚴重錯誤: {e}", exc_info=True)
            result["errors"].append(f"critical: {str(e)}")
        
        elapsed = (datetime.now() - start_time).total_seconds()
        result["elapsed_seconds"] = round(elapsed, 2)
        
        logger.info(f"訊號檢查完成: {result}")
        return result
    
    async def get_user_notifications(
        self,
        db: AsyncSession,
        user_id: int,
        limit: int = 50,
        unread_only: bool = False
    ) -> List[Dict]:
        """取得用戶的通知歷史"""
        query = select(Notification).where(
            Notification.user_id == user_id
        ).order_by(Notification.triggered_at.desc()).limit(limit)
        
        if unread_only:
            query = query.where(Notification.sent == False)
        
        result = await db.execute(query)
        notifications = result.scalars().all()
        
        return [n.to_dict() for n in notifications]


# 單例
notification_service = NotificationService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/price_cache_service.py  ⭐⭐⭐
> 價格快取服務
──────────────────────────────────────────────────────────────────────

```py
"""
價格快取服務
負責批次更新追蹤股票的即時價格

排程邏輯：
- 台股開盤 (09:00-13:30)：每 10 分鐘更新台股
- 美股開盤 (21:30-05:00)：每 10 分鐘更新美股
- 收盤後：不更新（使用收盤價）
- 加密貨幣：24 小時每 10 分鐘更新
"""
import logging
from datetime import datetime, time
from typing import Dict, List, Any
from sqlalchemy.orm import Session
from sqlalchemy import select, distinct
import yfinance as yf

from app.models.price_cache import StockPriceCache
from app.models.watchlist import Watchlist

logger = logging.getLogger(__name__)


# 台股名稱對照（常見的）
TAIWAN_STOCK_NAMES = {
    "0050": "元大台灣50",
    "0051": "元大中型100",
    "0052": "富邦科技",
    "0053": "元大電子",
    "0055": "元大MSCI金融",
    "0056": "元大高股息",
    "0057": "富邦摩台",
    "006205": "富邦上証",
    "006206": "元大上證50",
    "006208": "富邦台50",
    "00631L": "元大台灣50正2",
    "00632R": "元大台灣50反1",
    "00635U": "元大S&P黃金",
    "00636": "國泰中國A50",
    "00637L": "元大滬深300正2",
    "00639": "富邦深100",
    "00642U": "元大S&P石油",
    "00645": "富邦日本",
    "00646": "元大S&P500",
    "00647L": "元大S&P500正2",
    "00648R": "元大S&P500反1",
    "00650L": "復華香港正2",
    "00655L": "國泰中國A50正2",
    "00657": "國泰日經225",
    "00661": "元大日經225",
    "00662": "富邦NASDAQ",
    "00663L": "國泰臺灣加權正2",
    "00664R": "國泰臺灣加權反1",
    "00668": "國泰美國道瓊",
    "00669R": "國泰美國道瓊反1",
    "00670L": "富邦NASDAQ正2",
    "00675L": "富邦臺灣加權正2",
    "00676R": "富邦臺灣加權反1",
    "00677U": "富邦VIX",
    "00678": "群益NBI生技",
    "00680L": "元大美債20正2",
    "00681R": "元大美債20反1",
    "00682U": "元大美債20",
    "00683L": "元大美債反1",
    "00685L": "群益臺灣加權正2",
    "00686R": "群益臺灣加權反1",
    "00688L": "國泰20年美債正2",
    "00689R": "國泰20年美債反1",
    "00690": "兆豐藍籌30",
    "00692": "富邦公司治理",
    "00693U": "街口S&P黃金",
    "00696": "富邦游戲娛樂",
    "00700": "富邦恒生國企",
    "00701": "國泰股利精選30",
    "00703": "台新MSCI中國",
    "00706L": "元大美元指數正2",
    "00707R": "元大美元指數反1",
    "00708L": "元大歐洲50正2",
    "00709": "富邦歐洲",
    "00710B": "復華彭博非投等債",
    "00711B": "復華中國5年債",
    "00712": "復華富時不動產",
    "00713": "元大台灣高息低波",
    "00714": "群益道瓊美國地產",
    "00715L": "街口投信布蘭特正2",
    "00717": "富邦美國特別股",
    "00720B": "元大投資級公司債",
    "00721B": "元大中國債3-5",
    "00730": "富邦臺灣優質高息",
    "00731": "復華富時高息低波",
    "00733": "富邦臺灣中小",
    "00735": "國泰臺韓科技",
    "00736": "國泰新興市場",
    "00737": "國泰AI+Robo",
    "00738U": "元大道瓊白銀",
    "00739": "元大MSCI A股",
    "00752": "中信中國高股息",
    "00753L": "中信中國50正2",
    "00757": "統一FANG+",
    "00762": "元大全球AI",
    "00763U": "街口道瓊銅",
    "00770": "國泰北美科技",
    "00771": "元大US高息特別股",
    "00772B": "中信高評級公司債",
    "00773B": "中信優先金融債",
    "00774B": "新光投等債15+",
    "00775B": "新光美債1-3",
    "00850": "元大臺灣ESG永續",
    "00851": "台新全球AI",
    "00852L": "國泰美國費半正2",
    "00853": "統一MSCI韓國",
    "00861": "元大全球未來關鍵科技",
    "00865B": "國泰US短期公債",
    "00875": "國泰網路資安",
    "00876": "元大全球5G",
    "00878": "國泰永續高股息",
    "00881": "國泰台灣5G+",
    "00882": "中信中國高股息",
    "00885": "富邦越南",
    "00886": "元大全球雲端服務",
    "00887": "永豐台灣ESG",
    "00888": "永豐美國費半",
    "00889": "永豐台灣智能車",
    "00891": "中信關鍵半導體",
    "00892": "富邦台灣半導體",
    "00893": "國泰智能電動車",
    "00894": "中信小資高價30",
    "00895": "富邦未來車",
    "00896": "中信綠能電動車",
    "00897": "富邦基因免疫生技",
    "00898": "國泰基因免疫革命",
    "00899": "富邦美債20年",
    "00900": "富邦特選高股息30",
    "00901": "永豐智能車供應鏈",
    "00902": "中信電池及儲能",
    "00903": "富邦元宇宙",
    "00904": "新光臺灣半導體30",
    "00905": "FT臺灣Smart",
    "00907": "永豐優息存股",
    "00908": "富邦入息REITs+",
    "00909": "國泰數位支付服務",
    "00910": "第一金太空衛星",
    "00911": "兆豐洲際半導體",
    "00912": "中信臺灣智慧50",
    "00913": "兆豐台灣晶圓製造",
    "00915": "凱基優選高股息30",
    "00916": "國泰全球品牌50",
    "00917": "中信特選金融",
    "00918": "大華優利高填息30",
    "00919": "群益台灣精選高息",
    "00920": "富邦全球非投等債",
    "00921": "兆豐龍頭等權重",
    "00922": "國泰台灣領袖50",
    "00923": "群益半導體收益",
    "00924B": "復華新興主權債",
    "00925B": "國泰投資級電信債",
    "00926": "凱基半導體",
    "00927": "群益半導體收益",
    "00928": "中信上櫃ESG30",
    "00929": "復華台灣科技優息",
    "00930": "永豐ESG低碳高息",
    "00931": "統一台灣高息動能",
    "00932": "兆豐永續高息等權",
    "00933": "國泰10Y+金融債",
    "00934": "中信成長高股息",
    "00935": "野村台灣新科技50",
    "00936": "台新臺灣IC設計",
    "00937B": "群益ESG投等債20+",
    "00939": "統一台灣高息優選",
    "00940": "元大台灣價值高息",
    "2301": "光寶科",
    "2303": "聯電",
    "2308": "台達電",
    "2317": "鴻海",
    "2324": "仁寶",
    "2327": "國巨",
    "2330": "台積電",
    "2337": "旺宏",
    "2344": "華邦電",
    "2345": "智邦",
    "2351": "順德",
    "2353": "宏碁",
    "2354": "鴻準",
    "2356": "英業達",
    "2357": "華碩",
    "2360": "致茂",
    "2376": "技嘉",
    "2377": "微星",
    "2379": "瑞昱",
    "2382": "廣達",
    "2383": "台光電",
    "2385": "群光",
    "2388": "威盛",
    "2392": "正崴",
    "2395": "研華",
    "2401": "凌陽",
    "2402": "毅嘉",
    "2408": "南亞科",
    "2409": "友達",
    "2412": "中華電",
    "2454": "聯發科",
    "2474": "可成",
    "2492": "華新科",
    "2498": "宏達電",
    "2603": "長榮",
    "2609": "陽明",
    "2610": "華航",
    "2615": "萬海",
    "2618": "長榮航",
    "2633": "台灣高鐵",
    "2801": "彰銀",
    "2809": "京城銀",
    "2812": "台中銀",
    "2816": "旺旺保",
    "2823": "中壽",
    "2834": "臺企銀",
    "2838": "聯邦銀",
    "2845": "遠東銀",
    "2867": "三商壽",
    "2880": "華南金",
    "2881": "富邦金",
    "2882": "國泰金",
    "2883": "開發金",
    "2884": "玉山金",
    "2885": "元大金",
    "2886": "兆豐金",
    "2887": "台新金",
    "2888": "新光金",
    "2889": "國票金",
    "2890": "永豐金",
    "2891": "中信金",
    "2892": "第一金",
    "2903": "遠百",
    "2912": "統一超",
    "3008": "大立光",
    "3017": "奇鋐",
    "3034": "聯詠",
    "3037": "欣興",
    "3044": "健鼎",
    "3045": "台灣大",
    "3231": "緯創",
    "3443": "創意",
    "3481": "群創",
    "3533": "嘉澤",
    "3661": "世芯-KY",
    "3665": "貿聯-KY",
    "3711": "日月光投控",
    "4904": "遠傳",
    "4938": "和碩",
    "5269": "祥碩",
    "5347": "世界",
    "5871": "中租-KY",
    "5876": "上海商銀",
    "5880": "合庫金",
    "6005": "群益證",
    "6116": "彩晶",
    "6176": "瑞儀",
    "6239": "力成",
    "6269": "台郡",
    "6285": "啟碁",
    "6409": "旭隼",
    "6415": "矽力-KY",
    "6446": "藥華藥",
    "6488": "環球晶",
    "6505": "台塑化",
    "6515": "穎崴",
    "6531": "愛普",
    "6533": "晶心科",
    "6547": "高端疫苗",
    "6552": "易華電",
    "6558": "興能高",
    "6669": "緯穎",
    "6670": "復盛應用",
    "6789": "采鈺",
    "8046": "南電",
    "8454": "富邦媒",
    "9910": "豐泰",
    "9921": "巨大",
    "9941": "裕融",
    "9945": "潤泰新",
}


# ============================================================
# 開盤時間判斷（台灣時間）
# ============================================================

def is_tw_market_open() -> bool:
    """判斷台股是否開盤（週一到週五 09:00-13:30）"""
    now = datetime.now()
    if now.weekday() >= 5:
        return False
    return time(9, 0) <= now.time() <= time(13, 30)


def is_us_market_open() -> bool:
    """判斷美股是否開盤（台灣時間 21:30-05:00）"""
    now = datetime.now()
    weekday = now.weekday()
    current_time = now.time()
    
    # 晚上 21:30 後（週一到週五）
    if weekday < 5 and current_time >= time(21, 30):
        return True
    # 凌晨 05:00 前（週二到週六）
    if weekday > 0 and current_time <= time(5, 0):
        return True
    # 週六凌晨
    if weekday == 5 and current_time <= time(5, 0):
        return True
    return False


def get_market_status() -> Dict[str, bool]:
    """取得各市場開盤狀態"""
    return {
        "tw_open": is_tw_market_open(),
        "us_open": is_us_market_open(),
        "crypto_open": True,
    }


# ============================================================
# 價格快取服務
# ============================================================

class PriceCacheService:
    """價格快取服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def get_all_tracked_symbols(self) -> Dict[str, List[str]]:
        """取得所有被追蹤的 symbol（去重，按市場分類）"""
        stmt = select(distinct(Watchlist.symbol), Watchlist.asset_type)
        results = self.db.execute(stmt).all()
        
        tw_stocks = []
        us_stocks = []
        crypto = []
        
        for symbol, asset_type in results:
            if asset_type == "crypto":
                crypto.append(symbol)
            elif symbol.endswith((".TW", ".TWO")):
                tw_stocks.append(symbol)
            else:
                us_stocks.append(symbol)
        
        logger.info(f"追蹤: 台股 {len(tw_stocks)}, 美股 {len(us_stocks)}, 加密貨幣 {len(crypto)}")
        return {"tw_stocks": tw_stocks, "us_stocks": us_stocks, "crypto": crypto}
    
    def batch_update_stock_prices(self, symbols: List[str]) -> Dict[str, Any]:
        """批次更新股票價格"""
        if not symbols:
            return {"updated": 0, "failed": []}
        
        result = {"updated": 0, "failed": []}
        logger.info(f"開始更新 {len(symbols)} 支股票...")
        
        try:
            # 使用 yfinance 批次取得
            tickers = yf.Tickers(" ".join(symbols))
            
            for symbol in symbols:
                try:
                    ticker = tickers.tickers.get(symbol)
                    if not ticker:
                        result["failed"].append(symbol)
                        continue
                    
                    info = ticker.info
                    if not info:
                        result["failed"].append(symbol)
                        continue
                    
                    # 取得價格
                    price = info.get("regularMarketPrice") or info.get("currentPrice")
                    prev_close = info.get("regularMarketPreviousClose") or info.get("previousClose")
                    
                    if price is None:
                        # 嘗試從歷史資料取得
                        hist = ticker.history(period="2d")
                        if not hist.empty:
                            price = float(hist['Close'].iloc[-1])
                            if len(hist) > 1:
                                prev_close = float(hist['Close'].iloc[-2])
                    
                    if price is None:
                        result["failed"].append(symbol)
                        continue
                    
                    # 計算漲跌
                    change = None
                    change_pct = None
                    if prev_close and prev_close > 0:
                        change = price - prev_close
                        change_pct = (change / prev_close) * 100
                    
                    # 取得名稱
                    name = info.get("shortName") or info.get("longName") or ""
                    if not name and symbol.endswith((".TW", ".TWO")):
                        stock_code = symbol.replace(".TW", "").replace(".TWO", "")
                        name = TAIWAN_STOCK_NAMES.get(stock_code, "")
                    
                    # 取得成交量
                    volume = info.get("regularMarketVolume") or info.get("volume")
                    
                    # 更新快取
                    self._upsert_cache(
                        symbol=symbol,
                        name=name,
                        price=price,
                        prev_close=prev_close,
                        change=change,
                        change_pct=change_pct,
                        volume=volume,
                        asset_type="stock",
                    )
                    result["updated"] += 1
                    
                except Exception as e:
                    logger.error(f"更新 {symbol} 失敗: {e}")
                    result["failed"].append(symbol)
            
            self.db.commit()
            logger.info(f"股票更新完成: 成功 {result['updated']}, 失敗 {len(result['failed'])}")
            
        except Exception as e:
            logger.error(f"批次更新失敗: {e}")
        
        return result
    
    def batch_update_crypto_prices(self, symbols: List[str]) -> Dict[str, Any]:
        """批次更新加密貨幣價格"""
        if not symbols:
            return {"updated": 0, "failed": []}
        
        result = {"updated": 0, "failed": []}
        
        try:
            from app.data_sources.coingecko import coingecko
            
            for symbol in symbols:
                try:
                    data = coingecko.get_price(symbol)
                    if not data or data.get("price") is None:
                        result["failed"].append(symbol)
                        continue
                    
                    self._upsert_cache(
                        symbol=symbol,
                        name=data.get("name", symbol),
                        price=data["price"],
                        prev_close=None,
                        change=None,
                        change_pct=data.get("change_24h"),
                        volume=data.get("volume_24h"),
                        asset_type="crypto",
                    )
                    result["updated"] += 1
                    
                except Exception as e:
                    logger.error(f"更新 {symbol} 失敗: {e}")
                    result["failed"].append(symbol)
            
            self.db.commit()
            
        except Exception as e:
            logger.error(f"加密貨幣更新失敗: {e}")
        
        return result
    
    def _upsert_cache(self, symbol, name, price, prev_close, change, change_pct, volume, asset_type):
        """更新或新增快取"""
        cache = self.db.query(StockPriceCache).filter(
            StockPriceCache.symbol == symbol
        ).first()
        
        if cache:
            cache.name = name or cache.name
            cache.price = price
            cache.prev_close = prev_close
            cache.change = change
            cache.change_pct = change_pct
            cache.volume = volume
            cache.updated_at = datetime.now()
        else:
            cache = StockPriceCache(
                symbol=symbol,
                name=name,
                price=price,
                prev_close=prev_close,
                change=change,
                change_pct=change_pct,
                volume=volume,
                asset_type=asset_type,
            )
            self.db.add(cache)
    
    def update_all(self, force: bool = False) -> Dict[str, Any]:
        """
        更新所有追蹤的價格
        
        - force=True: 強制更新所有
        - force=False: 只更新開盤中的市場
        """
        logger.info("=" * 40)
        logger.info(f"開始更新價格快取 (force={force})")
        logger.info(f"時間: {datetime.now()}")
        
        tw_open = is_tw_market_open()
        us_open = is_us_market_open()
        logger.info(f"台股: {'開盤' if tw_open else '收盤'}, 美股: {'開盤' if us_open else '收盤'}")
        logger.info("=" * 40)
        
        tracked = self.get_all_tracked_symbols()
        
        result = {
            "tw_stocks": {"updated": 0, "failed": [], "skipped": False},
            "us_stocks": {"updated": 0, "failed": [], "skipped": False},
            "crypto": {"updated": 0, "failed": []},
            "timestamp": datetime.now().isoformat(),
        }
        
        # 台股
        if force or tw_open:
            if tracked["tw_stocks"]:
                result["tw_stocks"] = self.batch_update_stock_prices(tracked["tw_stocks"])
        else:
            result["tw_stocks"]["skipped"] = True
        
        # 美股
        if force or us_open:
            if tracked["us_stocks"]:
                result["us_stocks"] = self.batch_update_stock_prices(tracked["us_stocks"])
        else:
            result["us_stocks"]["skipped"] = True
        
        # 加密貨幣（24小時）
        if tracked["crypto"]:
            result["crypto"] = self.batch_update_crypto_prices(tracked["crypto"])
        
        result["total_updated"] = (
            result["tw_stocks"].get("updated", 0) +
            result["us_stocks"].get("updated", 0) +
            result["crypto"].get("updated", 0)
        )
        
        logger.info(f"更新完成: 共 {result['total_updated']} 筆")
        return result
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/signal_service.py  ⭐⭐⭐
> 訊號偵測服務
──────────────────────────────────────────────────────────────────────

```py
"""
訊號偵測服務
偵測技術指標訊號（黃金交叉、死亡交叉、超買超賣等）
"""
import logging
from datetime import datetime, date, timedelta
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)


class SignalType(str, Enum):
    """訊號類型"""
    # 均線
    MA_GOLDEN_CROSS = "ma_golden_cross"
    MA_DEATH_CROSS = "ma_death_cross"
    APPROACHING_BREAKOUT = "approaching_breakout"
    APPROACHING_BREAKDOWN = "approaching_breakdown"
    BREAKOUT = "breakout"
    BREAKDOWN = "breakdown"
    
    # RSI
    RSI_OVERBOUGHT = "rsi_overbought"
    RSI_OVERSOLD = "rsi_oversold"
    
    # MACD
    MACD_GOLDEN_CROSS = "macd_golden_cross"
    MACD_DEATH_CROSS = "macd_death_cross"
    
    # KD
    KD_GOLDEN_CROSS = "kd_golden_cross"
    KD_DEATH_CROSS = "kd_death_cross"
    
    # 布林通道
    BOLLINGER_BREAKOUT = "bollinger_breakout"
    BOLLINGER_BREAKDOWN = "bollinger_breakdown"
    
    # 成交量
    VOLUME_SURGE = "volume_surge"
    
    # 市場情緒
    SENTIMENT_EXTREME_FEAR = "sentiment_extreme_fear"
    SENTIMENT_EXTREME_GREED = "sentiment_extreme_greed"


@dataclass
class Signal:
    """訊號資料"""
    symbol: str
    asset_type: str  # stock / crypto
    signal_type: SignalType
    indicator: str
    message: str
    price: float
    details: Dict[str, Any]
    timestamp: datetime


class SignalService:
    """訊號偵測服務"""
    
    # 訊號類型中文對照
    SIGNAL_NAMES = {
        SignalType.MA_GOLDEN_CROSS: "均線黃金交叉",
        SignalType.MA_DEATH_CROSS: "均線死亡交叉",
        SignalType.APPROACHING_BREAKOUT: "接近向上突破",
        SignalType.APPROACHING_BREAKDOWN: "接近向下跌破",
        SignalType.BREAKOUT: "向上突破",
        SignalType.BREAKDOWN: "向下跌破",
        SignalType.RSI_OVERBOUGHT: "RSI 超買",
        SignalType.RSI_OVERSOLD: "RSI 超賣",
        SignalType.MACD_GOLDEN_CROSS: "MACD 黃金交叉",
        SignalType.MACD_DEATH_CROSS: "MACD 死亡交叉",
        SignalType.KD_GOLDEN_CROSS: "KD 黃金交叉",
        SignalType.KD_DEATH_CROSS: "KD 死亡交叉",
        SignalType.BOLLINGER_BREAKOUT: "突破布林上軌",
        SignalType.BOLLINGER_BREAKDOWN: "跌破布林下軌",
        SignalType.VOLUME_SURGE: "成交量暴增",
        SignalType.SENTIMENT_EXTREME_FEAR: "極度恐懼",
        SignalType.SENTIMENT_EXTREME_GREED: "極度貪婪",
    }
    
    # 訊號 Emoji
    SIGNAL_EMOJI = {
        SignalType.MA_GOLDEN_CROSS: "🟢",
        SignalType.MA_DEATH_CROSS: "🔴",
        SignalType.APPROACHING_BREAKOUT: "⬆️",
        SignalType.APPROACHING_BREAKDOWN: "⬇️",
        SignalType.BREAKOUT: "✅",
        SignalType.BREAKDOWN: "❌",
        SignalType.RSI_OVERBOUGHT: "⚠️",
        SignalType.RSI_OVERSOLD: "🟢",
        SignalType.MACD_GOLDEN_CROSS: "🟢",
        SignalType.MACD_DEATH_CROSS: "🔴",
        SignalType.KD_GOLDEN_CROSS: "🟢",
        SignalType.KD_DEATH_CROSS: "🔴",
        SignalType.BOLLINGER_BREAKOUT: "📈",
        SignalType.BOLLINGER_BREAKDOWN: "📉",
        SignalType.VOLUME_SURGE: "📊",
        SignalType.SENTIMENT_EXTREME_FEAR: "😱",
        SignalType.SENTIMENT_EXTREME_GREED: "🤑",
    }
    
    def __init__(self):
        # 預設參數（可被用戶設定覆蓋）
        self.default_params = {
            "ma_short": 20,
            "ma_mid": 50,
            "ma_long": 200,
            "rsi_period": 14,
            "rsi_overbought": 70,
            "rsi_oversold": 30,
            "macd_fast": 12,
            "macd_slow": 26,
            "macd_signal": 9,
            "kd_period": 9,
            "bollinger_period": 20,
            "bollinger_std": 2.0,
            "breakout_threshold": 2.0,  # 接近突破門檻 (%)
            "volume_alert_ratio": 2.0,  # 量比警戒倍數
        }
    
    def detect_signals(
        self, 
        symbol: str, 
        indicators: Dict[str, Any],
        asset_type: str = "stock",
        params: Optional[Dict] = None
    ) -> List[Signal]:
        """
        偵測股票/加密貨幣的技術指標訊號
        
        Args:
            symbol: 股票/幣種代號
            indicators: 技術指標資料（來自 indicator_service）
            asset_type: stock / crypto
            params: 用戶自訂參數（可選）
            
        Returns:
            偵測到的訊號列表
        """
        signals = []
        p = {**self.default_params, **(params or {})}
        
        current_price = indicators.get("current_price", 0)
        if not current_price:
            logger.warning(f"{symbol} 無法取得現價")
            return signals
        
        now = datetime.now()
        
        # 1. 均線訊號
        ma_signals = self._detect_ma_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(ma_signals)
        
        # 2. RSI 訊號
        rsi_signals = self._detect_rsi_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(rsi_signals)
        
        # 3. MACD 訊號
        macd_signals = self._detect_macd_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(macd_signals)
        
        # 4. KD 訊號
        kd_signals = self._detect_kd_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(kd_signals)
        
        # 5. 布林通道訊號
        bb_signals = self._detect_bollinger_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(bb_signals)
        
        # 6. 成交量訊號
        vol_signals = self._detect_volume_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(vol_signals)
        
        logger.info(f"{symbol} 偵測到 {len(signals)} 個訊號")
        return signals
    
    def _detect_ma_signals(
        self, symbol: str, indicators: Dict, price: float, 
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測均線訊號"""
        signals = []
        ma = indicators.get("ma", {})
        
        if not ma:
            return signals
        
        ma20 = ma.get("ma20")
        ma50 = ma.get("ma50")
        ma200 = ma.get("ma200")
        
        # 均線交叉（需要有前一日資料才能判斷，這裡簡化為檢查當前狀態）
        # 實際上需要比較昨日和今日的 MA 值
        
        # 接近突破/跌破檢測
        threshold_pct = params["breakout_threshold"] / 100
        
        for ma_name, ma_value in [("MA20", ma20), ("MA50", ma50), ("MA200", ma200)]:
            if ma_value is None or ma_value <= 0:
                continue
            
            diff_pct = (price - ma_value) / ma_value
            
            # 接近向上突破（價格在均線下方，差距小於門檻）
            if -threshold_pct < diff_pct < 0:
                signals.append(Signal(
                    symbol=symbol,
                    asset_type=asset_type,
                    signal_type=SignalType.APPROACHING_BREAKOUT,
                    indicator=ma_name,
                    message=f"{symbol} 接近突破 {ma_name} ({ma_value:.2f})，差距 {abs(diff_pct)*100:.1f}%",
                    price=price,
                    details={"ma_name": ma_name, "ma_value": ma_value, "diff_pct": diff_pct},
                    timestamp=now,
                ))
            
            # 接近向下跌破（價格在均線上方，差距小於門檻）
            elif 0 < diff_pct < threshold_pct:
                signals.append(Signal(
                    symbol=symbol,
                    asset_type=asset_type,
                    signal_type=SignalType.APPROACHING_BREAKDOWN,
                    indicator=ma_name,
                    message=f"{symbol} 接近跌破 {ma_name} ({ma_value:.2f})，差距 {diff_pct*100:.1f}%",
                    price=price,
                    details={"ma_name": ma_name, "ma_value": ma_value, "diff_pct": diff_pct},
                    timestamp=now,
                ))
        
        # 黃金交叉/死亡交叉（MA20 vs MA50）
        if ma20 and ma50:
            cross_info = ma.get("cross_info", {})
            if cross_info.get("type") == "golden_cross" and cross_info.get("days_ago", 999) <= 3:
                signals.append(Signal(
                    symbol=symbol,
                    asset_type=asset_type,
                    signal_type=SignalType.MA_GOLDEN_CROSS,
                    indicator="MA20/MA50",
                    message=f"{symbol} MA20 黃金交叉 MA50",
                    price=price,
                    details={"ma20": ma20, "ma50": ma50},
                    timestamp=now,
                ))
            elif cross_info.get("type") == "death_cross" and cross_info.get("days_ago", 999) <= 3:
                signals.append(Signal(
                    symbol=symbol,
                    asset_type=asset_type,
                    signal_type=SignalType.MA_DEATH_CROSS,
                    indicator="MA20/MA50",
                    message=f"{symbol} MA20 死亡交叉 MA50",
                    price=price,
                    details={"ma20": ma20, "ma50": ma50},
                    timestamp=now,
                ))
        
        return signals
    
    def _detect_rsi_signals(
        self, symbol: str, indicators: Dict, price: float,
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測 RSI 訊號"""
        signals = []
        rsi_data = indicators.get("rsi", {})
        
        if not rsi_data:
            return signals
        
        rsi_value = rsi_data.get("value")
        if rsi_value is None:
            return signals
        
        overbought = params["rsi_overbought"]
        oversold = params["rsi_oversold"]
        
        if rsi_value >= overbought:
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.RSI_OVERBOUGHT,
                indicator="RSI",
                message=f"{symbol} RSI 達 {rsi_value:.1f}，進入超買區",
                price=price,
                details={"rsi": rsi_value, "threshold": overbought},
                timestamp=now,
            ))
        elif rsi_value <= oversold:
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.RSI_OVERSOLD,
                indicator="RSI",
                message=f"{symbol} RSI 跌至 {rsi_value:.1f}，進入超賣區",
                price=price,
                details={"rsi": rsi_value, "threshold": oversold},
                timestamp=now,
            ))
        
        return signals
    
    def _detect_macd_signals(
        self, symbol: str, indicators: Dict, price: float,
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測 MACD 訊號"""
        signals = []
        macd_data = indicators.get("macd", {})
        
        if not macd_data:
            return signals
        
        dif = macd_data.get("dif")
        macd = macd_data.get("macd")
        histogram = macd_data.get("histogram")
        status = macd_data.get("status", "")
        
        # 根據 status 判斷（indicator_service 已經計算好）
        if "golden_cross" in status.lower() or status == "bullish_cross":
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.MACD_GOLDEN_CROSS,
                indicator="MACD",
                message=f"{symbol} MACD 黃金交叉",
                price=price,
                details={"dif": dif, "macd": macd, "histogram": histogram},
                timestamp=now,
            ))
        elif "death_cross" in status.lower() or status == "bearish_cross":
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.MACD_DEATH_CROSS,
                indicator="MACD",
                message=f"{symbol} MACD 死亡交叉",
                price=price,
                details={"dif": dif, "macd": macd, "histogram": histogram},
                timestamp=now,
            ))
        
        return signals
    
    def _detect_kd_signals(
        self, symbol: str, indicators: Dict, price: float,
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測 KD 訊號"""
        signals = []
        kd_data = indicators.get("kd", {})
        
        if not kd_data:
            return signals
        
        k = kd_data.get("k")
        d = kd_data.get("d")
        status = kd_data.get("status", "")
        
        # KD 交叉
        if "golden" in status.lower():
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.KD_GOLDEN_CROSS,
                indicator="KD",
                message=f"{symbol} KD 黃金交叉 (K={k:.1f}, D={d:.1f})",
                price=price,
                details={"k": k, "d": d},
                timestamp=now,
            ))
        elif "death" in status.lower():
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.KD_DEATH_CROSS,
                indicator="KD",
                message=f"{symbol} KD 死亡交叉 (K={k:.1f}, D={d:.1f})",
                price=price,
                details={"k": k, "d": d},
                timestamp=now,
            ))
        
        return signals
    
    def _detect_bollinger_signals(
        self, symbol: str, indicators: Dict, price: float,
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測布林通道訊號"""
        signals = []
        bb_data = indicators.get("bollinger", {})
        
        if not bb_data:
            return signals
        
        upper = bb_data.get("upper")
        lower = bb_data.get("lower")
        position = bb_data.get("position", "")
        
        if upper and price >= upper:
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.BOLLINGER_BREAKOUT,
                indicator="Bollinger",
                message=f"{symbol} 突破布林上軌 ({upper:.2f})",
                price=price,
                details={"upper": upper, "lower": lower, "price": price},
                timestamp=now,
            ))
        elif lower and price <= lower:
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.BOLLINGER_BREAKDOWN,
                indicator="Bollinger",
                message=f"{symbol} 跌破布林下軌 ({lower:.2f})",
                price=price,
                details={"upper": upper, "lower": lower, "price": price},
                timestamp=now,
            ))
        
        return signals
    
    def _detect_volume_signals(
        self, symbol: str, indicators: Dict, price: float,
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測成交量訊號"""
        signals = []
        vol_data = indicators.get("volume", {})
        
        if not vol_data:
            return signals
        
        ratio = vol_data.get("ratio")
        alert_ratio = params["volume_alert_ratio"]
        
        if ratio and ratio >= alert_ratio:
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.VOLUME_SURGE,
                indicator="Volume",
                message=f"{symbol} 成交量暴增 (量比 {ratio:.1f})",
                price=price,
                details={"ratio": ratio, "threshold": alert_ratio},
                timestamp=now,
            ))
        
        return signals
    
    def detect_sentiment_signals(
        self, sentiment_data: Dict[str, Any]
    ) -> List[Signal]:
        """
        偵測市場情緒訊號
        
        Args:
            sentiment_data: 情緒資料 {"stock": {...}, "crypto": {...}}
            
        Returns:
            偵測到的訊號列表
        """
        signals = []
        now = datetime.now()
        
        for market, data in sentiment_data.items():
            if not data:
                continue
            
            value = data.get("value")
            if value is None:
                continue
            
            asset_type = "stock" if market == "stock" else "crypto"
            market_name = "美股" if market == "stock" else "幣圈"
            
            if value <= 20:
                signals.append(Signal(
                    symbol=market_name,
                    asset_type=asset_type,
                    signal_type=SignalType.SENTIMENT_EXTREME_FEAR,
                    indicator="Fear & Greed",
                    message=f"{market_name}極度恐懼 ({value})，留意買入機會",
                    price=0,
                    details={"value": value, "classification": data.get("classification")},
                    timestamp=now,
                ))
            elif value >= 80:
                signals.append(Signal(
                    symbol=market_name,
                    asset_type=asset_type,
                    signal_type=SignalType.SENTIMENT_EXTREME_GREED,
                    indicator="Fear & Greed",
                    message=f"{market_name}極度貪婪 ({value})，留意風險",
                    price=0,
                    details={"value": value, "classification": data.get("classification")},
                    timestamp=now,
                ))
        
        return signals
    
    def format_signal_message(self, signal: Signal) -> str:
        """格式化訊號訊息（用於 LINE 推播）"""
        emoji = self.SIGNAL_EMOJI.get(signal.signal_type, "📢")
        return f"{emoji} {signal.message}"
    
    def format_signals_summary(self, signals: List[Signal]) -> str:
        """
        格式化多個訊號為摘要訊息
        
        Args:
            signals: 訊號列表
            
        Returns:
            格式化的訊息文字
        """
        if not signals:
            return ""
        
        # 按股票分組
        by_symbol = {}
        for s in signals:
            if s.symbol not in by_symbol:
                by_symbol[s.symbol] = []
            by_symbol[s.symbol].append(s)
        
        lines = ["📊 技術訊號通知", ""]
        
        for symbol, symbol_signals in by_symbol.items():
            lines.append(f"【{symbol}】")
            for s in symbol_signals:
                emoji = self.SIGNAL_EMOJI.get(s.signal_type, "•")
                name = self.SIGNAL_NAMES.get(s.signal_type, str(s.signal_type))
                if s.price > 0:
                    lines.append(f"  {emoji} {name} @ ${s.price:.2f}")
                else:
                    lines.append(f"  {emoji} {s.message}")
            lines.append("")
        
        lines.append(f"⏰ {datetime.now().strftime('%Y-%m-%d %H:%M')}")
        
        return "\n".join(lines)


# 單例
signal_service = SignalService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/stock_service.py  ⭐⭐⭐
> 股票服務
──────────────────────────────────────────────────────────────────────

```py
"""
股票服務
整合資料抓取、快取和技術指標計算
"""
import pandas as pd
from datetime import datetime, date, timedelta
from typing import Optional, Dict, Any, List
from sqlalchemy.orm import Session
from sqlalchemy import select, and_
import logging

from app.models.stock_price import StockPrice
from app.data_sources.yahoo_finance import yahoo_finance
from app.services.indicator_service import indicator_service, TrendDirection
from app.config import settings

logger = logging.getLogger(__name__)


class StockService:
    """股票服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def _is_cache_valid(self, symbol: str) -> bool:
        """
        檢查快取是否有效
        
        規則：
        1. 有今日資料
        2. 或是週末/假日時有最近交易日資料
        """
        today = date.today()
        
        # 查詢最新資料
        stmt = (
            select(StockPrice)
            .where(StockPrice.symbol == symbol.upper())
            .order_by(StockPrice.date.desc())
            .limit(1)
        )
        result = self.db.execute(stmt).scalar_one_or_none()
        
        if not result:
            return False
        
        # 如果有今日資料，快取有效
        if result.date == today:
            return True
        
        # 檢查是否為週末
        if today.weekday() >= 5:  # 週六=5, 週日=6
            # 週末時，只要有週五的資料就算有效
            friday = today - timedelta(days=(today.weekday() - 4))
            if result.date >= friday:
                return True
        
        # 檢查更新時間是否在快取時間內
        if result.updated_at:
            cache_hours = settings.STOCK_DATA_CACHE_HOURS
            cache_deadline = datetime.now() - timedelta(hours=cache_hours)
            if result.updated_at > cache_deadline:
                return True
        
        return False
    
    def _save_prices_to_db(self, df: pd.DataFrame) -> int:
        """
        儲存價格資料到資料庫
        
        Returns:
            儲存的筆數
        """
        if df is None or df.empty:
            return 0
        
        count = 0
        for _, row in df.iterrows():
            # 檢查是否已存在
            stmt = select(StockPrice).where(
                and_(
                    StockPrice.symbol == row["symbol"],
                    StockPrice.date == row["date"],
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if existing:
                # 更新現有資料
                existing.open = row["open"]
                existing.high = row["high"]
                existing.low = row["low"]
                existing.close = row["close"]
                existing.volume = row["volume"]
            else:
                # 新增資料
                price = StockPrice(
                    symbol=row["symbol"],
                    date=row["date"],
                    open=row["open"],
                    high=row["high"],
                    low=row["low"],
                    close=row["close"],
                    volume=row["volume"],
                )
                self.db.add(price)
                count += 1
        
        self.db.commit()
        return count
    
    def _load_prices_from_db(
        self,
        symbol: str,
        days: int = 365,
    ) -> Optional[pd.DataFrame]:
        """從資料庫載入價格資料"""
        start_date = date.today() - timedelta(days=days)
        
        stmt = (
            select(StockPrice)
            .where(
                and_(
                    StockPrice.symbol == symbol.upper(),
                    StockPrice.date >= start_date,
                )
            )
            .order_by(StockPrice.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        if not results:
            return None
        
        data = []
        for r in results:
            data.append({
                "symbol": r.symbol,
                "date": r.date,
                "open": float(r.open) if r.open else None,
                "high": float(r.high) if r.high else None,
                "low": float(r.low) if r.low else None,
                "close": float(r.close) if r.close else None,
                "volume": r.volume,
            })
        
        return pd.DataFrame(data)
    
    def fetch_and_cache_stock(self, symbol: str, period: str = "1y") -> bool:
        """
        抓取股票資料並快取
        
        Returns:
            是否成功
        """
        df = yahoo_finance.get_stock_history(symbol, period=period)
        if df is None:
            return False
        
        self._save_prices_to_db(df)
        return True
    
    def get_stock_data(
        self,
        symbol: str,
        force_refresh: bool = False,
    ) -> Optional[pd.DataFrame]:
        """
        取得股票資料（優先使用快取）
        
        Args:
            symbol: 股票代號
            force_refresh: 是否強制更新
            
        Returns:
            包含價格和技術指標的 DataFrame
        """
        symbol = symbol.upper()
        
        # 檢查快取
        if not force_refresh and self._is_cache_valid(symbol):
            logger.info(f"使用快取資料: {symbol}")
            df = self._load_prices_from_db(symbol)
        else:
            # 從 Yahoo Finance 抓取
            logger.info(f"從 Yahoo Finance 抓取: {symbol}")
            if not self.fetch_and_cache_stock(symbol):
                # 抓取失敗，嘗試使用舊的快取
                df = self._load_prices_from_db(symbol)
                if df is None:
                    return None
            else:
                df = self._load_prices_from_db(symbol)
        
        if df is None or df.empty:
            return None
        
        # 計算技術指標
        df = indicator_service.calculate_all_indicators(df)
        
        return df
    
    def get_stock_analysis(
        self,
        symbol: str,
        force_refresh: bool = False,
    ) -> Optional[Dict[str, Any]]:
        """
        取得股票完整分析報告
        
        Returns:
            分析報告字典
        """
        symbol = symbol.upper()
        
        # 取得資料
        df = self.get_stock_data(symbol, force_refresh)
        if df is None:
            return None
        
        # 取得股票基本資訊
        info = yahoo_finance.get_stock_info(symbol)
        
        # 最新價格資料
        latest = df.iloc[-1]
        price = float(latest["close"])
        
        # 計算漲跌幅
        changes = self._calculate_changes(df)
        
        # 技術指標
        indicators = self._get_indicators_summary(df, latest)
        
        # 訊號
        signals = indicator_service.get_all_signals(df)
        
        # 評分
        score = indicator_service.calculate_score(df)
        
        # 成交量
        volume_info = self._get_volume_info(df, latest)
        
        return {
            "symbol": symbol,
            "name": info.get("name", "N/A") if info else "N/A",
            "asset_type": "stock",
            "price": {
                "current": price,
                "high_52w": info.get("fifty_two_week_high") if info else None,
                "low_52w": info.get("fifty_two_week_low") if info else None,
                "from_high_pct": self._calc_pct_from_high(price, info),
                "from_low_pct": self._calc_pct_from_low(price, info),
            },
            "change": changes,
            "volume": volume_info,
            "indicators": indicators,
            "signals": [
                {
                    "type": s.type.value,
                    "indicator": s.indicator,
                    "description": s.description,
                }
                for s in signals
            ],
            "score": score,
            "updated_at": datetime.now().isoformat(),
        }
    
    def _calculate_changes(self, df: pd.DataFrame) -> Dict[str, float]:
        """計算各時間段漲跌幅"""
        latest_close = df["close"].iloc[-1]
        
        def calc_change(days: int) -> Optional[float]:
            if len(df) <= days:
                return None
            old_close = df["close"].iloc[-(days + 1)]
            return round((latest_close - old_close) / old_close * 100, 2)
        
        return {
            "day": calc_change(1),
            "week": calc_change(5),
            "month": calc_change(20),
            "quarter": calc_change(60),
            "year": calc_change(250) if len(df) > 250 else None,
        }
    
    def _get_indicators_summary(
        self,
        df: pd.DataFrame,
        latest: pd.Series,
    ) -> Dict[str, Any]:
        """取得指標摘要"""
        price = float(latest["close"])
        
        # MA
        ma_short = latest.get(f"ma{settings.MA_SHORT}")
        ma_mid = latest.get(f"ma{settings.MA_MID}")
        ma_long = latest.get(f"ma{settings.MA_LONG}")
        
        alignment, _ = indicator_service.get_ma_alignment(df)
        
        ma_info = {
            f"ma{settings.MA_SHORT}": round(ma_short, 2) if not pd.isna(ma_short) else None,
            f"ma{settings.MA_MID}": round(ma_mid, 2) if not pd.isna(ma_mid) else None,
            f"ma{settings.MA_LONG}": round(ma_long, 2) if not pd.isna(ma_long) else None,
            "alignment": alignment.value,
            f"price_vs_ma{settings.MA_SHORT}": "above" if price > ma_short else "below" if not pd.isna(ma_short) else None,
            f"price_vs_ma{settings.MA_MID}": "above" if price > ma_mid else "below" if not pd.isna(ma_mid) else None,
            f"price_vs_ma{settings.MA_LONG}": "above" if price > ma_long else "below" if not pd.isna(ma_long) else None,
        }
        
        # RSI
        rsi = latest.get("rsi")
        rsi_status, _ = indicator_service.get_rsi_status(rsi)
        rsi_info = {
            "value": round(rsi, 2) if not pd.isna(rsi) else None,
            "status": rsi_status,
        }
        
        # MACD
        macd_dif = latest.get("macd_dif")
        macd_dea = latest.get("macd_dea")
        macd_hist = latest.get("macd_hist")
        macd_info = {
            "dif": round(macd_dif, 4) if not pd.isna(macd_dif) else None,
            "dea": round(macd_dea, 4) if not pd.isna(macd_dea) else None,
            "histogram": round(macd_hist, 4) if not pd.isna(macd_hist) else None,
            "status": "bullish" if macd_hist and macd_hist > 0 else "bearish",
        }
        
        # KD
        kd_k = latest.get("kd_k")
        kd_d = latest.get("kd_d")
        kd_info = {
            "k": round(kd_k, 2) if not pd.isna(kd_k) else None,
            "d": round(kd_d, 2) if not pd.isna(kd_d) else None,
            "status": self._get_kd_status(kd_k),
        }
        
        # Bollinger
        bb_upper = latest.get("bb_upper")
        bb_middle = latest.get("bb_middle")
        bb_lower = latest.get("bb_lower")
        bb_info = {
            "upper": round(bb_upper, 2) if not pd.isna(bb_upper) else None,
            "middle": round(bb_middle, 2) if not pd.isna(bb_middle) else None,
            "lower": round(bb_lower, 2) if not pd.isna(bb_lower) else None,
            "position": indicator_service.get_bollinger_position(price, bb_upper, bb_middle, bb_lower),
        }
        
        # OBV
        obv_trend = indicator_service.get_obv_trend(df)
        obv_info = {
            "trend": obv_trend,
        }
        
        return {
            "ma": ma_info,
            "rsi": rsi_info,
            "macd": macd_info,
            "kd": kd_info,
            "bollinger": bb_info,
            "obv": obv_info,
        }
    
    def _get_kd_status(self, k_value: float) -> str:
        """取得 KD 狀態"""
        if pd.isna(k_value):
            return "unknown"
        if k_value > 80:
            return "overbought"
        elif k_value < 20:
            return "oversold"
        elif k_value > 50:
            return "neutral_high"
        else:
            return "neutral_low"
    
    def _get_volume_info(
        self,
        df: pd.DataFrame,
        latest: pd.Series,
    ) -> Dict[str, Any]:
        """取得成交量資訊"""
        today_vol = latest.get("volume", 0)
        avg_vol = latest.get("volume_ma20")
        vol_ratio = latest.get("volume_ratio")
        
        return {
            "today": int(today_vol) if today_vol else 0,
            "avg_20d": int(avg_vol) if not pd.isna(avg_vol) else None,
            "ratio": round(vol_ratio, 2) if not pd.isna(vol_ratio) else None,
        }
    
    def _calc_pct_from_high(self, price: float, info: Optional[Dict]) -> Optional[float]:
        """計算距離 52 週高點的跌幅"""
        if not info or not info.get("fifty_two_week_high"):
            return None
        high = info["fifty_two_week_high"]
        return round((price - high) / high * 100, 2)
    
    def _calc_pct_from_low(self, price: float, info: Optional[Dict]) -> Optional[float]:
        """計算距離 52 週低點的漲幅"""
        if not info or not info.get("fifty_two_week_low"):
            return None
        low = info["fifty_two_week_low"]
        return round((price - low) / low * 100, 2)
    
    def search_stocks(self, query: str) -> List[Dict[str, str]]:
        """
        搜尋股票（簡單實作，直接驗證代號）
        
        Returns:
            符合的股票列表
        """
        symbol = query.upper().strip()
        
        if yahoo_finance.validate_symbol(symbol):
            info = yahoo_finance.get_stock_info(symbol)
            if info:
                return [{
                    "symbol": info["symbol"],
                    "name": info.get("name", "N/A"),
                }]
        
        return []
    
    def fetch_extended_history(
        self,
        symbol: str,
        years: int = 10,
    ) -> bool:
        """
        抓取並快取延伸歷史資料（支援多年）
        
        Args:
            symbol: 股票代號
            years: 年數 (1, 3, 5, 10)
            
        Returns:
            是否成功
        """
        period_map = {1: "1y", 2: "2y", 5: "5y", 10: "10y"}
        period = period_map.get(years, "10y")
        
        df = yahoo_finance.get_stock_history(symbol, period=period)
        if df is None:
            return False
        
        self._save_prices_to_db(df)
        return True
    
    def get_price_history(
        self,
        symbol: str,
        days: int = 365,
    ) -> Optional[pd.DataFrame]:
        """
        取得股票價格歷史（從資料庫）
        
        Args:
            symbol: 股票代號
            days: 天數
            
        Returns:
            價格 DataFrame
        """
        return self._load_prices_from_db(symbol, days)
    
    def ensure_historical_data(
        self,
        symbol: str,
        years: int = 10,
    ) -> bool:
        """
        確保有足夠的歷史資料
        
        檢查資料庫是否有指定年份的資料，
        如果不足則從 API 抓取補齊
        """
        symbol = symbol.upper()
        days_needed = years * 365
        
        # 檢查資料庫中最早的資料日期
        stmt = (
            select(StockPrice)
            .where(StockPrice.symbol == symbol)
            .order_by(StockPrice.date)
            .limit(1)
        )
        earliest = self.db.execute(stmt).scalar_one_or_none()
        
        if earliest:
            days_available = (date.today() - earliest.date).days
            if days_available >= days_needed * 0.9:  # 90% 就算足夠
                return True
        
        # 資料不足，抓取更多
        logger.info(f"抓取 {symbol} 的 {years} 年歷史資料")
        return self.fetch_extended_history(symbol, years)
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/watchlist_service.py  ⭐⭐⭐
> 追蹤清單服務 (Async 版本)
──────────────────────────────────────────────────────────────────────

```py
"""
追蹤清單服務 (Async 版本)
"""
from typing import Optional, Dict, Any, List
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
import logging

from app.models.watchlist import Watchlist
from app.models.user import User
from app.data_sources.coingecko import CRYPTO_MAP

logger = logging.getLogger(__name__)

# 支援的加密貨幣代號
SUPPORTED_CRYPTO = set(k for k in CRYPTO_MAP.keys() if k not in ("BITCOIN", "ETHEREUM"))


class WatchlistService:
    """追蹤清單服務 (Async)"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    def _get_asset_type(self, symbol: str) -> str:
        """判斷資產類型"""
        return "crypto" if symbol.upper() in SUPPORTED_CRYPTO else "stock"
    
    async def add_to_watchlist(
        self,
        user_id: int,
        symbol: str,
        note: str = None,
    ) -> Dict[str, Any]:
        """
        新增追蹤標的
        
        Args:
            user_id: 用戶 ID
            symbol: 股票/加密貨幣代號
            note: 備註
            
        Returns:
            {
                "success": bool,
                "message": str,
                "watchlist": Watchlist (if success)
            }
        """
        symbol = symbol.upper()
        asset_type = self._get_asset_type(symbol)
        
        logger.info(f"=== 新增追蹤清單 ===")
        logger.info(f"用戶 ID: {user_id}, 代號: {symbol}, 類型: {asset_type}")
        
        # 檢查是否已存在
        existing = await self._get_watchlist_item(user_id, symbol, asset_type)
        if existing:
            logger.info(f"已存在追蹤: user_id={user_id}, symbol={symbol}")
            return {
                "success": False,
                "message": f"{symbol} 已在追蹤清單中",
            }
        
        # 驗證代號是否有效
        if asset_type == "crypto":
            from app.data_sources.coingecko import coingecko
            if not coingecko.validate_symbol(symbol):
                logger.warning(f"無效的加密貨幣: {symbol}")
                return {
                    "success": False,
                    "message": f"不支援的加密貨幣: {symbol}",
                }
        else:
            from app.data_sources.yahoo_finance import yahoo_finance
            if not yahoo_finance.validate_symbol(symbol):
                logger.warning(f"無效的股票代號: {symbol}")
                return {
                    "success": False,
                    "message": f"找不到股票: {symbol}",
                }
        
        # 新增
        watchlist = Watchlist(
            user_id=user_id,
            symbol=symbol,
            asset_type=asset_type,
            note=note,
        )
        self.db.add(watchlist)
        await self.db.commit()
        await self.db.refresh(watchlist)
        
        logger.info(f"★ 追蹤清單寫入成功: id={watchlist.id}, user_id={user_id}, symbol={symbol}")
        
        return {
            "success": True,
            "message": f"已新增 {symbol} 到追蹤清單",
            "watchlist": watchlist,
        }
    
    async def remove_from_watchlist(
        self,
        user_id: int,
        symbol: str = None,
        watchlist_id: int = None,
    ) -> Dict[str, Any]:
        """
        從追蹤清單移除
        
        Args:
            user_id: 用戶 ID
            symbol: 代號（與 watchlist_id 二擇一）
            watchlist_id: 追蹤清單 ID
            
        Returns:
            {"success": bool, "message": str}
        """
        logger.info(f"=== 移除追蹤清單 ===")
        logger.info(f"用戶 ID: {user_id}, 代號: {symbol}, watchlist_id: {watchlist_id}")
        
        if watchlist_id:
            stmt = select(Watchlist).where(
                and_(
                    Watchlist.id == watchlist_id,
                    Watchlist.user_id == user_id,  # ★ 確保只能刪除自己的
                )
            )
        elif symbol:
            symbol = symbol.upper()
            asset_type = self._get_asset_type(symbol)
            stmt = select(Watchlist).where(
                and_(
                    Watchlist.user_id == user_id,  # ★ 確保只能刪除自己的
                    Watchlist.symbol == symbol,
                    Watchlist.asset_type == asset_type,
                )
            )
        else:
            return {
                "success": False,
                "message": "請提供 symbol 或 watchlist_id",
            }
        
        result = await self.db.execute(stmt)
        watchlist = result.scalar_one_or_none()
        
        if not watchlist:
            logger.warning(f"找不到追蹤項目: user_id={user_id}, symbol={symbol}")
            return {
                "success": False,
                "message": "找不到追蹤項目",
            }
        
        # ★★★ 額外驗證：確保 watchlist 的 user_id 與請求的 user_id 一致 ★★★
        if watchlist.user_id != user_id:
            logger.error(f"權限錯誤！嘗試刪除他人資料: 請求 user_id={user_id}, 資料 user_id={watchlist.user_id}")
            return {
                "success": False,
                "message": "權限不足",
            }
        
        symbol = watchlist.symbol
        await self.db.delete(watchlist)
        await self.db.commit()
        
        logger.info(f"★ 追蹤清單刪除成功: user_id={user_id}, symbol={symbol}")
        
        return {
            "success": True,
            "message": f"已從追蹤清單移除 {symbol}",
        }
    
    async def update_note(
        self,
        user_id: int,
        symbol: str,
        note: str,
    ) -> Dict[str, Any]:
        """
        更新備註
        
        Args:
            user_id: 用戶 ID
            symbol: 代號
            note: 新備註
            
        Returns:
            {"success": bool, "message": str}
        """
        symbol = symbol.upper()
        asset_type = self._get_asset_type(symbol)
        
        watchlist = await self._get_watchlist_item(user_id, symbol, asset_type)
        if not watchlist:
            return {
                "success": False,
                "message": f"{symbol} 不在追蹤清單中",
            }
        
        watchlist.note = note
        await self.db.commit()
        
        return {
            "success": True,
            "message": f"已更新 {symbol} 的備註",
        }
    
    async def get_watchlist(self, user_id: int) -> List[Watchlist]:
        """
        取得用戶追蹤清單
        
        Args:
            user_id: 用戶 ID
            
        Returns:
            追蹤清單列表
        """
        logger.debug(f"取得追蹤清單: user_id={user_id}")
        
        stmt = (
            select(Watchlist)
            .where(Watchlist.user_id == user_id)  # ★ 只取得該用戶的資料
            .order_by(Watchlist.added_at.desc())
        )
        result = await self.db.execute(stmt)
        items = list(result.scalars().all())
        
        logger.info(f"取得追蹤清單: user_id={user_id}, 數量={len(items)}")
        for item in items:
            logger.debug(f"  - id={item.id}, symbol={item.symbol}, user_id={item.user_id}")
        
        return items
    
    async def get_watchlist_symbols(self, user_id: int) -> Dict[str, List[str]]:
        """
        取得用戶追蹤的代號列表（用於通知系統）
        
        Returns:
            {
                "stocks": ["AAPL", "TSLA"],
                "crypto": ["BTC", "ETH"]
            }
        """
        watchlists = await self.get_watchlist(user_id)
        
        stocks = []
        cryptos = []
        
        for item in watchlists:
            if item.asset_type == "stock":
                stocks.append(item.symbol)
            else:
                cryptos.append(item.symbol)
        
        return {
            "stocks": stocks,
            "crypto": cryptos,
        }
    
    async def _get_watchlist_item(
        self,
        user_id: int,
        symbol: str,
        asset_type: str,
    ) -> Optional[Watchlist]:
        """取得特定追蹤項目"""
        stmt = select(Watchlist).where(
            and_(
                Watchlist.user_id == user_id,
                Watchlist.symbol == symbol,
                Watchlist.asset_type == asset_type,
            )
        )
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_all_tracked_symbols(self) -> Dict[str, set]:
        """
        取得所有用戶追蹤的代號（用於批次更新）
        
        Returns:
            {
                "stocks": {"AAPL", "TSLA", ...},
                "crypto": {"BTC", "ETH"}
            }
        """
        stmt = select(Watchlist.symbol, Watchlist.asset_type).distinct()
        result = await self.db.execute(stmt)
        results = result.all()
        
        stocks = set()
        cryptos = set()
        
        for symbol, asset_type in results:
            if asset_type == "stock":
                stocks.add(symbol)
            else:
                cryptos.add(symbol)
        
        return {
            "stocks": stocks,
            "crypto": cryptos,
        }
```

======================================================================
## 🎨 前端 / 靜態資源
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 frontend/watchlist_with_cache.js  ⭐
> ========== 追蹤清單 - 使用快取版本 ==========
──────────────────────────────────────────────────────────────────────

```js
        // ========== 追蹤清單 - 使用快取版本 ==========
        // 改用 /api/watchlist/with-prices API，直接取得價格
        
        async function loadWatchlist() {
            const container = document.getElementById('watchlistContent');
            
            if (!currentUser || !currentUser.id) {
                console.error('loadWatchlist: 用戶未登入');
                container.innerHTML = '<p class="text-red-500 text-center py-4">請先登入</p>';
                return;
            }
            
            // 顯示載入中
            container.innerHTML = `
                <div class="text-center py-8">
                    <i class="fas fa-spinner fa-spin text-2xl text-blue-600"></i>
                    <p class="mt-2 text-gray-500">載入中...</p>
                </div>
            `;
            
            try {
                // ★ 改用新 API：一次取得清單 + 價格
                const res = await apiRequest('/api/watchlist/with-prices');
                const data = await res.json();
                
                console.log('追蹤清單(含價格):', data);
                
                if (!data.success || !data.data || data.data.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-12">
                            <i class="fas fa-star text-gray-300 text-4xl mb-3"></i>
                            <p class="text-gray-500 mb-4">尚無追蹤的股票</p>
                            <button onclick="showAddWatchlistModal()" class="px-6 py-2 bg-blue-600 text-white rounded-lg">
                                <i class="fas fa-plus mr-2"></i>新增追蹤
                            </button>
                        </div>
                    `;
                    return;
                }
                
                // 顯示快取更新時間（如果有）
                let cacheInfo = '';
                if (data.cache_info && data.cache_info.oldest_update) {
                    const updateTime = new Date(data.cache_info.oldest_update);
                    const now = new Date();
                    const diffMin = Math.round((now - updateTime) / 60000);
                    cacheInfo = `<p class="text-xs text-gray-400 text-right mb-2">價格更新於 ${diffMin} 分鐘前</p>`;
                }
                
                let html = cacheInfo + '<div class="space-y-3">';
                
                for (const item of data.data) {
                    const typeClass = item.asset_type === 'crypto' ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700';
                    const typeText = item.asset_type === 'crypto' ? '幣' : '股';
                    
                    // 價格顯示（直接從 API 回應取得）
                    let priceInfo = '';
                    if (item.price !== null) {
                        const change = item.change_pct || 0;
                        const changeClass = change >= 0 ? 'text-green-600' : 'text-red-600';
                        const changeIcon = change >= 0 ? '▲' : '▼';
                        priceInfo = `
                            <div class="flex items-baseline gap-2 mt-2">
                                <span class="text-xl font-bold text-gray-800">$${item.price.toLocaleString()}</span>
                                <span class="${changeClass} text-sm font-medium">${changeIcon} ${Math.abs(change).toFixed(2)}%</span>
                            </div>
                        `;
                    } else {
                        priceInfo = `
                            <div class="flex items-baseline gap-2 mt-2">
                                <span class="text-gray-400 text-sm">價格未更新</span>
                            </div>
                        `;
                    }
                    
                    // 顯示股票名稱
                    const nameDisplay = item.name ? `<span class="text-gray-500 text-sm ml-2">${item.name}</span>` : '';
                    
                    html += `
                        <div class="stock-card bg-white rounded-xl shadow-sm p-4 border-l-4 ${item.asset_type === 'crypto' ? 'border-purple-500' : 'border-blue-500'}">
                            <div class="flex items-start justify-between">
                                <div class="flex-1">
                                    <div class="flex items-center flex-wrap">
                                        <span class="font-bold text-lg text-gray-800">${item.symbol}</span>
                                        <span class="ml-2 px-2 py-0.5 rounded text-xs ${typeClass}">${typeText}</span>
                                        ${nameDisplay}
                                    </div>
                                    ${priceInfo}
                                    ${item.note ? `<p class="text-gray-500 text-sm mt-2 italic"><i class="fas fa-sticky-note mr-1"></i>${item.note}</p>` : ''}
                                </div>
                                <button onclick="removeFromWatchlist('${item.symbol}')" class="p-2 text-gray-400 hover:text-red-500 touch-target">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                            <div class="flex items-center justify-between mt-3 pt-3 border-t">
                                <span class="text-gray-400 text-xs"><i class="fas fa-clock mr-1"></i>加入於 ${new Date(item.added_at).toLocaleDateString()}</span>
                                <button onclick="searchSymbol('${item.symbol}')" class="px-4 py-2 bg-orange-500 text-white rounded-lg text-sm hover:bg-orange-600 touch-target">
                                    <i class="fas fa-chart-line mr-1"></i>詳細分析
                                </button>
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (e) {
                console.error('載入追蹤清單失敗', e);
                container.innerHTML = '<p class="text-red-500 text-center py-4">載入失敗</p>';
            }
        }
        
        // ========== 首頁追蹤清單快覽 ==========
        async function loadWatchlistOverview() {
            const container = document.getElementById('dashboardWatchlist');
            
            try {
                // ★ 同樣使用快取 API
                const res = await apiRequest('/api/watchlist/with-prices');
                const data = await res.json();
                
                if (!data.success || !data.data || data.data.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-6">
                            <i class="fas fa-star text-gray-300 text-3xl mb-2"></i>
                            <p class="text-gray-500 text-sm">尚無追蹤清單</p>
                            <button onclick="showSection('search')" class="mt-2 text-blue-600 text-sm">前往查詢股票</button>
                        </div>
                    `;
                    return;
                }
                
                // 只顯示前 5 筆
                const items = data.data.slice(0, 5);
                let html = '<div class="space-y-2">';
                
                for (const item of items) {
                    const change = item.change_pct || 0;
                    const changeClass = change >= 0 ? 'text-green-600' : 'text-red-600';
                    const changeText = item.price !== null 
                        ? `<span class="${changeClass} text-sm">${change >= 0 ? '+' : ''}${change.toFixed(2)}%</span>`
                        : '';
                    
                    const priceText = item.price !== null
                        ? `<span class="text-gray-700 font-medium">$${item.price.toLocaleString()}</span>`
                        : '<span class="text-gray-400 text-sm">--</span>';
                    
                    html += `
                        <div class="flex items-center justify-between py-2 border-b last:border-0 cursor-pointer hover:bg-gray-50 -mx-2 px-2 rounded" 
                             onclick="searchSymbol('${item.symbol}')">
                            <div class="flex items-center">
                                <span class="font-medium text-gray-800 w-20">${item.symbol}</span>
                                <span class="text-xs px-2 py-0.5 rounded ${item.asset_type === 'crypto' ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700'}">
                                    ${item.asset_type === 'crypto' ? '幣' : '股'}
                                </span>
                            </div>
                            <div class="text-right">
                                ${priceText}
                                ${changeText}
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                
                // 如果超過 5 筆，顯示「查看全部」
                if (data.data.length > 5) {
                    html += `
                        <div class="text-center mt-3">
                            <button onclick="showSection('watchlist')" class="text-blue-600 text-sm hover:underline">
                                查看全部 (${data.data.length})
                            </button>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
                
            } catch (e) {
                console.error('載入追蹤清單快覽失敗', e);
                container.innerHTML = '<p class="text-red-500 text-center py-4">載入失敗</p>';
            }
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 static/admin.html  ⭐
──────────────────────────────────────────────────────────────────────

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>管理後台 - SELA 自動選股系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" type="image/png" href="/static/logo.png">
    <style>
        .brand-orange { color: #FA7A35; }
        .bg-brand-orange { background-color: #FA7A35; }
        .hover\:bg-brand-orange-dark:hover { background-color: #e56a25; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <!-- 頂部導航 -->
    <nav class="bg-slate-800 text-white shadow-lg">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center space-x-4">
                    <span class="text-xl font-bold bg-brand-orange px-3 py-1 rounded">SELA</span>
                    <span class="text-lg">管理後台</span>
                </div>
                <div class="flex items-center space-x-4">
                    <a href="/static/dashboard.html" class="text-gray-300 hover:text-white">
                        ← 返回儀表板
                    </a>
                    <span id="adminName" class="text-gray-300"></span>
                </div>
            </div>
        </div>
    </nav>

    <!-- 主內容 -->
    <div class="max-w-7xl mx-auto px-4 py-6">
        <!-- 統計卡片 -->
        <div class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
            <div class="bg-white rounded-lg shadow p-4">
                <div class="text-gray-500 text-sm">總用戶數</div>
                <div id="statTotal" class="text-2xl font-bold text-slate-800">-</div>
            </div>
            <div class="bg-white rounded-lg shadow p-4">
                <div class="text-gray-500 text-sm">總登入次數</div>
                <div id="statTotalLogins" class="text-2xl font-bold text-purple-600">-</div>
            </div>
            <div class="bg-white rounded-lg shadow p-4">
                <div class="text-gray-500 text-sm">今日登入</div>
                <div id="statToday" class="text-2xl font-bold text-green-600">-</div>
            </div>
            <div class="bg-white rounded-lg shadow p-4">
                <div class="text-gray-500 text-sm">封鎖用戶</div>
                <div id="statBlocked" class="text-2xl font-bold text-red-600">-</div>
            </div>
            <div class="bg-white rounded-lg shadow p-4">
                <div class="text-gray-500 text-sm">管理員</div>
                <div id="statAdmin" class="text-2xl font-bold text-blue-600">-</div>
            </div>
        </div>
        
        <!-- 系統管理 -->
        <div class="bg-white rounded-lg shadow p-4 mb-6">
            <h3 class="font-bold text-gray-700 mb-4">📊 市場資料管理</h3>
            <div class="flex flex-wrap gap-3">
                <button onclick="initializeData()" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 flex items-center">
                    <span class="mr-2">🔄</span>初始化歷史資料
                </button>
                <button onclick="updateIndices()" class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 flex items-center">
                    <span class="mr-2">📈</span>更新三大指數
                </button>
                <button onclick="updateSentiment()" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 flex items-center">
                    <span class="mr-2">💭</span>更新恐懼貪婪
                </button>
                <button onclick="triggerDailyUpdate()" class="bg-orange-600 text-white px-4 py-2 rounded-lg hover:bg-orange-700 flex items-center">
                    <span class="mr-2">⚡</span>執行每日更新
                </button>
            </div>
            <p id="systemMessage" class="mt-3 text-sm text-gray-500"></p>
        </div>

        <!-- 訊號檢查與推播 -->
        <div class="bg-white rounded-lg shadow p-4 mb-6">
            <h3 class="font-bold text-gray-700 mb-4">🔔 訊號檢查與推播</h3>
            <div class="flex flex-wrap gap-3 mb-3">
                <button onclick="runSignalCheck()" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 flex items-center">
                    <span class="mr-2">🔍</span>偵測訊號（測試）
                </button>
                <button onclick="sendSignalNotifications()" class="bg-orange-600 text-white px-4 py-2 rounded-lg hover:bg-orange-700 flex items-center">
                    <span class="mr-2">📤</span>發送訊號通知
                </button>
                <button onclick="testLineNotify()" class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 flex items-center">
                    <span class="mr-2">📱</span>測試 LINE 推播
                </button>
            </div>
            <div class="flex gap-2 items-center">
                <input type="text" id="testSymbolInput" placeholder="輸入股票代號測試訊號偵測 (如 AAPL)"
                    class="flex-1 px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400">
                <button onclick="testSignalDetection()" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700">
                    測試偵測
                </button>
            </div>
            <p id="signalMessage" class="mt-3 text-sm text-gray-500"></p>
            <div id="signalResult" class="mt-3 hidden">
                <h4 class="font-medium text-gray-700 mb-2">偵測結果：</h4>
                <pre id="signalResultContent" class="bg-gray-100 p-3 rounded text-xs overflow-x-auto"></pre>
            </div>
        </div>

        <!-- 搜尋和篩選 -->
        <div class="bg-white rounded-lg shadow p-4 mb-6">
            <div class="flex flex-col md:flex-row gap-4">
                <div class="flex-1">
                    <input type="text" id="searchInput" placeholder="搜尋用戶名稱、Email 或 LINE ID..."
                        class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-400">
                </div>
                <div class="flex gap-2">
                    <label class="flex items-center">
                        <input type="checkbox" id="blockedOnly" class="mr-2">
                        <span class="text-sm">只顯示封鎖</span>
                    </label>
                    <button onclick="loadUsers()" class="bg-brand-orange text-white px-4 py-2 rounded-lg hover:bg-brand-orange-dark">
                        搜尋
                    </button>
                    <button onclick="kickAllUsers()" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700">
                        踢出全部
                    </button>
                </div>
            </div>
        </div>

        <!-- 用戶列表 -->
        <div class="bg-white rounded-lg shadow overflow-hidden">
            <div class="overflow-x-auto">
                <table class="w-full">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">用戶</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase hidden md:table-cell">Email</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">狀態</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">登入次數</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase hidden md:table-cell">最後登入</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">操作</th>
                        </tr>
                    </thead>
                    <tbody id="userList" class="divide-y divide-gray-200">
                        <!-- 動態載入 -->
                    </tbody>
                </table>
            </div>
            
            <!-- 分頁 -->
            <div class="px-4 py-3 bg-gray-50 flex items-center justify-between">
                <div id="pageInfo" class="text-sm text-gray-500"></div>
                <div class="flex gap-2">
                    <button id="prevPage" onclick="changePage(-1)" class="px-3 py-1 border rounded hover:bg-gray-100" disabled>上一頁</button>
                    <button id="nextPage" onclick="changePage(1)" class="px-3 py-1 border rounded hover:bg-gray-100" disabled>下一頁</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 用戶詳情 Modal -->
    <div id="userModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-xl max-w-lg w-full mx-4 max-h-[90vh] overflow-y-auto">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-bold">用戶詳情</h3>
                    <button onclick="closeModal()" class="text-gray-500 hover:text-gray-700">✕</button>
                </div>
                <div id="modalContent">
                    <!-- 動態載入 -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentPage = 1;
        let totalPages = 1;
        const token = localStorage.getItem('token');
        const user = JSON.parse(localStorage.getItem('user') || '{}');

        // 檢查登入和管理員權限
        if (!token) {
            window.location.href = '/static/index.html';
        }

        document.getElementById('adminName').textContent = user.display_name || '';

        // API 請求
        async function apiRequest(url, options = {}) {
            const response = await fetch(url, {
                ...options,
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });
            
            if (response.status === 401) {
                localStorage.clear();
                window.location.href = '/static/index.html';
                return null;
            }
            
            if (response.status === 403) {
                alert('您沒有管理員權限');
                window.location.href = '/static/dashboard.html';
                return null;
            }
            
            return response.json();
        }

        // 載入統計
        async function loadStats() {
            const data = await apiRequest('/api/admin/stats');
            if (data && data.success) {
                document.getElementById('statTotal').textContent = data.stats.total_users;
                document.getElementById('statTotalLogins').textContent = data.stats.total_logins;
                document.getElementById('statToday').textContent = data.stats.today_logins;
                document.getElementById('statBlocked').textContent = data.stats.blocked_users;
                document.getElementById('statAdmin').textContent = data.stats.admin_users;
            }
        }

        // 載入用戶列表
        async function loadUsers() {
            const search = document.getElementById('searchInput').value;
            const blockedOnly = document.getElementById('blockedOnly').checked;
            
            let url = `/api/admin/users?page=${currentPage}&page_size=20`;
            if (search) url += `&search=${encodeURIComponent(search)}`;
            if (blockedOnly) url += `&blocked_only=true`;
            
            const data = await apiRequest(url);
            if (data && data.success) {
                renderUsers(data.users);
                totalPages = data.pagination.total_pages;
                document.getElementById('pageInfo').textContent = 
                    `第 ${data.pagination.page} / ${totalPages} 頁，共 ${data.pagination.total} 筆`;
                document.getElementById('prevPage').disabled = currentPage <= 1;
                document.getElementById('nextPage').disabled = currentPage >= totalPages;
            }
        }

        // 渲染用戶列表
        function renderUsers(users) {
            const tbody = document.getElementById('userList');
            tbody.innerHTML = users.map(u => `
                <tr class="hover:bg-gray-50">
                    <td class="px-4 py-3">
                        <div class="flex items-center">
                            <img src="${u.picture_url || '/static/logo.png'}" 
                                class="w-10 h-10 rounded-full mr-3" 
                                onerror="this.src='/static/logo.png'">
                            <div>
                                <div class="font-medium text-gray-900">${escapeHtml(u.display_name || '未命名')}</div>
                                <div class="text-xs text-gray-500">ID: ${u.id}</div>
                            </div>
                        </div>
                    </td>
                    <td class="px-4 py-3 text-sm text-gray-500 hidden md:table-cell">
                        ${escapeHtml(u.email || '-')}
                    </td>
                    <td class="px-4 py-3">
                        <div class="flex flex-wrap gap-1">
                            ${u.is_admin ? '<span class="px-2 py-0.5 text-xs rounded-full bg-blue-100 text-blue-800">管理員</span>' : ''}
                            ${u.is_blocked ? '<span class="px-2 py-0.5 text-xs rounded-full bg-red-100 text-red-800">已封鎖</span>' : '<span class="px-2 py-0.5 text-xs rounded-full bg-green-100 text-green-800">正常</span>'}
                        </div>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="px-2 py-1 text-sm font-medium rounded-full bg-purple-100 text-purple-700">${u.login_count || 0}</span>
                    </td>
                    <td class="px-4 py-3 text-sm text-gray-500 hidden md:table-cell">
                        ${formatDate(u.last_login)}
                    </td>
                    <td class="px-4 py-3">
                        <div class="flex gap-1">
                            <button onclick="showUserDetail(${u.id})" 
                                class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 rounded">詳情</button>
                            ${u.is_blocked 
                                ? `<button onclick="unblockUser(${u.id})" class="px-2 py-1 text-xs bg-green-100 hover:bg-green-200 text-green-700 rounded">解封</button>`
                                : `<button onclick="blockUser(${u.id})" class="px-2 py-1 text-xs bg-red-100 hover:bg-red-200 text-red-700 rounded">封鎖</button>`
                            }
                            <button onclick="kickUser(${u.id})" 
                                class="px-2 py-1 text-xs bg-yellow-100 hover:bg-yellow-200 text-yellow-700 rounded">踢出</button>
                        </div>
                    </td>
                </tr>
            `).join('');
        }

        // 顯示用戶詳情
        async function showUserDetail(userId) {
            const data = await apiRequest(`/api/admin/users/${userId}`);
            if (data && data.success) {
                const u = data.user;
                const logs = data.recent_logs;
                
                document.getElementById('modalContent').innerHTML = `
                    <div class="flex items-center mb-4">
                        <img src="${u.picture_url || '/static/logo.png'}" 
                            class="w-16 h-16 rounded-full mr-4"
                            onerror="this.src='/static/logo.png'">
                        <div>
                            <div class="font-bold text-xl">${escapeHtml(u.display_name || '未命名')}</div>
                            <div class="text-gray-500">${escapeHtml(u.email || '無 Email')}</div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div class="bg-gray-50 p-3 rounded">
                            <div class="text-xs text-gray-500">用戶 ID</div>
                            <div class="font-medium">${u.id}</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded">
                            <div class="text-xs text-gray-500">LINE ID</div>
                            <div class="font-medium text-xs break-all">${u.line_user_id}</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded">
                            <div class="text-xs text-gray-500">註冊時間</div>
                            <div class="font-medium">${formatDate(u.created_at)}</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded">
                            <div class="text-xs text-gray-500">最後登入</div>
                            <div class="font-medium">${formatDate(u.last_login)}</div>
                        </div>
                    </div>
                    
                    <div class="flex gap-2 mb-4">
                        ${u.is_admin 
                            ? `<button onclick="removeAdmin(${u.id})" class="flex-1 py-2 bg-gray-200 hover:bg-gray-300 rounded">移除管理員</button>`
                            : `<button onclick="setAdmin(${u.id})" class="flex-1 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded">設為管理員</button>`
                        }
                        ${u.is_blocked 
                            ? `<button onclick="unblockUser(${u.id})" class="flex-1 py-2 bg-green-500 hover:bg-green-600 text-white rounded">解除封鎖</button>`
                            : `<button onclick="blockUser(${u.id})" class="flex-1 py-2 bg-red-500 hover:bg-red-600 text-white rounded">封鎖用戶</button>`
                        }
                    </div>
                    
                    ${u.is_blocked ? `
                        <div class="bg-red-50 p-3 rounded mb-4">
                            <div class="text-red-800 font-medium">封鎖資訊</div>
                            <div class="text-sm text-red-600">原因：${escapeHtml(u.blocked_reason || '未說明')}</div>
                            <div class="text-sm text-red-600">時間：${formatDate(u.blocked_at)}</div>
                        </div>
                    ` : ''}
                    
                    <div class="border-t pt-4">
                        <div class="font-medium mb-2">最近活動記錄</div>
                        <div class="max-h-48 overflow-y-auto">
                            ${logs.length ? logs.map(log => `
                                <div class="flex justify-between py-1 text-sm border-b">
                                    <span class="text-gray-600">${getActionText(log.action)}</span>
                                    <span class="text-gray-400">${formatDate(log.created_at)}</span>
                                </div>
                            `).join('') : '<div class="text-gray-400 text-sm">無記錄</div>'}
                        </div>
                    </div>
                `;
                
                document.getElementById('userModal').classList.remove('hidden');
                document.getElementById('userModal').classList.add('flex');
            }
        }

        function closeModal() {
            document.getElementById('userModal').classList.add('hidden');
            document.getElementById('userModal').classList.remove('flex');
        }

        // 操作函數
        async function blockUser(userId) {
            const reason = prompt('請輸入封鎖原因（可留空）：');
            if (reason === null) return;
            
            const data = await apiRequest(`/api/admin/users/${userId}/block?reason=${encodeURIComponent(reason)}`, {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
                loadUsers();
                loadStats();
                closeModal();
            }
        }

        async function unblockUser(userId) {
            if (!confirm('確定要解除封鎖此用戶嗎？')) return;
            
            const data = await apiRequest(`/api/admin/users/${userId}/unblock`, {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
                loadUsers();
                loadStats();
                closeModal();
            }
        }

        async function kickUser(userId) {
            if (!confirm('確定要踢出此用戶嗎？用戶需要重新登入。')) return;
            
            const data = await apiRequest(`/api/admin/users/${userId}/kick`, {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
            }
        }

        async function kickAllUsers() {
            if (!confirm('⚠️ 確定要踢出所有用戶嗎？所有人（包括您自己）都需要重新登入！')) return;
            if (!confirm('再次確認：這將使所有登入 Token 失效！')) return;
            
            const data = await apiRequest('/api/admin/kick-all', {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
                localStorage.clear();
                window.location.href = '/static/index.html';
            }
        }

        async function setAdmin(userId) {
            if (!confirm('確定要將此用戶設為管理員嗎？')) return;
            
            const data = await apiRequest(`/api/admin/users/${userId}/set-admin`, {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
                loadUsers();
                loadStats();
                closeModal();
            }
        }

        async function removeAdmin(userId) {
            if (!confirm('確定要移除此用戶的管理員權限嗎？')) return;
            
            const data = await apiRequest(`/api/admin/users/${userId}/remove-admin`, {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
                loadUsers();
                loadStats();
                closeModal();
            }
        }

        function changePage(delta) {
            currentPage += delta;
            loadUsers();
        }

        // 工具函數
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatDate(dateStr) {
            if (!dateStr) return '-';
            const date = new Date(dateStr);
            return date.toLocaleString('zh-TW', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function getActionText(action) {
            const actions = {
                'login': '🔑 登入',
                'logout': '🚪 登出',
                'blocked': '🚫 被封鎖',
                'unblocked': '✅ 解除封鎖',
                'kicked': '👢 被踢出',
                'kick_all': '👢 全員踢出',
            };
            return actions[action] || action;
        }
        
        // ===== 市場資料管理 =====
        
        function showSystemMessage(msg, isError = false) {
            const el = document.getElementById('systemMessage');
            el.textContent = msg;
            el.className = `mt-3 text-sm ${isError ? 'text-red-600' : 'text-green-600'}`;
        }
        
        async function initializeData() {
            if (!confirm('這會初始化三大指數歷史資料（10年）和幣圈情緒歷史（365天），可能需要幾分鐘。確定要執行嗎？')) {
                return;
            }
            
            showSystemMessage('正在初始化資料，請稍候...');
            
            try {
                const data = await apiRequest('/api/market/admin/initialize', { method: 'POST' });
                if (data && data.success) {
                    showSystemMessage(`✅ 初始化完成！指數: ${data.data?.indices || 0} 筆, 情緒: ${data.data?.sentiment || 0} 筆`);
                } else {
                    showSystemMessage(`❌ 初始化失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSystemMessage(`❌ 初始化失敗: ${e.message}`, true);
            }
        }
        
        async function updateIndices() {
            showSystemMessage('正在更新三大指數...');
            
            try {
                const data = await apiRequest('/api/market/admin/update-indices', { method: 'POST' });
                if (data && data.success) {
                    showSystemMessage(`✅ 三大指數更新完成！${data.data?.count || 0} 筆資料`);
                } else {
                    showSystemMessage(`❌ 更新失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSystemMessage(`❌ 更新失敗: ${e.message}`, true);
            }
        }
        
        async function updateSentiment() {
            showSystemMessage('正在更新恐懼貪婪指數...');
            
            try {
                const data = await apiRequest('/api/market/admin/update-sentiment', { method: 'POST' });
                if (data && data.success) {
                    showSystemMessage(`✅ 恐懼貪婪指數更新完成！`);
                } else {
                    showSystemMessage(`❌ 更新失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSystemMessage(`❌ 更新失敗: ${e.message}`, true);
            }
        }
        
        async function triggerDailyUpdate() {
            showSystemMessage('正在執行每日更新...');
            
            try {
                const data = await apiRequest('/api/market/admin/update', { method: 'POST' });
                if (data && data.success) {
                    showSystemMessage(`✅ 每日更新完成！`);
                } else {
                    showSystemMessage(`❌ 更新失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSystemMessage(`❌ 更新失敗: ${e.message}`, true);
            }
        }

        // ========== 訊號檢查相關 ==========
        
        function showSignalMessage(msg, isError = false) {
            const el = document.getElementById('signalMessage');
            el.textContent = msg;
            el.className = isError ? 'mt-3 text-sm text-red-500' : 'mt-3 text-sm text-gray-500';
        }

        async function runSignalCheck() {
            showSignalMessage('正在執行訊號檢查...');
            document.getElementById('signalResult').classList.add('hidden');
            
            try {
                const data = await apiRequest('/api/admin/signal/detect', { method: 'POST' });
                if (data && data.success) {
                    showSignalMessage(`✅ 檢查完成：偵測到 ${data.total_signals} 個訊號`);
                    
                    if (data.signals_by_symbol && Object.keys(data.signals_by_symbol).length > 0) {
                        document.getElementById('signalResult').classList.remove('hidden');
                        document.getElementById('signalResultContent').textContent = 
                            JSON.stringify(data.signals_by_symbol, null, 2);
                    }
                } else {
                    showSignalMessage(`❌ 檢查失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSignalMessage(`❌ 檢查失敗: ${e.message}`, true);
            }
        }

        async function sendSignalNotifications() {
            showSignalMessage('正在發送訊號通知...');
            
            try {
                const data = await apiRequest('/api/admin/signal/notify', { method: 'POST' });
                if (data && data.success) {
                    const r = data.result || {};
                    showSignalMessage(`✅ ${data.message} - 股票更新: ${r.stocks_updated}, 訊號偵測: ${r.signals_detected}, 通知發送: ${r.notifications_sent}`);
                    
                    if (r.errors && r.errors.length > 0) {
                        document.getElementById('signalResult').classList.remove('hidden');
                        document.getElementById('signalResultContent').textContent = 
                            '錯誤記錄:\n' + r.errors.join('\n');
                    }
                } else {
                    showSignalMessage(`❌ 發送失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSignalMessage(`❌ 發送失敗: ${e.message}`, true);
            }
        }

        async function testSignalDetection() {
            const symbol = document.getElementById('testSymbolInput').value.trim();
            if (!symbol) {
                showSignalMessage('請輸入股票代號', true);
                return;
            }
            
            showSignalMessage(`正在測試 ${symbol.toUpperCase()} 的訊號偵測...`);
            document.getElementById('signalResult').classList.add('hidden');
            
            // 使用 detect API 然後過濾特定股票
            try {
                const data = await apiRequest('/api/admin/signal/detect', { method: 'POST' });
                if (data && data.success) {
                    const symbolUpper = symbol.toUpperCase();
                    const symbolSignals = data.signals_by_symbol[symbolUpper] || [];
                    
                    showSignalMessage(`✅ ${symbolUpper} 偵測到 ${symbolSignals.length} 個訊號`);
                    
                    document.getElementById('signalResult').classList.remove('hidden');
                    document.getElementById('signalResultContent').textContent = 
                        JSON.stringify({ symbol: symbolUpper, signals: symbolSignals }, null, 2);
                } else {
                    showSignalMessage(`❌ 偵測失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSignalMessage(`❌ 偵測失敗: ${e.message}`, true);
            }
        }

        async function testLineNotify() {
            showSignalMessage('正在發送測試訊息...');
            
            try {
                const data = await apiRequest('/api/admin/signal/test-push?message=管理員測試訊息', { method: 'POST' });
                if (data && data.success) {
                    showSignalMessage('✅ 測試訊息已發送，請檢查 LINE');
                } else {
                    showSignalMessage(`❌ 發送失敗: ${data?.message || data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSignalMessage(`❌ 發送失敗: ${e.message}`, true);
            }
        }

        // 測試股票輸入框 Enter 鍵支援
        document.getElementById('testSymbolInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') testSignalDetection();
        });

        // 搜尋 Enter 鍵支援
        document.getElementById('searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') loadUsers();
        });

        // 初始載入
        loadStats();
        loadUsers();
    </script>
</body>
</html>
```

──────────────────────────────────────────────────────────────────────
### 📄 static/compare-nav.js  ⭐
> *
──────────────────────────────────────────────────────────────────────

```js
/**
 * SELA 報酬率比較功能 - 導航連結注入
 * 將此檔案放到 static/ 目錄，並在 dashboard.html 的 </body> 前引入
 * <script src="/static/compare-nav.js"></script>
 */

(function() {
    'use strict';
    
    // 等待 DOM 載入完成
    document.addEventListener('DOMContentLoaded', function() {
        injectCompareLinks();
    });
    
    // 如果 DOM 已經載入完成，直接執行
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(injectCompareLinks, 100);
    }
    
    function injectCompareLinks() {
        // 桌面版側邊欄連結 HTML
        const desktopLinkHTML = `
            <a href="/static/compare.html" class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-gray-50 rounded-lg">
                <i class="fas fa-chart-bar mr-3"></i>
                <span>報酬率比較</span>
            </a>
        `;
        
        // 手機版側邊欄連結 HTML
        const mobileLinkHTML = `
            <a href="/static/compare.html" class="mobile-nav-link flex items-center px-4 py-3 text-gray-600 hover:bg-gray-50 rounded-lg touch-target">
                <i class="fas fa-chart-bar mr-3 w-6"></i>
                <span>報酬率比較</span>
            </a>
        `;
        
        // 找到「設定」連結並在其後插入
        // 桌面版
        const desktopSettingsLinks = document.querySelectorAll('a.nav-link');
        desktopSettingsLinks.forEach(function(link) {
            if (link.textContent.includes('設定') && !link.nextElementSibling?.textContent?.includes('報酬率')) {
                link.insertAdjacentHTML('afterend', desktopLinkHTML);
            }
        });
        
        // 手機版側邊欄
        const mobileSettingsLinks = document.querySelectorAll('a.mobile-nav-link');
        mobileSettingsLinks.forEach(function(link) {
            if (link.textContent.includes('設定') && !link.nextElementSibling?.textContent?.includes('報酬率')) {
                link.insertAdjacentHTML('afterend', mobileLinkHTML);
            }
        });
        
        // 也可以在儀表板區域加入快捷入口
        addDashboardQuickAccess();
        
        console.log('✅ 報酬率比較連結已注入');
    }
    
    function addDashboardQuickAccess() {
        // 找到儀表板區塊
        const dashboardSection = document.getElementById('section-dashboard');
        if (!dashboardSection) return;
        
        // 檢查是否已經有快捷入口
        if (dashboardSection.querySelector('.compare-quick-access')) return;
        
        // 在儀表板開頭加入快捷卡片
        const quickAccessHTML = `
            <div class="compare-quick-access bg-gradient-to-r from-indigo-500 to-purple-600 rounded-xl shadow-lg p-4 mb-6 text-white">
                <div class="flex items-center justify-between">
                    <div>
                        <h3 class="font-bold text-lg">🏆 報酬率比較</h3>
                        <p class="text-indigo-100 text-sm">比較股票、加密貨幣的年化報酬</p>
                    </div>
                    <a href="/static/compare.html" 
                       class="px-4 py-2 bg-white text-indigo-600 rounded-lg font-medium hover:bg-indigo-50 transition">
                        立即比較 →
                    </a>
                </div>
            </div>
        `;
        
        // 找到第一個子元素並在前面插入
        const firstChild = dashboardSection.querySelector('h2');
        if (firstChild && firstChild.nextElementSibling) {
            firstChild.nextElementSibling.insertAdjacentHTML('beforebegin', quickAccessHTML);
        }
    }
})();
```

──────────────────────────────────────────────────────────────────────
### 📄 static/compare.html  ⭐
──────────────────────────────────────────────────────────────────────

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>報酬率比較 - SELA 自動選股系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="icon" type="image/png" href="/static/logo.png">
    <style>
        :root {
            --brand-orange: #FA7A35;
        }
        .brand-orange { background-color: var(--brand-orange); }
        .brand-orange:hover { background-color: #e86a25; }
        .brand-text { color: var(--brand-orange); }
        .brand-border { border-color: var(--brand-orange); }
        
        .cagr-positive { color: #16a34a; }
        .cagr-negative { color: #dc2626; }
        .cagr-neutral { color: #6b7280; }
        
        .rank-1 { background: linear-gradient(135deg, #ffd700 0%, #ffec8b 100%); }
        .rank-2 { background: linear-gradient(135deg, #c0c0c0 0%, #e8e8e8 100%); }
        .rank-3 { background: linear-gradient(135deg, #cd7f32 0%, #daa06d 100%); }
        
        .loading { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .symbol-tag {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            background: #f3f4f6;
            border-radius: 9999px;
            margin: 0.25rem;
        }
        .symbol-tag button {
            margin-left: 0.5rem;
            color: #9ca3af;
        }
        .symbol-tag button:hover {
            color: #ef4444;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <!-- 頂部導航 -->
    <nav class="bg-slate-800 text-white shadow-lg">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center space-x-4">
                    <a href="/static/dashboard.html" class="flex items-center space-x-2">
                        <img src="/static/logo.png" alt="SELA" class="w-10 h-10 rounded-lg">
                        <span class="font-bold text-xl">SELA</span>
                    </a>
                    <span class="text-gray-400">|</span>
                    <span class="text-lg">📊 報酬率比較</span>
                </div>
                <div class="flex items-center space-x-4">
                    <a href="/static/dashboard.html" class="text-gray-300 hover:text-white">
                        ← 返回儀表板
                    </a>
                    <span id="userName" class="text-gray-300"></span>
                </div>
            </div>
        </div>
    </nav>

    <!-- 主內容 -->
    <div class="max-w-7xl mx-auto px-4 py-6">
        <!-- 說明卡片 -->
        <div class="bg-gradient-to-r from-blue-600 to-indigo-600 rounded-xl shadow-lg p-6 mb-6 text-white">
            <h1 class="text-2xl font-bold mb-2">🏆 年化報酬率 (CAGR) 比較器</h1>
            <p class="text-blue-100">比較股票、加密貨幣、指數的長期投資報酬表現，找出最佳投資標的</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- 左側：選擇標的 -->
            <div class="lg:col-span-1 space-y-4">
                <!-- 快速選擇預設組合 -->
                <div class="bg-white rounded-xl shadow p-4">
                    <h3 class="font-bold text-gray-700 mb-3">🚀 快速比較</h3>
                    <div class="space-y-2" id="presetList">
                        <p class="text-gray-400 text-sm">載入中...</p>
                    </div>
                </div>

                <!-- 自訂標的 -->
                <div class="bg-white rounded-xl shadow p-4">
                    <h3 class="font-bold text-gray-700 mb-3">✏️ 自訂比較</h3>
                    
                    <!-- 已選標的 -->
                    <div class="mb-3">
                        <label class="text-sm text-gray-500 mb-1 block">已選標的 (最多5個)</label>
                        <div id="selectedSymbols" class="min-h-[40px] p-2 bg-gray-50 rounded-lg flex flex-wrap">
                            <span class="text-gray-400 text-sm">尚未選擇</span>
                        </div>
                    </div>
                    
                    <!-- 輸入框 -->
                    <div class="flex gap-2 mb-3">
                        <input type="text" id="symbolInput" placeholder="輸入代號 (如 AAPL, BTC)"
                            class="flex-1 px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400"
                            onkeypress="if(event.key==='Enter') addSymbol()">
                        <button onclick="addSymbol()" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    
                    <!-- 時間週期 -->
                    <div class="mb-3">
                        <label class="text-sm text-gray-500 mb-1 block">比較週期</label>
                        <div class="flex flex-wrap gap-2">
                            <label class="flex items-center">
                                <input type="checkbox" class="period-check mr-1" value="1y" checked> 1年
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" class="period-check mr-1" value="3y" checked> 3年
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" class="period-check mr-1" value="5y" checked> 5年
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" class="period-check mr-1" value="10y"> 10年
                            </label>
                        </div>
                    </div>
                    
                    <!-- 基準指數 -->
                    <div class="mb-4">
                        <label class="text-sm text-gray-500 mb-1 block">基準指數</label>
                        <select id="benchmarkSelect" class="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                            <option value="^GSPC">S&P 500</option>
                            <option value="^IXIC">納斯達克</option>
                            <option value="^DJI">道瓊工業</option>
                            <option value="">無</option>
                        </select>
                    </div>
                    
                    <!-- 排序 -->
                    <div class="mb-4">
                        <label class="text-sm text-gray-500 mb-1 block">排序依據</label>
                        <select id="sortBySelect" class="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                            <option value="1y">1年報酬率</option>
                            <option value="3y">3年報酬率</option>
                            <option value="5y" selected>5年報酬率</option>
                            <option value="10y">10年報酬率</option>
                        </select>
                    </div>
                    
                    <!-- 執行比較按鈕 -->
                    <button onclick="runComparison()" id="compareBtn"
                        class="w-full py-3 brand-orange text-white rounded-lg font-bold hover:opacity-90 transition disabled:opacity-50 disabled:cursor-not-allowed">
                        <i class="fas fa-chart-bar mr-2"></i>開始比較
                    </button>
                </div>
                
                <!-- 我的組合 -->
                <div class="bg-white rounded-xl shadow p-4">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-gray-700">💾 我的組合</h3>
                        <button onclick="saveCurrentComparison()" class="text-blue-600 hover:text-blue-800 text-sm">
                            <i class="fas fa-save mr-1"></i>儲存目前
                        </button>
                    </div>
                    <div id="savedComparisons" class="space-y-2">
                        <p class="text-gray-400 text-sm">登入後可儲存組合</p>
                    </div>
                </div>
            </div>

            <!-- 右側：比較結果 -->
            <div class="lg:col-span-2">
                <div class="bg-white rounded-xl shadow p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="font-bold text-gray-700 text-lg">📊 比較結果</h3>
                        <span id="resultTime" class="text-sm text-gray-400"></span>
                    </div>
                    
                    <div id="comparisonResult">
                        <div class="text-center py-12 text-gray-400">
                            <i class="fas fa-chart-line text-6xl mb-4"></i>
                            <p>選擇標的後點擊「開始比較」</p>
                            <p class="text-sm mt-2">或使用左側的快速比較預設組合</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast 通知 -->
    <div id="toast" class="fixed bottom-4 right-4 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg hidden transition-opacity z-50">
        <span id="toastMessage"></span>
    </div>

    <script>
        const API_BASE = '';
        const token = localStorage.getItem('token');
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        
        // 選中的標的
        let selectedSymbols = [];
        
        // 檢查登入
        if (token && user.display_name) {
            document.getElementById('userName').textContent = user.display_name;
        }
        
        // ==================== 預設組合 ====================
        async function loadPresets() {
            try {
                const res = await fetch(`${API_BASE}/api/compare/presets`);
                const data = await res.json();
                
                if (data.success) {
                    const container = document.getElementById('presetList');
                    container.innerHTML = data.presets.map(preset => `
                        <button onclick="quickCompare('${preset.id}')" 
                            class="w-full text-left px-3 py-2 rounded-lg hover:bg-gray-100 transition flex justify-between items-center">
                            <span>${preset.name}</span>
                            <span class="text-xs text-gray-400">${preset.count}個</span>
                        </button>
                    `).join('');
                }
            } catch (e) {
                console.error('載入預設組合失敗', e);
            }
        }
        
        async function quickCompare(presetId) {
            showLoading();
            try {
                const benchmark = document.getElementById('benchmarkSelect').value;
                const sortBy = document.getElementById('sortBySelect').value;
                
                const res = await fetch(`${API_BASE}/api/compare/quick/${presetId}?benchmark=${benchmark}&sort_by=${sortBy}`);
                const data = await res.json();
                
                if (data.success) {
                    // 更新選中的標的
                    if (data.preset && data.preset.symbols) {
                        selectedSymbols = data.preset.symbols;
                        renderSelectedSymbols();
                    }
                    renderResult(data);
                } else {
                    showToast('比較失敗：' + (data.error || '未知錯誤'));
                }
            } catch (e) {
                showToast('比較失敗：' + e.message);
            }
        }
        
        // ==================== 標的選擇 ====================
        function addSymbol() {
            const input = document.getElementById('symbolInput');
            const symbol = input.value.trim().toUpperCase();
            
            if (!symbol) return;
            
            if (selectedSymbols.length >= 5) {
                showToast('最多只能選擇 5 個標的');
                return;
            }
            
            if (selectedSymbols.includes(symbol)) {
                showToast('已經選擇過此標的');
                return;
            }
            
            selectedSymbols.push(symbol);
            renderSelectedSymbols();
            input.value = '';
        }
        
        function removeSymbol(symbol) {
            selectedSymbols = selectedSymbols.filter(s => s !== symbol);
            renderSelectedSymbols();
        }
        
        function renderSelectedSymbols() {
            const container = document.getElementById('selectedSymbols');
            
            if (selectedSymbols.length === 0) {
                container.innerHTML = '<span class="text-gray-400 text-sm">尚未選擇</span>';
                return;
            }
            
            container.innerHTML = selectedSymbols.map(symbol => `
                <span class="symbol-tag">
                    ${symbol}
                    <button onclick="removeSymbol('${symbol}')" title="移除">
                        <i class="fas fa-times"></i>
                    </button>
                </span>
            `).join('');
        }
        
        // ==================== 執行比較 ====================
        async function runComparison() {
            if (selectedSymbols.length === 0) {
                showToast('請至少選擇一個標的');
                return;
            }
            
            showLoading();
            
            // 取得勾選的週期
            const periods = Array.from(document.querySelectorAll('.period-check:checked'))
                .map(cb => cb.value);
            
            if (periods.length === 0) {
                showToast('請至少選擇一個時間週期');
                return;
            }
            
            const benchmark = document.getElementById('benchmarkSelect').value;
            const sortBy = document.getElementById('sortBySelect').value;
            
            try {
                const res = await fetch(`${API_BASE}/api/compare/cagr`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(token ? { 'Authorization': `Bearer ${token}` } : {})
                    },
                    body: JSON.stringify({
                        symbols: selectedSymbols,
                        periods: periods,
                        benchmark: benchmark,
                        sort_by: sortBy,
                        sort_order: 'desc'
                    })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    renderResult(data);
                } else {
                    showToast('比較失敗：' + (data.detail || data.error || '未知錯誤'));
                    document.getElementById('comparisonResult').innerHTML = `
                        <div class="text-center py-8 text-red-500">
                            <i class="fas fa-exclamation-circle text-4xl mb-2"></i>
                            <p>${data.detail || data.error || '比較失敗'}</p>
                        </div>
                    `;
                }
            } catch (e) {
                showToast('比較失敗：' + e.message);
            }
        }
        
        function showLoading() {
            document.getElementById('comparisonResult').innerHTML = `
                <div class="text-center py-12">
                    <i class="fas fa-spinner fa-spin text-4xl text-blue-500 mb-4"></i>
                    <p class="text-gray-500">正在計算報酬率...</p>
                    <p class="text-gray-400 text-sm mt-1">首次查詢可能需要較長時間</p>
                </div>
            `;
        }
        
        // ==================== 渲染結果 ====================
        function renderResult(data) {
            const container = document.getElementById('comparisonResult');
            const periods = data.periods || ['1y', '3y', '5y'];
            
            // 更新時間
            if (data.generated_at) {
                const time = new Date(data.generated_at).toLocaleString('zh-TW');
                document.getElementById('resultTime').textContent = `更新：${time}`;
            }
            
            // 建立表格
            let html = `
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead>
                            <tr class="bg-gray-50">
                                <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">排名</th>
                                <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">標的</th>
                                <th class="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase">現價</th>
                                ${periods.map(p => `
                                    <th class="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase">${formatPeriod(p)}</th>
                                `).join('')}
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
            `;
            
            data.comparison.forEach((item, index) => {
                const rankClass = index === 0 ? 'rank-1' : index === 1 ? 'rank-2' : index === 2 ? 'rank-3' : '';
                const rankIcon = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}`;
                const typeIcon = item.type === 'crypto' ? '🪙' : item.type === 'index' ? '📈' : '📊';
                
                html += `
                    <tr class="hover:bg-gray-50">
                        <td class="px-4 py-4">
                            <span class="inline-flex items-center justify-center w-8 h-8 rounded-full ${rankClass} font-bold text-sm">
                                ${rankIcon}
                            </span>
                        </td>
                        <td class="px-4 py-4">
                            <div class="flex items-center">
                                <span class="mr-2">${typeIcon}</span>
                                <div>
                                    <div class="font-medium text-gray-900">${item.symbol}</div>
                                    <div class="text-xs text-gray-500">${item.name || ''}</div>
                                </div>
                            </div>
                        </td>
                        <td class="px-4 py-4 text-right">
                            ${item.current_price ? `$${formatNumber(item.current_price)}` : '--'}
                        </td>
                        ${periods.map(p => {
                            const cagr = item.cagr ? item.cagr[p] : null;
                            const vsBench = item.vs_benchmark ? item.vs_benchmark[p] : null;
                            return `
                                <td class="px-4 py-4 text-right">
                                    ${formatCAGR(cagr)}
                                    ${vsBench !== null && vsBench !== undefined ? `
                                        <div class="text-xs ${vsBench >= 0 ? 'text-green-600' : 'text-red-600'}">
                                            ${vsBench >= 0 ? '+' : ''}${vsBench.toFixed(1)}%
                                        </div>
                                    ` : ''}
                                </td>
                            `;
                        }).join('')}
                    </tr>
                `;
            });
            
            html += '</tbody></table></div>';
            
            // 基準指數資訊
            if (data.benchmark) {
                html += `
                    <div class="mt-4 p-3 bg-gray-50 rounded-lg">
                        <span class="text-sm text-gray-500">📌 基準指數：</span>
                        <span class="font-medium">${data.benchmark.name} (${data.benchmark.symbol})</span>
                        <span class="ml-4 text-sm text-gray-500">
                            ${periods.map(p => `${formatPeriod(p)}: ${formatCAGR(data.benchmark.cagr[p], true)}`).join(' | ')}
                        </span>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function formatPeriod(period) {
            const map = { '1y': '1年', '3y': '3年', '5y': '5年', '10y': '10年', 'custom': '自訂' };
            return map[period] || period;
        }
        
        function formatCAGR(value, simple = false) {
            if (value === null || value === undefined) {
                return '<span class="text-gray-400">--</span>';
            }
            
            const colorClass = value > 0 ? 'cagr-positive' : value < 0 ? 'cagr-negative' : 'cagr-neutral';
            const sign = value > 0 ? '+' : '';
            
            if (simple) {
                return `<span class="${colorClass}">${sign}${value.toFixed(1)}%</span>`;
            }
            
            return `<span class="${colorClass} font-medium text-lg">${sign}${value.toFixed(1)}%</span>`;
        }
        
        function formatNumber(num) {
            if (num >= 1000) {
                return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }
            return num.toFixed(2);
        }
        
        // ==================== 儲存組合 ====================
        async function saveCurrentComparison() {
            if (!token) {
                showToast('請先登入');
                return;
            }
            
            if (selectedSymbols.length === 0) {
                showToast('請先選擇標的');
                return;
            }
            
            const name = prompt('請輸入組合名稱：');
            if (!name) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/compare/saved`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        name: name,
                        symbols: selectedSymbols,
                        benchmark: document.getElementById('benchmarkSelect').value
                    })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast('組合已儲存');
                    loadSavedComparisons();
                } else {
                    showToast('儲存失敗：' + (data.detail || '未知錯誤'));
                }
            } catch (e) {
                showToast('儲存失敗：' + e.message);
            }
        }
        
        async function loadSavedComparisons() {
            if (!token) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/compare/saved`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await res.json();
                
                if (data.success && data.comparisons.length > 0) {
                    const container = document.getElementById('savedComparisons');
                    container.innerHTML = data.comparisons.map(c => `
                        <div class="flex justify-between items-center p-2 rounded hover:bg-gray-50">
                            <button onclick="loadSavedComparison(${c.id}, ${JSON.stringify(c.symbols).replace(/"/g, '&quot;')})" 
                                class="text-left flex-1">
                                <div class="font-medium text-sm">${c.name}</div>
                                <div class="text-xs text-gray-400">${c.symbols.join(', ')}</div>
                            </button>
                            <button onclick="deleteSavedComparison(${c.id})" class="text-red-400 hover:text-red-600 ml-2">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `).join('');
                }
            } catch (e) {
                console.error('載入儲存組合失敗', e);
            }
        }
        
        function loadSavedComparison(id, symbols) {
            selectedSymbols = symbols;
            renderSelectedSymbols();
            runComparison();
        }
        
        async function deleteSavedComparison(id) {
            if (!confirm('確定要刪除此組合？')) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/compare/saved/${id}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast('已刪除');
                    loadSavedComparisons();
                }
            } catch (e) {
                showToast('刪除失敗');
            }
        }
        
        // ==================== 工具函數 ====================
        function showToast(message) {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.classList.remove('hidden');
            setTimeout(() => toast.classList.add('hidden'), 3000);
        }
        
        // ==================== 初始化 ====================
        loadPresets();
        if (token) {
            loadSavedComparisons();
        }
    </script>
</body>
</html>
```

──────────────────────────────────────────────────────────────────────
### 📄 static/dashboard-mobile.html  ⭐
──────────────────────────────────────────────────────────────────────

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SELA 自動選股系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --brand-orange: #FA7A35;
            --brand-orange-hover: #e86a25;
        }
        
        .brand-orange { background-color: var(--brand-orange); }
        .brand-orange:hover { background-color: var(--brand-orange-hover); }
        .brand-text { color: var(--brand-orange); }
        .brand-border { border-color: var(--brand-orange); }
        
        /* 預設隱藏主內容 */
        #app-content { display: none; }
        
        /* 通用動畫 */
        .transition-all { transition: all 0.3s ease; }
        
        /* ===== 電腦版樣式 (預設) ===== */
        .desktop-sidebar { display: block; }
        .mobile-header-menu { display: none; }
        .mobile-bottom-nav { display: none; }
        .mobile-sidebar-overlay { display: none; }
        .mobile-sidebar { transform: translateX(-100%); }
        
        /* ===== 手機版樣式 ===== */
        @media (max-width: 767px) {
            /* 隱藏電腦版側邊欄 */
            .desktop-sidebar { display: none !important; }
            
            /* 主內容區不需要左邊距 */
            .main-content { margin-left: 0 !important; padding-bottom: 70px; }
            
            /* 顯示手機版元素 */
            .mobile-header-menu { display: flex !important; }
            .mobile-bottom-nav { display: flex !important; }
            
            /* 手機版側邊選單 */
            .mobile-sidebar {
                position: fixed;
                top: 0;
                left: 0;
                width: 280px;
                height: 100vh;
                background: white;
                z-index: 1000;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            }
            
            .mobile-sidebar.open { transform: translateX(0); }
            
            .mobile-sidebar-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 999;
                display: none;
                opacity: 0;
                transition: opacity 0.3s ease;
            }
            
            .mobile-sidebar-overlay.open { display: block; opacity: 1; }
            
            /* 加大觸控區域 */
            .touch-target { min-height: 44px; min-width: 44px; }
            
            /* 卡片樣式 */
            .stock-card {
                background: white;
                border-radius: 12px;
                padding: 16px;
                margin-bottom: 12px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            }
            
            /* 摺疊區塊 */
            .collapsible-content {
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease;
            }
            
            .collapsible-content.open { max-height: 500px; }
            
            /* 全螢幕圖表 */
            .chart-fullscreen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: white;
                z-index: 2000;
                display: none;
            }
            
            .chart-fullscreen.open { display: block; }
            
            /* 強制橫向提示 */
            .rotate-hint {
                display: none;
            }
            
            @media (orientation: portrait) {
                .chart-fullscreen .rotate-hint { display: flex; }
                .chart-fullscreen .chart-container { display: none; }
            }
            
            @media (orientation: landscape) {
                .chart-fullscreen .rotate-hint { display: none; }
                .chart-fullscreen .chart-container { display: block; }
            }
        }
        
        /* 底部導航列 */
        .mobile-bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: white;
            border-top: 1px solid #e5e7eb;
            z-index: 100;
            display: none;
            justify-content: space-around;
            align-items: center;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .bottom-nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            padding: 8px 0;
            color: #6b7280;
            text-decoration: none;
            font-size: 10px;
            transition: color 0.2s;
        }
        
        .bottom-nav-item.active { color: var(--brand-orange); }
        .bottom-nav-item i { font-size: 20px; margin-bottom: 2px; }
        
        /* 載入動畫 */
        .loading { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- 載入畫面 -->
    <div id="loading-screen" class="fixed inset-0 bg-gradient-to-br from-slate-900 to-slate-800 flex items-center justify-center z-50">
        <div class="text-center">
            <img src="/static/logo.png" alt="SELA" class="w-24 h-24 mx-auto mb-4 rounded-xl">
            <p class="text-white text-lg">載入中...</p>
            <i class="fas fa-spinner fa-spin text-white text-2xl mt-4"></i>
        </div>
    </div>

    <!-- 主應用程式內容 -->
    <div id="app-content">
        
        <!-- ===== 手機版側邊選單遮罩 ===== -->
        <div id="sidebarOverlay" class="mobile-sidebar-overlay" onclick="closeMobileSidebar()"></div>
        
        <!-- ===== 手機版側邊選單 ===== -->
        <aside id="mobileSidebar" class="mobile-sidebar">
            <div class="p-4 border-b flex items-center justify-between">
                <div class="flex items-center">
                    <img src="/static/logo.png" alt="SELA" class="w-10 h-10 rounded-lg mr-2">
                    <span class="font-bold text-lg">SELA</span>
                </div>
                <button onclick="closeMobileSidebar()" class="p-2 text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <nav class="p-4 space-y-2">
                <a href="#" onclick="mobileNavTo('dashboard')" class="mobile-nav-link flex items-center px-4 py-3 text-gray-700 bg-blue-50 rounded-lg touch-target" data-section="dashboard">
                    <i class="fas fa-tachometer-alt mr-3 w-5"></i>
                    <span>儀表板</span>
                </a>
                <a href="#" onclick="mobileNavTo('search')" class="mobile-nav-link flex items-center px-4 py-3 text-gray-600 hover:bg-gray-50 rounded-lg touch-target" data-section="search">
                    <i class="fas fa-search mr-3 w-5"></i>
                    <span>股票查詢</span>
                </a>
                <a href="#" onclick="mobileNavTo('watchlist')" class="mobile-nav-link flex items-center px-4 py-3 text-gray-600 hover:bg-gray-50 rounded-lg touch-target" data-section="watchlist">
                    <i class="fas fa-star mr-3 w-5"></i>
                    <span>追蹤清單</span>
                </a>
                <a href="#" onclick="mobileNavTo('sentiment')" class="mobile-nav-link flex items-center px-4 py-3 text-gray-600 hover:bg-gray-50 rounded-lg touch-target" data-section="sentiment">
                    <i class="fas fa-heart-pulse mr-3 w-5"></i>
                    <span>市場情緒</span>
                </a>
                <a href="#" onclick="mobileNavTo('settings')" class="mobile-nav-link flex items-center px-4 py-3 text-gray-600 hover:bg-gray-50 rounded-lg touch-target" data-section="settings">
                    <i class="fas fa-cog mr-3 w-5"></i>
                    <span>設定</span>
                </a>
            </nav>
            <div class="absolute bottom-0 left-0 right-0 p-4 border-t">
                <div class="flex items-center justify-between mb-3">
                    <div class="flex items-center">
                        <img id="sidebarAvatar" class="w-10 h-10 rounded-full mr-3" src="" alt="">
                        <span id="sidebarUserName" class="text-gray-700 font-medium"></span>
                    </div>
                </div>
                <div class="text-xs text-gray-400 mb-2">
                    閒置登出: <span id="sidebarTimer">5:00</span>
                </div>
                <button onclick="logout()" class="w-full py-2 text-red-500 hover:bg-red-50 rounded-lg flex items-center justify-center touch-target">
                    <i class="fas fa-sign-out-alt mr-2"></i>
                    <span>登出</span>
                </button>
            </div>
        </aside>
        
        <!-- ===== 頂部導覽列 ===== -->
        <nav class="bg-white shadow-sm border-b fixed w-full z-50 top-0">
            <div class="px-4 h-14 flex items-center justify-between">
                <!-- 手機版: 漢堡選單按鈕 -->
                <button onclick="openMobileSidebar()" class="mobile-header-menu p-2 -ml-2 text-gray-600 touch-target">
                    <i class="fas fa-bars text-xl"></i>
                </button>
                
                <!-- Logo -->
                <div class="flex items-center">
                    <img src="/static/logo.png" alt="SELA" class="w-8 h-8 rounded-lg mr-2">
                    <span class="font-bold text-lg text-gray-800 hidden sm:inline">自動選股系統</span>
                    <span class="font-bold text-lg text-gray-800 sm:hidden">SELA</span>
                </div>
                
                <!-- 右側資訊 -->
                <div class="flex items-center space-x-2">
                    <span id="sessionTimer" class="text-xs text-gray-400 hidden sm:inline"></span>
                    <span id="userName" class="text-gray-600 text-sm hidden md:inline"></span>
                    <img id="userAvatar" class="w-8 h-8 rounded-full" src="" alt="">
                    <button onclick="logout()" class="text-gray-500 hover:text-red-500 hidden sm:inline p-2" title="登出">
                        <i class="fas fa-sign-out-alt"></i>
                    </button>
                </div>
            </div>
        </nav>

        <!-- ===== 電腦版側邊欄 ===== -->
        <aside class="desktop-sidebar w-64 bg-white shadow-sm min-h-screen fixed top-14">
            <nav class="p-4 space-y-2">
                <a href="#" onclick="showSection('dashboard', event)" class="nav-link flex items-center px-4 py-2 text-gray-700 bg-blue-50 rounded-lg" data-section="dashboard">
                    <i class="fas fa-tachometer-alt mr-3"></i>
                    <span>儀表板</span>
                </a>
                <a href="#" onclick="showSection('search', event)" class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-gray-50 rounded-lg" data-section="search">
                    <i class="fas fa-search mr-3"></i>
                    <span>股票查詢</span>
                </a>
                <a href="#" onclick="showSection('watchlist', event)" class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-gray-50 rounded-lg" data-section="watchlist">
                    <i class="fas fa-star mr-3"></i>
                    <span>追蹤清單</span>
                </a>
                <a href="#" onclick="showSection('sentiment', event)" class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-gray-50 rounded-lg" data-section="sentiment">
                    <i class="fas fa-heart-pulse mr-3"></i>
                    <span>市場情緒</span>
                </a>
                <a href="#" onclick="showSection('settings', event)" class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-gray-50 rounded-lg" data-section="settings">
                    <i class="fas fa-cog mr-3"></i>
                    <span>設定</span>
                </a>
            </nav>
        </aside>

        <!-- ===== 主區域 ===== -->
        <main class="main-content md:ml-64 pt-14 p-4 md:p-6 min-h-screen">
            
            <!-- ===== 儀表板區塊 ===== -->
            <section id="section-dashboard" class="section">
                <h2 class="text-xl md:text-2xl font-bold text-gray-800 mb-4 md:mb-6">儀表板</h2>
                
                <!-- 市場情緒卡片 -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6 mb-4 md:mb-6">
                    <!-- 美股情緒 -->
                    <div class="bg-white rounded-xl shadow p-4 md:p-6">
                        <div class="flex items-center justify-between mb-3 md:mb-4">
                            <h3 class="font-semibold text-gray-700 text-sm md:text-base">美股情緒指數</h3>
                            <span id="stockSentimentBadge" class="px-2 md:px-3 py-1 rounded-full text-xs md:text-sm font-medium"></span>
                        </div>
                        <div class="flex items-center">
                            <span id="stockSentimentValue" class="text-3xl md:text-4xl font-bold text-gray-800">--</span>
                            <span class="text-gray-500 ml-2 text-sm">/ 100</span>
                        </div>
                        <div class="mt-3 md:mt-4 bg-gray-200 rounded-full h-2 md:h-3">
                            <div id="stockSentimentBar" class="h-2 md:h-3 rounded-full transition-all" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <!-- 幣圈情緒 -->
                    <div class="bg-white rounded-xl shadow p-4 md:p-6">
                        <div class="flex items-center justify-between mb-3 md:mb-4">
                            <h3 class="font-semibold text-gray-700 text-sm md:text-base">幣圈情緒指數</h3>
                            <span id="cryptoSentimentBadge" class="px-2 md:px-3 py-1 rounded-full text-xs md:text-sm font-medium"></span>
                        </div>
                        <div class="flex items-center">
                            <span id="cryptoSentimentValue" class="text-3xl md:text-4xl font-bold text-gray-800">--</span>
                            <span class="text-gray-500 ml-2 text-sm">/ 100</span>
                        </div>
                        <div class="mt-3 md:mt-4 bg-gray-200 rounded-full h-2 md:h-3">
                            <div id="cryptoSentimentBar" class="h-2 md:h-3 rounded-full transition-all" style="width: 0%"></div>
                        </div>
                    </div>
                </div>

                <!-- 追蹤清單快覽 -->
                <div class="bg-white rounded-xl shadow p-4 md:p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="font-semibold text-gray-700">追蹤清單</h3>
                        <a href="#" onclick="showSection('watchlist')" class="text-blue-600 text-sm hover:underline">查看全部</a>
                    </div>
                    <div id="dashboardWatchlist">
                        <p class="text-gray-500 text-center py-4">載入中...</p>
                    </div>
                </div>
            </section>

            <!-- ===== 股票查詢區塊 ===== -->
            <section id="section-search" class="section hidden">
                <h2 class="text-xl md:text-2xl font-bold text-gray-800 mb-4 md:mb-6">股票查詢</h2>
                
                <!-- 搜尋框 -->
                <div class="bg-white rounded-xl shadow p-4 md:p-6 mb-4 md:mb-6">
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input type="text" id="searchSymbol" placeholder="輸入股票代號（如 AAPL）或加密貨幣（BTC）" 
                            class="flex-1 px-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-base"
                            onkeypress="if(event.key==='Enter')searchStock()">
                        <button onclick="searchStock()" class="brand-orange text-white px-6 py-3 rounded-lg font-medium flex items-center justify-center touch-target">
                            <i class="fas fa-search mr-2"></i>
                            <span>查詢</span>
                        </button>
                    </div>
                    <p class="text-gray-500 text-xs md:text-sm mt-2">支援美股代號及加密貨幣 (BTC, ETH)</p>
                </div>
                
                <!-- 搜尋結果 -->
                <div id="searchResult" class="hidden"></div>
            </section>

            <!-- ===== 追蹤清單區塊 ===== -->
            <section id="section-watchlist" class="section hidden">
                <div class="flex items-center justify-between mb-4 md:mb-6">
                    <h2 class="text-xl md:text-2xl font-bold text-gray-800">追蹤清單</h2>
                    <button onclick="showAddWatchlistModal()" class="brand-orange text-white px-4 py-2 rounded-lg font-medium flex items-center touch-target">
                        <i class="fas fa-plus mr-2"></i>
                        <span class="hidden sm:inline">新增</span>
                    </button>
                </div>
                <div id="watchlistContent">
                    <p class="text-gray-500 text-center py-4">載入中...</p>
                </div>
            </section>

            <!-- ===== 市場情緒區塊 ===== -->
            <section id="section-sentiment" class="section hidden">
                <h2 class="text-xl md:text-2xl font-bold text-gray-800 mb-4 md:mb-6">市場情緒</h2>
                <div id="sentimentContent">
                    <p class="text-gray-500 text-center py-4">載入中...</p>
                </div>
            </section>

            <!-- ===== 設定區塊 ===== -->
            <section id="section-settings" class="section hidden">
                <h2 class="text-xl md:text-2xl font-bold text-gray-800 mb-4 md:mb-6">設定</h2>
                <div id="settingsContent" class="bg-white rounded-xl shadow p-4 md:p-6">
                    <p class="text-gray-500 text-center py-4">載入中...</p>
                </div>
            </section>
            
        </main>

        <!-- ===== 手機版底部導航列 ===== -->
        <nav class="mobile-bottom-nav">
            <a href="#" onclick="mobileNavTo('dashboard')" class="bottom-nav-item active" data-section="dashboard">
                <i class="fas fa-tachometer-alt"></i>
                <span>首頁</span>
            </a>
            <a href="#" onclick="mobileNavTo('search')" class="bottom-nav-item" data-section="search">
                <i class="fas fa-search"></i>
                <span>查詢</span>
            </a>
            <a href="#" onclick="mobileNavTo('watchlist')" class="bottom-nav-item" data-section="watchlist">
                <i class="fas fa-star"></i>
                <span>追蹤</span>
            </a>
            <a href="#" onclick="mobileNavTo('sentiment')" class="bottom-nav-item" data-section="sentiment">
                <i class="fas fa-heart-pulse"></i>
                <span>情緒</span>
            </a>
            <a href="#" onclick="mobileNavTo('settings')" class="bottom-nav-item" data-section="settings">
                <i class="fas fa-cog"></i>
                <span>設定</span>
            </a>
        </nav>

    </div><!-- end app-content -->

    <!-- ===== 全螢幕圖表 ===== -->
    <div id="chartFullscreen" class="chart-fullscreen">
        <!-- 橫向提示 -->
        <div class="rotate-hint fixed inset-0 bg-white flex flex-col items-center justify-center z-10">
            <div class="text-6xl mb-4">📱🔄</div>
            <p class="text-lg text-gray-700 mb-2">請將手機橫向放置</p>
            <p class="text-gray-500 text-sm">以獲得最佳圖表體驗</p>
            <button onclick="closeChartFullscreen()" class="mt-6 px-6 py-2 border border-gray-300 rounded-lg text-gray-600">
                返回
            </button>
        </div>
        <!-- 橫向圖表 -->
        <div class="chart-container h-full flex flex-col">
            <div class="flex items-center justify-between p-3 border-b bg-white">
                <button onclick="closeChartFullscreen()" class="p-2 text-gray-600 touch-target">
                    <i class="fas fa-times text-xl"></i>
                </button>
                <span id="chartFullscreenTitle" class="font-bold text-lg"></span>
                <div class="w-10"></div>
            </div>
            <div class="flex-1 p-2 bg-gray-50">
                <canvas id="fullscreenChart"></canvas>
            </div>
            <div class="flex items-center justify-center gap-2 p-2 bg-white border-t">
                <button onclick="setChartRange(30)" class="chart-range-btn px-3 py-1 text-sm rounded border">1M</button>
                <button onclick="setChartRange(90)" class="chart-range-btn px-3 py-1 text-sm rounded border bg-blue-50 border-blue-500 text-blue-600">3M</button>
                <button onclick="setChartRange(180)" class="chart-range-btn px-3 py-1 text-sm rounded border">6M</button>
                <button onclick="setChartRange(365)" class="chart-range-btn px-3 py-1 text-sm rounded border">1Y</button>
            </div>
        </div>
    </div>

    <!-- ===== 新增追蹤清單 Modal ===== -->
    <div id="addWatchlistModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white rounded-xl w-full max-w-md p-6">
            <h3 class="text-lg font-bold text-gray-800 mb-4">新增追蹤</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-gray-700 mb-2 text-sm">股票/加密貨幣代號</label>
                    <input type="text" id="addSymbol" placeholder="如 AAPL、BTC" 
                        class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 text-base">
                </div>
                <div>
                    <label class="block text-gray-700 mb-2 text-sm">類型</label>
                    <select id="addAssetType" class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 text-base">
                        <option value="stock">股票</option>
                        <option value="crypto">加密貨幣</option>
                    </select>
                </div>
                <div>
                    <label class="block text-gray-700 mb-2 text-sm">備註（選填）</label>
                    <input type="text" id="addNote" placeholder="自訂備註" 
                        class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 text-base">
                </div>
            </div>
            <div class="flex gap-3 mt-6">
                <button onclick="hideAddWatchlistModal()" class="flex-1 px-4 py-3 border rounded-lg hover:bg-gray-50 touch-target">取消</button>
                <button onclick="addToWatchlist()" class="flex-1 px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 touch-target">新增</button>
            </div>
        </div>
    </div>

    <!-- ===== Toast 通知 ===== -->
    <div id="toast" class="fixed bottom-20 md:bottom-4 left-4 right-4 md:left-auto md:right-4 md:w-auto bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg hidden transition-opacity text-center">
        <span id="toastMessage"></span>
    </div>

    <script>
        const API_BASE = '';
        let token = localStorage.getItem('token');
        let currentUser = null;
        let currentChartData = null;
        let fullscreenChartInstance = null;
        
        // ========== 設備檢測 ==========
        const deviceInfo = {
            isMobile: window.innerWidth < 768,
            isTouch: 'ontouchstart' in window,
            isLineApp: /Line\//i.test(navigator.userAgent),
            isIOS: /iPhone|iPad/i.test(navigator.userAgent),
            isAndroid: /Android/i.test(navigator.userAgent),
        };
        
        console.log('Device info:', deviceInfo);
        
        // ========== 自動登出功能 ==========
        const SESSION_TIMEOUT = 5 * 60 * 1000; // 5 分鐘
        let sessionTimer = null;
        let lastActivity = Date.now();
        
        function resetSessionTimer() {
            lastActivity = Date.now();
        }
        
        function checkSessionTimeout() {
            const elapsed = Date.now() - lastActivity;
            const remaining = SESSION_TIMEOUT - elapsed;
            
            if (remaining <= 0) {
                showToast('閒置超過 5 分鐘，已自動登出');
                setTimeout(() => logout(), 1500);
            } else {
                const mins = Math.floor(remaining / 60000);
                const secs = Math.floor((remaining % 60000) / 1000);
                const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;
                
                const timerEl = document.getElementById('sessionTimer');
                const sidebarTimerEl = document.getElementById('sidebarTimer');
                if (timerEl) timerEl.textContent = `閒置登出: ${timeStr}`;
                if (sidebarTimerEl) sidebarTimerEl.textContent = timeStr;
            }
        }
        
        function startSessionMonitor() {
            ['mousedown', 'mousemove', 'keydown', 'scroll', 'touchstart', 'click'].forEach(event => {
                document.addEventListener(event, resetSessionTimer, { passive: true });
            });
            sessionTimer = setInterval(checkSessionTimeout, 1000);
        }
        
        function stopSessionMonitor() {
            if (sessionTimer) {
                clearInterval(sessionTimer);
                sessionTimer = null;
            }
        }
        
        // ========== 登入驗證 ==========
        async function checkAuth() {
            if (!token) {
                window.location.href = '/static/index.html';
                return;
            }

            try {
                const res = await fetch(`${API_BASE}/auth/me`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (!res.ok) throw new Error('Unauthorized');
                
                currentUser = await res.json();
                
                // 更新用戶資訊
                document.getElementById('userName').textContent = currentUser.display_name;
                document.getElementById('userAvatar').src = currentUser.picture_url || 'https://via.placeholder.com/40';
                document.getElementById('sidebarUserName').textContent = currentUser.display_name;
                document.getElementById('sidebarAvatar').src = currentUser.picture_url || 'https://via.placeholder.com/40';
                
                // 顯示主內容
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('app-content').style.display = 'block';
                
                startSessionMonitor();
                loadDashboard();
            } catch (e) {
                localStorage.removeItem('token');
                window.location.href = '/static/index.html';
            }
        }

        function logout() {
            stopSessionMonitor();
            localStorage.removeItem('token');
            window.location.href = '/static/index.html';
        }

        // ========== 手機版選單 ==========
        function openMobileSidebar() {
            document.getElementById('mobileSidebar').classList.add('open');
            document.getElementById('sidebarOverlay').classList.add('open');
            document.body.style.overflow = 'hidden';
        }
        
        function closeMobileSidebar() {
            document.getElementById('mobileSidebar').classList.remove('open');
            document.getElementById('sidebarOverlay').classList.remove('open');
            document.body.style.overflow = '';
        }
        
        function mobileNavTo(section) {
            closeMobileSidebar();
            showSection(section);
            
            // 更新底部導航和側邊選單高亮
            document.querySelectorAll('.bottom-nav-item, .mobile-nav-link').forEach(el => {
                el.classList.remove('active', 'bg-blue-50', 'text-gray-700');
                if (el.dataset.section === section) {
                    el.classList.add('active');
                    if (el.classList.contains('mobile-nav-link')) {
                        el.classList.add('bg-blue-50', 'text-gray-700');
                    }
                } else if (el.classList.contains('mobile-nav-link')) {
                    el.classList.add('text-gray-600');
                }
            });
        }

        // ========== 切換區塊 ==========
        function showSection(name, evt) {
            document.querySelectorAll('.section').forEach(s => s.classList.add('hidden'));
            const section = document.getElementById(`section-${name}`);
            if (section) {
                section.classList.remove('hidden');
            }
            
            // 更新電腦版導航高亮
            document.querySelectorAll('.nav-link').forEach(l => {
                l.classList.remove('bg-blue-50', 'text-gray-700');
                l.classList.add('text-gray-600');
            });
            
            if (evt && evt.target) {
                const navLink = evt.target.closest('.nav-link');
                if (navLink) {
                    navLink.classList.add('bg-blue-50', 'text-gray-700');
                    navLink.classList.remove('text-gray-600');
                }
            }
            
            // 更新底部導航高亮
            document.querySelectorAll('.bottom-nav-item').forEach(el => {
                el.classList.remove('active');
                if (el.dataset.section === name) {
                    el.classList.add('active');
                }
            });

            // 載入對應資料
            if (name === 'watchlist') loadWatchlist();
            if (name === 'sentiment') loadSentimentDetail();
            if (name === 'settings') loadSettings();
        }

        // ========== 載入儀表板 ==========
        async function loadDashboard() {
            await loadSentiment();
            await loadWatchlistOverview();
        }

        // ========== 載入市場情緒 ==========
        async function loadSentiment() {
            try {
                const res = await fetch(`${API_BASE}/api/market/sentiment`);
                const data = await res.json();
                
                if (data.success) {
                    if (data.stock) {
                        updateSentimentCard('stock', data.stock);
                    } else {
                        updateSentimentCard('stock', { value: 50, classification: 'neutral' });
                    }
                    
                    if (data.crypto) {
                        updateSentimentCard('crypto', data.crypto);
                    } else {
                        updateSentimentCard('crypto', { value: 50, classification: 'neutral' });
                    }
                }
            } catch (e) {
                console.error('載入情緒失敗', e);
                updateSentimentCard('stock', { value: 50, classification: 'neutral' });
                updateSentimentCard('crypto', { value: 50, classification: 'neutral' });
            }
        }

        function updateSentimentCard(type, sentiment) {
            if (!sentiment) return;
            
            const value = sentiment.value;
            
            document.getElementById(`${type}SentimentValue`).textContent = value;
            document.getElementById(`${type}SentimentBar`).style.width = `${value}%`;
            
            const badge = document.getElementById(`${type}SentimentBadge`);
            const bar = document.getElementById(`${type}SentimentBar`);
            
            let badgeClass, barClass, label;
            if (value <= 25) {
                badgeClass = 'bg-red-100 text-red-700';
                barClass = 'bg-red-500';
                label = '極度恐懼';
            } else if (value <= 45) {
                badgeClass = 'bg-orange-100 text-orange-700';
                barClass = 'bg-orange-500';
                label = '恐懼';
            } else if (value <= 55) {
                badgeClass = 'bg-gray-100 text-gray-700';
                barClass = 'bg-gray-500';
                label = '中性';
            } else if (value <= 75) {
                badgeClass = 'bg-green-100 text-green-700';
                barClass = 'bg-green-500';
                label = '貪婪';
            } else {
                badgeClass = 'bg-emerald-100 text-emerald-700';
                barClass = 'bg-emerald-500';
                label = '極度貪婪';
            }
            
            badge.className = `px-2 md:px-3 py-1 rounded-full text-xs md:text-sm font-medium ${badgeClass}`;
            badge.textContent = label;
            bar.className = `h-2 md:h-3 rounded-full transition-all ${barClass}`;
        }

        // ========== 追蹤清單快覽 ==========
        async function loadWatchlistOverview() {
            const container = document.getElementById('dashboardWatchlist');
            
            try {
                const res = await fetch(`${API_BASE}/api/watchlist`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await res.json();
                
                if (!data.success || !data.data || data.data.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-6">
                            <i class="fas fa-star text-gray-300 text-3xl mb-2"></i>
                            <p class="text-gray-500 text-sm">尚無追蹤清單</p>
                            <button onclick="showSection('search')" class="mt-2 text-blue-600 text-sm">前往查詢股票</button>
                        </div>
                    `;
                    return;
                }
                
                // 只顯示前 5 筆
                const items = data.data.slice(0, 5);
                let html = '<div class="space-y-2">';
                
                for (const item of items) {
                    html += `
                        <div class="flex items-center justify-between py-2 border-b last:border-0 cursor-pointer hover:bg-gray-50 -mx-2 px-2 rounded" onclick="searchSymbol('${item.symbol}')">
                            <div class="flex items-center">
                                <span class="font-medium text-gray-800">${item.symbol}</span>
                                <span class="ml-2 text-xs px-2 py-0.5 rounded ${item.asset_type === 'crypto' ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700'}">
                                    ${item.asset_type === 'crypto' ? '幣' : '股'}
                                </span>
                            </div>
                            <i class="fas fa-chevron-right text-gray-400 text-sm"></i>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (e) {
                console.error('載入追蹤清單失敗', e);
                container.innerHTML = '<p class="text-red-500 text-center py-4">載入失敗</p>';
            }
        }

        // ========== 股票查詢 ==========
        function searchStock() {
            const symbol = document.getElementById('searchSymbol').value.trim().toUpperCase();
            if (!symbol) {
                showToast('請輸入股票代號');
                return;
            }
            searchSymbol(symbol);
        }

        async function searchSymbol(symbol) {
            const container = document.getElementById('searchResult');
            container.classList.remove('hidden');
            container.innerHTML = '<div class="bg-white rounded-xl shadow p-6 text-center"><i class="fas fa-spinner fa-spin text-2xl text-blue-600"></i><p class="mt-2 text-gray-500 text-sm">查詢中...（首次查詢可能需要 10-30 秒）</p></div>';
            
            showSection('search');
            document.getElementById('searchSymbol').value = symbol;

            try {
                const isCrypto = ['BTC', 'ETH'].includes(symbol);
                const endpoint = isCrypto ? `/api/crypto/${symbol}` : `/api/stock/${symbol}`;
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);
                
                const res = await fetch(`${API_BASE}${endpoint}`, { signal: controller.signal });
                clearTimeout(timeoutId);
                
                const data = await res.json();
                
                if (!res.ok) {
                    container.innerHTML = `<div class="bg-white rounded-xl shadow p-6 text-center text-red-500">HTTP ${res.status}: ${data.detail || '查詢失敗'}</div>`;
                    return;
                }
                
                if (!data.success) {
                    container.innerHTML = `<div class="bg-white rounded-xl shadow p-6 text-center text-red-500">${data.detail || '查詢失敗'}</div>`;
                    return;
                }

                currentChartData = data.chart_data;
                renderStockResult(data, isCrypto);
                
            } catch (e) {
                console.error('Search error:', e);
                if (e.name === 'AbortError') {
                    container.innerHTML = '<div class="bg-white rounded-xl shadow p-6 text-center text-red-500">查詢超時，請稍後再試</div>';
                } else {
                    container.innerHTML = `<div class="bg-white rounded-xl shadow p-6 text-center text-red-500">查詢失敗: ${e.message}</div>`;
                }
            }
        }

        function renderStockResult(stock, isCrypto) {
            const container = document.getElementById('searchResult');
            const indicators = stock.indicators || {};
            const ma = indicators.ma || {};
            const rsi = indicators.rsi || {};
            const macd = indicators.macd || {};
            
            const priceChange = stock.change?.day || 0;
            const priceChangeClass = priceChange >= 0 ? 'text-green-600' : 'text-red-600';
            const priceChangeIcon = priceChange >= 0 ? '📈' : '📉';
            
            const alignmentClass = ma.alignment === 'bullish' ? 'text-green-600' : ma.alignment === 'bearish' ? 'text-red-600' : 'text-gray-600';
            const alignmentText = ma.alignment === 'bullish' ? '多頭 🟢' : ma.alignment === 'bearish' ? '空頭 🔴' : '中性';
            
            const rsiStatus = rsi.status === 'overbought' ? '超買 ⚠️' : rsi.status === 'oversold' ? '超賣 🟢' : '中性';
            const macdStatus = macd.status === 'bullish' ? '偏多 🟢' : '偏空 🔴';
            
            const html = `
                <div class="bg-white rounded-xl shadow overflow-hidden">
                    <!-- 價格區塊 -->
                    <div class="p-4 md:p-6 border-b">
                        <div class="flex items-start justify-between mb-2">
                            <div>
                                <h3 class="text-xl md:text-2xl font-bold text-gray-800">${stock.symbol}</h3>
                                <p class="text-gray-500 text-sm">${stock.name || (isCrypto ? '加密貨幣' : '股票')}</p>
                            </div>
                            <span class="px-2 py-1 rounded text-xs ${isCrypto ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700'}">
                                ${isCrypto ? '加密貨幣' : '美股'}
                            </span>
                        </div>
                        <div class="mt-3">
                            <span class="text-3xl md:text-4xl font-bold text-gray-800">$${stock.price?.current?.toLocaleString() || '--'}</span>
                            <span class="ml-2 ${priceChangeClass} text-lg">
                                ${priceChange >= 0 ? '+' : ''}${priceChange?.toFixed(2)}% ${priceChangeIcon}
                            </span>
                        </div>
                    </div>
                    
                    <!-- 快速總覽 -->
                    <div class="p-4 md:p-6 border-b bg-gray-50">
                        <h4 class="font-semibold text-gray-700 mb-3 text-sm">📊 快速總覽</h4>
                        <div class="grid grid-cols-2 gap-3 text-sm">
                            <div class="flex justify-between">
                                <span class="text-gray-500">均線排列</span>
                                <span class="${alignmentClass} font-medium">${alignmentText}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-500">RSI</span>
                                <span class="font-medium">${rsi.value?.toFixed(0) || '--'} ${rsiStatus}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-500">MACD</span>
                                <span class="font-medium">${macdStatus}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-500">評分</span>
                                <span class="font-medium">${stock.score?.rating === 'bullish' ? '偏多' : stock.score?.rating === 'bearish' ? '偏空' : '中性'} (${stock.score?.buy || 0}/${stock.score?.sell || 0})</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 詳細指標 (可摺疊) -->
                    <div class="border-b">
                        <button onclick="toggleCollapsible(this)" class="w-full p-4 flex items-center justify-between text-left hover:bg-gray-50 touch-target">
                            <span class="font-medium text-gray-700">▼ 展開詳細指標</span>
                            <i class="fas fa-chevron-down text-gray-400 transition-transform"></i>
                        </button>
                        <div class="collapsible-content">
                            <div class="px-4 pb-4 space-y-3">
                                <!-- MA 詳細 -->
                                <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
                                    <div class="p-3 rounded-lg ${ma.price_vs_ma20 === 'above' ? 'bg-green-50' : 'bg-red-50'}">
                                        <p class="text-gray-500 text-xs">MA20</p>
                                        <p class="font-semibold">${ma.ma20?.toFixed(2) || '--'}</p>
                                        <p class="text-xs ${ma.price_vs_ma20 === 'above' ? 'text-green-600' : 'text-red-600'}">
                                            ${ma.price_vs_ma20 === 'above' ? '價格在上 ✓' : '價格在下'}
                                        </p>
                                    </div>
                                    <div class="p-3 rounded-lg ${ma.price_vs_ma50 === 'above' ? 'bg-green-50' : 'bg-red-50'}">
                                        <p class="text-gray-500 text-xs">MA50</p>
                                        <p class="font-semibold">${ma.ma50?.toFixed(2) || '--'}</p>
                                        <p class="text-xs ${ma.price_vs_ma50 === 'above' ? 'text-green-600' : 'text-red-600'}">
                                            ${ma.price_vs_ma50 === 'above' ? '價格在上 ✓' : '價格在下'}
                                        </p>
                                    </div>
                                    <div class="p-3 rounded-lg ${ma.price_vs_ma200 === 'above' ? 'bg-green-50' : 'bg-red-50'}">
                                        <p class="text-gray-500 text-xs">MA200</p>
                                        <p class="font-semibold">${ma.ma200?.toFixed(2) || '--'}</p>
                                        <p class="text-xs ${ma.price_vs_ma200 === 'above' ? 'text-green-600' : 'text-red-600'}">
                                            ${ma.price_vs_ma200 === 'above' ? '價格在上 ✓' : '價格在下'}
                                        </p>
                                    </div>
                                </div>
                                
                                <!-- RSI & MACD 詳細 -->
                                <div class="grid grid-cols-2 gap-2 text-sm">
                                    <div class="p-3 bg-gray-50 rounded-lg">
                                        <p class="text-gray-500 text-xs">RSI (${rsi.period || 14})</p>
                                        <p class="font-semibold">${rsi.value?.toFixed(2) || '--'}</p>
                                    </div>
                                    <div class="p-3 bg-gray-50 rounded-lg">
                                        <p class="text-gray-500 text-xs">MACD DIF</p>
                                        <p class="font-semibold">${macd.dif?.toFixed(2) || '--'}</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 操作按鈕 -->
                    <div class="p-4 space-y-3">
                        ${stock.chart_data ? `
                        <button onclick="openChartFullscreen('${stock.symbol}', ${stock.price?.current || 0})" 
                            class="w-full py-3 bg-blue-600 text-white rounded-lg font-medium flex items-center justify-center touch-target hover:bg-blue-700">
                            <i class="fas fa-chart-line mr-2"></i>
                            查看完整圖表
                        </button>
                        ` : ''}
                        <button onclick="quickAddToWatchlist('${stock.symbol}', '${isCrypto ? 'crypto' : 'stock'}')" 
                            class="w-full py-3 border-2 border-orange-500 text-orange-600 rounded-lg font-medium flex items-center justify-center touch-target hover:bg-orange-50">
                            <i class="fas fa-star mr-2"></i>
                            加入追蹤清單
                        </button>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        function toggleCollapsible(btn) {
            const content = btn.nextElementSibling;
            const icon = btn.querySelector('i');
            content.classList.toggle('open');
            icon.style.transform = content.classList.contains('open') ? 'rotate(180deg)' : '';
            btn.querySelector('span').textContent = content.classList.contains('open') ? '▲ 收合詳細指標' : '▼ 展開詳細指標';
        }

        // ========== 全螢幕圖表 ==========
        function openChartFullscreen(symbol, price) {
            if (!currentChartData) {
                showToast('沒有圖表資料');
                return;
            }
            
            document.getElementById('chartFullscreenTitle').textContent = `${symbol}  $${price.toLocaleString()}`;
            document.getElementById('chartFullscreen').classList.add('open');
            document.body.style.overflow = 'hidden';
            
            // 延遲渲染圖表
            setTimeout(() => {
                renderFullscreenChart(currentChartData, 90);
            }, 100);
        }
        
        function closeChartFullscreen() {
            document.getElementById('chartFullscreen').classList.remove('open');
            document.body.style.overflow = '';
            
            if (fullscreenChartInstance) {
                fullscreenChartInstance.destroy();
                fullscreenChartInstance = null;
            }
        }
        
        function setChartRange(days) {
            // 更新按鈕樣式
            document.querySelectorAll('.chart-range-btn').forEach(btn => {
                btn.classList.remove('bg-blue-50', 'border-blue-500', 'text-blue-600');
            });
            event.target.classList.add('bg-blue-50', 'border-blue-500', 'text-blue-600');
            
            renderFullscreenChart(currentChartData, days);
        }
        
        function renderFullscreenChart(chartData, days) {
            const canvas = document.getElementById('fullscreenChart');
            if (!canvas) return;
            
            if (fullscreenChartInstance) {
                fullscreenChartInstance.destroy();
            }
            
            const ctx = canvas.getContext('2d');
            const dataLength = chartData.dates.length;
            const startIdx = Math.max(0, dataLength - days);
            
            const labels = chartData.dates.slice(startIdx).map((d, i) => {
                if (i % Math.ceil(days / 6) === 0) return d.slice(5);
                return '';
            });
            
            fullscreenChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: '收盤價',
                            data: chartData.prices.slice(startIdx),
                            borderColor: '#3B82F6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1,
                            pointRadius: 0,
                        },
                        {
                            label: 'MA20',
                            data: chartData.ma20.slice(startIdx),
                            borderColor: '#10B981',
                            borderWidth: 1.5,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                        },
                        {
                            label: 'MA50',
                            data: chartData.ma50.slice(startIdx),
                            borderColor: '#F59E0B',
                            borderWidth: 1.5,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                        },
                        {
                            label: 'MA200',
                            data: chartData.ma200.slice(startIdx),
                            borderColor: '#EF4444',
                            borderWidth: 1.5,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                        },
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index',
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: { usePointStyle: true, padding: 10 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.raw === null) return null;
                                    return `${context.dataset.label}: $${context.raw.toFixed(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false } },
                        y: { grid: { color: 'rgba(0,0,0,0.05)' } }
                    }
                }
            });
        }

        // ========== 追蹤清單 (卡片式) ==========
        async function loadWatchlist() {
            const container = document.getElementById('watchlistContent');
            
            try {
                const res = await fetch(`${API_BASE}/api/watchlist`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await res.json();
                
                if (!data.success || !data.data || data.data.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-12">
                            <i class="fas fa-star text-gray-300 text-4xl mb-3"></i>
                            <p class="text-gray-500 mb-4">尚無追蹤的股票</p>
                            <button onclick="showAddWatchlistModal()" class="px-6 py-2 bg-blue-600 text-white rounded-lg">
                                <i class="fas fa-plus mr-2"></i>新增追蹤
                            </button>
                        </div>
                    `;
                    return;
                }
                
                let html = '<div class="space-y-3">';
                
                for (const item of data.data) {
                    const typeClass = item.asset_type === 'crypto' ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700';
                    const typeText = item.asset_type === 'crypto' ? '幣' : '股';
                    
                    html += `
                        <div class="stock-card bg-white rounded-xl shadow-sm p-4">
                            <div class="flex items-start justify-between mb-2">
                                <div class="flex items-center">
                                    <span class="font-bold text-lg text-gray-800">${item.symbol}</span>
                                    <span class="ml-2 px-2 py-0.5 rounded text-xs ${typeClass}">${typeText}</span>
                                </div>
                                <button onclick="removeFromWatchlist(${item.id})" class="p-2 text-gray-400 hover:text-red-500 touch-target">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                            ${item.note ? `<p class="text-gray-500 text-sm mb-2">${item.note}</p>` : ''}
                            <div class="flex items-center justify-between mt-3">
                                <span class="text-gray-400 text-xs">加入於 ${new Date(item.added_at).toLocaleDateString()}</span>
                                <button onclick="searchSymbol('${item.symbol}')" class="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg text-sm hover:bg-gray-200 touch-target">
                                    查看詳情
                                </button>
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (e) {
                console.error('載入追蹤清單失敗', e);
                container.innerHTML = '<p class="text-red-500 text-center py-4">載入失敗</p>';
            }
        }
        
        function showAddWatchlistModal() {
            document.getElementById('addWatchlistModal').classList.remove('hidden');
            document.getElementById('addWatchlistModal').classList.add('flex');
        }
        
        function hideAddWatchlistModal() {
            document.getElementById('addWatchlistModal').classList.add('hidden');
            document.getElementById('addWatchlistModal').classList.remove('flex');
            document.getElementById('addSymbol').value = '';
            document.getElementById('addNote').value = '';
        }
        
        async function addToWatchlist() {
            const symbol = document.getElementById('addSymbol').value.trim().toUpperCase();
            const assetType = document.getElementById('addAssetType').value;
            const note = document.getElementById('addNote').value.trim();
            
            if (!symbol) {
                showToast('請輸入股票代號');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/api/watchlist`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol, asset_type: assetType, note })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast('已加入追蹤清單');
                    hideAddWatchlistModal();
                    loadWatchlist();
                    loadWatchlistOverview();
                } else {
                    showToast(data.detail || '新增失敗');
                }
            } catch (e) {
                showToast('新增失敗');
            }
        }
        
        async function quickAddToWatchlist(symbol, assetType) {
            try {
                const res = await fetch(`${API_BASE}/api/watchlist`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol, asset_type: assetType, note: '' })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast(`${symbol} 已加入追蹤清單`);
                    loadWatchlistOverview();
                } else {
                    showToast(data.detail || '新增失敗');
                }
            } catch (e) {
                showToast('新增失敗');
            }
        }
        
        async function removeFromWatchlist(id) {
            if (!confirm('確定要移除此追蹤？')) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/watchlist/${id}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast('已移除');
                    loadWatchlist();
                    loadWatchlistOverview();
                } else {
                    showToast('移除失敗');
                }
            } catch (e) {
                showToast('移除失敗');
            }
        }

        // ========== 設定 ==========
        async function loadSettings() {
            const container = document.getElementById('settingsContent');
            container.innerHTML = `
                <div class="space-y-6">
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-3">帳號資訊</h3>
                        <div class="flex items-center p-4 bg-gray-50 rounded-lg">
                            <img id="settingsAvatar" class="w-12 h-12 rounded-full mr-4" src="${currentUser?.picture_url || ''}" alt="">
                            <div>
                                <p class="font-medium text-gray-800">${currentUser?.display_name || ''}</p>
                                <p class="text-gray-500 text-sm">LINE 登入</p>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-3">關於</h3>
                        <div class="p-4 bg-gray-50 rounded-lg text-sm text-gray-600">
                            <p>SELA 自動選股系統 v0.3.2</p>
                            <p class="mt-1">技術指標分析 · 智能預警通知</p>
                        </div>
                    </div>
                    
                    <button onclick="logout()" class="w-full py-3 border border-red-500 text-red-500 rounded-lg font-medium hover:bg-red-50 touch-target">
                        <i class="fas fa-sign-out-alt mr-2"></i>登出
                    </button>
                </div>
            `;
        }
        
        async function loadSentimentDetail() {
            const container = document.getElementById('sentimentContent');
            container.innerHTML = `
                <div class="space-y-4">
                    <div class="bg-white rounded-xl shadow p-6">
                        <h3 class="font-semibold text-gray-700 mb-4">市場情緒解讀</h3>
                        <div class="space-y-4 text-sm text-gray-600">
                            <div class="flex items-start">
                                <span class="w-24 flex-shrink-0 font-medium">0-25</span>
                                <span class="px-2 py-1 bg-red-100 text-red-700 rounded mr-2">極度恐懼</span>
                                <span>市場恐慌，可能是買入機會</span>
                            </div>
                            <div class="flex items-start">
                                <span class="w-24 flex-shrink-0 font-medium">26-45</span>
                                <span class="px-2 py-1 bg-orange-100 text-orange-700 rounded mr-2">恐懼</span>
                                <span>市場偏謹慎</span>
                            </div>
                            <div class="flex items-start">
                                <span class="w-24 flex-shrink-0 font-medium">46-55</span>
                                <span class="px-2 py-1 bg-gray-100 text-gray-700 rounded mr-2">中性</span>
                                <span>觀望為主</span>
                            </div>
                            <div class="flex items-start">
                                <span class="w-24 flex-shrink-0 font-medium">56-75</span>
                                <span class="px-2 py-1 bg-green-100 text-green-700 rounded mr-2">貪婪</span>
                                <span>市場偏樂觀</span>
                            </div>
                            <div class="flex items-start">
                                <span class="w-24 flex-shrink-0 font-medium">76-100</span>
                                <span class="px-2 py-1 bg-emerald-100 text-emerald-700 rounded mr-2">極度貪婪</span>
                                <span>市場過熱，留意風險</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // ========== Toast ==========
        function showToast(message) {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.classList.remove('hidden');
            setTimeout(() => {
                toast.classList.add('hidden');
            }, 3000);
        }

        // ========== 初始化 ==========
        document.addEventListener('DOMContentLoaded', checkAuth);
        
        // 監聽視窗大小變化
        window.addEventListener('resize', () => {
            deviceInfo.isMobile = window.innerWidth < 768;
        });
    </script>
</body>
</html>
```

──────────────────────────────────────────────────────────────────────
### 📄 static/dashboard.html  ⭐
──────────────────────────────────────────────────────────────────────

⚠️ 檔案過大，略過內容（171.4 KB）

──────────────────────────────────────────────────────────────────────
### 📄 static/index.html  ⭐
──────────────────────────────────────────────────────────────────────

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SELA 自動選股系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .brand-orange { background-color: #FA7A35; }
        .brand-orange:hover { background-color: #e86a25; }
        .brand-text { color: #FA7A35; }
        .line-btn { background-color: #06C755; }
        .line-btn:hover { background-color: #05b34c; }
        .touch-target { min-height: 48px; }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 min-h-screen flex items-center justify-center p-4">
    <div class="bg-white rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-md">
        <!-- Logo -->
        <div class="text-center mb-6 md:mb-8">
            <img src="/static/logo.png" alt="SELA Logo" class="w-20 h-20 md:w-24 md:h-24 mx-auto mb-3 md:mb-4 rounded-xl">
            <h1 class="text-xl md:text-2xl font-bold text-gray-800">SELA 自動選股系統</h1>
            <p class="text-gray-500 mt-2 text-sm md:text-base">技術指標分析 · 智能預警通知</p>
        </div>

        <!-- 功能介紹 -->
        <div class="space-y-2 md:space-y-3 mb-6 md:mb-8">
            <div class="flex items-center text-gray-600 text-sm md:text-base">
                <i class="fas fa-check-circle brand-text mr-3 flex-shrink-0"></i>
                <span>美股即時報價與技術分析</span>
            </div>
            <div class="flex items-center text-gray-600 text-sm md:text-base">
                <i class="fas fa-check-circle brand-text mr-3 flex-shrink-0"></i>
                <span>比特幣、以太幣價格追蹤</span>
            </div>
            <div class="flex items-center text-gray-600 text-sm md:text-base">
                <i class="fas fa-check-circle brand-text mr-3 flex-shrink-0"></i>
                <span>個人化追蹤清單</span>
            </div>
            <div class="flex items-center text-gray-600 text-sm md:text-base">
                <i class="fas fa-check-circle brand-text mr-3 flex-shrink-0"></i>
                <span>LINE 推播智能預警</span>
            </div>
        </div>

        <!-- LINE 登入按鈕 -->
        <a href="/auth/line" class="line-btn w-full py-3 md:py-4 px-4 rounded-lg text-white font-semibold flex items-center justify-center space-x-2 transition-colors touch-target">
            <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor">
                <path d="M19.365 9.863c.349 0 .63.285.63.631 0 .345-.281.63-.63.63H17.61v1.125h1.755c.349 0 .63.283.63.63 0 .344-.281.629-.63.629h-2.386c-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63h2.386c.346 0 .627.285.627.63 0 .349-.281.63-.63.63H17.61v1.125h1.755zm-3.855 3.016c0 .27-.174.51-.432.596-.064.021-.133.031-.199.031-.211 0-.391-.09-.51-.25l-2.443-3.317v2.94c0 .344-.279.629-.631.629-.346 0-.626-.285-.626-.629V8.108c0-.27.173-.51.43-.595.06-.023.136-.033.194-.033.195 0 .375.104.495.254l2.462 3.33V8.108c0-.345.282-.63.63-.63.345 0 .63.285.63.63v4.771zm-5.741 0c0 .344-.282.629-.631.629-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63.346 0 .628.285.628.63v4.771zm-2.466.629H4.917c-.345 0-.63-.285-.63-.629V8.108c0-.345.285-.63.63-.63.348 0 .63.285.63.63v4.141h1.756c.348 0 .629.283.629.63 0 .344-.282.629-.629.629M24 10.314C24 4.943 18.615.572 12 .572S0 4.943 0 10.314c0 4.811 4.27 8.842 10.035 9.608.391.082.923.258 1.058.59.12.301.079.766.038 1.08l-.164 1.02c-.045.301-.24 1.186 1.049.645 1.291-.539 6.916-4.078 9.436-6.975C23.176 14.393 24 12.458 24 10.314"/>
            </svg>
            <span>使用 LINE 帳號登入</span>
        </a>

        <!-- 版權 -->
        <p class="text-center text-gray-400 text-xs md:text-sm mt-6 md:mt-8">
            © 2025 SELA · 自動選股系統 v0.3.2
        </p>
    </div>

    <script>
        // 檢查是否已登入
        const token = localStorage.getItem('token');
        if (token) {
            window.location.href = '/static/dashboard.html';
        }
    </script>
</body>
</html>
```

──────────────────────────────────────────────────────────────────────
### 📄 static/SELA-Bug修復記錄.md  ⭐
> SELA 選股系統 - Bug 修復記錄
──────────────────────────────────────────────────────────────────────

```md
# SELA 選股系統 - Bug 修復記錄

> 版本：v0.3.0  
> 更新日期：2026-01-05

---

## 目錄

1. [前端 Bug](#前端-bug)
2. [後端 Bug](#後端-bug)
3. [Async/Await 問題](#asyncawait-問題)
4. [部署注意事項](#部署注意事項)

---

## 前端 Bug

### Bug 1：showSection 函數 event 未定義

**錯誤訊息**：
```
Uncaught TypeError: Cannot read properties of null (reading 'classList')
    at showSection (dashboard.html:277:46)
    at searchSymbol (dashboard.html:411:13)
```

**原因**：
- `showSection` 函數使用了全域 `event` 對象
- 從導航列點擊時有 `event`，但從 `searchSymbol` 等函數調用時沒有

**錯誤代碼**：
```javascript
function showSection(name) {
    // ...
    event.target.closest('.nav-link').classList.add('bg-blue-50');  // ❌ event 未定義
}
```

**修復代碼**：
```javascript
function showSection(name, evt) {
    document.querySelectorAll('.section').forEach(s => s.classList.add('hidden'));
    const section = document.getElementById(`section-${name}`);
    if (section) {
        section.classList.remove('hidden');
    }
    
    document.querySelectorAll('.nav-link').forEach(l => {
        l.classList.remove('bg-blue-50', 'text-gray-700');
        l.classList.add('text-gray-600');
    });
    
    // ✅ 只有點擊導航時才更新高亮
    if (evt && evt.target) {
        const navLink = evt.target.closest('.nav-link');
        if (navLink) {
            navLink.classList.add('bg-blue-50', 'text-gray-700');
            navLink.classList.remove('text-gray-600');
        }
    }
    // ...
}
```

**HTML 調用也要修改**：
```html
<!-- ❌ 錯誤 -->
<a onclick="showSection('dashboard')">

<!-- ✅ 正確 -->
<a onclick="showSection('dashboard', event)">
```

---

### Bug 2：API 資料格式不符

**錯誤訊息**：
```
TypeError: Cannot read properties of undefined (reading 'stock')
    at loadSentiment (dashboard.html:299:60)
```

**原因**：
- 前端期望 `data.data.stock` 格式
- 後端 API 實際返回 `data.stock` 格式

**錯誤代碼**：
```javascript
// ❌ 前端期望
updateSentimentCard('stock', data.data.stock);
updateSentimentCard('crypto', data.data.crypto);
```

**修復代碼**：
```javascript
// ✅ 符合 API 實際返回格式
updateSentimentCard('stock', data.stock);
updateSentimentCard('crypto', data.crypto);
```

**API 實際返回格式**：
```json
{
  "success": true,
  "stock": { "value": 45, "classification": "neutral" },
  "crypto": { "value": 32, "classification": "fear" }
}
```

---

### Bug 3：搜尋結果資料格式

**原因**：
- 前端期望 `data.data` 包含股票資料
- 後端直接返回資料在頂層

**錯誤代碼**：
```javascript
// ❌ 錯誤
renderStockResult(data.data, isCrypto);
```

**修復代碼**：
```javascript
// ✅ 正確 - 資料直接在頂層
renderStockResult(data, isCrypto);
```

---

## 後端 Bug

### Bug 4：技術指標欄位名大小寫不一致

**原因**：
- `indicator_service.py` 產生小寫欄位名：`ma20`, `rsi`, `macd_dif`
- `stock.py` / `crypto.py` 讀取大寫欄位名：`MA20`, `RSI`, `MACD_DIF`

**錯誤代碼**：
```python
# ❌ routers/stock.py 使用大寫
ma20 = float(latest.get('MA20', 0)) if 'MA20' in latest else None
rsi_value = float(latest.get('RSI', 50)) if 'RSI' in latest else 50
macd_dif = float(latest.get('MACD_DIF', 0)) if 'MACD_DIF' in latest else 0
```

**修復代碼**：
```python
# ✅ 使用小寫，符合 indicator_service 產生的欄位名
ma20 = float(latest.get('ma20', 0)) if 'ma20' in latest else None
ma50 = float(latest.get('ma50', 0)) if 'ma50' in latest else None
ma200 = float(latest.get('ma200', 0)) if 'ma200' in latest else None
rsi_value = float(latest.get('rsi', 50)) if 'rsi' in latest else 50
macd_dif = float(latest.get('macd_dif', 0)) if 'macd_dif' in latest else 0
macd_dea = float(latest.get('macd_dea', 0)) if 'macd_dea' in latest else 0
macd_hist = float(latest.get('macd_hist', 0)) if 'macd_hist' in latest else 0
```

**indicator_service.py 產生的欄位名參考**：
```python
df[f"ma{self.ma_short}"]  # ma20
df[f"ma{self.ma_mid}"]    # ma50
df[f"ma{self.ma_long}"]   # ma200
df["rsi"]                  # rsi
df["macd_dif"]            # macd_dif
df["macd_dea"]            # macd_dea
df["macd_hist"]           # macd_hist
df["kd_k"]                # kd_k
df["kd_d"]                # kd_d
```

---

### Bug 5：方法名稱錯誤

**原因**：調用不存在的方法名

**錯誤代碼**：
```python
# ❌ routers/stock.py
df = yahoo_finance.get_stock_data(symbol, period="1y")  # 方法不存在

# ❌ routers/crypto.py
df = coingecko.get_historical_data(symbol, days=365)  # 方法不存在
```

**修復代碼**：
```python
# ✅ routers/stock.py - 使用正確的方法名
df = yahoo_finance.get_stock_history(symbol, period="1y")

# ✅ routers/crypto.py - 使用正確的方法名
df = coingecko.get_ohlc(symbol, days=365)
```

**data_sources 可用方法參考**：

| 檔案 | 可用方法 |
|------|----------|
| yahoo_finance.py | `get_stock_info()`, `get_stock_history()`, `get_current_price()` |
| coingecko.py | `get_coin_info()`, `get_market_chart()`, `get_ohlc()`, `get_current_price()`, `validate_symbol()` |

---

## Async/Await 問題

### Bug 6：Settings API 缺少 await

**錯誤訊息**：
```
'coroutine' object has no attribute 'scalar_one_or_none'
```

**原因**：
- 使用 `AsyncSession` 但沒有 `await` 資料庫操作

**錯誤代碼**：
```python
# ❌ 缺少 await
settings = db.execute(stmt).scalar_one_or_none()
db.commit()
db.refresh(settings)
```

**修復代碼**：
```python
# ✅ 加上 await
result = await db.execute(stmt)
settings = result.scalar_one_or_none()
await db.commit()
await db.refresh(settings)
```

---

## 部署注意事項

### 1. 瀏覽器快取問題

修改前端檔案後，用戶可能看到舊版本。

**解決方法**：
- 按 `Ctrl + Shift + R` 強制重新整理
- 開啟無痕視窗測試
- 在檔案名加上版本號：`dashboard.html?v=1.0.1`

### 2. Railway 部署檢查

部署後檢查 log 確認：
- 容器啟動成功
- API 端點返回 200 OK
- 沒有 500 錯誤

### 3. API 測試方法

直接在瀏覽器測試 API：
```
https://your-domain.railway.app/api/stock/AAPL
https://your-domain.railway.app/api/crypto/BTC
https://your-domain.railway.app/api/market/sentiment
```

### 4. 前端 Console 調試

按 `F12` 開啟開發者工具，查看：
- Console 錯誤訊息
- Network 請求狀態
- API 回應內容

---

## 修復檔案清單

| 檔案 | 修復內容 |
|------|----------|
| `static/dashboard.html` | showSection 參數、API 資料格式 |
| `app/routers/stock.py` | 方法名、欄位名大小寫 |
| `app/routers/crypto.py` | 方法名、欄位名大小寫 |
| `app/routers/settings.py` | async/await 完整版 |

---

## 快速檢查清單

- [ ] `indicator_service` 欄位名是小寫
- [ ] `routers` 讀取欄位名也用小寫
- [ ] API 方法名與 data_sources 一致
- [ ] 前端資料格式與 API 返回一致
- [ ] `showSection` 等函數的 event 參數可選
- [ ] AsyncSession 的操作都有 await

---

> 文件維護：每次修復 bug 後更新此文件
```

======================================================================
## 📁 其他檔案
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/__init__.py  ⭐
> Stock Analysis System
──────────────────────────────────────────────────────────────────────

```py
"""
Stock Analysis System
多用戶股票與加密貨幣技術分析平台
"""
__version__ = "0.1.0"
```

──────────────────────────────────────────────────────────────────────
### 📄 app/cli.py  ⭐
> 股票分析系統 CLI
──────────────────────────────────────────────────────────────────────

```py
#!/usr/bin/env python3
"""
股票分析系統 CLI
命令列查詢介面
"""
import sys
import argparse
from datetime import datetime
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
from rich import box

from app.database import init_db_sync, get_sync_session
from app.services.stock_service import StockService
from app.services.crypto_service import CryptoService
from app.services.chart_service import chart_service
from app.data_sources.coingecko import CRYPTO_MAP
from app.config import settings

console = Console()

# 支援的加密貨幣代號
SUPPORTED_CRYPTO = set(k for k in CRYPTO_MAP.keys() if k not in ("BITCOIN", "ETHEREUM"))


def print_header():
    """顯示標題"""
    console.print()
    console.print(Panel.fit(
        "[bold orange1]📈 股票技術分析系統[/bold orange1]\n"
        f"[dim]版本 {settings.APP_VERSION}[/dim]",
        border_style="orange1",
    ))
    console.print()


def is_crypto(symbol: str) -> bool:
    """判斷是否為加密貨幣"""
    return symbol.upper() in SUPPORTED_CRYPTO


def print_stock_analysis(analysis: dict):
    """顯示股票分析報告"""
    symbol = analysis["symbol"]
    name = analysis["name"]
    price_info = analysis["price"]
    change_info = analysis["change"]
    volume_info = analysis.get("volume", {})
    indicators = analysis["indicators"]
    signals = analysis["signals"]
    score = analysis["score"]
    
    # 標題
    console.print(Panel(
        f"[bold]{symbol}[/bold] - {name}",
        border_style="blue",
    ))
    
    # 價格資訊
    price_table = Table(title="💰 價格資訊", box=box.ROUNDED, show_header=False)
    price_table.add_column("項目", style="cyan")
    price_table.add_column("數值", justify="right")
    
    current_price = price_info["current"]
    price_table.add_row("現價", f"[bold green]${current_price:,.2f}[/bold green]")
    
    if price_info.get("high_52w"):
        price_table.add_row("52週最高", f"${price_info['high_52w']:,.2f}")
    if price_info.get("low_52w"):
        price_table.add_row("52週最低", f"${price_info['low_52w']:,.2f}")
    if price_info.get("from_high_pct"):
        pct = price_info["from_high_pct"]
        color = "red" if pct < 0 else "green"
        price_table.add_row("距高點", f"[{color}]{pct:+.2f}%[/{color}]")
    if price_info.get("from_low_pct"):
        pct = price_info["from_low_pct"]
        color = "green" if pct > 0 else "red"
        price_table.add_row("距低點", f"[{color}]{pct:+.2f}%[/{color}]")
    
    console.print(price_table)
    console.print()
    
    # 漲跌幅
    change_table = Table(title="📊 漲跌幅", box=box.ROUNDED)
    change_table.add_column("日", justify="center")
    change_table.add_column("週", justify="center")
    change_table.add_column("月", justify="center")
    change_table.add_column("季", justify="center")
    change_table.add_column("年", justify="center")
    
    def format_change(val):
        if val is None:
            return "-"
        color = "green" if val >= 0 else "red"
        return f"[{color}]{val:+.2f}%[/{color}]"
    
    change_table.add_row(
        format_change(change_info.get("day")),
        format_change(change_info.get("week")),
        format_change(change_info.get("month")),
        format_change(change_info.get("quarter")),
        format_change(change_info.get("year")),
    )
    
    console.print(change_table)
    console.print()
    
    # 成交量
    if volume_info:
        vol_table = Table(title="📈 成交量", box=box.ROUNDED, show_header=False)
        vol_table.add_column("項目", style="cyan")
        vol_table.add_column("數值", justify="right")
        
        vol_table.add_row("今日成交量", f"{volume_info.get('today', 0):,}")
        if volume_info.get("avg_20d"):
            vol_table.add_row("20日均量", f"{volume_info['avg_20d']:,}")
        if volume_info.get("ratio"):
            ratio = volume_info["ratio"]
            color = "yellow" if ratio >= 2.0 else ("green" if ratio >= 1.0 else "dim")
            vol_table.add_row("量比", f"[{color}]{ratio:.2f}[/{color}]")
        
        console.print(vol_table)
        console.print()
    
    # 技術指標
    _print_indicators(indicators)
    
    # 訊號
    if signals:
        signal_panel = Panel(
            "\n".join([f"• {s['description']}" for s in signals]),
            title="⚡ 最新訊號",
            border_style="yellow",
        )
        console.print(signal_panel)
        console.print()
    
    # 綜合評分
    _print_score(score)
    
    # 更新時間
    console.print()
    console.print(f"[dim]更新時間: {analysis.get('updated_at', '-')}[/dim]")


def print_crypto_analysis(analysis: dict):
    """顯示加密貨幣分析報告"""
    symbol = analysis["symbol"]
    name = analysis["name"]
    price_info = analysis["price"]
    change_info = analysis["change"]
    market_info = analysis.get("market", {})
    indicators = analysis["indicators"]
    signals = analysis["signals"]
    score = analysis["score"]
    
    # 標題
    console.print(Panel(
        f"[bold]{symbol}[/bold] - {name} [dim](加密貨幣)[/dim]",
        border_style="yellow",
    ))
    
    # 價格資訊
    price_table = Table(title="💰 價格資訊", box=box.ROUNDED, show_header=False)
    price_table.add_column("項目", style="cyan")
    price_table.add_column("數值", justify="right")
    
    current_price = price_info["current"]
    if current_price >= 1000:
        price_table.add_row("現價", f"[bold green]${current_price:,.2f}[/bold green]")
    else:
        price_table.add_row("現價", f"[bold green]${current_price:,.4f}[/bold green]")
    
    if price_info.get("ath"):
        price_table.add_row("歷史最高 (ATH)", f"${price_info['ath']:,.2f}")
    if price_info.get("from_ath_pct"):
        pct = price_info["from_ath_pct"]
        color = "red" if pct < 0 else "green"
        price_table.add_row("距 ATH", f"[{color}]{pct:+.2f}%[/{color}]")
    if price_info.get("high_24h"):
        price_table.add_row("24H 最高", f"${price_info['high_24h']:,.2f}")
    if price_info.get("low_24h"):
        price_table.add_row("24H 最低", f"${price_info['low_24h']:,.2f}")
    
    console.print(price_table)
    console.print()
    
    # 市場資訊
    if market_info:
        market_table = Table(title="🌐 市場資訊", box=box.ROUNDED, show_header=False)
        market_table.add_column("項目", style="cyan")
        market_table.add_column("數值", justify="right")
        
        if market_info.get("market_cap"):
            market_table.add_row("市值", f"${market_info['market_cap']:,.0f}")
        if market_info.get("market_cap_rank"):
            market_table.add_row("市值排名", f"#{market_info['market_cap_rank']}")
        if market_info.get("volume_24h"):
            market_table.add_row("24H 成交量", f"${market_info['volume_24h']:,.0f}")
        
        console.print(market_table)
        console.print()
    
    # 漲跌幅
    change_table = Table(title="📊 漲跌幅", box=box.ROUNDED)
    change_table.add_column("24H", justify="center")
    change_table.add_column("7D", justify="center")
    change_table.add_column("30D", justify="center")
    change_table.add_column("1Y", justify="center")
    
    def format_change(val):
        if val is None:
            return "-"
        color = "green" if val >= 0 else "red"
        return f"[{color}]{val:+.2f}%[/{color}]"
    
    change_table.add_row(
        format_change(change_info.get("day")),
        format_change(change_info.get("week")),
        format_change(change_info.get("month")),
        format_change(change_info.get("year")),
    )
    
    console.print(change_table)
    console.print()
    
    # 技術指標
    _print_crypto_indicators(indicators)
    
    # 訊號
    if signals:
        signal_panel = Panel(
            "\n".join([f"• {s['description']}" for s in signals]),
            title="⚡ 最新訊號",
            border_style="yellow",
        )
        console.print(signal_panel)
        console.print()
    
    # 綜合評分
    _print_score(score)
    
    # 更新時間
    console.print()
    console.print(f"[dim]更新時間: {analysis.get('updated_at', '-')}[/dim]")


def _print_indicators(indicators: dict):
    """列印技術指標（股票版）"""
    ind_table = Table(title="📐 技術指標", box=box.ROUNDED)
    ind_table.add_column("指標", style="cyan")
    ind_table.add_column("數值", justify="right")
    ind_table.add_column("狀態", justify="center")
    
    # MA
    ma = indicators.get("ma", {})
    alignment = ma.get("alignment", "neutral")
    alignment_text = {
        "bullish": "[green]多頭排列[/green]",
        "bearish": "[red]空頭排列[/red]",
        "neutral": "[yellow]盤整[/yellow]",
    }.get(alignment, alignment)
    
    for ma_key in [f"ma{settings.MA_SHORT}", f"ma{settings.MA_MID}", f"ma{settings.MA_LONG}"]:
        val = ma.get(ma_key)
        pos = ma.get(f"price_vs_{ma_key}")
        pos_text = "[green]▲[/green]" if pos == "above" else "[red]▼[/red]" if pos == "below" else ""
        ind_table.add_row(
            ma_key.upper(),
            f"${val:,.2f}" if val else "-",
            pos_text,
        )
    
    ind_table.add_row("排列", "", alignment_text)
    
    # RSI
    rsi = indicators.get("rsi", {})
    rsi_val = rsi.get("value")
    rsi_status = rsi.get("status", "")
    rsi_color = "red" if rsi_status == "overbought" else "green" if rsi_status == "oversold" else "white"
    rsi_status_text = {
        "overbought": "[red]超買[/red]",
        "oversold": "[green]超賣[/green]",
        "neutral": "中性",
    }.get(rsi_status, rsi_status)
    
    ind_table.add_row(
        "RSI",
        f"[{rsi_color}]{rsi_val:.1f}[/{rsi_color}]" if rsi_val else "-",
        rsi_status_text,
    )
    
    # MACD
    macd = indicators.get("macd", {})
    macd_hist = macd.get("histogram")
    macd_status = macd.get("status", "")
    macd_color = "green" if macd_status == "bullish" else "red"
    
    ind_table.add_row(
        "MACD 柱",
        f"[{macd_color}]{macd_hist:.4f}[/{macd_color}]" if macd_hist is not None else "-",
        f"[{macd_color}]{'多' if macd_status == 'bullish' else '空'}[/{macd_color}]",
    )
    
    # Bollinger
    bb = indicators.get("bollinger", {})
    bb_pos = bb.get("position", "")
    bb_pos_text = {
        "above_upper": "[red]超出上軌[/red]",
        "below_lower": "[green]跌破下軌[/green]",
        "upper_half": "通道上半",
        "lower_half": "通道下半",
    }.get(bb_pos, bb_pos)
    
    ind_table.add_row(
        "布林",
        f"↑{bb.get('upper'):.2f} ↓{bb.get('lower'):.2f}" if bb.get("upper") else "-",
        bb_pos_text,
    )
    
    console.print(ind_table)
    console.print()


def _print_crypto_indicators(indicators: dict):
    """列印技術指標（加密貨幣版）"""
    ind_table = Table(title="📐 技術指標", box=box.ROUNDED)
    ind_table.add_column("指標", style="cyan")
    ind_table.add_column("數值", justify="right")
    ind_table.add_column("狀態", justify="center")
    
    # MA（幣圈週期）
    ma = indicators.get("ma", {})
    alignment = ma.get("alignment", "neutral")
    alignment_text = {
        "bullish": "[green]多頭排列[/green]",
        "bearish": "[red]空頭排列[/red]",
        "neutral": "[yellow]盤整[/yellow]",
    }.get(alignment, alignment)
    
    for ma_key in ["ma7", "ma25", "ma99"]:
        val = ma.get(ma_key)
        ind_table.add_row(
            ma_key.upper(),
            f"${val:,.2f}" if val else "-",
            "",
        )
    
    ind_table.add_row("排列", "", alignment_text)
    
    # RSI
    rsi = indicators.get("rsi", {})
    rsi_val = rsi.get("value")
    rsi_status = rsi.get("status", "")
    rsi_color = "red" if rsi_status == "overbought" else "green" if rsi_status == "oversold" else "white"
    rsi_status_text = {
        "overbought": "[red]超買[/red]",
        "oversold": "[green]超賣[/green]",
        "neutral": "中性",
    }.get(rsi_status, rsi_status)
    
    ind_table.add_row(
        "RSI",
        f"[{rsi_color}]{rsi_val:.1f}[/{rsi_color}]" if rsi_val else "-",
        rsi_status_text,
    )
    
    # MACD
    macd = indicators.get("macd", {})
    macd_hist = macd.get("histogram")
    macd_status = macd.get("status", "")
    macd_color = "green" if macd_status == "bullish" else "red"
    
    ind_table.add_row(
        "MACD",
        f"[{macd_color}]{macd_hist:.2f}[/{macd_color}]" if macd_hist is not None else "-",
        f"[{macd_color}]{'多' if macd_status == 'bullish' else '空'}[/{macd_color}]",
    )
    
    console.print(ind_table)
    console.print()


def _print_score(score: dict):
    """列印綜合評分"""
    buy_score = score.get("buy_score", 0)
    sell_score = score.get("sell_score", 0)
    rating = score.get("rating", "neutral")
    details = score.get("details", [])
    
    rating_text = {
        "strong_buy": "[bold green]強烈買進 ⭐⭐⭐⭐⭐[/bold green]",
        "buy": "[green]買進 ⭐⭐⭐⭐[/green]",
        "neutral": "[yellow]中性 ⭐⭐⭐[/yellow]",
        "sell": "[red]賣出 ⭐⭐[/red]",
        "strong_sell": "[bold red]強烈賣出 ⭐[/bold red]",
        "insufficient_data": "[dim]資料不足[/dim]",
    }.get(rating, rating)
    
    score_content = f"買進訊號: {buy_score} / 賣出訊號: {sell_score}\n"
    score_content += f"綜合評等: {rating_text}\n\n"
    if details:
        score_content += "\n".join(details)
    
    console.print(Panel(
        score_content,
        title="🎯 綜合評分",
        border_style="magenta",
    ))


def print_sentiment(sentiment: dict):
    """顯示市場情緒"""
    console.print(Panel.fit(
        "[bold]📊 市場情緒指數[/bold]",
        border_style="cyan",
    ))
    
    sent_table = Table(box=box.ROUNDED)
    sent_table.add_column("市場", style="cyan")
    sent_table.add_column("指數", justify="center")
    sent_table.add_column("狀態", justify="center")
    sent_table.add_column("建議", justify="left")
    
    from app.data_sources.fear_greed import fear_greed as fg_client
    
    for market, data in sentiment.items():
        if not data:
            continue
        
        value = data.get("value", 0)
        classification_zh = data.get("classification_zh", "")
        
        # 根據數值決定顏色
        if value <= 25:
            color = "green"
            emoji = "😱"
        elif value <= 45:
            color = "cyan"
            emoji = "😟"
        elif value <= 55:
            color = "yellow"
            emoji = "😐"
        elif value <= 75:
            color = "orange1"
            emoji = "😊"
        else:
            color = "red"
            emoji = "🤑"
        
        market_name = "美股" if market == "stock" else "加密貨幣"
        advice = fg_client.get_sentiment_advice(value)
        
        sent_table.add_row(
            market_name,
            f"[{color}]{value}[/{color}] {emoji}",
            f"[{color}]{classification_zh}[/{color}]",
            advice[:30] + "..." if len(advice) > 30 else advice,
        )
    
    console.print(sent_table)


def cmd_query(args):
    """查詢股票或加密貨幣"""
    symbol = args.symbol.upper()
    
    db = get_sync_session()
    try:
        if is_crypto(symbol):
            # 加密貨幣
            with console.status(f"[bold green]正在分析 {symbol} (加密貨幣)..."):
                service = CryptoService(db)
                analysis = service.get_crypto_analysis(symbol, force_refresh=args.refresh)
                
                if analysis is None:
                    console.print(f"[red]❌ 找不到加密貨幣: {symbol}[/red]")
                    return 1
                
                print_crypto_analysis(analysis)
        else:
            # 股票
            with console.status(f"[bold green]正在分析 {symbol}..."):
                service = StockService(db)
                analysis = service.get_stock_analysis(symbol, force_refresh=args.refresh)
                
                if analysis is None:
                    console.print(f"[red]❌ 找不到股票: {symbol}[/red]")
                    return 1
                
                print_stock_analysis(analysis)
        
        return 0
    finally:
        db.close()


def cmd_sentiment(args):
    """查詢市場情緒"""
    with console.status("[bold green]正在取得市場情緒..."):
        db = get_sync_session()
        try:
            service = CryptoService(db)
            sentiment = service.get_market_sentiment("all")
            
            if not sentiment:
                console.print("[yellow]⚠️ 無法取得市場情緒資料[/yellow]")
                return 1
            
            print_sentiment(sentiment)
            return 0
        finally:
            db.close()


def cmd_chart(args):
    """生成圖表"""
    symbol = args.symbol.upper()
    
    db = get_sync_session()
    try:
        if is_crypto(symbol):
            service = CryptoService(db)
            with console.status(f"[bold green]正在生成 {symbol} 圖表..."):
                df = service.get_crypto_data(symbol)
        else:
            service = StockService(db)
            with console.status(f"[bold green]正在生成 {symbol} 圖表..."):
                df = service.get_stock_data(symbol)
        
        if df is None:
            console.print(f"[red]❌ 無法取得資料: {symbol}[/red]")
            return 1
        
        # 生成圖表
        chart_path = chart_service.plot_stock_analysis(
            df,
            symbol,
            days=args.days,
            show_kd=args.kd,
        )
        
        console.print(f"[green]✅ 圖表已儲存: {chart_path}[/green]")
        return 0
        
    finally:
        db.close()


def cmd_refresh(args):
    """更新資料"""
    symbol = args.symbol.upper()
    
    db = get_sync_session()
    try:
        if is_crypto(symbol):
            with console.status(f"[bold green]正在更新 {symbol}..."):
                service = CryptoService(db)
                success = service.fetch_and_cache_crypto(symbol)
        else:
            with console.status(f"[bold green]正在更新 {symbol}..."):
                service = StockService(db)
                success = service.fetch_and_cache_stock(symbol)
        
        if success:
            console.print(f"[green]✅ 已更新 {symbol} 資料[/green]")
            return 0
        else:
            console.print(f"[red]❌ 更新失敗: {symbol}[/red]")
            return 1
    finally:
        db.close()


def cmd_init(args):
    """初始化資料庫"""
    with console.status("[bold green]正在初始化資料庫..."):
        init_db_sync()
    console.print("[green]✅ 資料庫初始化完成[/green]")
    return 0


def main():
    """主程式"""
    parser = argparse.ArgumentParser(
        description="股票技術分析系統",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    
    subparsers = parser.add_subparsers(dest="command", help="可用指令")
    
    # init 指令
    init_parser = subparsers.add_parser("init", help="初始化資料庫")
    init_parser.set_defaults(func=cmd_init)
    
    # query 指令
    query_parser = subparsers.add_parser("query", help="查詢股票或加密貨幣")
    query_parser.add_argument("symbol", help="代號 (股票如 AAPL, 加密貨幣如 BTC)")
    query_parser.add_argument("-r", "--refresh", action="store_true", help="強制更新資料")
    query_parser.set_defaults(func=cmd_query)
    
    # sentiment 指令
    sentiment_parser = subparsers.add_parser("sentiment", help="查詢市場情緒")
    sentiment_parser.set_defaults(func=cmd_sentiment)
    
    # chart 指令
    chart_parser = subparsers.add_parser("chart", help="生成技術分析圖表")
    chart_parser.add_argument("symbol", help="代號")
    chart_parser.add_argument("-d", "--days", type=int, default=120, help="顯示天數 (預設 120)")
    chart_parser.add_argument("--kd", action="store_true", help="顯示 KD 指標")
    chart_parser.set_defaults(func=cmd_chart)
    
    # refresh 指令
    refresh_parser = subparsers.add_parser("refresh", help="更新資料")
    refresh_parser.add_argument("symbol", help="代號")
    refresh_parser.set_defaults(func=cmd_refresh)
    
    # 解析參數
    args = parser.parse_args()
    
    print_header()
    
    if not args.command:
        # 互動模式
        console.print("[cyan]輸入代號進行查詢 (股票如 AAPL，加密貨幣如 BTC)[/cyan]")
        console.print("[cyan]輸入 'sentiment' 查看市場情緒，'q' 離開[/cyan]")
        console.print()
        
        init_db_sync()
        db = get_sync_session()
        stock_service = StockService(db)
        crypto_service = CryptoService(db)
        
        try:
            while True:
                try:
                    user_input = console.input("[bold]代號> [/bold]").strip().upper()
                    
                    if user_input in ("Q", "QUIT", "EXIT"):
                        console.print("[yellow]再見！[/yellow]")
                        break
                    
                    if not user_input:
                        continue
                    
                    if user_input == "SENTIMENT":
                        sentiment = crypto_service.get_market_sentiment("all")
                        if sentiment:
                            print_sentiment(sentiment)
                        else:
                            console.print("[yellow]⚠️ 無法取得市場情緒[/yellow]")
                        console.print()
                        continue
                    
                    # 查詢股票或加密貨幣
                    if is_crypto(user_input):
                        with console.status(f"[bold green]正在分析 {user_input}..."):
                            analysis = crypto_service.get_crypto_analysis(user_input)
                        if analysis:
                            print_crypto_analysis(analysis)
                        else:
                            console.print(f"[red]❌ 找不到: {user_input}[/red]")
                    else:
                        with console.status(f"[bold green]正在分析 {user_input}..."):
                            analysis = stock_service.get_stock_analysis(user_input)
                        if analysis:
                            print_stock_analysis(analysis)
                        else:
                            console.print(f"[red]❌ 找不到: {user_input}[/red]")
                    
                    console.print()
                    
                except KeyboardInterrupt:
                    console.print("\n[yellow]再見！[/yellow]")
                    break
        finally:
            db.close()
        
        return 0
    
    # 執行指令
    return args.func(args)


if __name__ == "__main__":
    sys.exit(main())
```

──────────────────────────────────────────────────────────────────────
### 📄 app/data_sources/__init__.py  ⭐
> 外部資料來源模組
──────────────────────────────────────────────────────────────────────

```py
"""
外部資料來源模組
"""
from app.data_sources.yahoo_finance import yahoo_finance
from app.data_sources.coingecko import coingecko
from app.data_sources.fear_greed import fear_greed

__all__ = [
    "yahoo_finance",
    "coingecko",
    "fear_greed",
]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/data_sources/coingecko.py  ⭐
> CoinGecko API 資料來源
──────────────────────────────────────────────────────────────────────

```py
"""
CoinGecko API 資料來源
抓取加密貨幣價格資料
"""
import requests
import pandas as pd
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
import logging
import time

logger = logging.getLogger(__name__)

# CoinGecko API 基礎 URL
BASE_URL = "https://api.coingecko.com/api/v3"

# 支援的加密貨幣對應
CRYPTO_MAP = {
    "BTC": "bitcoin",
    "ETH": "ethereum",
    "BITCOIN": "bitcoin",
    "ETHEREUM": "ethereum",
}


class CoinGeckoClient:
    """CoinGecko API 客戶端"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "Accept": "application/json",
        })
        self._last_request_time = 0
        self._min_request_interval = 1.5  # 免費 API 限制：~30 次/分鐘
    
    def _rate_limit(self):
        """速率限制"""
        elapsed = time.time() - self._last_request_time
        if elapsed < self._min_request_interval:
            time.sleep(self._min_request_interval - elapsed)
        self._last_request_time = time.time()
    
    def _get(self, endpoint: str, params: dict = None) -> Optional[Dict]:
        """發送 GET 請求"""
        self._rate_limit()
        
        try:
            url = f"{BASE_URL}/{endpoint}"
            logger.info(f"CoinGecko API 請求: {url}")
            response = self.session.get(url, params=params, timeout=15)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.Timeout as e:
            logger.error(f"CoinGecko API 請求超時: {e}")
            return None
        except requests.exceptions.ConnectionError as e:
            logger.error(f"CoinGecko API 連線失敗 (可能被網路限制): {e}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"CoinGecko API 請求失敗: {e}")
            return None
    
    def get_coin_id(self, symbol: str) -> Optional[str]:
        """將代號轉換為 CoinGecko ID"""
        symbol = symbol.upper()
        return CRYPTO_MAP.get(symbol)
    
    def get_current_price(self, symbols: List[str]) -> Optional[Dict[str, Any]]:
        """
        取得即時價格
        
        Args:
            symbols: 代號列表 (如 ["BTC", "ETH"])
            
        Returns:
            {
                "BTC": {"price": 67850, "change_24h": 2.35, ...},
                "ETH": {"price": 3450, "change_24h": 1.82, ...}
            }
        """
        # 轉換代號
        coin_ids = []
        symbol_map = {}
        for symbol in symbols:
            coin_id = self.get_coin_id(symbol)
            if coin_id:
                coin_ids.append(coin_id)
                symbol_map[coin_id] = symbol.upper()
        
        if not coin_ids:
            return None
        
        params = {
            "ids": ",".join(coin_ids),
            "vs_currencies": "usd",
            "include_24hr_change": "true",
            "include_24hr_vol": "true",
            "include_market_cap": "true",
        }
        
        data = self._get("simple/price", params)
        if not data:
            return None
        
        result = {}
        for coin_id, values in data.items():
            symbol = symbol_map.get(coin_id, coin_id.upper())
            result[symbol] = {
                "price": values.get("usd"),
                "change_24h": values.get("usd_24h_change"),
                "volume_24h": values.get("usd_24h_vol"),
                "market_cap": values.get("usd_market_cap"),
            }
        
        return result
    
    def get_coin_info(self, symbol: str) -> Optional[Dict[str, Any]]:
        """
        取得加密貨幣詳細資訊
        
        Args:
            symbol: 代號 (如 BTC, ETH)
            
        Returns:
            包含價格、市值、歷史高點等資訊
        """
        coin_id = self.get_coin_id(symbol)
        if not coin_id:
            logger.warning(f"不支援的加密貨幣: {symbol}")
            return None
        
        params = {
            "localization": "false",
            "tickers": "false",
            "community_data": "false",
            "developer_data": "false",
        }
        
        data = self._get(f"coins/{coin_id}", params)
        if not data:
            return None
        
        market_data = data.get("market_data", {})
        
        return {
            "symbol": symbol.upper(),
            "name": data.get("name"),
            "current_price": market_data.get("current_price", {}).get("usd"),
            "market_cap": market_data.get("market_cap", {}).get("usd"),
            "market_cap_rank": market_data.get("market_cap_rank"),
            "total_volume": market_data.get("total_volume", {}).get("usd"),
            "high_24h": market_data.get("high_24h", {}).get("usd"),
            "low_24h": market_data.get("low_24h", {}).get("usd"),
            "price_change_24h": market_data.get("price_change_24h"),
            "price_change_percentage_24h": market_data.get("price_change_percentage_24h"),
            "price_change_percentage_7d": market_data.get("price_change_percentage_7d"),
            "price_change_percentage_30d": market_data.get("price_change_percentage_30d"),
            "price_change_percentage_1y": market_data.get("price_change_percentage_1y"),
            "ath": market_data.get("ath", {}).get("usd"),
            "ath_date": market_data.get("ath_date", {}).get("usd"),
            "ath_change_percentage": market_data.get("ath_change_percentage", {}).get("usd"),
            "atl": market_data.get("atl", {}).get("usd"),
            "atl_date": market_data.get("atl_date", {}).get("usd"),
            "circulating_supply": market_data.get("circulating_supply"),
            "total_supply": market_data.get("total_supply"),
            "last_updated": data.get("last_updated"),
        }
    
    def get_market_chart(
        self,
        symbol: str,
        days: int = 365,
    ) -> Optional[pd.DataFrame]:
        """
        取得歷史價格資料
        
        Args:
            symbol: 代號 (如 BTC, ETH)
            days: 天數 (最多 365 天，免費 API 限制)
            
        Returns:
            DataFrame with columns: date, price, volume, market_cap
        """
        coin_id = self.get_coin_id(symbol)
        if not coin_id:
            return None
        
        params = {
            "vs_currency": "usd",
            "days": min(days, 365),  # 免費 API 限制
            "interval": "daily",
        }
        
        data = self._get(f"coins/{coin_id}/market_chart", params)
        if not data:
            return None
        
        # 解析資料
        prices = data.get("prices", [])
        volumes = data.get("total_volumes", [])
        market_caps = data.get("market_caps", [])
        
        if not prices:
            return None
        
        records = []
        for i, (timestamp, price) in enumerate(prices):
            record = {
                "date": datetime.fromtimestamp(timestamp / 1000).date(),
                "price": price,
                "volume_24h": volumes[i][1] if i < len(volumes) else None,
                "market_cap": market_caps[i][1] if i < len(market_caps) else None,
            }
            records.append(record)
        
        df = pd.DataFrame(records)
        df["symbol"] = symbol.upper()
        
        # 移除重複日期（保留最後一筆）
        df = df.drop_duplicates(subset=["date"], keep="last")
        df = df.sort_values("date").reset_index(drop=True)
        
        return df
    
    def get_ohlc(
        self,
        symbol: str,
        days: int = 365,
    ) -> Optional[pd.DataFrame]:
        """
        取得 OHLC 資料（K線資料）
        
        Args:
            symbol: 代號
            days: 天數 (1/7/14/30/90/180/365/max)
            
        Returns:
            DataFrame with columns: date, open, high, low, close
        """
        coin_id = self.get_coin_id(symbol)
        if not coin_id:
            return None
        
        # CoinGecko OHLC 只支援特定天數
        valid_days = [1, 7, 14, 30, 90, 180, 365]
        days = min(valid_days, key=lambda x: abs(x - days))
        
        params = {
            "vs_currency": "usd",
            "days": days,
        }
        
        data = self._get(f"coins/{coin_id}/ohlc", params)
        if not data:
            return None
        
        records = []
        for item in data:
            timestamp, open_p, high, low, close = item
            records.append({
                "date": datetime.fromtimestamp(timestamp / 1000).date(),
                "open": open_p,
                "high": high,
                "low": low,
                "close": close,
            })
        
        df = pd.DataFrame(records)
        df["symbol"] = symbol.upper()
        
        # 移除重複日期
        df = df.drop_duplicates(subset=["date"], keep="last")
        df = df.sort_values("date").reset_index(drop=True)
        
        return df
    
    def validate_symbol(self, symbol: str) -> bool:
        """驗證代號是否支援"""
        return self.get_coin_id(symbol) is not None


# 建立全域客戶端實例
coingecko = CoinGeckoClient()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/data_sources/fear_greed.py  ⭐
> 市場情緒指數資料來源
──────────────────────────────────────────────────────────────────────

```py
"""
市場情緒指數資料來源
- CNN Fear & Greed Index (美股)
- Alternative.me (加密貨幣)
"""
import requests
from datetime import datetime, date
from typing import Optional, Dict, Any, List
import logging
import re

logger = logging.getLogger(__name__)


class FearGreedClient:
    """市場情緒指數客戶端"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        })
    
    # ==================== 加密貨幣情緒 (Alternative.me) ====================
    
    def get_crypto_fear_greed(self, limit: int = 1) -> Optional[Dict[str, Any]]:
        """
        取得加密貨幣 Fear & Greed 指數
        來源: Alternative.me
        
        Args:
            limit: 取得天數 (1 = 只取今天)
            
        Returns:
            {
                "value": 45,
                "classification": "fear",
                "classification_zh": "恐懼",
                "timestamp": "2025-01-05",
                "history": [...]  # 如果 limit > 1
            }
        """
        try:
            url = "https://api.alternative.me/fng/"
            params = {"limit": limit}
            
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            if not data.get("data"):
                return self._get_fallback_crypto()
            
            latest = data["data"][0]
            value = int(latest["value"])
            
            result = {
                "value": value,
                "classification": latest.get("value_classification", "").lower().replace(" ", "_"),
                "classification_zh": self._get_classification_zh(value),
                "timestamp": datetime.fromtimestamp(int(latest["timestamp"])).strftime("%Y-%m-%d"),
                "market": "crypto",
            }
            
            # 如果需要歷史資料
            if limit > 1:
                result["history"] = [
                    {
                        "value": int(item["value"]),
                        "classification": item.get("value_classification", "").lower().replace(" ", "_"),
                        "timestamp": datetime.fromtimestamp(int(item["timestamp"])).strftime("%Y-%m-%d"),
                    }
                    for item in data["data"]
                ]
            
            return result
            
        except Exception as e:
            logger.error(f"取得加密貨幣情緒指數失敗: {e}")
            return self._get_fallback_crypto()
    
    def _get_fallback_crypto(self) -> Dict[str, Any]:
        """加密貨幣情緒的備用值"""
        return {
            "value": 50,
            "classification": "neutral",
            "classification_zh": "中性",
            "timestamp": date.today().strftime("%Y-%m-%d"),
            "market": "crypto",
            "is_fallback": True,
        }
    
    # ==================== 美股情緒 (CNN Fear & Greed) ====================
    
    def get_stock_fear_greed(self) -> Optional[Dict[str, Any]]:
        """
        取得美股 Fear & Greed 指數
        來源: CNN Business (透過第三方 API 或爬蟲)
        
        Returns:
            {
                "value": 55,
                "classification": "neutral",
                "classification_zh": "中性",
                "timestamp": "2025-01-05",
            }
        """
        # 方法 1: 使用 CNN 的非官方 API
        result = self._get_cnn_fear_greed_api()
        if result:
            return result
        
        # 方法 2: 使用備用資料來源
        result = self._get_fear_greed_alternative()
        if result:
            return result
        
        logger.warning("無法取得美股情緒指數，使用備用值")
        # 返回備用值而非 None
        return {
            "value": 50,
            "classification": "neutral",
            "classification_zh": "中性",
            "timestamp": date.today().strftime("%Y-%m-%d"),
            "market": "stock",
            "is_fallback": True,
        }
    
    def _get_cnn_fear_greed_api(self) -> Optional[Dict[str, Any]]:
        """從 CNN API 取得 Fear & Greed"""
        try:
            # CNN 的非官方 API 端點
            url = "https://production.dataviz.cnn.io/index/fearandgreed/graphdata"
            
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            if not data.get("fear_and_greed"):
                return None
            
            fg_data = data["fear_and_greed"]
            value = int(round(fg_data.get("score", 0)))
            
            return {
                "value": value,
                "classification": self._get_classification(value),
                "classification_zh": self._get_classification_zh(value),
                "timestamp": date.today().strftime("%Y-%m-%d"),
                "market": "stock",
                "rating": fg_data.get("rating", ""),
            }
            
        except Exception as e:
            logger.debug(f"CNN API 取得失敗: {e}")
            return None
    
    def _get_fear_greed_alternative(self) -> Optional[Dict[str, Any]]:
        """備用方法：使用其他資料來源"""
        try:
            # 可以使用其他公開 API 或爬蟲
            # 這裡提供一個模擬的備用方案
            
            # 例如從 rapidapi 或其他來源取得
            # 目前返回 None，表示無法取得
            return None
            
        except Exception as e:
            logger.debug(f"備用來源取得失敗: {e}")
            return None
    
    # ==================== 通用方法 ====================
    
    def get_all_sentiment(self) -> Dict[str, Any]:
        """
        取得所有市場情緒
        
        Returns:
            {
                "stock": {...},
                "crypto": {...}
            }
        """
        result = {}
        
        # 美股情緒
        stock_sentiment = self.get_stock_fear_greed()
        if stock_sentiment:
            result["stock"] = stock_sentiment
        
        # 加密貨幣情緒
        crypto_sentiment = self.get_crypto_fear_greed()
        if crypto_sentiment:
            result["crypto"] = crypto_sentiment
        
        return result
    
    def _get_classification(self, value: int) -> str:
        """取得英文分類"""
        if value <= 25:
            return "extreme_fear"
        elif value <= 45:
            return "fear"
        elif value <= 55:
            return "neutral"
        elif value <= 75:
            return "greed"
        else:
            return "extreme_greed"
    
    def _get_classification_zh(self, value: int) -> str:
        """取得中文分類"""
        if value <= 25:
            return "極度恐懼"
        elif value <= 45:
            return "恐懼"
        elif value <= 55:
            return "中性"
        elif value <= 75:
            return "貪婪"
        else:
            return "極度貪婪"
    
    def get_sentiment_advice(self, value: int) -> str:
        """根據情緒值取得建議"""
        if value <= 25:
            return "市場極度恐懼，可能是買入機會，但需謹慎"
        elif value <= 45:
            return "市場偏恐懼，留意潛在機會"
        elif value <= 55:
            return "市場中性，觀望為主"
        elif value <= 75:
            return "市場偏樂觀，留意風險"
        else:
            return "市場極度貪婪，可能是獲利了結時機"
    
    def get_crypto_fear_greed_history(self, days: int = 365) -> List[Dict[str, Any]]:
        """
        取得加密貨幣 Fear & Greed 歷史資料
        
        Args:
            days: 取得天數（最多 365 天）
            
        Returns:
            歷史資料列表
        """
        try:
            url = "https://api.alternative.me/fng/"
            params = {"limit": min(days, 365)}
            
            response = self.session.get(url, params=params, timeout=15)
            response.raise_for_status()
            data = response.json()
            
            if not data.get("data"):
                return []
            
            history = []
            for item in data["data"]:
                value = int(item["value"])
                history.append({
                    "date": datetime.fromtimestamp(int(item["timestamp"])).strftime("%Y-%m-%d"),
                    "value": value,
                    "classification": item.get("value_classification", "").lower().replace(" ", "_"),
                    "classification_zh": self._get_classification_zh(value),
                })
            
            # 反轉順序，讓最舊的在前面
            history.reverse()
            
            return history
            
        except Exception as e:
            logger.error(f"取得加密貨幣情緒歷史失敗: {e}")
            return []


# 建立全域客戶端實例
fear_greed = FearGreedClient()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/data_sources/yahoo_finance.py  ⭐
> Yahoo Finance è³‡æ–™ä¾†æº
──────────────────────────────────────────────────────────────────────

```py
"""
Yahoo Finance è³‡æ–™ä¾†æº
ä½¿ç”¨ yfinance å¥—ä»¶æŠ“å–ç¾Žè‚¡è³‡æ–™
"""
import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
import logging

logger = logging.getLogger(__name__)

# å¸¸ç”¨å°è‚¡ä¸­æ–‡åç¨±å°ç…§è¡¨
TAIWAN_STOCK_NAMES = {
    # æ¬Šå€¼è‚¡
    "2330": "å°ç©é›»",
    "2317": "é´»æµ·",
    "2454": "è¯ç™¼ç§‘",
    "2308": "å°é”é›»",
    "2412": "ä¸­è¯é›»",
    "2303": "è¯é›»",
    "2002": "ä¸­é‹¼",
    "1301": "å°å¡‘",
    "1303": "å—äºž",
    "1326": "å°åŒ–",
    "6505": "å°å¡‘åŒ–",
    "1101": "å°æ³¥",
    "1102": "äºžæ³¥",
    # é‡‘èžè‚¡
    "2881": "å¯Œé‚¦é‡‘",
    "2882": "åœ‹æ³°é‡‘",
    "2884": "çŽ‰å±±é‡‘",
    "2886": "å…†è±é‡‘",
    "2891": "ä¸­ä¿¡é‡‘",
    "2892": "ç¬¬ä¸€é‡‘",
    "2880": "è¯å—é‡‘",
    "2883": "é–‹ç™¼é‡‘",
    "2885": "å…ƒå¤§é‡‘",
    "2887": "å°æ–°é‡‘",
    "2888": "æ–°å…‰é‡‘",
    "2890": "æ°¸è±é‡‘",
    "5880": "åˆåº«é‡‘",
    # é›»å­è‚¡
    "2912": "çµ±ä¸€è¶…",
    "2357": "è¯ç¢©",
    "2382": "å»£é”",
    "2395": "ç ”è¯",
    "3008": "å¤§ç«‹å…‰",
    "3711": "æ—¥æœˆå…‰æŠ•æŽ§",
    "2345": "æ™ºé‚¦",
    "2379": "ç‘žæ˜±",
    "2327": "åœ‹å·¨",
    "3034": "è¯è© ",
    "2301": "å…‰å¯¶ç§‘",
    "2408": "å—äºžç§‘",
    "2474": "å¯æˆ",
    "2049": "ä¸ŠéŠ€",
    "3045": "å°ç£å¤§",
    "4904": "é å‚³",
    "3231": "ç·¯å‰µ",
    "2356": "è‹±æ¥­é”",
    "2324": "ä»å¯¶",
    "2353": "å®ç¢",
    "2377": "å¾®æ˜Ÿ",
    "2376": "æŠ€å˜‰",
    "2388": "å¨ç››",
    "2409": "å‹é”",
    "3481": "ç¾¤å‰µ",
    "2404": "æ¼¢å”",
    # å‚³ç”¢è‚¡
    "5871": "ä¸­ç§Ÿ-KY",
    "1216": "çµ±ä¸€",
    "2207": "å’Œæ³°è»Š",
    "2105": "æ­£æ–°",
    "9910": "è±æ³°",
    "2603": "é•·æ¦®",
    "2609": "é™½æ˜Ž",
    "2615": "è¬æµ·",
    "2618": "é•·æ¦®èˆª",
    "2610": "è¯èˆª",
    "1402": "é æ±æ–°",
    "1590": "äºžå¾·å®¢-KY",
    "4938": "å’Œç¢©",
    "2014": "ä¸­é´»",
    "2006": "æ±å’Œé‹¼éµ",
    "2015": "è±èˆˆ",
    # AI æ¦‚å¿µè‚¡
    "3443": "å‰µæ„",
    "5274": "ä¿¡é©Š",
    "6669": "ç·¯ç©Ž",
    "3661": "ä¸–èŠ¯-KY",
    "6415": "çŸ½åŠ›-KY",
    "3533": "å˜‰æ¾¤",
    "2368": "é‡‘åƒé›»",
    "6176": "ç‘žå„€",
    "3037": "æ¬£èˆˆ",
    "5347": "ä¸–ç•Œ",
    "8046": "å—é›»",
    "6239": "åŠ›æˆ",
    # å…¶ä»–ç†±é–€è‚¡
    "2498": "å®é”é›»",
    "3706": "ç¥žé”",
    "2354": "é´»æº–",
    "2360": "è‡´èŒ‚",
    "2393": "å„„å…‰",
    "2383": "å°å…‰é›»",
    "3036": "æ–‡æ›„",
    "6446": "è—¥è¯è—¥",
    "4743": "åˆä¸€",
    "6547": "é«˜ç«¯ç–«è‹—",
    "2344": "è¯é‚¦é›»",
    "2449": "äº¬å…ƒé›»å­",
    "6531": "æ„›æ™®",
    "3017": "å¥‡é‹",
    "2059": "å·æ¹–",
    "2385": "ç¾¤å…‰",
    "6770": "åŠ›ç©é›»",
    "8299": "ç¾¤è¯",
    "6285": "å•Ÿç¢",
    "2347": "è¯å¼·",
    "2458": "ç¾©éš†",
    "3023": "ä¿¡é‚¦",
    "2492": "è¯æ–°ç§‘",
    "3044": "å¥é¼Ž",
    "5483": "ä¸­ç¾Žæ™¶",
    "6488": "ç’°çƒæ™¶",
    "3529": "åŠ›æ—º",
    "2542": "èˆˆå¯Œç™¼",
    "2545": "çš‡ç¿”",
    "2504": "åœ‹ç”¢",
    "2520": "å† å¾·",
    "2534": "å®ç››",
    "9921": "å·¨å¤§",
    "9914": "ç¾Žåˆ©é”",
    "1227": "ä½³æ ¼",
    "1229": "è¯è¯",
    "1234": "é»‘æ¾",
    "2912": "çµ±ä¸€è¶…",
    "2915": "æ½¤æ³°å…¨",
    "9904": "å¯¶æˆ",
    "9945": "æ½¤æ³°æ–°",
    # ä¸Šæ«ƒè‚¡ç¥¨ (.TWO)
    "8069": "å…ƒå¤ª",
    "6547": "é«˜ç«¯ç–«è‹—",
    "4743": "åˆä¸€",
    "6446": "è—¥è¯è—¥",
    "5765": "æ°¸ä¿¡é†«è—¥",
    "8086": "å®æ·ç§‘",
    "3105": "ç©©æ‡‹",
    "5269": "ç¥¥ç¢©",
    "6409": "æ—­éš¼",
    "6510": "ç²¾æ¸¬",
    "3293": "é‘«å–¬",
    "6533": "æ™¶å¿ƒç§‘",
    "6477": "å®‰é›†",
    "6568": "å®è§€",
    "3163": "æ³¢è‹¥å¨",
    "6197": "ä½³å¿…çª",
    "5388": "ä¸­ç£Š",
    "6781": "AES-KY",
    "3152": "ç’Ÿå¾·",
    "5289": "å®œé¼Ž",
    "6223": "æ—ºçŸ½",
    "8150": "å—èŒ‚",
    "5484": "æ…§å‹",
    "6442": "å…‰è–",
    "6472": "ä¿ç‘ž",
    "4966": "è­œç‘ž-KY",
    "6789": "é‡‡éˆº",
    "6640": "å‡è¯",
    "3260": "å¨å‰›",
    "4763": "ææ–™-KY",
    "5299": "æ°åŠ›",
    "8016": "çŸ½å‰µ",
    "6719": "åŠ›æ™º",
    "6456": "GIS-KY",
    "6451": "è¨ŠèŠ¯-KY",
    "3707": "æ¼¢ç£Š",
    "4968": "ç«‹ç©",
    "6679": "éˆºå¤ª",
    "6592": "å’Œæ½¤ä¼æ¥­",
    "6591": "å‹•åŠ›-KY",
    "5425": "å°åŠ",
    "6803": "å´‡è¶Šé›»",
    "3527": "èšç©",
    "6449": "éˆºé‚¦",
    # ETF
    "0050": "å…ƒå¤§å°ç£50",
    "0056": "å…ƒå¤§é«˜è‚¡æ¯",
    "00878": "åœ‹æ³°æ°¸çºŒé«˜è‚¡æ¯",
    "00919": "ç¾¤ç›Šå°ç£ç²¾é¸é«˜æ¯",
    "00929": "å¾©è¯å°ç£ç§‘æŠ€å„ªæ¯",
    "006208": "å¯Œé‚¦å°50",
    "00713": "å…ƒå¤§å°ç£é«˜æ¯ä½Žæ³¢",
    "00692": "å¯Œé‚¦å…¬å¸æ²»ç†",
}


class YahooFinanceClient:
    """Yahoo Finance è³‡æ–™æ“·å–å®¢æˆ¶ç«¯"""
    
    def __init__(self):
        pass
    
    def get_stock_info(self, symbol: str) -> Optional[Dict[str, Any]]:
        """
        å–å¾—è‚¡ç¥¨åŸºæœ¬è³‡è¨Š
        
        Args:
            symbol: è‚¡ç¥¨ä»£è™Ÿ (å¦‚ AAPL, TSLA, 2330.TW)
            
        Returns:
            è‚¡ç¥¨è³‡è¨Šå­—å…¸ï¼ŒåŒ…å«åç¨±ã€å¸‚å€¼ç­‰
        """
        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info or {}
            
            # å–å¾—åç¨±ï¼šå„ªå…ˆä½¿ç”¨ longNameï¼Œç„¶å¾Œ shortName
            name = info.get("longName") or info.get("shortName") or symbol
            
            # å°æ–¼å°è‚¡ï¼Œå„ªå…ˆä½¿ç”¨æœ¬åœ°æ˜ å°„è¡¨çš„ä¸­æ–‡åç¨±
            if symbol.endswith(".TW") or symbol.endswith(".TWO"):
                # æå–è‚¡ç¥¨ä»£è™Ÿ (åŽ»æŽ‰ .TW æˆ– .TWO)
                stock_code = symbol.replace(".TW", "").replace(".TWO", "")
                # å„ªå…ˆä½¿ç”¨æœ¬åœ°æ˜ å°„è¡¨
                if stock_code in TAIWAN_STOCK_NAMES:
                    name = TAIWAN_STOCK_NAMES[stock_code]
                else:
                    # å˜—è©¦å¾ž Yahoo Finance å–å¾—ä¸­æ–‡å
                    display_name = info.get("displayName")
                    if display_name:
                        name = display_name
            
            # å³ä½¿ info ä¸å®Œæ•´ï¼Œä¹Ÿè¿”å›žåŸºæœ¬è³‡è¨Š
            return {
                "symbol": info.get("symbol", symbol),
                "name": name,
                "shortName": info.get("shortName", ""),
                "longName": info.get("longName", ""),
                "currency": info.get("currency", "TWD" if symbol.endswith((".TW", ".TWO")) else "USD"),
                "market_cap": info.get("marketCap"),
                "sector": info.get("sector"),
                "industry": info.get("industry"),
                "fifty_two_week_high": info.get("fiftyTwoWeekHigh"),
                "fifty_two_week_low": info.get("fiftyTwoWeekLow"),
            }
        except Exception as e:
            logger.error(f"å–å¾—è‚¡ç¥¨è³‡è¨Šå¤±æ•— {symbol}: {e}")
            # å³ä½¿å‡ºéŒ¯ï¼Œå°æ–¼å°è‚¡ä¹Ÿå˜—è©¦è¿”å›žæœ¬åœ°åç¨±
            if symbol.endswith(".TW") or symbol.endswith(".TWO"):
                stock_code = symbol.replace(".TW", "").replace(".TWO", "")
                name = TAIWAN_STOCK_NAMES.get(stock_code, symbol)
                return {
                    "symbol": symbol,
                    "name": name,
                    "shortName": "",
                    "longName": "",
                    "currency": "TWD",
                    "market_cap": None,
                    "sector": None,
                    "industry": None,
                    "fifty_two_week_high": None,
                    "fifty_two_week_low": None,
                }
            return None
    
    def get_stock_history(
        self,
        symbol: str,
        period: str = "1y",
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
    ) -> Optional[pd.DataFrame]:
        """
        å–å¾—è‚¡ç¥¨æ­·å²åƒ¹æ ¼è³‡æ–™
        
        Args:
            symbol: è‚¡ç¥¨ä»£è™Ÿ
            period: è³‡æ–™æœŸé–“ (1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, 10y, ytd, max)
            start: é–‹å§‹æ—¥æœŸï¼ˆèˆ‡ end æ­é…ä½¿ç”¨æ™‚ï¼Œperiod æœƒè¢«å¿½ç•¥ï¼‰
            end: çµæŸæ—¥æœŸ
            
        Returns:
            åŒ…å« OHLCV çš„ DataFrameï¼Œå…¶ä¸­ï¼š
            - close: åŽŸå§‹æ”¶ç›¤åƒ¹ï¼ˆç”¨æ–¼é¡¯ç¤ºï¼‰
            - adj_close: åˆ†å‰²èª¿æ•´å¾Œåƒ¹æ ¼ï¼ˆç”¨æ–¼åœ–è¡¨ï¼Œä¸å«é…æ¯ï¼‰
        """
        try:
            ticker = yf.Ticker(symbol)
            
            # å–å¾—åŽŸå§‹åƒ¹æ ¼
            if start and end:
                df_raw = ticker.history(start=start, end=end, auto_adjust=False)
            else:
                df_raw = ticker.history(period=period, auto_adjust=False)
            
            if df_raw.empty:
                logger.warning(f"ç„¡æ­·å²è³‡æ–™: {symbol}")
                return None
            
            df_raw = df_raw.reset_index()
            
            # æ¨™æº–åŒ–æ—¥æœŸæ¬„ä½
            date_col = "Date" if "Date" in df_raw.columns else "Datetime"
            
            # å»ºç«‹çµæžœ DataFrame
            df = pd.DataFrame()
            df["date"] = pd.to_datetime(df_raw[date_col]).dt.date
            df["open"] = df_raw["Open"].values
            df["high"] = df_raw["High"].values
            df["low"] = df_raw["Low"].values
            df["close"] = df_raw["Close"].values
            df["volume"] = df_raw["Volume"].values if "Volume" in df_raw.columns else 0
            
            # åµæ¸¬ä¸¦èª¿æ•´åˆ†å‰²ï¼ˆä¸å«é…æ¯ï¼‰
            df = self._detect_and_adjust_splits(df, symbol)
            
            # åŠ å…¥è‚¡ç¥¨ä»£è™Ÿ
            df["symbol"] = symbol.upper()
            
            return df
            
        except Exception as e:
            logger.error(f"å–å¾—æ­·å²è³‡æ–™å¤±æ•— {symbol}: {e}")
            return None
    
    def _detect_and_adjust_splits(self, df: pd.DataFrame, symbol: str) -> pd.DataFrame:
        """
        åµæ¸¬åƒ¹æ ¼æ–·å´–ä¸¦èª¿æ•´æ­·å²åƒ¹æ ¼ï¼ˆåªè™•ç†åˆ†å‰²ï¼Œä¸å«é…æ¯ï¼‰
        
        ç•¶åµæ¸¬åˆ°åƒ¹æ ¼çªç„¶ä¸‹è·Œè¶…éŽ 40%ï¼ˆå¯èƒ½æ˜¯åˆ†å‰²ï¼‰ï¼Œ
        æœƒè‡ªå‹•èª¿æ•´åˆ†å‰²å‰çš„åƒ¹æ ¼ï¼Œä½¿æ•´å€‹åºåˆ—é€£çºŒã€‚
        """
        if len(df) < 2:
            df['adj_close'] = df['close'].copy()
            return df
        
        df = df.copy()
        df = df.sort_values('date').reset_index(drop=True)
        
        # è¨ˆç®—æ¯æ—¥æ¼²è·Œå¹…
        df['pct_change'] = df['close'].pct_change()
        
        # åµæ¸¬åˆ†å‰²é»žï¼ˆåƒ¹æ ¼ä¸‹è·Œè¶…éŽ 40%ï¼‰
        split_indices = []
        for i in range(1, len(df)):
            pct = df.loc[i, 'pct_change']
            if pd.notna(pct) and pct < -0.40:
                prev_close = float(df.loc[i-1, 'close'])
                curr_close = float(df.loc[i, 'close'])
                if curr_close > 0:
                    ratio = prev_close / curr_close
                    rounded_ratio = round(ratio)
                    # åªæœ‰æ¯”çŽ‡æŽ¥è¿‘æ•´æ•¸æ™‚æ‰èªç‚ºæ˜¯åˆ†å‰²ï¼ˆ2, 3, 4, 5, 10 ç­‰ï¼‰
                    if rounded_ratio >= 2 and abs(ratio - rounded_ratio) < 0.3:
                        split_indices.append({
                            'index': i,
                            'date': df.loc[i, 'date'],
                            'ratio': rounded_ratio,
                            'prev_close': prev_close,
                            'curr_close': curr_close
                        })
                        logger.info(f"{symbol} åµæ¸¬åˆ°åˆ†å‰²: {df.loc[i, 'date']}, æ¯”çŽ‡ 1:{rounded_ratio}, å‰æ”¶ {prev_close:.2f} -> ç¾æ”¶ {curr_close:.2f}")
        
        # åˆå§‹åŒ–èª¿æ•´å¾Œåƒ¹æ ¼
        df['adj_close'] = df['close'].astype(float)
        
        # å¾žæœ€è¿‘çš„åˆ†å‰²é–‹å§‹å¾€å‰èª¿æ•´ï¼ˆä½¿ç”¨ç´¯ç©å› å­ï¼‰
        if split_indices:
            cumulative_factor = 1.0
            
            for split in reversed(split_indices):
                idx = split['index']
                ratio = split['ratio']
                cumulative_factor *= ratio
                
                # èª¿æ•´åˆ†å‰²é»žä¹‹å‰çš„æ‰€æœ‰åƒ¹æ ¼ï¼ˆç”¨åŽŸå§‹ close é™¤ä»¥ç´¯ç©å› å­ï¼‰
                df.loc[:idx-1, 'adj_close'] = df.loc[:idx-1, 'close'].astype(float) / cumulative_factor
            
            logger.info(f"{symbol} å·²èª¿æ•´ {len(split_indices)} æ¬¡åˆ†å‰²ï¼Œç¸½èª¿æ•´å› å­: {cumulative_factor}")
        
        # ç§»é™¤è‡¨æ™‚æ¬„ä½
        df = df.drop(columns=['pct_change'], errors='ignore')
        
        return df
    
    def get_current_price(self, symbol: str) -> Optional[Dict[str, Any]]:
        """
        å–å¾—è‚¡ç¥¨å³æ™‚ï¼ˆå»¶é²ï¼‰å ±åƒ¹
        
        Args:
            symbol: è‚¡ç¥¨ä»£è™Ÿ
            
        Returns:
            åŒ…å«ç•¶å‰åƒ¹æ ¼å’Œæ¼²è·Œè³‡è¨Šçš„å­—å…¸
        """
        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info
            
            if not info:
                return None
            
            # å˜—è©¦å–å¾—å³æ™‚åƒ¹æ ¼
            current_price = info.get("currentPrice") or info.get("regularMarketPrice")
            previous_close = info.get("previousClose") or info.get("regularMarketPreviousClose")
            
            if not current_price:
                # å¾žæ­·å²è³‡æ–™å–å¾—æœ€æ–°æ”¶ç›¤åƒ¹ï¼ˆä½¿ç”¨åŽŸå§‹åƒ¹æ ¼ï¼‰
                hist = ticker.history(period="5d", auto_adjust=False)
                if not hist.empty:
                    current_price = hist["Close"].iloc[-1]
                    if len(hist) >= 2:
                        previous_close = hist["Close"].iloc[-2]
            
            if not current_price:
                return None
            
            change = current_price - previous_close if previous_close else 0
            change_pct = (change / previous_close * 100) if previous_close else 0
            
            return {
                "symbol": symbol.upper(),
                "price": round(current_price, 2),
                "previous_close": round(previous_close, 2) if previous_close else None,
                "change": round(change, 2),
                "change_pct": round(change_pct, 2),
                "volume": info.get("volume") or info.get("regularMarketVolume"),
            }
            
        except Exception as e:
            logger.error(f"å–å¾—å³æ™‚å ±åƒ¹å¤±æ•— {symbol}: {e}")
            return None
    
    def validate_symbol(self, symbol: str) -> bool:
        """
        快速驗證股票代號是否有效
        
        使用 history API 而非 info，速度快 5-10 倍
        
        Args:
            symbol: 股票代號
            
        Returns:
            是否為有效代號
        """
        try:
            ticker = yf.Ticker(symbol)
            # 只抓 1 天資料，比 info 快很多
            hist = ticker.history(period="1d")
            return not hist.empty
        except Exception:
            return False
    
    def get_dividends(
        self,
        symbol: str,
        period: str = "10y",
    ) -> Optional[pd.DataFrame]:
        """
        å–å¾—è‚¡ç¥¨é…æ¯æ­·å²
        
        Args:
            symbol: è‚¡ç¥¨ä»£è™Ÿ
            period: è³‡æ–™æœŸé–“ (1y, 5y, 10y, max)
            
        Returns:
            åŒ…å«é…æ¯è¨˜éŒ„çš„ DataFrame
        """
        try:
            ticker = yf.Ticker(symbol)
            dividends = ticker.dividends
            
            if dividends.empty:
                logger.info(f"{symbol} ç„¡é…æ¯è¨˜éŒ„")
                return None
            
            # è½‰æ›æˆ DataFrame
            df = dividends.reset_index()
            df.columns = ["date", "amount"]
            df["date"] = pd.to_datetime(df["date"]).dt.date
            df["symbol"] = symbol.upper()
            
            # æ ¹æ“š period éŽæ¿¾
            if period != "max":
                years = int(period.replace("y", ""))
                cutoff_date = datetime.now().date() - timedelta(days=years * 365)
                df = df[df["date"] >= cutoff_date]
            
            return df
            
        except Exception as e:
            logger.error(f"å–å¾—é…æ¯è³‡æ–™å¤±æ•— {symbol}: {e}")
            return None
    
    def get_index_data(
        self,
        symbol: str,
        period: str = "10y",
    ) -> Optional[pd.DataFrame]:
        """
        å–å¾—å¸‚å ´æŒ‡æ•¸æ­·å²è³‡æ–™
        
        Args:
            symbol: æŒ‡æ•¸ä»£è™Ÿ (^GSPC, ^DJI, ^IXIC)
            period: è³‡æ–™æœŸé–“
            
        Returns:
            åŒ…å« OHLCV çš„ DataFrame
        """
        try:
            ticker = yf.Ticker(symbol)
            df = ticker.history(period=period, auto_adjust=False)
            
            if df.empty:
                logger.warning(f"ç„¡æŒ‡æ•¸è³‡æ–™: {symbol}")
                return None
            
            # é‡è¨­ç´¢å¼•
            df = df.reset_index()
            
            # æ¨™æº–åŒ–æ¬„ä½åç¨±
            column_mapping = {
                "Date": "date",
                "Datetime": "date",
                "Open": "open",
                "High": "high",
                "Low": "low",
                "Close": "close",
                "Volume": "volume",
            }
            existing_columns = {k: v for k, v in column_mapping.items() if k in df.columns}
            df = df.rename(columns=existing_columns)
            
            # ç¢ºä¿æ—¥æœŸæ˜¯ date é¡žåž‹
            df["date"] = pd.to_datetime(df["date"]).dt.date
            
            # è¨ˆç®—æ¼²è·Œ
            df["change"] = df["close"].diff()
            df["change_pct"] = df["close"].pct_change() * 100
            
            # åŠ å…¥ä»£è™Ÿ
            df["symbol"] = symbol
            
            # åªä¿ç•™éœ€è¦çš„æ¬„ä½
            keep_columns = ["symbol", "date", "open", "high", "low", "close", "volume", "change", "change_pct"]
            df = df[[c for c in keep_columns if c in df.columns]]
            
            return df
            
        except Exception as e:
            logger.error(f"å–å¾—æŒ‡æ•¸è³‡æ–™å¤±æ•— {symbol}: {e}")
            return None
    
    def get_all_indices(self, period: str = "10y") -> Dict[str, pd.DataFrame]:
        """
        å–å¾—æ‰€æœ‰ä¸‰å¤§æŒ‡æ•¸è³‡æ–™
        
        Returns:
            {symbol: DataFrame}
        """
        indices = ["^GSPC", "^DJI", "^IXIC"]
        result = {}
        
        for symbol in indices:
            df = self.get_index_data(symbol, period)
            if df is not None:
                result[symbol] = df
        
        return result
    
    def get_stock_history_extended(
        self,
        symbol: str,
        years: int = 10,
    ) -> Optional[pd.DataFrame]:
        """
        å–å¾—è‚¡ç¥¨å»¶ä¼¸æ­·å²è³‡æ–™ï¼ˆæ”¯æ´æ›´é•·æ™‚é–“ï¼‰
        
        Args:
            symbol: è‚¡ç¥¨ä»£è™Ÿ
            years: å¹´æ•¸ (1, 3, 5, 10)
            
        Returns:
            åŒ…å« OHLCV çš„ DataFrame
        """
        period_map = {
            1: "1y",
            2: "2y",
            3: "3y",  # yfinance ä¸æ”¯æ´ 3yï¼Œç”¨ 5y ä»£æ›¿
            5: "5y",
            10: "10y",
        }
        
        period = period_map.get(years, "10y")
        if years == 3:
            period = "5y"  # ç„¶å¾Œåœ¨ç¨‹å¼ä¸­éŽæ¿¾
        
        df = self.get_stock_history(symbol, period=period)
        
        if df is None:
            return None
        
        # å¦‚æžœæ˜¯ 3 å¹´ï¼Œéœ€è¦éŽæ¿¾
        if years == 3:
            cutoff_date = datetime.now().date() - timedelta(days=3 * 365)
            df = df[df["date"] >= cutoff_date]
        
        return df


# å»ºç«‹å…¨åŸŸå®¢æˆ¶ç«¯å¯¦ä¾‹
yahoo_finance = YahooFinanceClient()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/logging_config.py  ⭐
> 日誌設定
──────────────────────────────────────────────────────────────────────

```py
"""
日誌設定
確保所有重要操作都有記錄
"""
import logging
import sys
from datetime import datetime
from pathlib import Path


def setup_logging(log_level: str = "INFO", log_to_file: bool = True):
    """
    設定日誌系統
    
    Args:
        log_level: 日誌等級 (DEBUG, INFO, WARNING, ERROR)
        log_to_file: 是否寫入檔案
    """
    # 建立 logs 目錄
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)
    
    # 日誌格式
    log_format = "%(asctime)s | %(levelname)-8s | %(name)s | %(message)s"
    date_format = "%Y-%m-%d %H:%M:%S"
    
    # 建立 formatter
    formatter = logging.Formatter(log_format, datefmt=date_format)
    
    # 取得 root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, log_level.upper(), logging.INFO))
    
    # 清除現有的 handlers
    root_logger.handlers.clear()
    
    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    console_handler.setLevel(logging.INFO)
    root_logger.addHandler(console_handler)
    
    if log_to_file:
        # 主要日誌檔（所有日誌）
        today = datetime.now().strftime("%Y-%m-%d")
        main_log_file = log_dir / f"app_{today}.log"
        file_handler = logging.FileHandler(main_log_file, encoding="utf-8")
        file_handler.setFormatter(formatter)
        file_handler.setLevel(logging.DEBUG)
        root_logger.addHandler(file_handler)
        
        # 認證日誌檔（登入/登出）
        auth_logger = logging.getLogger("app.services.auth_service")
        auth_log_file = log_dir / f"auth_{today}.log"
        auth_handler = logging.FileHandler(auth_log_file, encoding="utf-8")
        auth_handler.setFormatter(formatter)
        auth_handler.setLevel(logging.INFO)
        auth_logger.addHandler(auth_handler)
        
        # Watchlist 日誌檔
        watchlist_logger = logging.getLogger("app.services.watchlist_service")
        watchlist_log_file = log_dir / f"watchlist_{today}.log"
        watchlist_handler = logging.FileHandler(watchlist_log_file, encoding="utf-8")
        watchlist_handler.setFormatter(formatter)
        watchlist_handler.setLevel(logging.INFO)
        watchlist_logger.addHandler(watchlist_handler)
    
    # 設定第三方套件的日誌等級
    logging.getLogger("httpx").setLevel(logging.WARNING)
    logging.getLogger("httpcore").setLevel(logging.WARNING)
    logging.getLogger("sqlalchemy.engine").setLevel(logging.WARNING)
    logging.getLogger("uvicorn").setLevel(logging.INFO)
    
    root_logger.info("日誌系統初始化完成")
    if log_to_file:
        root_logger.info(f"日誌檔案: {log_dir.absolute()}")


def get_logger(name: str) -> logging.Logger:
    """取得 logger"""
    return logging.getLogger(name)
```

──────────────────────────────────────────────────────────────────────
### 📄 app/tasks/__init__.py  ⭐
> 排程任務模組
──────────────────────────────────────────────────────────────────────

```py
"""
排程任務模組
"""
from app.tasks.scheduler import scheduler_service, SchedulerService

__all__ = [
    "scheduler_service",
    "SchedulerService",
]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/tasks/price_cache_task.py  ⭐
> 價格快取排程任務
──────────────────────────────────────────────────────────────────────

```py
"""
價格快取排程任務

排程邏輯：
1. 每 10 分鐘執行 run_update()
   - 自動判斷哪些市場開盤
   - 只更新開盤中的市場
   
2. 收盤後各執行一次（確保有最終收盤價）
   - 台股：13:35
   - 美股：05:05
"""
import logging
from datetime import datetime
from typing import Dict, Any

from app.database import SyncSessionLocal
from app.services.price_cache_service import PriceCacheService, get_market_status

logger = logging.getLogger(__name__)


class PriceCacheScheduler:
    """價格快取排程器"""
    
    def __init__(self):
        self.last_run: datetime = None
        self.last_result: Dict[str, Any] = {}
    
    def run_update(self) -> Dict[str, Any]:
        """
        執行價格快取更新（每 10 分鐘）
        
        自動判斷：
        - 台股開盤 (09:00-13:30) → 更新台股
        - 美股開盤 (21:30-05:00) → 更新美股
        - 加密貨幣 → 24 小時更新
        """
        market_status = get_market_status()
        
        # 如果所有股市都收盤，只更新加密貨幣
        if not market_status["tw_open"] and not market_status["us_open"]:
            logger.info("台股美股皆收盤，只更新加密貨幣")
        
        return self._do_update(force=False)
    
    def run_force_update(self) -> Dict[str, Any]:
        """
        強制更新所有市場（用於收盤後或手動觸發）
        """
        logger.info("強制更新所有市場")
        return self._do_update(force=True)
    
    def run_tw_close_update(self) -> Dict[str, Any]:
        """
        台股收盤後更新（13:35 執行）
        確保有最終收盤價
        """
        logger.info("台股收盤，執行最終更新")
        
        db = SyncSessionLocal()
        try:
            service = PriceCacheService(db)
            tracked = service.get_all_tracked_symbols()
            
            if tracked["tw_stocks"]:
                result = service.batch_update_stock_prices(tracked["tw_stocks"])
                logger.info(f"台股收盤更新完成: {result['updated']} 支")
                return result
            return {"updated": 0, "message": "無台股追蹤"}
            
        except Exception as e:
            logger.error(f"台股收盤更新失敗: {e}")
            return {"error": str(e)}
        finally:
            db.close()
    
    def run_us_close_update(self) -> Dict[str, Any]:
        """
        美股收盤後更新（05:05 執行）
        確保有最終收盤價
        """
        logger.info("美股收盤，執行最終更新")
        
        db = SyncSessionLocal()
        try:
            service = PriceCacheService(db)
            tracked = service.get_all_tracked_symbols()
            
            if tracked["us_stocks"]:
                result = service.batch_update_stock_prices(tracked["us_stocks"])
                logger.info(f"美股收盤更新完成: {result['updated']} 支")
                return result
            return {"updated": 0, "message": "無美股追蹤"}
            
        except Exception as e:
            logger.error(f"美股收盤更新失敗: {e}")
            return {"error": str(e)}
        finally:
            db.close()
    
    def _do_update(self, force: bool = False) -> Dict[str, Any]:
        """執行更新"""
        logger.info("=" * 50)
        logger.info(f"排程: 開始更新價格快取 (force={force})")
        logger.info(f"時間: {datetime.now()}")
        logger.info("=" * 50)
        
        db = SyncSessionLocal()
        
        try:
            service = PriceCacheService(db)
            result = service.update_all_tracked_prices(force=force)
            
            self.last_run = datetime.now()
            self.last_result = result
            
            logger.info(f"排程: 價格快取更新完成, 共 {result['total_updated']} 筆")
            
            return result
            
        except Exception as e:
            logger.error(f"排程: 價格快取更新失敗: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.now().isoformat(),
            }
        finally:
            db.close()
    
    def get_status(self) -> Dict[str, Any]:
        """取得排程狀態"""
        return {
            "last_run": self.last_run.isoformat() if self.last_run else None,
            "last_result": self.last_result,
            "market_status": get_market_status(),
        }


# 全域實例
price_cache_scheduler = PriceCacheScheduler()


# ============================================================
# APScheduler 設定範例（加到 main.py）
# ============================================================

"""
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from app.tasks.price_cache_task import price_cache_scheduler

scheduler = AsyncIOScheduler()

# 1. 每 10 分鐘執行（自動判斷開盤時間）
scheduler.add_job(
    price_cache_scheduler.run_update,
    'interval',
    minutes=10,
    id='price_cache_interval',
    name='價格快取更新(每10分鐘)',
)

# 2. 台股收盤後執行一次（週一到週五 13:35）
scheduler.add_job(
    price_cache_scheduler.run_tw_close_update,
    CronTrigger(day_of_week='mon-fri', hour=13, minute=35),
    id='price_cache_tw_close',
    name='台股收盤更新',
)

# 3. 美股收盤後執行一次（週二到週六 05:05，對應美股週一到週五）
scheduler.add_job(
    price_cache_scheduler.run_us_close_update,
    CronTrigger(day_of_week='tue-sat', hour=5, minute=5),
    id='price_cache_us_close',
    name='美股收盤更新',
)

# 啟動排程
@app.on_event("startup")
async def startup_event():
    scheduler.start()
    # 啟動時執行一次（強制更新所有）
    price_cache_scheduler.run_force_update()

@app.on_event("shutdown")
async def shutdown_event():
    scheduler.shutdown()
"""
```

──────────────────────────────────────────────────────────────────────
### 📄 app/tasks/scheduler.py  ⭐
> 排程任務服務
──────────────────────────────────────────────────────────────────────

```py
"""
排程任務服務
每日自動更新股價、指數、情緒資料，並發送訊號通知
"""
import asyncio
from datetime import datetime, date, timedelta
from typing import Dict, Any, List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import select, distinct, and_
import logging

from app.database import SyncSessionLocal, AsyncSessionLocal
from app.models.watchlist import Watchlist
from app.models.stock_price import StockPrice
from app.models.index_price import IndexPrice, INDEX_SYMBOLS
from app.models.market_sentiment import MarketSentiment
from app.models.notification import Notification
from app.models.user import User
from app.models.user_settings import UserAlertSettings
from app.services.market_service import MarketService
from app.services.signal_service import signal_service, SignalType
from app.data_sources.yahoo_finance import yahoo_finance

logger = logging.getLogger(__name__)


class SchedulerService:
    """排程任務服務"""
    
    # 重要訊號類型（只通知這些）
    IMPORTANT_SIGNAL_TYPES = [
        # 交叉訊號
        SignalType.MA_GOLDEN_CROSS,
        SignalType.MA_DEATH_CROSS,
        SignalType.MACD_GOLDEN_CROSS,
        SignalType.MACD_DEATH_CROSS,
        SignalType.KD_GOLDEN_CROSS,
        SignalType.KD_DEATH_CROSS,
        # RSI 極端值
        SignalType.RSI_OVERBOUGHT,
        SignalType.RSI_OVERSOLD,
    ]
    
    def __init__(self):
        self.last_run: Optional[datetime] = None
        self.last_result: Dict[str, Any] = {}
    
    def _get_db(self) -> Session:
        """取得資料庫 session"""
        return SyncSessionLocal()
    
    def run_daily_update(self) -> Dict[str, Any]:
        """
        執行每日更新任務
        
        包含：
        1. 更新所有追蹤股票的價格
        2. 更新三大指數
        3. 更新市場情緒
        4. 偵測訊號並發送通知
        
        Returns:
            執行結果摘要
        """
        logger.info("=" * 50)
        logger.info("開始執行每日更新任務")
        logger.info(f"執行時間: {datetime.now()}")
        logger.info("=" * 50)
        
        result = {
            "start_time": datetime.now().isoformat(),
            "stocks_updated": 0,
            "indices_updated": {},
            "sentiment_updated": {},
            "signals_detected": 0,
            "notifications_sent": 0,
            "errors": [],
        }
        
        db = self._get_db()
        
        try:
            # 1. 更新追蹤股票
            stocks_result = self._update_watchlist_stocks(db)
            result["stocks_updated"] = stocks_result["count"]
            if stocks_result.get("errors"):
                result["errors"].extend(stocks_result["errors"])
            
            # 2. 更新三大指數
            market_service = MarketService(db)
            indices_result = self._update_indices(market_service)
            result["indices_updated"] = indices_result
            
            # 3. 更新市場情緒
            sentiment_result = market_service.update_today_sentiment()
            result["sentiment_updated"] = sentiment_result
            
            # 4. 偵測訊號並發送通知
            signal_result = self._detect_and_notify(db)
            result["signals_detected"] = signal_result.get("signals_count", 0)
            result["notifications_sent"] = signal_result.get("notifications_sent", 0)
            if signal_result.get("errors"):
                result["errors"].extend(signal_result["errors"])
            
            result["end_time"] = datetime.now().isoformat()
            result["success"] = True
            
            logger.info("=" * 50)
            logger.info("每日更新任務完成")
            logger.info(f"股票更新: {result['stocks_updated']} 檔")
            logger.info(f"指數更新: {result['indices_updated']}")
            logger.info(f"情緒更新: {result['sentiment_updated']}")
            logger.info(f"訊號偵測: {result['signals_detected']} 個")
            logger.info(f"通知發送: {result['notifications_sent']} 人")
            logger.info("=" * 50)
            
        except Exception as e:
            logger.error(f"每日更新任務失敗: {e}")
            result["errors"].append(str(e))
            result["success"] = False
        finally:
            db.close()
        
        self.last_run = datetime.now()
        self.last_result = result
        
        return result
    
    def _detect_and_notify(self, db: Session) -> Dict[str, Any]:
        """
        偵測訊號並發送通知
        
        流程：
        1. 取得所有用戶的追蹤清單（聯集）
        2. 對每支股票計算指標並偵測訊號
        3. 根據用戶設定發送通知
        """
        result = {
            "signals_count": 0,
            "notifications_sent": 0,
            "errors": [],
        }
        
        logger.info("開始偵測訊號...")
        
        try:
            # 1. 取得所有追蹤的股票
            stmt = select(distinct(Watchlist.symbol)).where(Watchlist.asset_type == "stock")
            symbols = db.execute(stmt).scalars().all()
            logger.info(f"需要偵測的股票: {len(symbols)} 檔")
            
            # 2. 對每支股票偵測訊號
            all_signals = {}  # {symbol: [signals]}
            
            for symbol in symbols:
                try:
                    signals = self._detect_signals_for_symbol(symbol)
                    
                    # 只保留交叉訊號
                    cross_signals = [s for s in signals if s.signal_type in self.IMPORTANT_SIGNAL_TYPES]
                    
                    if cross_signals:
                        all_signals[symbol] = cross_signals
                        result["signals_count"] += len(cross_signals)
                        logger.info(f"{symbol}: 偵測到 {len(cross_signals)} 個交叉訊號")
                
                except Exception as e:
                    logger.error(f"偵測 {symbol} 訊號失敗: {e}")
                    result["errors"].append(f"{symbol}: {str(e)}")
            
            logger.info(f"共偵測到 {result['signals_count']} 個交叉訊號")
            
            if not all_signals:
                logger.info("今日無交叉訊號，不發送通知")
                return result
            
            # 3. 取得需要通知的用戶
            users_to_notify = self._get_users_to_notify(db, all_signals)
            logger.info(f"需要通知的用戶: {len(users_to_notify)} 人")
            
            # 4. 發送通知
            for user_id, user_data in users_to_notify.items():
                try:
                    success = self._send_notification(db, user_data)
                    if success:
                        result["notifications_sent"] += 1
                except Exception as e:
                    logger.error(f"發送通知給用戶 {user_id} 失敗: {e}")
                    result["errors"].append(f"notify user {user_id}: {str(e)}")
            
        except Exception as e:
            logger.error(f"訊號偵測失敗: {e}")
            result["errors"].append(str(e))
        
        return result
    
    def _detect_signals_for_symbol(self, symbol: str) -> List:
        """對單一股票偵測訊號"""
        from app.services.indicator_service import indicator_service, SignalType as IndicatorSignalType
        
        # 取得股票資料
        df = yahoo_finance.get_stock_history(symbol, period="3mo")
        
        if df is None or df.empty:
            return []
        
        # 計算指標
        df = indicator_service.calculate_all_indicators(df)
        
        if df is None or df.empty:
            return []
        
        # 取得訊號
        indicator_signals = indicator_service.get_all_signals(df)
        
        if not indicator_signals:
            return []
        
        # 轉換訊號格式（從 indicator_service.Signal 到 signal_service.Signal）
        from app.services.signal_service import Signal, SignalType
        
        signals = []
        current_price = float(df.iloc[-1]['close']) if 'close' in df.columns else 0
        
        # 訊號類型對照
        type_mapping = {
            IndicatorSignalType.GOLDEN_CROSS: SignalType.MA_GOLDEN_CROSS,
            IndicatorSignalType.DEATH_CROSS: SignalType.MA_DEATH_CROSS,
            IndicatorSignalType.RSI_OVERBOUGHT: SignalType.RSI_OVERBOUGHT,
            IndicatorSignalType.RSI_OVERSOLD: SignalType.RSI_OVERSOLD,
            IndicatorSignalType.MACD_GOLDEN_CROSS: SignalType.MACD_GOLDEN_CROSS,
            IndicatorSignalType.MACD_DEATH_CROSS: SignalType.MACD_DEATH_CROSS,
            IndicatorSignalType.KD_GOLDEN_CROSS: SignalType.KD_GOLDEN_CROSS,
            IndicatorSignalType.KD_DEATH_CROSS: SignalType.KD_DEATH_CROSS,
            IndicatorSignalType.APPROACHING_BREAKOUT: SignalType.APPROACHING_BREAKOUT,
            IndicatorSignalType.APPROACHING_BREAKDOWN: SignalType.APPROACHING_BREAKDOWN,
        }
        
        for ind_sig in indicator_signals:
            sig_type = type_mapping.get(ind_sig.type)
            if sig_type:
                signals.append(Signal(
                    symbol=symbol,
                    asset_type="stock",
                    signal_type=sig_type,
                    indicator=ind_sig.indicator,
                    message=ind_sig.description,
                    price=current_price,
                    details={},
                    timestamp=datetime.now(),
                ))
        
        return signals
    
    def _get_users_to_notify(self, db: Session, all_signals: Dict) -> Dict:
        """
        取得需要通知的用戶
        
        Returns:
            {user_id: {
                "line_user_id": "xxx",
                "display_name": "xxx",
                "signals": [...]
            }}
        """
        users_to_notify = {}
        
        # 取得所有用戶和他們的追蹤清單
        stmt = select(User).where(User.is_active == True, User.is_blocked == False)
        users = db.execute(stmt).scalars().all()
        
        for user in users:
            # 取得用戶的追蹤清單
            watchlist_stmt = select(Watchlist.symbol).where(
                Watchlist.user_id == user.id,
                Watchlist.asset_type == "stock"
            )
            user_symbols = set(db.execute(watchlist_stmt).scalars().all())
            
            # 取得用戶的通知設定（檢查是否開啟交叉通知）
            alert_stmt = select(UserAlertSettings).where(UserAlertSettings.user_id == user.id)
            alert_settings = db.execute(alert_stmt).scalar_one_or_none()
            
            # 預設開啟 MA 和 MACD 交叉通知
            alert_ma = True
            alert_macd = True
            alert_kd = False
            alert_rsi = True  # 預設開啟 RSI
            
            if alert_settings:
                alert_ma = alert_settings.alert_ma_cross
                alert_macd = alert_settings.alert_macd
                alert_kd = alert_settings.alert_kd
                alert_rsi = alert_settings.alert_rsi
            
            # 找出用戶追蹤中有訊號的股票
            user_signals = []
            for symbol, signals in all_signals.items():
                if symbol not in user_symbols:
                    continue
                
                for signal in signals:
                    # 檢查用戶是否開啟該類型的通知
                    if signal.signal_type in [SignalType.MA_GOLDEN_CROSS, SignalType.MA_DEATH_CROSS]:
                        if not alert_ma:
                            continue
                    elif signal.signal_type in [SignalType.MACD_GOLDEN_CROSS, SignalType.MACD_DEATH_CROSS]:
                        if not alert_macd:
                            continue
                    elif signal.signal_type in [SignalType.KD_GOLDEN_CROSS, SignalType.KD_DEATH_CROSS]:
                        if not alert_kd:
                            continue
                    elif signal.signal_type in [SignalType.RSI_OVERBOUGHT, SignalType.RSI_OVERSOLD]:
                        if not alert_rsi:
                            continue
                    
                    # 檢查 24 小時內是否已通知過
                    if self._has_recent_notification(db, user.id, symbol, signal.signal_type.value):
                        continue
                    
                    user_signals.append(signal)
            
            if user_signals:
                users_to_notify[user.id] = {
                    "user_id": user.id,
                    "line_user_id": user.line_user_id,
                    "display_name": user.display_name,
                    "signals": user_signals,
                }
        
        return users_to_notify
    
    def _has_recent_notification(self, db: Session, user_id: int, symbol: str, alert_type: str) -> bool:
        """檢查 24 小時內是否已發送過相同通知"""
        cutoff = datetime.now() - timedelta(hours=24)
        
        stmt = select(Notification).where(
            Notification.user_id == user_id,
            Notification.symbol == symbol,
            Notification.alert_type == alert_type,
            Notification.triggered_at >= cutoff,
        )
        
        existing = db.execute(stmt).scalar_one_or_none()
        return existing is not None
    
    def _send_notification(self, db: Session, user_data: Dict) -> bool:
        """發送通知給用戶"""
        from app.services.line_notify_service import line_notify_service
        
        line_user_id = user_data["line_user_id"]
        signals = user_data["signals"]
        
        if not line_user_id or not signals:
            return False
        
        # 分類訊號
        bullish = []
        bearish = []
        
        for signal in signals:
            signal_name = signal_service.SIGNAL_NAMES.get(signal.signal_type, str(signal.signal_type))
            item = {
                "symbol": signal.symbol,
                "signal": signal_name,
                "price": signal.price,
                "signal_type": signal.signal_type.value,
            }
            
            # 判斷多空
            if signal.signal_type in [
                SignalType.MA_GOLDEN_CROSS, 
                SignalType.MACD_GOLDEN_CROSS, 
                SignalType.KD_GOLDEN_CROSS,
                SignalType.RSI_OVERSOLD,
            ]:
                bullish.append(item)
            else:
                bearish.append(item)
        
        # 格式化訊息
        message = self._format_notification_message(bullish, bearish)
        
        # 發送訊息（使用 asyncio 執行）
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            success = loop.run_until_complete(
                line_notify_service.push_text_message(line_user_id, message)
            )
            loop.close()
        except Exception as e:
            logger.error(f"發送 LINE 訊息失敗: {e}")
            success = False
        
        # 記錄通知
        for signal in signals:
            notification = Notification(
                user_id=user_data.get("user_id"),
                symbol=signal.symbol,
                asset_type=signal.asset_type,
                alert_type=signal.signal_type.value,
                indicator=signal.indicator,
                message=signal.message,
                price_at_trigger=signal.price,
                sent=success,
                sent_at=datetime.now() if success else None,
            )
            db.add(notification)
        
        db.commit()
        
        return success
    
    def _format_notification_message(self, bullish: List[Dict], bearish: List[Dict]) -> str:
        """格式化每日訊號通知訊息"""
        lines = ["📊 SELA 選股系統 - 每日訊號", ""]
        
        if bullish:
            lines.append("🟢 偏多訊號")
            for item in bullish:
                price_str = f" @ ${item['price']:.2f}" if item['price'] > 0 else ""
                lines.append(f"  • {item['symbol']}{price_str}")
                lines.append(f"    {item['signal']}")
            lines.append("")
        
        if bearish:
            lines.append("🔴 偏空訊號")
            for item in bearish:
                price_str = f" @ ${item['price']:.2f}" if item['price'] > 0 else ""
                lines.append(f"  • {item['symbol']}{price_str}")
                lines.append(f"    {item['signal']}")
            lines.append("")
        
        if not bullish and not bearish:
            lines.append("今日您的追蹤清單無重要訊號 ✨")
            lines.append("")
        
        lines.append(f"⏰ {datetime.now().strftime('%Y-%m-%d %H:%M')}")
        
        return "\n".join(lines)
    
    def run_signal_detection_only(self) -> Dict[str, Any]:
        """
        只執行訊號偵測（不發送通知）
        用於測試
        """
        logger.info("開始訊號偵測（測試模式）...")
        
        result = {
            "signals": [],
            "by_symbol": {},
        }
        
        db = self._get_db()
        
        try:
            stmt = select(distinct(Watchlist.symbol)).where(Watchlist.asset_type == "stock")
            symbols = db.execute(stmt).scalars().all()
            
            for symbol in symbols:
                try:
                    signals = self._detect_signals_for_symbol(symbol)
                    cross_signals = [s for s in signals if s.signal_type in self.IMPORTANT_SIGNAL_TYPES]
                    
                    if cross_signals:
                        result["by_symbol"][symbol] = [
                            {
                                "type": s.signal_type.value,
                                "message": s.message,
                                "price": s.price,
                            }
                            for s in cross_signals
                        ]
                        result["signals"].extend(cross_signals)
                
                except Exception as e:
                    logger.error(f"{symbol} 偵測失敗: {e}")
        
        finally:
            db.close()
        
        return result

    def _update_watchlist_stocks(self, db: Session) -> Dict[str, Any]:
        """
        更新所有追蹤清單中的股票
        """
        result = {"count": 0, "errors": []}
        
        # 取得所有不重複的追蹤股票
        stmt = select(distinct(Watchlist.symbol)).where(Watchlist.asset_type == "stock")
        symbols = db.execute(stmt).scalars().all()
        
        logger.info(f"需要更新的股票: {len(symbols)} 檔")
        
        for symbol in symbols:
            try:
                # 從 Yahoo Finance 抓取最新資料
                df = yahoo_finance.get_stock_history(symbol, period="5d")
                
                if df is None or df.empty:
                    logger.warning(f"無法取得 {symbol} 的資料")
                    result["errors"].append(f"{symbol}: 無資料")
                    continue
                
                # 儲存到資料庫
                count = self._save_stock_prices(db, df)
                result["count"] += 1
                logger.debug(f"{symbol} 更新完成，新增 {count} 筆")
                
            except Exception as e:
                logger.error(f"更新 {symbol} 失敗: {e}")
                result["errors"].append(f"{symbol}: {str(e)}")
        
        return result
    
    def _save_stock_prices(self, db: Session, df) -> int:
        """儲存股票價格"""
        if df is None or df.empty:
            return 0
        
        count = 0
        for _, row in df.iterrows():
            stmt = select(StockPrice).where(
                and_(
                    StockPrice.symbol == row["symbol"],
                    StockPrice.date == row["date"],
                )
            )
            existing = db.execute(stmt).scalar_one_or_none()
            
            if existing:
                existing.open = row["open"]
                existing.high = row["high"]
                existing.low = row["low"]
                existing.close = row["close"]
                existing.volume = row["volume"]
            else:
                price = StockPrice(
                    symbol=row["symbol"],
                    date=row["date"],
                    open=row["open"],
                    high=row["high"],
                    low=row["low"],
                    close=row["close"],
                    volume=row["volume"],
                )
                db.add(price)
                count += 1
        
        db.commit()
        return count
    
    def _update_indices(self, market_service: MarketService) -> Dict[str, int]:
        """
        更新三大指數（只更新最近 5 天）
        """
        result = {}
        
        for symbol in INDEX_SYMBOLS.keys():
            try:
                df = yahoo_finance.get_index_data(symbol, period="5d")
                if df is not None:
                    count = market_service.save_index_data(df, symbol)
                    result[symbol] = count
                else:
                    result[symbol] = 0
            except Exception as e:
                logger.error(f"更新指數 {symbol} 失敗: {e}")
                result[symbol] = -1
        
        return result
    
    def initialize_historical_data(self, years: int = 10) -> Dict[str, Any]:
        """
        初始化歷史資料（首次執行時使用）
        
        包含：
        1. 三大指數 10 年歷史
        2. 幣圈情緒 365 天歷史
        
        Args:
            years: 指數歷史年數
            
        Returns:
            執行結果
        """
        logger.info("=" * 50)
        logger.info("開始初始化歷史資料")
        logger.info("=" * 50)
        
        result = {
            "start_time": datetime.now().isoformat(),
            "indices": {},
            "crypto_sentiment": 0,
            "errors": [],
        }
        
        db = self._get_db()
        
        try:
            market_service = MarketService(db)
            
            # 1. 初始化三大指數
            logger.info(f"初始化三大指數 ({years} 年資料)...")
            indices_result = market_service.fetch_and_save_all_indices(period=f"{years}y")
            result["indices"] = indices_result
            
            # 2. 初始化幣圈情緒歷史
            logger.info("初始化幣圈情緒歷史 (365 天)...")
            crypto_count = market_service.fetch_and_save_crypto_history(days=365)
            result["crypto_sentiment"] = crypto_count
            
            result["success"] = True
            result["end_time"] = datetime.now().isoformat()
            
            logger.info("=" * 50)
            logger.info("歷史資料初始化完成")
            logger.info(f"指數: {result['indices']}")
            logger.info(f"幣圈情緒: {result['crypto_sentiment']} 筆")
            logger.info("=" * 50)
            
        except Exception as e:
            logger.error(f"初始化失敗: {e}")
            result["errors"].append(str(e))
            result["success"] = False
        finally:
            db.close()
        
        return result
    
    def get_status(self) -> Dict[str, Any]:
        """取得排程狀態"""
        return {
            "last_run": self.last_run.isoformat() if self.last_run else None,
            "last_result": self.last_result,
        }


# 建立全域排程服務實例
scheduler_service = SchedulerService()
```

──────────────────────────────────────────────────────────────────────
### 📄 railway.json  ⭐
──────────────────────────────────────────────────────────────────────

```json
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "uvicorn app.main:app --host 0.0.0.0 --port $PORT",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}
```

──────────────────────────────────────────────────────────────────────
### 📄 RAILWAY_SETUP.md  ⭐
> Railway PostgreSQL 設定指南
──────────────────────────────────────────────────────────────────────

```md
# Railway PostgreSQL 設定指南

## 步驟 1：在 Railway 添加 PostgreSQL

1. 進入你的 Railway 專案
2. 點擊 **New** → **Database** → **Add PostgreSQL**
3. 等待資料庫建立完成

## 步驟 2：取得資料庫連線字串

1. 點擊新建立的 PostgreSQL 服務
2. 進入 **Variables** 標籤
3. 複製 `DATABASE_URL` 的值

格式類似：
```
postgres://username:password@host:port/database
```

## 步驟 3：設定環境變數

在你的 **Web Service** (不是 PostgreSQL) 中設定：

1. 點擊 Web Service → **Variables**
2. 添加以下變數：

```bash
# 資料庫 (從 PostgreSQL 服務複製)
DATABASE_URL=${{Postgres.DATABASE_URL}}

# 或直接貼上完整的連線字串
# DATABASE_URL=postgres://username:password@host:port/database

# 應用程式
APP_ENV=production
DEBUG=false

# LINE Login
LINE_LOGIN_CHANNEL_ID=你的_channel_id
LINE_LOGIN_CHANNEL_SECRET=你的_channel_secret
LINE_LOGIN_CALLBACK_URL=https://你的網域/auth/line/callback

# JWT
JWT_SECRET_KEY=你的隨機密鑰
JWT_EXPIRE_DAYS=7
```

### 使用 Railway 的變數引用（推薦）

Railway 支援在同一專案內引用其他服務的變數：

```bash
DATABASE_URL=${{Postgres.DATABASE_URL}}
```

這樣當資料庫連線資訊變更時，會自動更新。

## 步驟 4：部署

```bash
# 更新代碼
git add .
git commit -m "feat: add PostgreSQL support"
git push
```

Railway 會自動偵測到變更並重新部署。

## 步驟 5：驗證

1. 等待部署完成
2. 檢查日誌，應該看到：
   ```
   Starting SELA 自動選股系統 v0.3.x
   Database initialized
   ```

3. 訪問你的網站測試功能

## 資料庫表格

系統會自動建立以下表格：

| 表格 | 說明 |
|------|------|
| users | 用戶資料 (LINE Login) |
| watchlists | 追蹤清單 |
| stock_prices | 股價快取 |
| crypto_prices | 幣價快取 |
| market_sentiment | 市場情緒 |
| user_indicator_settings | 用戶指標設定 |
| user_alert_settings | 用戶通知設定 |
| user_indicator_params | 用戶參數設定 |
| notifications | 通知記錄 |

## 注意事項

1. **首次部署**：表格會自動建立，不需要手動執行 migration

2. **postgres:// vs postgresql://**：
   - Railway 使用 `postgres://`
   - SQLAlchemy 需要 `postgresql://`
   - 程式已自動處理轉換

3. **連線池**：
   - 使用 `NullPool` 避免連線問題
   - 適合 Railway 的 serverless 環境

## 故障排除

### 連線失敗
- 確認 DATABASE_URL 正確
- 確認 PostgreSQL 服務正在運行

### 表格不存在
- 檢查日誌確認 "Database initialized" 訊息
- 嘗試重新部署

### SSL 錯誤
如果遇到 SSL 錯誤，在 DATABASE_URL 後面加上：
```
?sslmode=require
```
```

──────────────────────────────────────────────────────────────────────
### 📄 runtime.txt  ⭐
──────────────────────────────────────────────────────────────────────

```text
python-3.11.0
```

──────────────────────────────────────────────────────────────────────
### 📄 scripts/匯整子程式.py  ⭐
> 專案整合工具 - 把資料夾結構和程式碼整合成單一檔案
──────────────────────────────────────────────────────────────────────

```py
#!/usr/bin/env python3
"""
專案整合工具 - 把資料夾結構和程式碼整合成單一檔案
用途：上傳到 Claude 專案作為 context
"""

import os
from pathlib import Path
from datetime import datetime

# ===== 設定 =====
IGNORE_DIRS = {'.git', '__pycache__', '.venv', 'venv', 'node_modules', '.idea', '.vscode', 'dist', 'build', '__MACOSX'}
IGNORE_FILES = {'.DS_Store', 'Thumbs.db', '.gitignore', '*.pyc', '*.pyo'}
CODE_EXTENSIONS = {'.py', '.js', '.ts', '.html', '.css', '.json', '.yaml', '.yml', '.md', '.txt', '.sql', '.sh', '.env.example'}
MAX_FILE_SIZE = 100 * 1024  # 100KB，超過的檔案只顯示路徑不顯示內容


def should_ignore(path: Path) -> bool:
    """判斷是否要忽略此路徑"""
    if path.name in IGNORE_DIRS or path.name in IGNORE_FILES:
        return True
    if path.name.startswith('.') and path.name not in {'.env.example'}:
        return True
    return False


def generate_tree(root: Path, prefix: str = "") -> list[str]:
    """產生目錄樹狀圖"""
    lines = []
    items = sorted(root.iterdir(), key=lambda x: (x.is_file(), x.name.lower()))
    items = [x for x in items if not should_ignore(x)]
    
    for i, item in enumerate(items):
        is_last = i == len(items) - 1
        connector = "└── " if is_last else "├── "
        
        if item.is_dir():
            lines.append(f"{prefix}{connector}{item.name}/")
            extension = "    " if is_last else "│   "
            lines.extend(generate_tree(item, prefix + extension))
        else:
            lines.append(f"{prefix}{connector}{item.name}")
    
    return lines


def collect_files(root: Path) -> list[Path]:
    """收集所有程式碼檔案"""
    files = []
    for path in root.rglob('*'):
        if path.is_file() and not should_ignore(path):
            # 檢查父目錄是否在忽略清單
            if any(p.name in IGNORE_DIRS for p in path.parents):
                continue
            if path.suffix.lower() in CODE_EXTENSIONS or path.name in {'Dockerfile', 'Makefile', 'requirements.txt', 'Procfile'}:
                files.append(path)
    return sorted(files, key=lambda x: str(x).lower())


def bundle_project(target_dir: str, output_file: str = None):
    """主程式：整合專案"""
    root = Path(target_dir).resolve()
    
    if not root.exists():
        print(f"❌ 找不到資料夾: {root}")
        return
    
    if output_file is None:
        output_file = f"{root.name}_bundle.txt"
    
    output_path = Path(output_file).resolve()
    
    with open(output_path, 'w', encoding='utf-8') as out:
        # 標題
        out.write(f"{'='*70}\n")
        out.write(f"專案名稱: {root.name}\n")
        out.write(f"整合時間: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        out.write(f"{'='*70}\n\n")
        
        # 目錄結構
        out.write("## 目錄結構\n\n")
        out.write("```\n")
        out.write(f"{root.name}/\n")
        for line in generate_tree(root):
            out.write(f"{line}\n")
        out.write("```\n\n")
        
        # 檔案內容
        out.write(f"{'='*70}\n")
        out.write("## 檔案內容\n")
        out.write(f"{'='*70}\n\n")
        
        files = collect_files(root)
        
        for filepath in files:
            rel_path = filepath.relative_to(root)
            out.write(f"\n{'─'*70}\n")
            out.write(f"### {rel_path}\n")
            out.write(f"{'─'*70}\n\n")
            
            # 檢查檔案大小
            if filepath.stat().st_size > MAX_FILE_SIZE:
                out.write(f"（檔案過大，略過內容：{filepath.stat().st_size / 1024:.1f} KB）\n")
                continue
            
            try:
                content = filepath.read_text(encoding='utf-8')
                # 根據副檔名加上 code block
                lang = filepath.suffix.lstrip('.') or 'text'
                if lang == 'txt':
                    lang = 'text'
                out.write(f"```{lang}\n")
                out.write(content)
                if not content.endswith('\n'):
                    out.write('\n')
                out.write("```\n")
            except UnicodeDecodeError:
                out.write("（二進位檔案，略過）\n")
            except Exception as e:
                out.write(f"（讀取錯誤：{e}）\n")
        
        # 統計
        out.write(f"\n{'='*70}\n")
        out.write(f"## 統計\n")
        out.write(f"共 {len(files)} 個檔案\n")
        out.write(f"{'='*70}\n")
    
    print(f"✅ 完成！輸出檔案: {output_path}")
    print(f"   共整合 {len(files)} 個檔案")


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        # 預設使用目前目錄
        target = "."
    else:
        target = sys.argv[1]
    
    output = sys.argv[2] if len(sys.argv) > 2 else None
    bundle_project(target, output)
```

──────────────────────────────────────────────────────────────────────
### 📄 匯整專案 V2 .py  ⭐
> 專案整合工具 v2 - 智能分層整理
──────────────────────────────────────────────────────────────────────

```py
#!/usr/bin/env python3
"""
專案整合工具 v2 - 智能分層整理
用途：上傳到 Claude 專案作為 context，結構化便於閱讀
"""

import os
import re
from pathlib import Path
from datetime import datetime
from collections import defaultdict

# ===== 設定 =====
IGNORE_DIRS = {'.git', '__pycache__', '.venv', 'venv', 'node_modules', '.idea', '.vscode', 'dist', 'build', '__MACOSX', '.pytest_cache', 'htmlcov'}
IGNORE_FILES = {'.DS_Store', 'Thumbs.db', '*.pyc', '*.pyo', '*.so', '*.egg-info'}
CODE_EXTENSIONS = {'.py', '.js', '.ts', '.jsx', '.tsx', '.html', '.css', '.json', '.yaml', '.yml', '.md', '.txt', '.sql', '.sh', '.env.example', '.toml'}
MAX_FILE_SIZE = 100 * 1024  # 100KB

# ===== 分層定義 =====
# 優先順序：數字越小越前面
LAYER_RULES = {
    # 第 1 層：專案概述
    'overview': {
        'order': 1,
        'title': '📋 專案概述',
        'patterns': ['README*', 'CHANGELOG*', 'LICENSE*', 'docs/*', 'doc/*'],
        'files': {
            # 基本
            'readme.md', 'readme.txt', 'changelog.md', 'license', 'license.md',
            # 開發文檔
            'troubleshooting.md', 'trouble_shooting.md', 'faq.md',
            'architecture.md', 'design.md', 'structure.md',
            'setup.md', 'install.md', 'installation.md',
            'development.md', 'dev.md', 'dev_notes.md', 'notes.md',
            'deployment.md', 'deploy.md',
            'contributing.md', 'contribute.md',
            'api.md', 'api_docs.md', 'endpoints.md',
            'todo.md', 'roadmap.md', 'plan.md',
            'guide.md', 'usage.md', 'manual.md',
            # 中文常見
            '說明.md', '開發筆記.md', '問題排解.md', '架構.md',
        },
    },
    # 第 2 層：設定檔
    'config': {
        'order': 2,
        'title': '⚙️ 設定檔',
        'patterns': ['*.toml', '*.yaml', '*.yml', '.env*', 'config/*', 'settings/*'],
        'files': {'pyproject.toml', 'package.json', 'requirements.txt', 'dockerfile', 'docker-compose.yml', 'makefile', 'procfile', '.env.example', 'config.py', 'settings.py'},
    },
    # 第 3 層：進入點
    'entry': {
        'order': 3,
        'title': '🚀 程式進入點',
        'patterns': [],
        'files': {'main.py', 'app.py', 'index.py', 'server.py', 'run.py', 'index.js', 'index.ts', 'app.js', 'server.js'},
    },
    # 第 4 層：路由/API
    'api': {
        'order': 4,
        'title': '🌐 API / 路由',
        'patterns': ['routes/*', 'routers/*', 'api/*', 'endpoints/*', 'views/*'],
        'files': {'routes.py', 'router.py', 'api.py', 'urls.py'},
    },
    # 第 5 層：資料模型
    'models': {
        'order': 5,
        'title': '📦 資料模型',
        'patterns': ['models/*', 'schemas/*', 'entities/*', 'types/*'],
        'files': {'models.py', 'schemas.py', 'database.py', 'db.py'},
    },
    # 第 6 層：核心邏輯
    'core': {
        'order': 6,
        'title': '🧠 核心邏輯',
        'patterns': ['core/*', 'services/*', 'handlers/*', 'controllers/*', 'lib/*'],
        'files': {'service.py', 'services.py', 'handler.py', 'controller.py'},
    },
    # 第 7 層：工具/輔助
    'utils': {
        'order': 7,
        'title': '🔧 工具 / 輔助',
        'patterns': ['utils/*', 'helpers/*', 'common/*', 'shared/*'],
        'files': {'utils.py', 'helpers.py', 'common.py', 'tools.py'},
    },
    # 第 8 層：前端/靜態
    'frontend': {
        'order': 8,
        'title': '🎨 前端 / 靜態資源',
        'patterns': ['static/*', 'public/*', 'templates/*', 'assets/*', 'frontend/*', 'src/*'],
        'files': set(),
        'extensions': {'.html', '.css', '.js', '.jsx', '.tsx', '.vue', '.svelte'},
    },
    # 第 9 層：測試
    'tests': {
        'order': 9,
        'title': '🧪 測試',
        'patterns': ['tests/*', 'test/*', '__tests__/*', 'spec/*'],
        'files': set(),
    },
    # 第 10 層：其他
    'other': {
        'order': 99,
        'title': '📁 其他檔案',
        'patterns': [],
        'files': set(),
    },
}


def should_ignore(path: Path) -> bool:
    """判斷是否要忽略此路徑"""
    name = path.name
    if name in IGNORE_DIRS or name in IGNORE_FILES:
        return True
    if name.startswith('.') and name not in {'.env.example', '.gitignore'}:
        return True
    for pattern in IGNORE_FILES:
        if '*' in pattern and name.endswith(pattern.replace('*', '')):
            return True
    return False


def match_pattern(rel_path: str, patterns: list) -> bool:
    """檢查路徑是否符合 pattern"""
    rel_lower = rel_path.lower()
    for pattern in patterns:
        pattern_lower = pattern.lower()
        if pattern_lower.endswith('/*'):
            # 資料夾 pattern
            folder = pattern_lower[:-2]
            if rel_lower.startswith(folder + '/') or ('/' + folder + '/') in rel_lower:
                return True
        elif '*' in pattern_lower:
            # 萬用字元
            regex = pattern_lower.replace('*', '.*')
            if re.match(regex, rel_lower):
                return True
        else:
            if rel_lower == pattern_lower:
                return True
    return False


def classify_file(filepath: Path, root: Path) -> str:
    """分類檔案到對應層級"""
    rel_path = str(filepath.relative_to(root))
    filename = filepath.name.lower()
    ext = filepath.suffix.lower()
    
    for layer_id, layer in LAYER_RULES.items():
        # 1. 檢查檔名
        if filename in layer['files']:
            return layer_id
        
        # 2. 檢查路徑 pattern
        if match_pattern(rel_path, layer['patterns']):
            return layer_id
        
        # 3. 檢查副檔名（僅 frontend 層）
        if layer_id == 'frontend' and ext in layer.get('extensions', set()):
            # 但要排除已經被其他規則匹配的
            if '/static/' in rel_path.lower() or '/templates/' in rel_path.lower() or '/public/' in rel_path.lower():
                return layer_id
    
    # 特殊判斷：test 檔案
    if 'test' in filename or filename.startswith('test_') or filename.endswith('_test.py'):
        return 'tests'
    
    return 'other'


def generate_tree(root: Path, prefix: str = "") -> list[str]:
    """產生目錄樹狀圖"""
    lines = []
    try:
        items = sorted(root.iterdir(), key=lambda x: (x.is_file(), x.name.lower()))
    except PermissionError:
        return lines
    
    items = [x for x in items if not should_ignore(x)]
    
    for i, item in enumerate(items):
        is_last = i == len(items) - 1
        connector = "└── " if is_last else "├── "
        
        if item.is_dir():
            lines.append(f"{prefix}{connector}{item.name}/")
            extension = "    " if is_last else "│   "
            lines.extend(generate_tree(item, prefix + extension))
        else:
            lines.append(f"{prefix}{connector}{item.name}")
    
    return lines


def collect_files(root: Path) -> list[Path]:
    """收集所有程式碼檔案"""
    files = []
    for path in root.rglob('*'):
        if path.is_file() and not should_ignore(path):
            if any(p.name in IGNORE_DIRS for p in path.parents):
                continue
            if path.suffix.lower() in CODE_EXTENSIONS or path.name.lower() in {'dockerfile', 'makefile', 'requirements.txt', 'procfile', 'license'}:
                files.append(path)
    return files


def estimate_importance(filepath: Path, layer: str) -> str:
    """估算檔案重要度"""
    filename = filepath.name.lower()
    
    # 高重要度
    if layer in ('entry', 'overview'):
        return '⭐⭐⭐'
    if layer == 'config' and filename in {'pyproject.toml', 'package.json', 'requirements.txt'}:
        return '⭐⭐⭐'
    if layer == 'api':
        return '⭐⭐⭐'
    if layer == 'models':
        return '⭐⭐'
    if layer == 'core':
        return '⭐⭐⭐'
    
    # 中重要度
    if layer in ('config', 'models'):
        return '⭐⭐'
    
    # 低重要度
    if layer in ('utils', 'tests', 'other'):
        return '⭐'
    if layer == 'frontend':
        return '⭐'
    
    return '⭐'


def get_file_description(filepath: Path) -> str:
    """嘗試從檔案取得描述（docstring 或第一行註解）"""
    try:
        content = filepath.read_text(encoding='utf-8')
        lines = content.split('\n')
        
        # Python docstring
        if filepath.suffix == '.py':
            for i, line in enumerate(lines[:10]):
                if '"""' in line or "'''" in line:
                    # 單行 docstring
                    match = re.search(r'["\'\s]{3}(.+?)["\'\s]{3}', line)
                    if match:
                        return match.group(1).strip()[:60]
                    # 多行 docstring
                    for j in range(i+1, min(i+5, len(lines))):
                        if lines[j].strip() and not lines[j].strip().startswith(('"""', "'''")):
                            return lines[j].strip()[:60]
                    break
        
        # 第一行註解
        for line in lines[:5]:
            line = line.strip()
            if line.startswith('#') and len(line) > 2:
                return line[1:].strip()[:60]
            if line.startswith('//') and len(line) > 3:
                return line[2:].strip()[:60]
            if line.startswith('/*'):
                return line[2:].replace('*/', '').strip()[:60]
    except:
        pass
    return ''


def bundle_project(target_dir: str, output_file: str = None, split_output: bool = False):
    """主程式：整合專案"""
    root = Path(target_dir).resolve()
    
    if not root.exists():
        print(f"❌ 找不到資料夾: {root}")
        return
    
    if output_file is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M')
        output_file = f"{root.name}_bundle_{timestamp}.txt"
    
    output_path = Path(output_file).resolve()
    
    # 收集並分類檔案
    all_files = collect_files(root)
    layers = defaultdict(list)
    
    for f in all_files:
        layer = classify_file(f, root)
        layers[layer].append(f)
    
    # 排序每層內的檔案
    for layer in layers:
        layers[layer].sort(key=lambda x: str(x).lower())
    
    # 開始輸出
    with open(output_path, 'w', encoding='utf-8') as out:
        # ===== 標題 =====
        out.write(f"{'='*70}\n")
        out.write(f"# 專案：{root.name}\n")
        out.write(f"# 整合時間：{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        out.write(f"# 檔案數量：{len(all_files)}\n")
        out.write(f"{'='*70}\n\n")
        
        # ===== 目錄結構 =====
        out.write("## 📂 目錄結構\n\n")
        out.write("```\n")
        out.write(f"{root.name}/\n")
        for line in generate_tree(root):
            out.write(f"{line}\n")
        out.write("```\n\n")
        
        # ===== 檔案索引 =====
        out.write(f"{'='*70}\n")
        out.write("## 📑 檔案索引\n\n")
        out.write("| 層級 | 檔案 | 說明 | 重要度 |\n")
        out.write("|------|------|------|--------|\n")
        
        sorted_layers = sorted(LAYER_RULES.items(), key=lambda x: x[1]['order'])
        for layer_id, layer_info in sorted_layers:
            if layer_id not in layers:
                continue
            for f in layers[layer_id]:
                rel = f.relative_to(root)
                desc = get_file_description(f)
                importance = estimate_importance(f, layer_id)
                layer_emoji = layer_info['title'].split()[0]
                out.write(f"| {layer_emoji} | `{rel}` | {desc} | {importance} |\n")
        out.write("\n")
        
        # ===== 分層內容 =====
        for layer_id, layer_info in sorted_layers:
            if layer_id not in layers:
                continue
            
            out.write(f"\n{'='*70}\n")
            out.write(f"## {layer_info['title']}\n")
            out.write(f"{'='*70}\n")
            
            for filepath in layers[layer_id]:
                rel_path = filepath.relative_to(root)
                importance = estimate_importance(filepath, layer_id)
                desc = get_file_description(filepath)
                
                out.write(f"\n{'─'*70}\n")
                out.write(f"### 📄 {rel_path}  {importance}\n")
                if desc:
                    out.write(f"> {desc}\n")
                out.write(f"{'─'*70}\n\n")
                
                # 檢查檔案大小
                if filepath.stat().st_size > MAX_FILE_SIZE:
                    out.write(f"⚠️ 檔案過大，略過內容（{filepath.stat().st_size / 1024:.1f} KB）\n")
                    continue
                
                try:
                    content = filepath.read_text(encoding='utf-8')
                    lang = filepath.suffix.lstrip('.') or 'text'
                    lang_map = {'txt': 'text', 'yml': 'yaml'}
                    lang = lang_map.get(lang, lang)
                    
                    out.write(f"```{lang}\n")
                    out.write(content)
                    if not content.endswith('\n'):
                        out.write('\n')
                    out.write("```\n")
                except UnicodeDecodeError:
                    out.write("⚠️ 二進位檔案，略過\n")
                except Exception as e:
                    out.write(f"⚠️ 讀取錯誤：{e}\n")
        
        # ===== 統計 =====
        out.write(f"\n{'='*70}\n")
        out.write("## 📊 統計\n\n")
        for layer_id, layer_info in sorted_layers:
            if layer_id in layers:
                out.write(f"- {layer_info['title']}：{len(layers[layer_id])} 個檔案\n")
        out.write(f"\n**總計：{len(all_files)} 個檔案**\n")
        out.write(f"{'='*70}\n")
    
    print(f"✅ 完成！輸出檔案: {output_path}")
    print(f"   共整合 {len(all_files)} 個檔案")
    print(f"\n📊 分層統計:")
    for layer_id, layer_info in sorted_layers:
        if layer_id in layers:
            print(f"   {layer_info['title']}：{len(layers[layer_id])} 個")


if __name__ == "__main__":
    import sys
    
    print("=" * 50)
    print("📦 專案整合工具 v2")
    print("=" * 50)
    
    if len(sys.argv) < 2:
        target = "."
        print(f"使用目前目錄: {Path(target).resolve()}")
    else:
        target = sys.argv[1]
    
    output = sys.argv[2] if len(sys.argv) > 2 else None
    bundle_project(target, output)
```

======================================================================
## 📊 統計

- 📋 專案概述：2 個檔案
- ⚙️ 設定檔：4 個檔案
- 🚀 程式進入點：1 個檔案
- 🌐 API / 路由：9 個檔案
- 📦 資料模型：15 個檔案
- 🧠 核心邏輯：13 個檔案
- 🎨 前端 / 靜態資源：8 個檔案
- 📁 其他檔案：15 個檔案

**總計：67 個檔案**
======================================================================
