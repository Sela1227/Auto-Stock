======================================================================
# 專案：自動選股系統
# 整合時間：2026-01-15 20:00:04
# 檔案數量：96
======================================================================

## 📂 目錄結構

```
自動選股系統/
├── app/
│   ├── data_sources/
│   │   ├── __init__.py
│   │   ├── coingecko.py
│   │   ├── fear_greed.py
│   │   ├── taiwan_stocks.py
│   │   └── yahoo_finance.py
│   ├── models/
│   │   ├── __init__.py
│   │   ├── comparison.py
│   │   ├── crypto_price.py
│   │   ├── dividend_history.py
│   │   ├── index_price.py
│   │   ├── market_sentiment.py
│   │   ├── notification.py
│   │   ├── portfolio.py
│   │   ├── price_cache.py
│   │   ├── stock_price.py
│   │   ├── subscription.py
│   │   ├── user.py
│   │   ├── user_settings.py
│   │   └── watchlist.py
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── admin.py
│   │   ├── auth.py
│   │   ├── compare.py
│   │   ├── crypto.py
│   │   ├── market.py
│   │   ├── portfolio.py
│   │   ├── settings.py
│   │   ├── stock.py
│   │   ├── subscription.py
│   │   └── watchlist.py
│   ├── schemas/
│   │   ├── __init__.py
│   │   └── schemas.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── auth_service.py
│   │   ├── cache_helper.py
│   │   ├── chart_service.py
│   │   ├── compare_service.py
│   │   ├── compare_service_patch.py
│   │   ├── crypto_service.py
│   │   ├── exchange_rate_service.py
│   │   ├── indicator_service.py
│   │   ├── line_notify_service.py
│   │   ├── market_service.py
│   │   ├── notification_service.py
│   │   ├── portfolio_service.py
│   │   ├── price_cache_service.py
│   │   ├── rss_fetcher.py
│   │   ├── signal_service.py
│   │   ├── stock_service.py
│   │   ├── subscription_service.py
│   │   └── watchlist_service.py
│   ├── tasks/
│   │   ├── __init__.py
│   │   ├── price_cache_task.py
│   │   ├── scheduler.py
│   │   └── subscription_tasks.py
│   ├── utils/
│   │   └── migrations.py
│   ├── __init__.py
│   ├── cli.py
│   ├── config.py
│   ├── database.py
│   ├── logging_config.py
│   └── main.py
├── docs/
│   ├── 20260113-007-portfolio-v2.md
│   ├── 20260113-007-portfolio-v3.md
│   ├── 20260113-007-portfolio.md
│   ├── 20260114-008-query-cache.md
│   ├── 20260114-011-subscription-feature.md
│   ├── main_py_patch.txt
│   ├── README-1.md
│   ├── README-2.md
│   ├── SELA-01-BUG修復指南.md
│   ├── SELA-02-功能整合指南.md
│   ├── SELA-03-系統規格書.md
│   └── SELA-Bug修復記錄.md
├── fixes/
│   └── taiwan_stock_names_fix.py
├── for_Claude_20260115_2000/
│   └── 自動選股系統_bundle_20260115_2000.txt
├── frontend/
│   └── watchlist_with_cache.js
├── migrations/
│   └── add_target_price.sql
├── scripts/
│   └── 匯整子程式.py
├── static/
│   ├── css/
│   │   └── settings.css
│   ├── js/
│   │   ├── settings.js
│   │   └── watchlist-enhanced.js
│   ├── admin.html
│   ├── compare-nav.js
│   ├── compare.html
│   ├── dashboard-mobile.html
│   ├── dashboard.html
│   ├── index.html
│   ├── logo.png
│   └── settings-section.html
├── 更新檔/
├── .gitignore
├── CHANGELOG.md
├── Procfile
├── railway.json
├── RAILWAY_SETUP.md
├── README.md
├── requirements.txt
├── runtime.txt
└── 匯整專案 V3.py
```

======================================================================
## 📑 檔案索引

| 層級 | 檔案 | 說明 | 重要度 |
|------|------|------|--------|
| 📋 | `CHANGELOG.md` | Changelog | ⭐⭐⭐ |
| 📋 | `docs/20260113-007-portfolio-v2.md` | 💼 SELA 更新包 - 個人投資記錄 | ⭐⭐⭐ |
| 📋 | `docs/20260113-007-portfolio-v3.md` | 💼 SELA 更新包 - 個人投資記錄 v3 | ⭐⭐⭐ |
| 📋 | `docs/20260113-007-portfolio.md` | 💼 SELA 更新包 - 投資組合管理 | ⭐⭐⭐ |
| 📋 | `docs/20260114-008-query-cache.md` | 查詢結果快取功能 | ⭐⭐⭐ |
| 📋 | `docs/20260114-011-subscription-feature.md` | SELA 訂閱精選功能 | ⭐⭐⭐ |
| 📋 | `docs/main_py_patch.txt` | ============================================================ | ⭐⭐⭐ |
| 📋 | `docs/README-1.md` | SELA 更新包 20260114 | ⭐⭐⭐ |
| 📋 | `docs/README-2.md` | SELA 更新包 20260114 - 排序功能 + MA20 支援 | ⭐⭐⭐ |
| 📋 | `docs/SELA-01-BUG修復指南.md` | 🔧 SELA Bug 修復指南 | ⭐⭐⭐ |
| 📋 | `docs/SELA-02-功能整合指南.md` | 🚀 SELA 功能整合指南 | ⭐⭐⭐ |
| 📋 | `docs/SELA-03-系統規格書.md` | 📈 SELA 系統規格書（精簡版） | ⭐⭐⭐ |
| 📋 | `docs/SELA-Bug修復記錄.md` | SELA 選股系統 - Bug 修復記錄 | ⭐⭐⭐ |
| 📋 | `README.md` | SELA 部署包 2026-01-15 | ⭐⭐⭐ |
| ⚙️ | `app/config.py` | 應用程式設定檔 | ⭐⭐ |
| ⚙️ | `app/routers/settings.py` | 設定管理 API 路由 | ⭐⭐ |
| ⚙️ | `Procfile` |  | ⭐⭐ |
| ⚙️ | `requirements.txt` | Core Framework | ⭐⭐⭐ |
| 🚀 | `app/main.py` | FastAPI 主程式 | ⭐⭐⭐ |
| 🌐 | `app/routers/__init__.py` | API 路由模組 | ⭐⭐⭐ |
| 🌐 | `app/routers/admin.py` | 管理員 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/auth.py` | 認證 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/compare.py` | 報酬率比較 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/crypto.py` | 加密貨幣和市場情緒 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/market.py` | 市場資料 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/portfolio.py` | 個人投資記錄 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/stock.py` | 股票查詢 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/subscription.py` | 訂閱精選 API 路由 | ⭐⭐⭐ |
| 🌐 | `app/routers/watchlist.py` | 追蹤清單 API 路由 | ⭐⭐⭐ |
| 📦 | `app/database.py` | 資料庫連線與 Session 管理 | ⭐⭐ |
| 📦 | `app/models/__init__.py` | 資料模型 | ⭐⭐ |
| 📦 | `app/models/comparison.py` | 報酬率比較組合 Model | ⭐⭐ |
| 📦 | `app/models/crypto_price.py` | 加密貨幣價格歷史資料模型 | ⭐⭐ |
| 📦 | `app/models/dividend_history.py` | 股票配息歷史資料模型 | ⭐⭐ |
| 📦 | `app/models/index_price.py` | 市場指數價格歷史資料模型 | ⭐⭐ |
| 📦 | `app/models/market_sentiment.py` | 市場情緒指數資料模型 | ⭐⭐ |
| 📦 | `app/models/notification.py` | 通知記錄資料模型 | ⭐⭐ |
| 📦 | `app/models/portfolio.py` | 個人投資記錄模型 | ⭐⭐ |
| 📦 | `app/models/price_cache.py` | 股票價格快取 Model | ⭐⭐ |
| 📦 | `app/models/stock_price.py` | 股票價格歷史資料模型 | ⭐⭐ |
| 📦 | `app/models/subscription.py` | 訂閱精選相關 Model | ⭐⭐ |
| 📦 | `app/models/user.py` | 用戶資料模型 | ⭐⭐ |
| 📦 | `app/models/user_settings.py` | 用戶設定資料模型 | ⭐⭐ |
| 📦 | `app/models/watchlist.py` | 追蹤清單資料模型 | ⭐⭐ |
| 📦 | `app/schemas/__init__.py` | Pydantic Schemas | ⭐⭐ |
| 📦 | `app/schemas/schemas.py` | Pydantic Schemas | ⭐⭐ |
| 🧠 | `app/services/__init__.py` | 商業邏輯服務模組 | ⭐⭐⭐ |
| 🧠 | `app/services/auth_service.py` | 認證服務 | ⭐⭐⭐ |
| 🧠 | `app/services/cache_helper.py` | 價格快取輔助模組 | ⭐⭐⭐ |
| 🧠 | `app/services/chart_service.py` | 圖表繪製服務 | ⭐⭐⭐ |
| 🧠 | `app/services/compare_service.py` | 報酬率比較服務 | ⭐⭐⭐ |
| 🧠 | `app/services/compare_service_patch.py` | compare_service.py 台股名稱修復補丁 | ⭐⭐⭐ |
| 🧠 | `app/services/crypto_service.py` | 加密貨幣服務 | ⭐⭐⭐ |
| 🧠 | `app/services/exchange_rate_service.py` | 匯率服務 | ⭐⭐⭐ |
| 🧠 | `app/services/indicator_service.py` | 技術指標計算服務 | ⭐⭐⭐ |
| 🧠 | `app/services/line_notify_service.py` | LINE Messaging API 推播服務 | ⭐⭐⭐ |
| 🧠 | `app/services/market_service.py` | 市場服務 | ⭐⭐⭐ |
| 🧠 | `app/services/notification_service.py` | 通知管理服務 | ⭐⭐⭐ |
| 🧠 | `app/services/portfolio_service.py` | 投資組合業務邏輯服務 | ⭐⭐⭐ |
| 🧠 | `app/services/price_cache_service.py` | 價格快取服務 | ⭐⭐⭐ |
| 🧠 | `app/services/rss_fetcher.py` | 訂閱源爬蟲服務 | ⭐⭐⭐ |
| 🧠 | `app/services/signal_service.py` | 訊號偵測服務 | ⭐⭐⭐ |
| 🧠 | `app/services/stock_service.py` | 股票服務 | ⭐⭐⭐ |
| 🧠 | `app/services/subscription_service.py` | 訂閱精選服務 | ⭐⭐⭐ |
| 🧠 | `app/services/watchlist_service.py` | 追蹤清單服務 (Async 版本) | ⭐⭐⭐ |
| 🔧 | `app/utils/migrations.py` | 資料庫自動遷移 | ⭐ |
| 🎨 | `frontend/watchlist_with_cache.js` | ========== 追蹤清單 - 使用快取版本 ========== | ⭐ |
| 🎨 | `static/admin.html` |  | ⭐ |
| 🎨 | `static/compare-nav.js` | * | ⭐ |
| 🎨 | `static/compare.html` |  | ⭐ |
| 🎨 | `static/css/settings.css` | * | ⭐ |
| 🎨 | `static/dashboard-mobile.html` |  | ⭐ |
| 🎨 | `static/dashboard.html` |  | ⭐ |
| 🎨 | `static/index.html` |  | ⭐ |
| 🎨 | `static/js/settings.js` | * | ⭐ |
| 🎨 | `static/js/watchlist-enhanced.js` | * | ⭐ |
| 🎨 | `static/settings-section.html` |  | ⭐ |
| 📁 | `app/__init__.py` | Stock Analysis System | ⭐ |
| 📁 | `app/cli.py` | 股票分析系統 CLI | ⭐ |
| 📁 | `app/data_sources/__init__.py` | 外部資料來源模組 | ⭐ |
| 📁 | `app/data_sources/coingecko.py` | CoinGecko API 資料來源 | ⭐ |
| 📁 | `app/data_sources/fear_greed.py` | 市場情緒指數資料來源 | ⭐ |
| 📁 | `app/data_sources/taiwan_stocks.py` | 台股名稱對照表 | ⭐ |
| 📁 | `app/data_sources/yahoo_finance.py` | Yahoo Finance Ã¨Â³â€¡Ã¦â€“â„¢Ã¤Â¾â€ Ã¦ÂºÂ | ⭐ |
| 📁 | `app/logging_config.py` | 日誌設定 | ⭐ |
| 📁 | `app/tasks/__init__.py` | 排程任務模組 | ⭐ |
| 📁 | `app/tasks/price_cache_task.py` | 價格快取排程任務 | ⭐ |
| 📁 | `app/tasks/scheduler.py` | 排程任務服務 | ⭐ |
| 📁 | `app/tasks/subscription_tasks.py` | 訂閱精選排程任務 | ⭐ |
| 📁 | `fixes/taiwan_stock_names_fix.py` | ============================================================ | ⭐ |
| 📁 | `migrations/add_target_price.sql` |  | ⭐ |
| 📁 | `railway.json` |  | ⭐ |
| 📁 | `RAILWAY_SETUP.md` | Railway PostgreSQL 設定指南 | ⭐ |
| 📁 | `runtime.txt` |  | ⭐ |
| 📁 | `scripts/匯整子程式.py` | 專案整合工具 - 把資料夾結構和程式碼整合成單一檔案 | ⭐ |
| 📁 | `匯整專案 V3.py` | 專案整合工具 v2 - 智能分層整理 | ⭐ |


======================================================================
## 📋 專案概述
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 CHANGELOG.md  ⭐⭐⭐
> Changelog
──────────────────────────────────────────────────────────────────────

```md
# Changelog

所有重要的變更都會記錄在此文件中。

格式基於 [Keep a Changelog](https://keepachangelog.com/zh-TW/1.0.0/)，
版本號遵循 [Semantic Versioning](https://semver.org/lang/zh-TW/)。

## [Unreleased]

### Planned
- Phase 5: 錯誤回報系統
- Phase 6: 會員權限系統

## [0.8.2] - 2025-01-08

### Added
- **訊號偵測引擎 (signal_service.py)**
  - 均線訊號：黃金交叉、死亡交叉、接近突破/跌破
  - RSI 訊號：超買 (>70)、超賣 (<30)
  - MACD 訊號：黃金交叉、死亡交叉
  - KD 訊號：黃金交叉、死亡交叉
  - 布林通道訊號：突破上軌、跌破下軌
  - 成交量訊號：量比暴增 (>2 倍)
  - 市場情緒訊號：極度恐懼 (<20)、極度貪婪 (>80)

- **LINE 推播通知服務 (line_notify_service.py)**
  - LINE Messaging API 整合
  - 單一用戶推播 (push_text_message)
  - 多用戶推播 (multicast_text_message，最多 500 人)
  - Flex Message 支援（卡片式訊號通知）
  - 每日訊號彙整報告格式

- **排程任務整合 (scheduler.py)**
  - 訊號偵測整合到每日更新任務
  - 根據用戶追蹤清單偵測訊號
  - 根據用戶通知設定過濾訊號
  - 24 小時內不重複通知同一訊號
  - 通知記錄儲存至 notifications 表

- **管理後台訊號功能**
  - POST /api/admin/signal/detect - 手動偵測訊號（測試）
  - POST /api/admin/signal/notify - 手動發送通知
  - POST /api/admin/signal/test-push - 測試 LINE 推播
  - GET /api/admin/signal/status - 通知系統狀態
  - GET /api/admin/notifications - 通知記錄查詢

- **管理後台登入統計**
  - 顯示總登入次數
  - 顯示每個用戶的登入次數

### Changed
- **年化報酬率簡化**
  - Yahoo Finance 歷史價格為除權息調整後價格
  - 移除重複的「含配息」「配息再投入」計算
  - 只顯示單一「CAGR (年化報酬率)」
  - 前端 UI 簡化為大字顯示 CAGR
  - API 回傳欄位從 price_return/total_return/reinvested_return 改為 cagr

### Fixed
- 修正年化報酬率因使用調整後價格導致的重複計算問題

### Added
- **Phase 3: 走勢比較功能**
  - 新增「走勢比較」頁面
  - 支援最多 5 支股票/指數同時比較
  - 價格正規化為起始日 = 100%
  - 快速選擇按鈕（四大指數、熱門美股、台股、加密貨幣）
  - 時間範圍選擇：1M / 3M / 6M / 1Y
  - 比較結果表格顯示起始價、最新價、漲跌幅
  - API: GET /api/stock/compare/history

- **Phase 4: 年化報酬率計算**
  - 股票查詢結果新增「年化報酬率」按鈕
  - 計算 1Y / 3Y / 5Y / 10Y 年化報酬率
  - 三種計算方式：
    - 價格報酬：純股價漲跌
    - 含配息：股價 + 配息（不再投入）
    - 配息再投入：配息以除息日股價買入更多股數
  - 顯示配息次數、年均殖利率
  - API: GET /api/stock/{symbol}/returns

- **儀表板新增台股加權指數**
  - 支援 ^TWII 台灣加權股價指數
  - 儀表板指數卡片從 3 個增加到 4 個
  - 走勢比較快速選擇新增台積電、鴻海

- **管理後台登入統計**
  - 統計卡片新增「總登入次數」
  - 用戶列表新增「登入次數」欄位
  - API: /api/admin/stats 新增 total_logins
  - API: /api/admin/users 新增 login_count

### Fixed
- **重要：修復歷史股價使用調整後價格的問題**
  - yfinance 預設回傳 auto_adjust=True（配息調整後價格）
  - 改為 auto_adjust=False 取得原始收盤價
  - 影響：年化報酬率、殖利率計算現在使用正確的歷史價格
- 修復指數歷史 API 的 NaN 值 JSON 序列化錯誤
- IndexPrice model to_dict() 加入 NaN/Infinity 檢查
- market_service save_index_data() 儲存前清理無效數值
- 修復走勢比較圖表需要 chartjs-adapter-date-fns
- 修復年化報酬率 yearly_detail 變數未定義錯誤

## [0.7.0] - 2025-01-07

### Added
- **Phase 2: 前端顯示功能**
  - 儀表板頂部三大指數卡片（S&P 500、道瓊工業、納斯達克）
  - 點擊指數卡片開啟全螢幕走勢圖（Modal 視窗）
  - 指數走勢支援 1M/3M/1Y/5Y 時間範圍切換
  - 恐懼貪婪指數點擊開啟全螢幕歷史走勢圖
  - 情緒走勢支援 1M/3M/6M/1Y 時間範圍切換
  - **管理後台市場資料管理區塊**
    - 初始化歷史資料按鈕
    - 更新三大指數按鈕
    - 更新恐懼貪婪指數按鈕
    - 執行每日更新按鈕

### Changed
- 「情緒指數」更名為「恐懼貪婪指數」
- 圖表改為 Modal 全螢幕顯示，解決卡片內嵌顯示問題
- 圖表邊距增加，改善觸控體驗

### Fixed
- 修復 get_latest_indices 回傳格式（List → Dict）
- 加強資料庫錯誤處理，自動 fallback 到 Yahoo Finance API
- 修復指數/情緒走勢圖無法正常顯示的問題

## [0.6.1] - 2025-01-07

### Fixed
- **用戶身份驗證強化**
  - 登入時清除所有舊的 localStorage/sessionStorage 資料，避免 A 用戶看到 B 用戶資料
  - JWT Token 驗證增加 LINE ID 一致性檢查
  - 前端 checkAuth 增加本地與伺服器用戶 ID 比對
  - 所有 API 請求改用統一的 apiRequest 函數，自動帶入驗證
  - **UserResponse schema 加入 is_admin 欄位**（修復管理員權限消失問題）

- **追蹤清單安全性**
  - 追蹤清單刪除時增加 user_id 二次驗證
  - 所有追蹤清單操作加入詳細 log 記錄
  - 前端操作前檢查 currentUser 是否存在

- **日誌系統強化**
  - 新增 logging_config.py 統一日誌設定
  - 認證服務 (auth_service) 完整登入流程 log
  - 追蹤清單服務 (watchlist_service) 操作 log
  - 日誌檔案按日期分類存放於 logs/ 目錄
  - 分離 auth、watchlist 專用日誌檔

### Changed
- auth_service.py: login_with_line() 加入完整 log 記錄
- auth_service.py: get_user_from_token() 加入 LINE ID 一致性驗證
- watchlist_service.py: 所有操作加入詳細 log
- watchlist.py router: 所有端點加入 log 記錄
- dashboard.html: 新增 apiRequest() 統一 API 請求函數
- dashboard.html: 新增 clearAllUserData() 清除用戶資料函數
- main.py: 使用 logging_config.py 初始化日誌系統
- schemas.py: UserResponse 加入 is_admin 欄位

### Added
- app/logging_config.py: 日誌設定模組

## [0.6.0] - 2025-01-07

### Added
- **資料基礎建設 (Phase 1)**
  - 三大指數支援
    - S&P 500 (^GSPC)
    - 道瓊工業 (^DJI)
    - 納斯達克 (^IXIC)
    - IndexPrice 資料模型
    - 10 年歷史資料支援
  - 配息資料
    - DividendHistory 資料模型
    - yfinance 配息抓取
  - 情緒指數歷史
    - 幣圈情緒 365 天歷史抓取
    - 美股情緒每日累積
  - 排程任務服務 (scheduler.py)
    - 每日自動更新股價
    - 每日更新三大指數
    - 每日更新市場情緒
    - 初始化歷史資料功能
  - 市場服務 (market_service.py)
    - 指數資料存取
    - 情緒資料存取
    - 配息資料存取
  - 市場 API 端點 (/api/market)
    - GET /indices - 取得三大指數
    - GET /indices/{symbol}/history - 指數歷史
    - GET /sentiment - 市場情緒
    - GET /sentiment/{market}/history - 情緒歷史
    - POST /admin/update - 手動觸發更新
    - POST /admin/initialize - 初始化歷史資料
    - POST /admin/update-indices - 更新指數
    - POST /admin/update-sentiment - 更新情緒
    - POST /admin/init-crypto-sentiment - 初始化幣圈情緒

### Changed
- stock_service.py 支援 10 年歷史資料
- yahoo_finance.py 新增指數和配息抓取方法
- fear_greed.py 新增歷史資料抓取

## [0.5.3] - 2025-01-06

### Fixed
- 可折疊指標區塊在桌面版無法運作
- 追蹤清單缺少即時價格資訊
- 模板選擇無視覺回饋
- 設定頁面顯示 LINE ID（隱私問題）

### Changed
- 追蹤清單卡片增加即時價格和漲跌幅
- 模板按鈕選中狀態樣式
- 設定頁面改顯示會員等級

## [0.3.0] - 2025-01-05

### Added
- 用戶系統
  - LINE Login 整合
  - JWT Token 認證
  - 用戶資料管理
- 追蹤清單功能
  - 新增/移除追蹤標的
  - 自訂備註
  - 追蹤清單總覽 (含即時價格)
- 個人化設定
  - 指標顯示設定
  - 通知設定
  - 指標參數調整
  - 預設模板 (極簡/標準/完整/短線)
- FastAPI Web API
  - 認證路由 (/auth)
  - 股票查詢 (/api/stock)
  - 加密貨幣查詢 (/api/crypto)
  - 追蹤清單管理 (/api/watchlist)
  - 設定管理 (/api/settings)
  - 市場情緒 (/api/market/sentiment)
  - Swagger 文件 (/docs)
- 資料模型
  - User (用戶)
  - Watchlist (追蹤清單)
  - UserIndicatorSettings (指標設定)
  - UserAlertSettings (通知設定)
  - UserIndicatorParams (參數設定)
  - Notification (通知記錄)

## [0.2.0] - 2025-01-05

### Added
- 圖表繪製服務 (chart_service.py)
  - 價格走勢圖 + 均線 + 布林通道
  - 成交量柱狀圖
  - RSI、MACD、KD 子圖
  - 均線交叉點標記
  - K線圖支援
- 加密貨幣支援
  - CoinGecko API 整合
  - BTC、ETH 價格追蹤
  - 幣圈技術指標 (MA7/25/99)
- 市場情緒指數
  - CNN Fear & Greed Index (美股)
  - Alternative.me (加密貨幣)
- CLI 新增指令
  - `sentiment` - 查詢市場情緒
  - `chart` - 生成技術分析圖表
  - 支援加密貨幣查詢 (BTC, ETH)

### Changed
- CLI 互動模式提示符改為 `代號>`
- 支援同時查詢股票和加密貨幣

## [0.1.0] - 2025-01-05

### Added
- 專案初始化
- Yahoo Finance 股價資料抓取
- SQLite 本地快取機制
- 技術指標計算引擎
  - 移動平均線 (MA20, MA50, MA200)
  - RSI 相對強弱指標
  - MACD 指數平滑異同移動平均
  - KD 隨機指標
  - 布林通道
  - OBV 能量潮指標
  - 成交量分析
- 訊號偵測系統
  - 均線黃金交叉/死亡交叉
  - 接近突破/跌破預警
  - RSI 超買超賣
  - MACD/KD 交叉
- 綜合評分系統
- CLI 命令列查詢介面
  - 互動模式
  - 單次查詢指令
  - 強制更新選項
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/20260113-007-portfolio-v2.md  ⭐⭐⭐
> 💼 SELA 更新包 - 個人投資記錄
──────────────────────────────────────────────────────────────────────

```md
# 💼 SELA 更新包 - 個人投資記錄

> 文件編號: 20260113-007-portfolio-v2  
> 建立日期: 2026-01-13  
> 功能: 功能 2 - 個人交易管理（完整版）

---

## 📦 檔案清單

```
app/
├── main.py                          ← 覆蓋（註冊 router + 匯率排程）
├── models/
│   ├── __init__.py                  ← 覆蓋
│   └── portfolio.py                 ← 新增
├── routers/
│   ├── __init__.py                  ← 覆蓋
│   └── portfolio.py                 ← 新增
└── services/
    ├── exchange_rate_service.py     ← 新增
    └── portfolio_service.py         ← 新增

static/
└── dashboard.html                   ← 覆蓋（含 BTC + 個人投資記錄）
```

---

## ✨ 功能特色

### 1. 台美股分開管理
- 台股區塊：獨立「新增」按鈕，自動加 `.TW` 後綴
- 美股區塊：獨立「新增」按鈕
- 各自統計損益

### 2. 匯率自動更新
- 每天 3 次自動抓取（09:00、12:00、17:00）
- 來源：Yahoo Finance (TWD=X)
- 預設值：32.5（抓取失敗時使用）

### 3. 總覽加總
- 台股 + (美股 × 匯率) = 總計 (TWD)
- 顯示總現值、總損益、報酬率

### 4. 台股張數輸入
- 張數 + 零股 分開輸入
- 自動計算總股數
- 顯示：「1張500股」格式

### 5. 股票名稱自動帶入
- 輸入代碼後 0.5 秒自動查詢
- 名稱欄位唯讀
- 查無股票時無法送出

### 6. 追蹤清單買賣按鈕
- 每個追蹤項目新增「買」「賣」按鈕
- 點擊後自動開啟對應市場 Modal
- 自動帶入代碼和名稱

---

## 🗄️ 資料庫

新增三張表（首次啟動自動建立）：

### portfolio_transactions（交易紀錄）
| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| user_id | INTEGER | 用戶 ID |
| symbol | VARCHAR(20) | 股票代碼 |
| name | VARCHAR(100) | 股票名稱 |
| market | VARCHAR(10) | tw / us |
| transaction_type | VARCHAR(10) | buy / sell |
| quantity | INTEGER | 總股數 |
| price | NUMERIC(12,4) | 成交價 |
| fee | NUMERIC(10,2) | 手續費 |
| tax | NUMERIC(10,2) | 交易稅 |
| transaction_date | DATE | 交易日期 |
| note | TEXT | 備註 |

### portfolio_holdings（持股彙總）
| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| user_id | INTEGER | 用戶 ID |
| symbol | VARCHAR(20) | 股票代碼 |
| name | VARCHAR(100) | 股票名稱 |
| market | VARCHAR(10) | tw / us |
| total_shares | INTEGER | 總持股 |
| avg_cost | NUMERIC(12,4) | 平均成本 |
| total_invested | NUMERIC(14,2) | 總投入 |
| realized_profit | NUMERIC(14,2) | 已實現損益 |

### exchange_rates（匯率）
| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| from_currency | VARCHAR(10) | USD |
| to_currency | VARCHAR(10) | TWD |
| rate | FLOAT | 匯率 |
| updated_at | DATETIME | 更新時間 |

---

## 📡 API 端點

### 匯率
| Method | Endpoint | 說明 |
|--------|----------|------|
| GET | `/api/portfolio/exchange-rate` | 取得匯率 |
| PUT | `/api/portfolio/exchange-rate` | 手動設定匯率 |

### 交易紀錄
| Method | Endpoint | 說明 |
|--------|----------|------|
| POST | `/api/portfolio/transactions` | 新增交易 |
| GET | `/api/portfolio/transactions` | 交易列表 |
| GET | `/api/portfolio/transactions/{id}` | 單筆交易 |
| PUT | `/api/portfolio/transactions/{id}` | 更新交易 |
| DELETE | `/api/portfolio/transactions/{id}` | 刪除交易 |

### 持股與摘要
| Method | Endpoint | 說明 |
|--------|----------|------|
| GET | `/api/portfolio/holdings` | 持股列表（含現價） |
| GET | `/api/portfolio/summary` | 投資摘要（含匯率換算） |

---

## 🔧 整合方式

1. 將 `app/` 目錄下的檔案複製到專案對應位置
2. 將 `static/dashboard.html` 覆蓋專案中的同名檔案
3. 重新部署（資料庫表會自動建立）

---

## ⏰ 排程任務

| 時間 | 任務 |
|------|------|
| 每 10 分鐘 | 價格快取更新 |
| 週一~五 13:35 | 台股收盤更新 |
| 週二~六 05:05 | 美股收盤更新 |
| **每天 09:00** | 匯率更新（早） |
| **每天 12:00** | 匯率更新（中） |
| **每天 17:00** | 匯率更新（晚） |

---

## ✅ 驗收清單

### 個人投資記錄
- [x] 側邊欄顯示「個人投資記錄」
- [x] 台股/美股分開區塊
- [x] 各自有「新增」按鈕
- [x] 台股：張數 + 零股輸入
- [x] 美股：股數輸入
- [x] 股票代碼自動查詢名稱
- [x] 名稱欄位唯讀
- [x] 投資總覽（匯率換算）
- [x] 持股總覽 / 台股紀錄 / 美股紀錄 三個 Tab

### 追蹤清單
- [x] 每個項目新增「買」「賣」按鈕
- [x] 點擊自動開啟對應 Modal
- [x] 自動帶入代碼和名稱

### 匯率
- [x] 每天 3 次自動更新
- [x] 總覽顯示匯率和更新時間

### BTC 卡片
- [x] 儀表板顯示 BTC 價格
- [x] 動態背景色
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/20260113-007-portfolio-v3.md  ⭐⭐⭐
> 💼 SELA 更新包 - 個人投資記錄 v3
──────────────────────────────────────────────────────────────────────

```md
# 💼 SELA 更新包 - 個人投資記錄 v3

> 文件編號: 20260113-007-portfolio-v3  
> 建立日期: 2026-01-13  
> 功能: 功能 2 - 個人交易管理 + 待辦完成

---

## 📦 檔案清單

```
app/
├── main.py                          ← 覆蓋（註冊 router + 匯率排程）
├── models/
│   ├── __init__.py                  ← 覆蓋
│   └── portfolio.py                 ← 新增
├── routers/
│   ├── __init__.py                  ← 覆蓋
│   ├── admin.py                     ← 覆蓋（含三個更新 API）
│   └── portfolio.py                 ← 新增
└── services/
    ├── exchange_rate_service.py     ← 新增
    └── portfolio_service.py         ← 新增

static/
└── dashboard.html                   ← 覆蓋
```

---

## ✅ 待辦完成

### 1. BTC 卡片移到第一項 ✓
儀表板頂部第一個元素現在是比特幣價格卡片

### 2. 管理員登入觸發全部更新 ✓
管理員登入後自動觸發：
- 四大指數更新 (`/api/admin/update-indices`)
- 價格快取更新 (`/api/admin/update-price-cache`)
- BTC 價格更新（前端載入）
- 匯率更新 (`/api/admin/update-exchange-rate`)

### 3. 投資總覽分三區 ✓
- 🔴 **台股區**：現值、損益、報酬率、持股數（NT$）
- 🔵 **美股區**：現值、損益、報酬率、持股數（USD）
- 🟣 **合計區**：總現值、總損益、報酬率、總持股（TWD，美股 × 匯率）

---

## ✨ 功能特色

### 1. 台美股分開管理
- 台股區塊：獨立「新增」按鈕，自動加 `.TW` 後綴
- 美股區塊：獨立「新增」按鈕
- 各自統計損益

### 2. 匯率自動更新
- 每天 3 次自動抓取（09:00、12:00、17:00）
- 來源：Yahoo Finance (TWD=X)
- 預設值：32.5（抓取失敗時使用）

### 3. 總覽加總
- 台股 + (美股 × 匯率) = 總計 (TWD)
- 顯示總現值、總損益、報酬率

### 4. 台股張數輸入
- 張數 + 零股 分開輸入
- 自動計算總股數
- 顯示：「1張500股」格式

### 5. 股票名稱自動帶入
- 輸入代碼後 0.5 秒自動查詢
- 名稱欄位唯讀
- 查無股票時無法送出

### 6. 追蹤清單買賣按鈕
- 每個追蹤項目新增「買」「賣」按鈕
- 點擊後自動開啟對應市場 Modal
- 自動帶入代碼和名稱

---

## 🗄️ 資料庫

新增三張表（首次啟動自動建立）：

### portfolio_transactions（交易紀錄）
| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| user_id | INTEGER | 用戶 ID |
| symbol | VARCHAR(20) | 股票代碼 |
| name | VARCHAR(100) | 股票名稱 |
| market | VARCHAR(10) | tw / us |
| transaction_type | VARCHAR(10) | buy / sell |
| quantity | INTEGER | 總股數 |
| price | NUMERIC(12,4) | 成交價 |
| fee | NUMERIC(10,2) | 手續費 |
| tax | NUMERIC(10,2) | 交易稅 |
| transaction_date | DATE | 交易日期 |
| note | TEXT | 備註 |

### portfolio_holdings（持股彙總）
| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| user_id | INTEGER | 用戶 ID |
| symbol | VARCHAR(20) | 股票代碼 |
| name | VARCHAR(100) | 股票名稱 |
| market | VARCHAR(10) | tw / us |
| total_shares | INTEGER | 總持股 |
| avg_cost | NUMERIC(12,4) | 平均成本 |
| total_invested | NUMERIC(14,2) | 總投入 |
| realized_profit | NUMERIC(14,2) | 已實現損益 |

### exchange_rates（匯率）
| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| from_currency | VARCHAR(10) | USD |
| to_currency | VARCHAR(10) | TWD |
| rate | FLOAT | 匯率 |
| updated_at | DATETIME | 更新時間 |

---

## 📡 API 端點

### 匯率
| Method | Endpoint | 說明 |
|--------|----------|------|
| GET | `/api/portfolio/exchange-rate` | 取得匯率 |
| PUT | `/api/portfolio/exchange-rate` | 手動設定匯率 |

### 交易紀錄
| Method | Endpoint | 說明 |
|--------|----------|------|
| POST | `/api/portfolio/transactions` | 新增交易 |
| GET | `/api/portfolio/transactions` | 交易列表 |
| GET | `/api/portfolio/transactions/{id}` | 單筆交易 |
| PUT | `/api/portfolio/transactions/{id}` | 更新交易 |
| DELETE | `/api/portfolio/transactions/{id}` | 刪除交易 |

### 持股與摘要
| Method | Endpoint | 說明 |
|--------|----------|------|
| GET | `/api/portfolio/holdings` | 持股列表（含現價） |
| GET | `/api/portfolio/summary` | 投資摘要（含匯率換算） |

---

## 🔧 整合方式

1. 將 `app/` 目錄下的檔案複製到專案對應位置
2. 將 `static/dashboard.html` 覆蓋專案中的同名檔案
3. 重新部署（資料庫表會自動建立）

---

## ⏰ 排程任務

| 時間 | 任務 |
|------|------|
| 每 10 分鐘 | 價格快取更新 |
| 週一~五 13:35 | 台股收盤更新 |
| 週二~六 05:05 | 美股收盤更新 |
| **每天 09:00** | 匯率更新（早） |
| **每天 12:00** | 匯率更新（中） |
| **每天 17:00** | 匯率更新（晚） |

---

## ✅ 驗收清單

### 個人投資記錄
- [x] 側邊欄顯示「個人投資記錄」
- [x] 台股/美股分開區塊
- [x] 各自有「新增」按鈕
- [x] 台股：張數 + 零股輸入
- [x] 美股：股數輸入
- [x] 股票代碼自動查詢名稱
- [x] 名稱欄位唯讀
- [x] 投資總覽（匯率換算）
- [x] 持股總覽 / 台股紀錄 / 美股紀錄 三個 Tab

### 追蹤清單
- [x] 每個項目新增「買」「賣」按鈕
- [x] 點擊自動開啟對應 Modal
- [x] 自動帶入代碼和名稱

### 匯率
- [x] 每天 3 次自動更新
- [x] 總覽顯示匯率和更新時間

### BTC 卡片
- [x] 儀表板顯示 BTC 價格
- [x] 動態背景色
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/20260113-007-portfolio.md  ⭐⭐⭐
> 💼 SELA 更新包 - 投資組合管理
──────────────────────────────────────────────────────────────────────

```md
# 💼 SELA 更新包 - 投資組合管理

> 文件編號: 20260113-007-portfolio  
> 建立日期: 2026-01-13  
> 功能: 功能 2 - 個人交易管理

---

## 📦 檔案清單

```
app/
├── main.py              ← 覆蓋（註冊 portfolio_router）
├── models/
│   ├── __init__.py      ← 覆蓋（匯出新 Model）
│   └── portfolio.py     ← 新增
├── routers/
│   ├── __init__.py      ← 覆蓋（匯出新 Router）
│   └── portfolio.py     ← 新增
└── services/
    └── portfolio_service.py  ← 新增

static/
└── dashboard.html       ← 覆蓋（含 BTC 卡片 + 投資組合頁面）
```

---

## ✨ 新增功能

### 1. 投資組合頁面

位置：側邊欄「投資組合」選項

**功能特色：**
- 持股總覽（分台股/美股）
- 交易紀錄管理（新增/編輯/刪除）
- 投資摘要（總投入、現值、損益、報酬率）
- 未實現損益即時計算（從價格快取讀取）
- 已實現損益追蹤

### 2. BTC 價格卡片

位置：儀表板頁面，恐懼貪婪指數下方

**功能特色：**
- 即時 BTC 價格
- 24h/週/月漲跌幅
- 動態背景色
- 每 60 秒自動更新

---

## 🗄️ 資料庫

新增兩張表（首次啟動自動建立）：

### portfolio_transactions（交易紀錄）
| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| user_id | INTEGER | 用戶 ID |
| symbol | VARCHAR(20) | 股票代碼 |
| name | VARCHAR(100) | 股票名稱 |
| market | VARCHAR(10) | tw / us |
| transaction_type | VARCHAR(10) | buy / sell |
| quantity | INTEGER | 股數 |
| price | NUMERIC(12,4) | 成交價 |
| fee | NUMERIC(10,2) | 手續費 |
| tax | NUMERIC(10,2) | 交易稅 |
| transaction_date | DATE | 交易日期 |
| note | TEXT | 備註 |

### portfolio_holdings（持股彙總）
| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| user_id | INTEGER | 用戶 ID |
| symbol | VARCHAR(20) | 股票代碼 |
| name | VARCHAR(100) | 股票名稱 |
| market | VARCHAR(10) | tw / us |
| total_shares | INTEGER | 總持股 |
| avg_cost | NUMERIC(12,4) | 平均成本 |
| total_invested | NUMERIC(14,2) | 總投入 |
| realized_profit | NUMERIC(14,2) | 已實現損益 |

---

## 📡 新增 API

### 交易紀錄

| Method | Endpoint | 說明 |
|--------|----------|------|
| POST | `/api/portfolio/transactions` | 新增交易 |
| GET | `/api/portfolio/transactions` | 交易列表 |
| GET | `/api/portfolio/transactions/{id}` | 單筆交易 |
| PUT | `/api/portfolio/transactions/{id}` | 更新交易 |
| DELETE | `/api/portfolio/transactions/{id}` | 刪除交易 |

### 持股與摘要

| Method | Endpoint | 說明 |
|--------|----------|------|
| GET | `/api/portfolio/holdings` | 持股列表（含現價） |
| GET | `/api/portfolio/summary` | 投資摘要 |

---

## 🔧 整合方式

1. 將 `app/` 目錄下的檔案複製到專案對應位置
2. 將 `static/dashboard.html` 覆蓋專案中的同名檔案
3. 重新部署（資料庫表會自動建立）

---

## ✅ 驗收清單

### 投資組合
- [x] 側邊欄顯示「投資組合」選項
- [x] 持股總覽（台股/美股分開）
- [x] 顯示現價和未實現損益
- [x] 新增交易 Modal
- [x] 編輯/刪除交易
- [x] 投資摘要統計

### BTC 卡片
- [x] 儀表板顯示 BTC 價格
- [x] 漲跌幅顯示
- [x] 動態背景色
- [x] 自動更新

---

## 📝 注意事項

1. **價格來源**：持股現價來自 `stock_price_cache` 表，需確保價格快取排程正常運作
2. **損益計算**：採用「先進先出」(FIFO) 方式計算已實現損益
3. **資料隔離**：每個用戶只能看到自己的交易紀錄
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/20260114-008-query-cache.md  ⭐⭐⭐
> 查詢結果快取功能
──────────────────────────────────────────────────────────────────────

```md
# 查詢結果快取功能

> 文件編號: 20260114-008-query-cache  
> 建立日期: 2026-01-14

## 功能說明

將查詢過的股票/加密貨幣自動寫入 `StockPriceCache` 快取表。

### 特點
- ✅ 查詢過的股票會被快取
- ✅ 所有用戶共用快取
- ❌ 不會自動更新（只有追蹤清單才會）
- ❌ 管理員登入只更新追蹤清單的股票

---

## 新增檔案

### `app/services/cache_helper.py`

已包含在 zip 中，直接部署即可。

---

## 修改現有檔案

### 1. `app/routers/stock.py`

在 `get_stock_analysis` 函數的 `return` 語句**之前**加入：

```python
# === 在 return 之前加入以下代碼 ===

# 🆕 將查詢結果寫入快取
from app.services.cache_helper import cache_stock_price

day_change = calc_change(1)
prev_close = float(df.iloc[-2]['close_raw']) if len(df) > 1 else None
change_amount = current_price - prev_close if prev_close else None

cache_stock_price(
    symbol=symbol,
    name=stock_name,
    price=current_price,
    prev_close=prev_close,
    change=change_amount,
    change_pct=day_change,
    volume=volume_today
)

# === 加入結束 ===

return {
    "success": True,
    ...
```

完整位置參考（約在第 180-200 行）：

```python
        logger.info(f"{symbol} 查詢完成，評分: {rating}")
        
        # 確保 name 正確獲取
        stock_name = ""
        if info:
            stock_name = info.get("name", "")
        if not stock_name:
            from app.data_sources.yahoo_finance import TAIWAN_STOCK_NAMES
            stock_code = symbol.replace(".TW", "").replace(".TWO", "")
            stock_name = TAIWAN_STOCK_NAMES.get(stock_code, symbol)
        
        # 🆕 === 加入快取代碼 START ===
        from app.services.cache_helper import cache_stock_price
        
        day_change = calc_change(1)
        prev_close = float(df.iloc[-2]['close_raw']) if len(df) > 1 else None
        change_amount = current_price - prev_close if prev_close else None
        
        cache_stock_price(
            symbol=symbol,
            name=stock_name,
            price=current_price,
            prev_close=prev_close,
            change=change_amount,
            change_pct=day_change,
            volume=volume_today
        )
        # 🆕 === 加入快取代碼 END ===
        
        return {
            "success": True,
            "symbol": symbol,
            ...
```

---

### 2. `app/routers/crypto.py`

在 `get_crypto_analysis` 函數的 `return` 語句**之前**加入：

```python
# === 在 return 之前加入以下代碼 ===

# 🆕 將查詢結果寫入快取
from app.services.cache_helper import cache_crypto_price

cache_crypto_price(
    symbol=symbol,
    name=info.get("name", symbol) if info else symbol,
    price=current_price,
    change_pct=calc_change(1),
    volume=info.get("total_volume") if info else None
)

# === 加入結束 ===

return {
    "success": True,
    ...
```

---

## 驗證方式

1. 查詢一個新股票（如 NVDA）
2. 檢查資料庫：
   ```sql
   SELECT * FROM stock_price_cache WHERE symbol = 'NVDA';
   ```
3. 應該看到剛才查詢的價格已被快取

---

## 資料流程

```
用戶查詢 AAPL
    │
    ├─► Yahoo Finance API 取得資料
    │
    ├─► 計算技術指標
    │
    ├─► 🆕 寫入 StockPriceCache（新增）
    │
    └─► 回傳結果給前端


管理員登入
    │
    └─► 更新追蹤清單的股票（從 Watchlist 表撈）
        │
        └─► 不會更新「只查詢過」的股票 ✓
```

---

## 注意事項

1. `cache_helper.py` 使用 try-except 包裝，快取失敗不影響查詢
2. 快取寫入是同步的，但很快（單次資料庫 upsert）
3. 如果未來需要非同步，可改用 `background_tasks.add_task()`
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/20260114-011-subscription-feature.md  ⭐⭐⭐
> SELA 訂閱精選功能
──────────────────────────────────────────────────────────────────────

```md
# SELA 訂閱精選功能

## 功能說明

自動抓取「美股大叔」Substack 文章中提及的股票代碼，用戶可訂閱查看。

### 特點

- **自動抓取**：每小時自動抓取新文章
- **30 天有效期**：每次被提及重新計算，累計提及次數
- **訂閱制**：用戶自選是否訂閱
- **整合價格**：顯示即時價格（來自快取）

---

## 檔案結構

```
app/
├── database.py                         # 資料庫（含遷移）
├── models/
│   └── subscription.py                 # Model: 訂閱源、精選、用戶訂閱
├── services/
│   ├── rss_fetcher.py                  # RSS 爬蟲
│   └── subscription_service.py         # 訂閱服務
├── routers/
│   └── subscription.py                 # API 路由
└── tasks/
    └── subscription_tasks.py           # 排程任務
docs/
└── 20260114-011-subscription-feature.md
```

---

## 部署步驟

### 1. 覆蓋檔案

解壓後覆蓋到專案目錄

### 2. 在 main.py 註冊路由

```python
from app.routers import subscription
app.include_router(subscription.router)
```

### 3. 在 main.py 加入排程任務

找到 `scheduler` 設定的地方，加入：

```python
from app.tasks.subscription_tasks import scheduled_fetch_subscriptions

# 每小時抓取訂閱源
scheduler.add_job(
    scheduled_fetch_subscriptions,
    'interval',
    hours=1,
    id='subscription_fetch',
    name='訂閱源抓取(每小時)',
)
```

### 4. 安裝依賴

```bash
pip install feedparser beautifulsoup4
```

或加入 `requirements.txt`：

```
feedparser>=6.0.0
beautifulsoup4>=4.12.0
```

### 5. 部署後初始化

訪問一次（回溯抓取 30 天）：

```
POST /api/subscription/admin/init
POST /api/subscription/admin/fetch?backfill=true
```

---

## API 說明

### 訂閱源

| 方法 | 路徑 | 說明 |
|------|------|------|
| GET | `/api/subscription/sources` | 所有訂閱源 |
| GET | `/api/subscription/sources/{slug}` | 單一訂閱源 |

### 用戶訂閱

| 方法 | 路徑 | 說明 |
|------|------|------|
| GET | `/api/subscription/my` | 我的訂閱 |
| POST | `/api/subscription/subscribe/{source_id}` | 訂閱 |
| DELETE | `/api/subscription/unsubscribe/{source_id}` | 取消訂閱 |

### 精選列表

| 方法 | 路徑 | 說明 |
|------|------|------|
| GET | `/api/subscription/picks` | 我的訂閱精選（需登入）|
| GET | `/api/subscription/picks/{source_slug}` | 特定來源精選（公開）|

### 管理

| 方法 | 路徑 | 說明 |
|------|------|------|
| POST | `/api/subscription/admin/init` | 初始化訂閱源 |
| POST | `/api/subscription/admin/fetch?backfill=true` | 回溯抓取 |

---

## 資料流程

```
每小時排程
    │
    ├─► GET unclestocknotes.substack.com/feed
    │
    ├─► 解析 RSS 文章
    │
    ├─► 正則提取股票代碼
    │   - $AAPL 格式（高可信度）
    │   - (AAPL) 括號格式
    │   - 已知代碼白名單
    │
    ├─► 過濾常見詞（THE, AND, ETF...）
    │
    └─► 寫入 auto_picks
        - 新代碼：建立，expires_at = 30天後
        - 舊代碼：更新 last_seen_at、重算 expires_at、mention_count++
```

---

## 提及次數說明

```
NVDA 第一次提及 (1/14)
├─► expires_at = 2/14
├─► mention_count = 1

NVDA 第二次提及 (1/20)
├─► expires_at = 2/20（重算）
├─► mention_count = 2

NVDA 第三次提及 (2/15)
├─► expires_at = 3/15（重算）
├─► mention_count = 3
```

---

## 前端整合（待完成）

之後會在 dashboard.html 新增「📡 訂閱精選」Tab
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/main_py_patch.txt  ⭐⭐⭐
> ============================================================
──────────────────────────────────────────────────────────────────────

```text
# ============================================================
# 在 main.py 的啟動流程加入這段（約在 database 初始化後）
# ============================================================

# 找到類似這行：
#   Base.metadata.create_all(bind=engine)
# 或
#   logger.info("Database initialized")

# 在其後加入：

# --- 自動資料庫遷移 ---
from app.utils.migrations import run_migrations
from app.database import SessionLocal

try:
    db = SessionLocal()
    run_migrations(db)
    db.close()
    logger.info("Database migrations completed")
except Exception as e:
    logger.warning(f"Database migrations failed: {e}")
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/README-1.md  ⭐⭐⭐
> SELA 更新包 20260114
──────────────────────────────────────────────────────────────────────

```md
# SELA 更新包 20260114

## 目錄結構

```
├── static/
│   └── dashboard.html      # 追蹤清單排序功能
├── app/
│   └── services/
│       └── cache_helper.py # 查詢結果快取模組（新增）
└── README.md
```

---

## 功能 1: 追蹤清單排序

### 排序選項
- **自訂** - 按加入時間（最新在前）
- **代碼** - 按股票代碼 A-Z
- **漲幅↓** - 漲幅高到低
- **跌幅↓** - 漲幅低到高

### 特點
- ✅ 排序偏好自動儲存到 localStorage
- ✅ 切換排序不重新呼叫 API
- ✅ 手機版滾動友善

---

## 功能 2: 查詢結果快取

需手動在 `app/routers/stock.py` 的 `get_stock_analysis` 函數 return 前加入：

```python
from app.services.cache_helper import cache_stock_price

day_change = calc_change(1)
prev_close = float(df.iloc[-2]['close_raw']) if len(df) > 1 else None
change_amount = current_price - prev_close if prev_close else None

cache_stock_price(
    symbol=symbol,
    name=stock_name,
    price=current_price,
    prev_close=prev_close,
    change=change_amount,
    change_pct=day_change,
    volume=volume_today
)
```

---

## 部署步驟

1. 解壓後直接覆蓋到專案根目錄
2. （可選）手動修改 `stock.py` 啟用查詢快取
3. 重新部署
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/README-2.md  ⭐⭐⭐
> SELA 更新包 20260114 - 排序功能 + MA20 支援
──────────────────────────────────────────────────────────────────────

```md
# SELA 更新包 20260114 - 排序功能 + MA20 支援

## 目錄結構

```
├── static/
│   └── dashboard.html              # 前端排序功能
├── app/
│   ├── models/
│   │   └── price_cache.py          # 快取 Model（加 ma20 欄位）
│   ├── services/
│   │   ├── cache_helper.py         # 快取輔助模組
│   │   └── price_cache_service.py  # 批次更新服務（計算 MA20）
│   └── routers/
│       ├── watchlist.py            # API 返回 ma20
│       └── stock.py                # 查詢時寫入 MA20
└── README.md
```

**所有檔案都是完整版本，直接覆蓋即可。**

---

## 功能說明

### 1. 追蹤清單排序

```
排序： [自訂] [代碼] [漲幅↓] [跌幅↓] [MA20]
```

| 模式 | 說明 |
|------|------|
| 自訂 | 按加入時間（最新在前）|
| 代碼 | A-Z 排序 |
| 漲幅↓ | 漲幅高到低 |
| 跌幅↓ | 漲幅低到高 |
| **MA20** | 站上 MA20 優先 |

### 2. MA20 標籤顯示

```
AAPL  股  Apple Inc.
$185.50  ▲ 2.31%  [站上MA20]
```

| 標籤 | 條件 |
|------|------|
| ▲MA20 | 價格高於 MA20 超過 3% |
| 站上MA20 | 價格高於 MA20 在 0-3% |
| 測MA20 | 價格低於 MA20 在 0-3% |
| ▼MA20 | 價格低於 MA20 超過 3% |

---

## 部署步驟

### 步驟 1: 覆蓋檔案

解壓後直接覆蓋到專案目錄：

```bash
unzip sela-update-20260114.zip -d /path/to/project/
```

### 步驟 2: 資料庫遷移（新增 ma20 欄位）

```sql
-- PostgreSQL
ALTER TABLE stock_price_cache ADD COLUMN IF NOT EXISTS ma20 NUMERIC(12, 4);
```

或讓 SQLAlchemy 自動建立（重新啟動時會自動新增欄位）。

### 步驟 3: 重新部署

```bash
git add .
git commit -m "feat: 追蹤清單排序 + MA20 支援"
git push
```

---

## 驗證方式

1. 查詢一個股票（如 AAPL）
2. 檢查資料庫：
   ```sql
   SELECT symbol, price, ma20 FROM stock_price_cache WHERE symbol = 'AAPL';
   ```
3. 確認 ma20 欄位有值
4. 前端追蹤清單應顯示 MA20 標籤
5. MA20 排序功能正常

---

## 資料流程

```
用戶查詢股票
    │
    ├─► Yahoo Finance 取得數據
    │
    ├─► 計算技術指標（含 MA20）
    │
    ├─► 寫入 StockPriceCache（含 MA20）
    │
    └─► 回傳結果


管理員登入 / 排程更新
    │
    └─► batch_update_stock_prices
        │
        ├─► 取得 1 個月歷史數據
        │
        ├─► 計算 MA20 = 最近 20 天收盤價平均
        │
        └─► 寫入快取


追蹤清單頁面
    │
    └─► GET /api/watchlist/with-prices
        │
        └─► 從快取讀取（含 ma20 欄位）
            │
            └─► 前端排序 + 顯示標籤
```
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/SELA-01-BUG修復指南.md  ⭐⭐⭐
> 🔧 SELA Bug 修復指南
──────────────────────────────────────────────────────────────────────

```md
# 🔧 SELA Bug 修復指南

> 版本: v0.9.1  
> 最後更新: 2026-01-12  
> 適用專案: SELA 多用戶選股分析系統

---

## 📋 修復清單總覽

| # | 問題 | 優先級 | 狀態 |
|---|------|--------|------|
| 1 | 台股名稱顯示亂碼 | **緊急** | 待修復 |
| 2 | BRK.B 等含點號股票搜尋失敗 | 高 | 待修復 |
| 3 | FIG 等新 IPO 股票找不到數據 | 高 | 待修復 |

---

## 🔴 Bug #1: 台股名稱編碼修復（緊急）

### 問題描述

Bundle 文件中的 `TAIWAN_STOCK_NAMES` 字典已經是亂碼，導致台股名稱無法正確顯示。

**問題現象：**
```python
# 現在的狀態（已損壞）:
"2330": "Ã¥ÂÂ°Ã§Â©ÂÃ©â€ºÂ»"  # 應該是「台積電」
"0050": "å…ƒå¤§å°ç£50"        # 應該是「元大台灣50」
```

**原因：** 在某次檔案處理時，UTF-8 編碼被破壞了。

### 需要修復的檔案

| 檔案 | 位置 | 重要性 |
|------|------|--------|
| `yahoo_finance.py` | `app/data_sources/` | **必須修復** |
| `price_cache_service.py` | `app/services/` | 需要修復 |

### 修復步驟

#### 步驟 1: 修復 yahoo_finance.py

找到 `app/data_sources/yahoo_finance.py` 中的 `TAIWAN_STOCK_NAMES = {...}`，**整個替換為以下內容：**

```python
TAIWAN_STOCK_NAMES = {
    # 權值股
    "2330": "台積電",
    "2317": "鴻海",
    "2454": "聯發科",
    "2308": "台達電",
    "2412": "中華電",
    "2303": "聯電",
    "2002": "中鋼",
    "1301": "台塑",
    "1303": "南亞",
    "1326": "台化",
    "6505": "台塑化",
    "1101": "台泥",
    "1102": "亞泥",
    # 金融股
    "2881": "富邦金",
    "2882": "國泰金",
    "2884": "玉山金",
    "2886": "兆豐金",
    "2891": "中信金",
    "2892": "第一金",
    "2880": "華南金",
    "2883": "開發金",
    "2885": "元大金",
    "2887": "台新金",
    "2888": "新光金",
    "2890": "永豐金",
    "5880": "合庫金",
    # 電子股
    "2912": "統一超",
    "2357": "華碩",
    "2382": "廣達",
    "2395": "研華",
    "3008": "大立光",
    "3711": "日月光投控",
    "2345": "智邦",
    "2379": "瑞昱",
    "2327": "國巨",
    "3034": "聯詠",
    "2301": "光寶科",
    "2408": "南亞科",
    "2474": "可成",
    "3045": "台灣大",
    "4904": "遠傳",
    "3231": "緯創",
    "2356": "英業達",
    "2353": "宏碁",
    "2324": "仁寶",
    "2377": "微星",
    "2376": "技嘉",
    "4938": "和碩",
    "2409": "友達",
    "3481": "群創",
    "6669": "緯穎",
    "3037": "欣興",
    "2344": "華邦電",
    "2337": "旺宏",
    "3443": "創意",
    "6488": "環球晶",
    "5269": "祥碩",
    "6415": "矽力-KY",
    "3661": "世芯-KY",
    "2603": "長榮",
    "2609": "陽明",
    "2615": "萬海",
    "2618": "長榮航",
    "2610": "華航",
    "2633": "台灣高鐵",
    "9910": "豐泰",
    "9921": "巨大",
    "1216": "統一",
    "2207": "和泰車",
    "5871": "中租-KY",
    "9941": "裕融",
    "5876": "上海商銀",
    "6239": "力成",
    "8046": "南電",
    "3017": "奇鋐",
    "6176": "瑞儀",
    "6285": "啟碁",
    "2492": "華新科",
    "3533": "嘉澤",
    "6531": "愛普",
    "3665": "貿聯-KY",
    "8454": "富邦媒",
    "2383": "台光電",
    "6446": "藥華藥",
    "6547": "高端疫苗",
    # ETF
    "0050": "元大台灣50",
    "0051": "元大中型100",
    "0052": "富邦科技",
    "0053": "元大電子",
    "0055": "元大MSCI金融",
    "0056": "元大高股息",
    "006208": "富邦台50",
    "00646": "元大S&P500",
    "00662": "富邦NASDAQ",
    "00713": "元大台灣高息低波",
    "00850": "元大臺灣ESG永續",
    "00878": "國泰永續高股息",
    "00881": "國泰台灣5G+",
    "00891": "中信關鍵半導體",
    "00892": "富邦台灣半導體",
    "00893": "國泰智能電動車",
    "00895": "富邦未來車",
    "00900": "富邦特選高股息30",
    "00919": "群益台灣精選高息",
    "00929": "復華台灣科技優息",
    "00939": "統一台灣高息優選",
    "00940": "元大台灣價值高息",
}
```

#### 步驟 2: 同樣修復 price_cache_service.py

找到 `app/services/price_cache_service.py` 中的 `TAIWAN_STOCK_NAMES = {...}`，用相同的字典替換。

#### 步驟 3: 確保編碼正確

儲存時確認編輯器使用 **UTF-8 without BOM** 編碼。

### 驗證方式

1. 開啟比較頁面
2. 選擇台股（如 `2330.TW`）
3. 確認名稱顯示為「台積電」而非亂碼

### 預防措施

```bash
# Git 設定
git config --global core.quotepath false

# 避免使用 Windows 記事本編輯 Python 檔案
# 推薦使用 VS Code 並設定編碼為 UTF-8
```

---

## 🟡 Bug #2 & #3: 股票搜尋修復

### 問題描述

| 股票 | 問題現象 | 根本原因 |
|------|----------|---------|
| BRK.B | 搜尋返回 404 | URL 中 `.B` 被解析為副檔名 + Yahoo 格式問題 |
| FIG | 找不到股票 | 2024 IPO 新股，只有 1 年數據，但系統要求 10 年 |

### 需要修改的檔案

- `app/routers/stock.py`

### 修復步驟

#### 步驟 1: 修改路由定義

找到約第 **3706 行**：

```python
# ❌ 原本
@router.get("/{symbol}", summary="查詢股票")

# ✅ 改為
@router.get("/{symbol:path}", summary="查詢股票")
```

#### 步驟 2: 新增股票代碼變體函數

在 `normalize_tw_symbol` 函數後面加入：

```python
def get_symbol_variants(symbol: str) -> list:
    """
    產生股票代碼的變體列表
    BRK.B -> ["BRK.B", "BRK-B"]
    """
    variants = [symbol]
    
    # 含 `.` 但不是台股，也嘗試 `-` 格式
    if '.' in symbol and not symbol.endswith('.TW') and not symbol.endswith('.TWO'):
        variants.append(symbol.replace('.', '-'))
    
    # 含 `-`，也嘗試 `.` 格式
    if '-' in symbol:
        variants.append(symbol.replace('-', '.'))
    
    return variants
```

#### 步驟 3: 修改歷史數據抓取邏輯

找到約第 **3722-3741 行**，將原本的程式碼替換為：

```python
df = None
used_period = None
actual_symbol = symbol

# 產生代碼變體（BRK.B -> BRK-B）
symbol_variants = get_symbol_variants(symbol)

# 嘗試不同期間（解決新股問題）
periods = ["10y", "5y", "2y", "1y", "6mo", "3mo"]

for try_symbol in symbol_variants:
    if df is not None and len(df) >= 20:
        break
    for period in periods:
        logger.info(f"嘗試 {try_symbol} 期間 {period}...")
        df = yahoo_finance.get_stock_history(try_symbol, period=period)
        if df is not None and len(df) >= 20:
            used_period = period
            actual_symbol = try_symbol
            logger.info(f"成功: {try_symbol} 使用 {period}，共 {len(df)} 筆")
            break

# 台股 .TW -> .TWO 嘗試
if (df is None or len(df) < 20) and symbol.endswith('.TW'):
    two_symbol = symbol.replace('.TW', '.TWO')
    for period in periods:
        df = yahoo_finance.get_stock_history(two_symbol, period=period)
        if df is not None and len(df) >= 20:
            actual_symbol = two_symbol
            used_period = period
            break

if df is None or len(df) < 20:
    tried = ", ".join(set(symbol_variants))
    raise HTTPException(
        status_code=404,
        detail=f"找不到股票: {original_symbol}（已嘗試: {tried}）"
    )

# 使用實際找到的 symbol
symbol = actual_symbol
```

### 驗證方式

| 輸入 | 預期行為 |
|------|---------|
| `BRK.B` | 自動嘗試 BRK.B 和 BRK-B |
| `BRK-B` | 自動嘗試 BRK-B 和 BRK.B |
| `FIG` | 自動嘗試較短期間（1y, 6mo）|
| `AAPL` | 正常（10y）|
| `2330` | 正常（自動加 .TW）|

### 特殊股票代碼對照

| 公司 | Yahoo 格式 | 說明 |
|------|-----------|------|
| Berkshire A | BRK-A 或 BRK.A | 系統會自動嘗試兩種 |
| Berkshire B | BRK-B 或 BRK.B | 系統會自動嘗試兩種 |
| Figma | FIG | 2024 IPO，需用短期間 |

---

## ⚠️ 通用注意事項

1. **備份現有檔案再修改**
2. **所有 Python 檔案必須使用 UTF-8 編碼儲存**
3. **修改後進行完整測試**
4. **部署命令：**

```bash
git add .
git commit -m "fix: 台股名稱編碼 + 股票搜尋 BRK.B/FIG"
git push
```

---

## ✅ 完成確認清單

- [ ] yahoo_finance.py 中的 TAIWAN_STOCK_NAMES 已修復
- [ ] price_cache_service.py 中的 TAIWAN_STOCK_NAMES 已修復
- [ ] stock.py 路由改為 `{symbol:path}`
- [ ] get_symbol_variants 函數已加入
- [ ] 歷史數據抓取邏輯已更新
- [ ] 台股名稱顯示正常
- [ ] BRK.B 搜尋正常
- [ ] FIG 搜尋正常
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/SELA-02-功能整合指南.md  ⭐⭐⭐
> 🚀 SELA 功能整合指南
──────────────────────────────────────────────────────────────────────

```md
# 🚀 SELA 功能整合指南

> 版本: v0.9.1  
> 最後更新: 2026-01-12  
> 適用專案: SELA 多用戶選股分析系統

---

## 📋 功能清單總覽

| # | 功能名稱 | 優先級 | 複雜度 | 預估工時 | 狀態 |
|---|---------|--------|--------|---------|------|
| 1 | 設定頁面 UI | P0 | 中 | 4h | 待整合 |
| 2 | 儀表板比特幣價格 | P2 | 低 | 1h | 待整合 |
| 3 | 管理員登入自動更新 | P1 | 低 | 2h | 待開發 |
| 4 | 個人買賣股票管理 | P0 | 高 | 8h | 待開發 |
| 5 | 列表清單排序 | P1 | 中 | 3h | 待開發 |

---

# 功能 1: 設定頁面 UI

## 1.1 功能概述

新增用戶設定頁面 UI，包含：
- 快速模板（極簡/標準/完整/短線）
- 指標顯示開關（7 種技術指標）
- 通知設定開關（8 種 LINE 推播警報）
- 進階參數調整（14 種可自訂參數）

## 1.2 新增檔案

| 檔案 | 位置 | 說明 |
|------|------|------|
| `settings.css` | `static/css/` | 設定頁面樣式 |
| `settings.js` | `static/js/` | 設定頁面邏輯 |
| `settings-section.html` | `static/` | HTML 片段 |

## 1.3 整合步驟

### 步驟 1: 複製靜態資源

```bash
cp -r settings-ui-update/static/css /path/to/project/static/
cp -r settings-ui-update/static/js /path/to/project/static/
```

### 步驟 2: 在 dashboard.html 引入資源

在 `<head>` 區塊內加入 CSS：

```html
<!-- 設定頁面樣式 -->
<link rel="stylesheet" href="/static/css/settings.css">
```

在 `</body>` 標籤之前加入 JavaScript：

```html
<!-- 設定頁面腳本 -->
<script src="/static/js/settings.js"></script>
```

### 步驟 3: 加入 HTML 結構

將 `settings-section.html` 的內容複製到 dashboard.html 中，放在其他 section 之後：

```html
<!-- 現有的 sections -->
<section id="section-dashboard" class="section">...</section>
<section id="section-watchlist" class="section hidden">...</section>
<section id="section-compare" class="section hidden">...</section>

<!-- 新增：設定頁面 section -->
<section id="section-settings" class="section hidden">
    <!-- 從 settings-section.html 複製內容 -->
</section>
```

### 步驟 4: 新增導航連結

**桌面版導航列：**

```html
<a onclick="showSection('settings', event)" 
   class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-blue-50 hover:text-gray-700 rounded-lg transition-colors cursor-pointer">
    <i class="fas fa-cog mr-2"></i>
    設定
</a>
```

**手機版底部導航：**

```html
<button onclick="showSection('settings', event)" 
        class="nav-tab flex flex-col items-center py-2 px-3 text-gray-500 hover:text-orange-500 transition-colors">
    <i class="fas fa-cog text-lg"></i>
    <span class="text-xs mt-1">設定</span>
</button>
```

### 步驟 5: 更新 showSection 函數

在現有的 `showSection` 函數中加入：

```javascript
function showSection(name, evt) {
    // ... 原有的 section 切換邏輯 ...
    
    // 切換到設定頁時載入設定
    if (name === 'settings') {
        if (typeof initSettingsPage === 'function') {
            initSettingsPage();
        }
    }
}
```

### 步驟 6: 更新用戶資訊顯示

在登入成功後，更新設定頁面的用戶資訊：

```javascript
function updateSettingsUserInfo() {
    const user = JSON.parse(localStorage.getItem('user') || '{}');
    
    const avatar = document.getElementById('settings-user-avatar');
    const name = document.getElementById('settings-user-name');
    const level = document.getElementById('settings-user-level');
    
    if (avatar && user.avatar_url) {
        avatar.src = user.avatar_url;
    }
    if (name) {
        name.textContent = user.display_name || '用戶';
    }
    if (level) {
        level.textContent = user.is_admin ? '管理員' : '免費會員';
    }
}

// 在 checkAuth() 成功後調用
updateSettingsUserInfo();
```

## 1.4 API 依賴

| 端點 | 方法 | 說明 |
|------|------|------|
| `/api/settings/indicators` | GET/PUT | 指標顯示設定 |
| `/api/settings/alerts` | GET/PUT | 通知設定 |
| `/api/settings/params` | GET/PUT | 參數設定 |
| `/api/settings/template/{name}` | POST | 套用預設模板 |

## 1.5 驗證清單

- [ ] CSS 檔案已複製到 `/static/css/`
- [ ] JS 檔案已複製到 `/static/js/`
- [ ] dashboard.html 已引入 CSS
- [ ] dashboard.html 已引入 JS
- [ ] HTML section 已加入
- [ ] 導航連結已加入（桌面版 + 手機版）
- [ ] showSection 函數已更新
- [ ] 測試：可以切換到設定頁面
- [ ] 測試：設定可以正常載入/儲存
- [ ] 測試：模板可以正常套用

---

# 功能 2: 儀表板比特幣價格

## 2.1 功能概述

在儀表板頁面新增比特幣價格卡片，位置在恐懼貪婪指數下方。

**功能特色：**
- 即時 BTC 價格（美元）
- 24h 漲跌幅 + 週/月漲跌
- 動態背景色（大漲綠、大跌紅、平盤橘）
- 每 60 秒自動更新
- 點擊跳轉查詢 BTC 詳情

## 2.2 UI 設計

| 狀態 | 背景色 |
|------|--------|
| 大漲 (≥3%) | 綠色漸層 |
| 大跌 (≤-3%) | 紅色漸層 |
| 平盤 | 橘黃漸層（預設） |

## 2.3 整合方式

直接用更新包中的 `static/dashboard.html` 替換專案中的同名檔案。

**或手動加入以下程式碼：**

### HTML 部分

在儀表板區塊加入：

```html
<!-- 比特幣價格卡片 -->
<div id="btc-price-card" 
     onclick="searchStock('BTC')" 
     class="bg-gradient-to-br from-orange-500 to-yellow-500 rounded-xl p-4 text-white cursor-pointer hover:shadow-lg transition-shadow">
    <div class="flex items-center justify-between">
        <div>
            <div class="text-sm opacity-80">Bitcoin</div>
            <div class="text-2xl font-bold" id="btc-price">$--,---</div>
        </div>
        <div class="text-right">
            <div class="text-lg font-semibold" id="btc-change-24h">--%</div>
            <div class="text-xs opacity-80">24h</div>
        </div>
        <i class="fab fa-bitcoin text-4xl opacity-50"></i>
    </div>
    <div class="mt-2 flex justify-between text-xs opacity-80">
        <span>週: <span id="btc-change-week">--%</span></span>
        <span>月: <span id="btc-change-month">--%</span></span>
    </div>
</div>
```

### JavaScript 部分

```javascript
async function loadBtcPrice() {
    try {
        const res = await fetch(`${API_BASE}/api/crypto/BTC`);
        const data = await res.json();
        
        if (data.success) {
            const price = data.price.current;
            const change24h = data.change.day;
            const changeWeek = data.change.week;
            const changeMonth = data.change.month;
            
            // 更新價格
            document.getElementById('btc-price').textContent = 
                `$${price.toLocaleString('en-US', {minimumFractionDigits: 0})}`;
            
            // 更新漲跌幅
            const change24hEl = document.getElementById('btc-change-24h');
            change24hEl.textContent = `${change24h >= 0 ? '+' : ''}${change24h.toFixed(2)}%`;
            
            document.getElementById('btc-change-week').textContent = 
                `${changeWeek >= 0 ? '+' : ''}${changeWeek.toFixed(1)}%`;
            document.getElementById('btc-change-month').textContent = 
                `${changeMonth >= 0 ? '+' : ''}${changeMonth.toFixed(1)}%`;
            
            // 動態背景色
            const card = document.getElementById('btc-price-card');
            card.className = card.className.replace(/from-\w+-\d+ to-\w+-\d+/g, '');
            
            if (change24h >= 3) {
                card.classList.add('from-green-500', 'to-emerald-600');
            } else if (change24h <= -3) {
                card.classList.add('from-red-500', 'to-rose-600');
            } else {
                card.classList.add('from-orange-500', 'to-yellow-500');
            }
        }
    } catch (e) {
        console.error('載入 BTC 價格失敗:', e);
    }
}

// 頁面載入時執行
document.addEventListener('DOMContentLoaded', () => {
    loadBtcPrice();
    // 每 60 秒更新
    setInterval(loadBtcPrice, 60000);
});
```

## 2.4 API 依賴

```
GET /api/crypto/BTC

Response:
{
    "success": true,
    "price": { "current": 97000 },
    "change": { "day": 2.5, "week": 5.2, "month": 10.3 }
}
```

## 2.5 驗證清單

- [ ] BTC 價格卡片顯示在儀表板
- [ ] 價格格式化（千分位）
- [ ] 漲跌幅正確顯示
- [ ] 顏色正確（綠漲紅跌）
- [ ] 背景色動態變化
- [ ] 60 秒自動更新
- [ ] 點擊跳轉查詢 BTC
- [ ] 響應式設計（手機/桌面）

---

# 功能 3: 管理員登入自動更新

## 3.1 功能概述

管理員登入後，自動在背景觸發系統更新，不阻塞登入流程。

## 3.2 觸發時機

- 管理員成功登入時（`is_admin=True`）
- 僅觸發一次

## 3.3 更新項目

```python
AUTO_UPDATE_TASKS = [
    "update_stock_prices",      # 更新股票價格快取
    "update_crypto_prices",     # 更新加密貨幣價格
    "update_market_sentiment",  # 更新恐懼貪婪指數
    "cleanup_old_data",         # 清理過期數據
]
```

## 3.4 技術設計

### 後端修改

**檔案:** `app/routers/auth.py`

```python
# 在 LINE callback 處理成功登入後加入

@router.get("/callback")
async def line_callback(..., background_tasks: BackgroundTasks):
    # ... 現有登入邏輯 ...
    
    # 管理員登入觸發自動更新
    if user.is_admin:
        background_tasks.add_task(trigger_admin_updates, db)
    
    return RedirectResponse(...)


async def trigger_admin_updates(db: Session):
    """管理員登入觸發的背景更新"""
    from app.services.price_cache_service import PriceCacheService
    
    logger.info("🔄 管理員登入，觸發自動更新...")
    
    try:
        cache_service = PriceCacheService(db)
        
        # 1. 更新所有追蹤股票價格
        result = cache_service.update_all_prices()
        logger.info(f"股票價格更新: {result}")
        
        # 2. 更新市場情緒
        from app.services.market_service import market_service
        market_service.update_fear_greed()
        
        logger.info("✅ 自動更新完成")
        
    except Exception as e:
        logger.error(f"自動更新失敗: {e}")
```

### API 端點（可選）

```
POST /api/admin/trigger-update
Authorization: Bearer {admin_token}

Response:
{
    "success": true,
    "message": "更新已觸發",
    "tasks": ["stock_prices", "crypto_prices", "market_sentiment"]
}
```

## 3.5 前端提示（可選）

登入後在儀表板顯示 Toast 提示：

```javascript
if (user.is_admin) {
    showToast('🔄 系統正在背景更新數據...', 'info');
}
```

## 3.6 驗證清單

- [ ] 管理員登入後自動觸發更新
- [ ] 更新在背景執行，不影響登入
- [ ] 更新日誌正確記錄

---

# 功能 4: 個人買賣股票管理

## 4.1 功能概述

用戶可記錄個人股票買賣交易，追蹤持股和損益。

## 4.2 資料庫設計

### 新增檔案

**檔案:** `app/models/portfolio.py`

```python
"""
個人投資組合模型
"""
from sqlalchemy import Column, Integer, String, Date, Numeric, DateTime, ForeignKey, Index
from sqlalchemy.sql import func
from app.database import Base


class PortfolioTransaction(Base):
    """交易紀錄"""
    
    __tablename__ = "portfolio_transactions"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    
    # 股票資訊
    symbol = Column(String(20), nullable=False)           # 股票代碼
    name = Column(String(100))                            # 股票名稱
    market = Column(String(10), nullable=False)           # tw / us
    
    # 交易資訊
    transaction_type = Column(String(10), nullable=False) # buy / sell
    quantity = Column(Integer, nullable=False)            # 股數
    price = Column(Numeric(12, 4), nullable=False)        # 成交價
    fee = Column(Numeric(10, 2), default=0)               # 手續費
    tax = Column(Numeric(10, 2), default=0)               # 交易稅（賣出時）
    transaction_date = Column(Date, nullable=False)       # 交易日期
    
    # 備註
    note = Column(String(500))
    
    # 時間戳
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # 索引
    __table_args__ = (
        Index('idx_portfolio_user', 'user_id'),
        Index('idx_portfolio_symbol', 'symbol'),
        Index('idx_portfolio_market', 'market'),
        Index('idx_portfolio_date', 'transaction_date'),
    )
    
    @property
    def total_cost(self) -> float:
        """總成本（含手續費）"""
        base = float(self.quantity) * float(self.price)
        if self.transaction_type == "buy":
            return base + float(self.fee or 0)
        else:  # sell
            return base - float(self.fee or 0) - float(self.tax or 0)
    
    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "symbol": self.symbol,
            "name": self.name,
            "market": self.market,
            "transaction_type": self.transaction_type,
            "quantity": self.quantity,
            "price": float(self.price),
            "fee": float(self.fee or 0),
            "tax": float(self.tax or 0),
            "total_cost": self.total_cost,
            "transaction_date": self.transaction_date.isoformat() if self.transaction_date else None,
            "note": self.note,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }


class PortfolioHolding(Base):
    """持股彙總"""
    
    __tablename__ = "portfolio_holdings"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    symbol = Column(String(20), nullable=False)
    name = Column(String(100))
    market = Column(String(10), nullable=False)
    
    # 持股資訊
    total_shares = Column(Integer, default=0)              # 總持股
    avg_cost = Column(Numeric(12, 4), default=0)           # 平均成本
    total_invested = Column(Numeric(14, 2), default=0)     # 總投入金額
    realized_profit = Column(Numeric(14, 2), default=0)    # 已實現損益
    
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_holding_user_symbol', 'user_id', 'symbol', 'market', unique=True),
    )
```

## 4.3 API 設計

**檔案:** `app/routers/portfolio.py`

| 方法 | 端點 | 說明 |
|------|------|------|
| GET | `/api/portfolio/transactions` | 取得交易紀錄 |
| POST | `/api/portfolio/transactions` | 新增交易 |
| PUT | `/api/portfolio/transactions/{id}` | 修改交易 |
| DELETE | `/api/portfolio/transactions/{id}` | 刪除交易 |
| GET | `/api/portfolio/holdings` | 取得持股總覽 |
| GET | `/api/portfolio/holdings/{market}` | 取得特定市場持股 |
| GET | `/api/portfolio/summary` | 取得投資摘要 |

### 請求格式

```python
# POST /api/portfolio/transactions
class TransactionCreate(BaseModel):
    symbol: str                     # "2330" 或 "AAPL"
    name: Optional[str] = None      # "台積電" 或 "Apple"
    market: str                     # "tw" 或 "us"
    transaction_type: str           # "buy" 或 "sell"
    quantity: int                   # 股數
    price: float                    # 成交價
    fee: Optional[float] = 0        # 手續費
    tax: Optional[float] = 0        # 交易稅
    transaction_date: date          # 交易日期
    note: Optional[str] = None      # 備註
```

### 回應格式

```python
# GET /api/portfolio/summary
{
    "success": true,
    "data": {
        "total_invested": 100000,     # 總投入
        "current_value": 120000,      # 現值
        "unrealized_profit": 20000,   # 未實現損益
        "realized_profit": 5000,      # 已實現損益
        "total_profit": 25000,        # 總損益
        "return_rate": 25.0,          # 報酬率 %
        "tw_count": 5,                # 台股持股數
        "us_count": 3,                # 美股持股數
    }
}
```

## 4.4 前端頁面結構

```
📊 投資組合
├── 📈 總覽卡片
│   ├── 總資產
│   ├── 總損益
│   └── 報酬率
├── 🔄 Tab 切換
│   ├── 台股
│   └── 美股
├── 📋 持股列表
│   ├── 股票名稱
│   ├── 持股數
│   ├── 平均成本
│   ├── 現價
│   └── 損益
└── ➕ 新增交易按鈕
```

## 4.5 新增檔案清單

| 檔案 | 說明 |
|------|------|
| `app/models/portfolio.py` | 投資組合資料模型 |
| `app/routers/portfolio.py` | 投資組合 API |
| `app/services/portfolio_service.py` | 投資組合業務邏輯 |
| `static/js/portfolio.js` | 投資組合前端 |
| `static/css/portfolio.css` | 投資組合樣式 |

## 4.6 驗證清單

- [ ] 可新增/編輯/刪除交易紀錄
- [ ] 台股/美股分開顯示
- [ ] 持股和損益計算正確
- [ ] 手機版顯示正常

---

# 功能 5: 列表清單排序

## 5.1 功能概述

各種列表支援點擊欄位標題排序。

## 5.2 適用頁面

1. 自選股列表（`watchlist`）
2. 比較頁面（`compare`）
3. 投資組合（`portfolio`）

## 5.3 通用排序模組

**檔案:** `static/js/table-sort.js`

```javascript
/**
 * 表格排序模組
 */
class TableSorter {
    constructor(tableId, options = {}) {
        this.table = document.getElementById(tableId);
        this.data = [];
        this.currentSort = { column: null, direction: 'asc' };
        this.options = {
            onSort: options.onSort || null,
            savePreference: options.savePreference !== false,
            storageKey: options.storageKey || `sort_${tableId}`,
        };
        
        this.init();
    }
    
    init() {
        // 載入儲存的偏好
        if (this.options.savePreference) {
            const saved = localStorage.getItem(this.options.storageKey);
            if (saved) {
                this.currentSort = JSON.parse(saved);
            }
        }
        
        // 綁定標題點擊事件
        this.bindHeaders();
    }
    
    bindHeaders() {
        const headers = this.table.querySelectorAll('th[data-sort]');
        headers.forEach(header => {
            header.style.cursor = 'pointer';
            header.addEventListener('click', () => {
                this.sort(header.dataset.sort);
            });
            
            // 加入排序圖示
            const icon = document.createElement('i');
            icon.className = 'fas fa-sort ml-1 opacity-30';
            header.appendChild(icon);
        });
    }
    
    setData(data) {
        this.data = [...data];
        if (this.currentSort.column) {
            this.applySort();
        }
    }
    
    sort(column) {
        // 切換方向
        if (this.currentSort.column === column) {
            this.currentSort.direction = 
                this.currentSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            this.currentSort.column = column;
            this.currentSort.direction = 'asc';
        }
        
        // 儲存偏好
        if (this.options.savePreference) {
            localStorage.setItem(
                this.options.storageKey, 
                JSON.stringify(this.currentSort)
            );
        }
        
        this.applySort();
        this.updateIcons();
    }
    
    applySort() {
        const { column, direction } = this.currentSort;
        
        this.data.sort((a, b) => {
            let valA = a[column];
            let valB = b[column];
            
            // 處理數字
            if (typeof valA === 'string' && !isNaN(parseFloat(valA))) {
                valA = parseFloat(valA);
                valB = parseFloat(valB);
            }
            
            // 處理 null/undefined
            if (valA == null) return 1;
            if (valB == null) return -1;
            
            // 比較
            let result = 0;
            if (typeof valA === 'string') {
                result = valA.localeCompare(valB, 'zh-TW');
            } else {
                result = valA - valB;
            }
            
            return direction === 'asc' ? result : -result;
        });
        
        // 觸發回調
        if (this.options.onSort) {
            this.options.onSort(this.data, this.currentSort);
        }
    }
    
    updateIcons() {
        const headers = this.table.querySelectorAll('th[data-sort]');
        headers.forEach(header => {
            const icon = header.querySelector('i');
            const column = header.dataset.sort;
            
            if (column === this.currentSort.column) {
                icon.className = this.currentSort.direction === 'asc' 
                    ? 'fas fa-sort-up ml-1' 
                    : 'fas fa-sort-down ml-1';
                icon.classList.remove('opacity-30');
            } else {
                icon.className = 'fas fa-sort ml-1 opacity-30';
            }
        });
    }
    
    getData() {
        return this.data;
    }
}

// 導出
window.TableSorter = TableSorter;
```

## 5.4 使用範例

### 自選股列表

```html
<table id="watchlist-table">
    <thead>
        <tr>
            <th data-sort="symbol">代碼</th>
            <th data-sort="name">名稱</th>
            <th data-sort="price">現價</th>
            <th data-sort="change_pct">漲跌幅</th>
            <th data-sort="volume">成交量</th>
        </tr>
    </thead>
    <tbody id="watchlist-body"></tbody>
</table>

<script>
const watchlistSorter = new TableSorter('watchlist-table', {
    onSort: (sortedData) => {
        renderWatchlistTable(sortedData);
    },
    storageKey: 'watchlist_sort'
});

// 載入數據時
function loadWatchlist(data) {
    watchlistSorter.setData(data);
    renderWatchlistTable(watchlistSorter.getData());
}
</script>
```

### 比較頁面

```html
<table id="compare-table">
    <thead>
        <tr>
            <th>排名</th>
            <th data-sort="symbol">標的</th>
            <th data-sort="price">現價</th>
            <th data-sort="return_1y">1年</th>
            <th data-sort="return_3y">3年</th>
            <th data-sort="return_5y">5年</th>
        </tr>
    </thead>
</table>
```

## 5.5 驗證清單

- [ ] 點擊標題可排序
- [ ] 升降序切換正常
- [ ] 排序偏好被記住
- [ ] 排序圖示正確顯示

---

# 📅 實作順序建議

```
Week 1:
├── Day 1: 功能 2 (BTC 價格) - 簡單，快速見效
├── Day 2: 功能 3 (管理員更新) - 後端為主
└── Day 3: 功能 5 (排序) - 通用模組 + 功能 1 (設定頁面)

Week 2:
├── Day 1-2: 功能 4 後端 (Model + API)
├── Day 3-4: 功能 4 前端 (UI + 整合)
└── Day 5: 測試 + 修復
```

---

# 📁 新增/修改檔案總覽

## 新增檔案

| 檔案 | 說明 |
|------|------|
| `app/models/portfolio.py` | 投資組合資料模型 |
| `app/routers/portfolio.py` | 投資組合 API |
| `app/services/portfolio_service.py` | 投資組合業務邏輯 |
| `static/js/portfolio.js` | 投資組合前端 |
| `static/css/portfolio.css` | 投資組合樣式 |
| `static/js/settings.js` | 設定頁面邏輯 |
| `static/css/settings.css` | 設定頁面樣式 |
| `static/js/table-sort.js` | 通用排序模組 |

## 修改檔案

| 檔案 | 修改內容 |
|------|----------|
| `app/routers/auth.py` | 加入管理員自動更新 |
| `app/routers/__init__.py` | 註冊 portfolio router |
| `app/models/__init__.py` | 匯出新模型 |
| `static/dashboard.html` | 加入 BTC 價格、設定導航、投資組合導航 |
| `static/js/watchlist.js` | 整合排序功能 |
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/SELA-03-系統規格書.md  ⭐⭐⭐
> 📈 SELA 系統規格書（精簡版）
──────────────────────────────────────────────────────────────────────

```md
# 📈 SELA 系統規格書（精簡版）

> 版本: 1.0  
> 最後更新: 2026-01-12  
> 完整版本: stock-analysis-system-spec.md

---

## 1. 專案概述

### 1.1 專案目標

建立一個支援多用戶的股票與加密貨幣技術分析平台。

### 1.2 核心特色

| 特色 | 說明 |
|------|------|
| 多用戶支援 | LINE 登入，每人獨立追蹤清單 |
| 共享資料庫 | 股價資料共用，減少 API 呼叫 |
| 彈性指標 | 用戶可自選要顯示/通知的指標 |
| 智能預警 | 突破、交叉、極端值自動推播 |
| 雙市場 | 同時支援美股與加密貨幣 |

### 1.3 支援資產

| 類型 | 標的 |
|------|------|
| 美股 | 所有 Yahoo Finance 支援的股票代號 |
| 台股 | Yahoo Finance 台股 (.TW / .TWO) |
| 加密貨幣 | BTC（比特幣）、ETH（以太幣） |

---

## 2. 系統架構

```
┌─────────────────────────────────────────────────────────────┐
│                        前端介面                              │
│              (Web 應用程式 / LINE Bot)                       │
├─────────────────────────────────────────────────────────────┤
│                        API 層                                │
│    ├─ 用戶驗證 (LINE Login)                                  │
│    ├─ 追蹤清單管理                                           │
│    ├─ 股票/幣圈查詢                                          │
│    └─ 設定管理                                               │
├─────────────────────────────────────────────────────────────┤
│                      商業邏輯層                               │
│    ├─ 技術指標計算引擎                                        │
│    ├─ 訊號偵測引擎                                           │
│    ├─ 綜合評分系統                                           │
│    └─ 通知排程服務                                           │
├─────────────────────────────────────────────────────────────┤
│                       快取層                                  │
│    └─ 判斷讀取本地資料庫 或 抓取外部 API                       │
├─────────────────────────────────────────────────────────────┤
│                      資料庫層                                 │
│    ├─ 共享資料 (股價、幣價、情緒指數)                          │
│    └─ 私有資料 (用戶、追蹤清單、設定)                          │
├─────────────────────────────────────────────────────────────┤
│                    外部資料來源                               │
│    ├─ Yahoo Finance (美股/台股)                              │
│    ├─ CoinGecko (加密貨幣)                                   │
│    ├─ CNN Fear & Greed (美股情緒)                            │
│    ├─ Alternative.me (幣圈情緒)                              │
│    └─ LINE Login API (用戶驗證)                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 資料來源

### 3.1 外部 API

| 來源 | 用途 | 取得方式 |
|------|------|----------|
| Yahoo Finance | 美股/台股股價 | yfinance Python 套件 |
| CoinGecko | BTC/ETH 價格 | 免費公開 API |
| CNN Fear & Greed | 美股市場情緒 | 網頁爬蟲 或 第三方 API |
| Alternative.me | 幣圈情緒 | 免費公開 API |

### 3.2 資料更新策略

| 資料類型 | 更新頻率 | 觸發方式 |
|----------|----------|----------|
| 美股股價 | 每日一次 | 美股收盤後 (約 UTC+8 05:00) |
| 加密貨幣 | 每小時 或 查詢時 | 排程 / 用戶查詢觸發 |
| 情緒指數 | 每日一次 | 排程任務 |

---

## 4. 資料庫設計

### 4.1 共享資料表

#### stock_prices（股票價格歷史）

| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| symbol | VARCHAR(10) | 股票代號 |
| date | DATE | 交易日期 |
| open/high/low/close | DECIMAL(12,4) | OHLC 價格 |
| volume | BIGINT | 成交量 |
| updated_at | TIMESTAMP | 資料更新時間 |

#### crypto_prices（加密貨幣價格歷史）

| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| symbol | VARCHAR(10) | 幣種代號 |
| date | DATE | 日期 |
| price | DECIMAL(18,8) | 價格 (USD) |
| volume_24h | DECIMAL(18,2) | 24 小時成交量 |
| market_cap | DECIMAL(18,2) | 市值 |

#### market_sentiment（市場情緒指數）

| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| date | DATE | 日期 |
| market | VARCHAR(10) | stock / crypto |
| value | INTEGER | 指數值 (0-100) |
| classification | VARCHAR(20) | 文字分類 |

### 4.2 私有資料表

#### users（用戶資料）

| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| line_user_id | VARCHAR(50) | LINE 唯一識別碼 |
| display_name | VARCHAR(100) | LINE 顯示名稱 |
| picture_url | VARCHAR(500) | LINE 頭像網址 |
| is_admin | BOOLEAN | 是否為管理員 |
| created_at | TIMESTAMP | 註冊時間 |

#### watchlists（追蹤清單）

| 欄位 | 類型 | 說明 |
|------|------|------|
| id | INTEGER | 主鍵 |
| user_id | INTEGER | 用戶 ID (FK) |
| symbol | VARCHAR(10) | 股票/幣種代號 |
| asset_type | VARCHAR(10) | stock / crypto |
| note | VARCHAR(200) | 自訂備註 |

#### user_indicator_settings（指標顯示設定）

| 欄位 | 類型 | 預設值 | 說明 |
|------|------|--------|------|
| user_id | INTEGER | - | 用戶 ID (PK) |
| show_ma | BOOLEAN | true | 顯示均線 |
| show_rsi | BOOLEAN | true | 顯示 RSI |
| show_macd | BOOLEAN | true | 顯示 MACD |
| show_kd | BOOLEAN | false | 顯示 KD |
| show_bollinger | BOOLEAN | true | 顯示布林通道 |
| show_obv | BOOLEAN | false | 顯示 OBV |
| show_volume | BOOLEAN | true | 顯示成交量 |

#### user_alert_settings（通知設定）

| 欄位 | 類型 | 預設值 | 說明 |
|------|------|--------|------|
| user_id | INTEGER | - | 用戶 ID (PK) |
| alert_ma_cross | BOOLEAN | true | 均線交叉通知 |
| alert_ma_breakout | BOOLEAN | true | 均線突破通知 |
| alert_rsi | BOOLEAN | true | RSI 超買超賣通知 |
| alert_macd | BOOLEAN | true | MACD 交叉通知 |
| alert_kd | BOOLEAN | false | KD 交叉通知 |
| alert_bollinger | BOOLEAN | false | 布林突破通知 |
| alert_volume | BOOLEAN | false | 量能異常通知 |
| alert_sentiment | BOOLEAN | true | 情緒極端通知 |

#### user_indicator_params（指標參數設定）

| 欄位 | 類型 | 預設值 | 說明 |
|------|------|--------|------|
| ma_short | INTEGER | 20 | 短均線週期 |
| ma_mid | INTEGER | 50 | 中均線週期 |
| ma_long | INTEGER | 200 | 長均線週期 |
| rsi_period | INTEGER | 14 | RSI 週期 |
| rsi_overbought | INTEGER | 70 | RSI 超買門檻 |
| rsi_oversold | INTEGER | 30 | RSI 超賣門檻 |
| macd_fast | INTEGER | 12 | MACD 快線週期 |
| macd_slow | INTEGER | 26 | MACD 慢線週期 |
| macd_signal | INTEGER | 9 | MACD 訊號線週期 |
| kd_period | INTEGER | 9 | KD 週期 |
| bollinger_period | INTEGER | 20 | 布林通道週期 |
| bollinger_std | DECIMAL | 2.0 | 布林標準差倍數 |

---

## 5. 技術指標

### 5.1 支援的技術指標

| 指標 | 說明 | 判讀 |
|------|------|------|
| MA | 移動平均線 (20/50/200) | 多頭/空頭排列、黃金/死亡交叉 |
| RSI | 相對強弱指數 | >70 超買、<30 超賣 |
| MACD | 指數平滑異同移動平均 | 黃金/死亡交叉 |
| KD | 隨機指標 | >80 超買、<20 超賣 |
| 布林通道 | Bollinger Bands | 突破上/下軌 |
| OBV | 能量潮 | 量價背離 |
| 成交量 | 量比分析 | 量能異常 |

### 5.2 綜合評分系統

| 訊號 | 分數 | 說明 |
|------|------|------|
| 價格 > MA20 | +1 | 短期多頭 |
| MA20 > MA50 | +1 | 中期多頭 |
| MA50 > MA200 | +1 | 長期多頭 |
| RSI 超買 | -1 | 可能回調 |
| RSI 超賣 | +1 | 可能反彈 |
| MACD 正值 | +1 | 多頭動能 |
| KD 黃金交叉 | +1 | 短線買訊 |

**評級標準：**
- 3~4 分：強勢多頭
- 1~2 分：偏多
- 0 分：中性
- -1~-2 分：偏空
- -3~-4 分：強勢空頭

---

## 6. 通知類型

| alert_type | 中文 | 說明 |
|------------|------|------|
| `ma_golden_cross` | 均線黃金交叉 | MA20 上穿 MA50 |
| `ma_death_cross` | 均線死亡交叉 | MA20 下穿 MA50 |
| `approaching_breakout` | 接近向上突破 | 價格接近關鍵阻力位 |
| `approaching_breakdown` | 接近向下跌破 | 價格接近關鍵支撐位 |
| `rsi_overbought` | RSI 超買 | RSI > 70 |
| `rsi_oversold` | RSI 超賣 | RSI < 30 |
| `macd_golden_cross` | MACD 黃金交叉 | DIF 上穿 DEA |
| `macd_death_cross` | MACD 死亡交叉 | DIF 下穿 DEA |
| `kd_golden_cross` | KD 黃金交叉 | K 上穿 D |
| `kd_death_cross` | KD 死亡交叉 | K 下穿 D |
| `bollinger_breakout` | 布林上軌突破 | 價格突破上軌 |
| `bollinger_breakdown` | 布林下軌跌破 | 價格跌破下軌 |
| `volume_surge` | 成交量暴增 | 量比 > 2.0 |
| `sentiment_extreme_fear` | 極度恐懼 | 情緒指數 < 25 |
| `sentiment_extreme_greed` | 極度貪婪 | 情緒指數 > 75 |

---

## 7. API 設計

### 7.1 主要端點

| 方法 | 端點 | 說明 |
|------|------|------|
| GET | `/api/stock/{symbol}` | 查詢股票詳情 |
| GET | `/api/crypto/{symbol}` | 查詢加密貨幣詳情 |
| GET | `/api/watchlist` | 取得追蹤清單 |
| POST | `/api/watchlist` | 新增追蹤 |
| DELETE | `/api/watchlist/{id}` | 移除追蹤 |
| GET | `/api/watchlist/overview` | 追蹤清單總覽 |
| GET | `/api/sentiment` | 市場情緒 |
| GET | `/api/settings/indicators` | 取得指標設定 |
| PUT | `/api/settings/indicators` | 更新指標設定 |
| GET | `/api/settings/alerts` | 取得通知設定 |
| PUT | `/api/settings/alerts` | 更新通知設定 |

### 7.2 回應格式

```json
{
  "success": true,
  "data": { ... },
  "message": "操作成功"
}
```

**錯誤格式：**

```json
{
  "success": false,
  "error": {
    "code": "INVALID_SYMBOL",
    "message": "找不到此股票代號"
  }
}
```

---

## 8. 技術選型

### 8.1 後端

| 項目 | 選擇 | 理由 |
|------|------|------|
| 語言 | Python 3.10+ | 豐富的金融分析套件 |
| 框架 | FastAPI | 現代、高效能、自動 API 文件 |
| 資料庫 | PostgreSQL | 穩定、支援多用戶併發 |
| ORM | SQLAlchemy | 成熟穩定 |
| 任務排程 | APScheduler | 定時更新資料 |

### 8.2 資料處理

| 項目 | 套件 |
|------|------|
| 股價抓取 | yfinance |
| 數據處理 | pandas, numpy |
| 技術指標 | pandas-ta |
| 圖表繪製 | matplotlib, mplfinance |

### 8.3 部署

| 項目 | 建議選項 |
|------|----------|
| 主機 | Railway |
| 資料庫 | Railway PostgreSQL |
| 域名 | Cloudflare |

---

## 9. 專案目錄結構

```
sela-stock-analysis/
├── app/
│   ├── __init__.py
│   ├── main.py              # FastAPI 入口
│   ├── config.py            # 設定檔
│   ├── database.py          # 資料庫連線
│   │
│   ├── models/              # 資料模型
│   │   ├── user.py
│   │   ├── watchlist.py
│   │   ├── stock_price.py
│   │   ├── crypto_price.py
│   │   ├── sentiment.py
│   │   ├── notification.py
│   │   ├── settings.py
│   │   └── portfolio.py     # 新增
│   │
│   ├── schemas/             # Pydantic schemas
│   │   ├── user.py
│   │   ├── stock.py
│   │   ├── crypto.py
│   │   └── settings.py
│   │
│   ├── routers/             # API 路由
│   │   ├── auth.py
│   │   ├── stock.py
│   │   ├── crypto.py
│   │   ├── watchlist.py
│   │   ├── settings.py
│   │   └── portfolio.py     # 新增
│   │
│   ├── services/            # 商業邏輯
│   │   ├── stock_service.py
│   │   ├── crypto_service.py
│   │   ├── indicator_service.py
│   │   ├── chart_service.py
│   │   ├── notification_service.py
│   │   ├── line_service.py
│   │   ├── price_cache_service.py
│   │   └── portfolio_service.py  # 新增
│   │
│   ├── data_sources/        # 外部資料來源
│   │   ├── yahoo_finance.py
│   │   ├── coingecko.py
│   │   ├── cnn_fear_greed.py
│   │   └── alternative_me.py
│   │
│   └── tasks/               # 排程任務
│       ├── update_prices.py
│       ├── update_sentiment.py
│       └── check_alerts.py
│
├── static/                  # 前端靜態檔案
│   ├── css/
│   │   ├── main.css
│   │   ├── settings.css     # 新增
│   │   └── portfolio.css    # 新增
│   ├── js/
│   │   ├── main.js
│   │   ├── settings.js      # 新增
│   │   ├── portfolio.js     # 新增
│   │   └── table-sort.js    # 新增
│   └── dashboard.html
│
├── tests/                   # 測試
├── migrations/              # 資料庫遷移
├── requirements.txt
├── Dockerfile
├── docker-compose.yml
└── README.md
```

---

## 10. 環境變數

```bash
# 資料庫
DATABASE_URL=postgresql://user:pass@host:5432/dbname

# LINE Login
LINE_LOGIN_CHANNEL_ID=your_channel_id
LINE_LOGIN_CHANNEL_SECRET=your_channel_secret
LINE_LOGIN_CALLBACK_URL=https://your-domain.com/auth/line/callback

# LINE Messaging
LINE_MESSAGING_CHANNEL_ACCESS_TOKEN=your_access_token

# JWT
JWT_SECRET_KEY=your_secret_key
JWT_EXPIRE_DAYS=7

# 應用程式
APP_ENV=production
APP_DEBUG=false
```

---

## 11. 市場情緒分級

| 數值 | 分類 | 意義 |
|------|------|------|
| 0-25 | 極度恐懼 | 可能買點 |
| 26-45 | 恐懼 | 偏謹慎 |
| 46-55 | 中性 | 觀望 |
| 56-75 | 貪婪 | 偏樂觀 |
| 76-100 | 極度貪婪 | 可能賣點 |

---

> 💡 完整技術規格請參考 `stock-analysis-system-spec.md`
```

──────────────────────────────────────────────────────────────────────
### 📄 docs/SELA-Bug修復記錄.md  ⭐⭐⭐
> SELA 選股系統 - Bug 修復記錄
──────────────────────────────────────────────────────────────────────

```md
# SELA 選股系統 - Bug 修復記錄

> 版本：v0.3.0  
> 更新日期：2026-01-05

---

## 目錄

1. [前端 Bug](#前端-bug)
2. [後端 Bug](#後端-bug)
3. [Async/Await 問題](#asyncawait-問題)
4. [部署注意事項](#部署注意事項)

---

## 前端 Bug

### Bug 1：showSection 函數 event 未定義

**錯誤訊息**：
```
Uncaught TypeError: Cannot read properties of null (reading 'classList')
    at showSection (dashboard.html:277:46)
    at searchSymbol (dashboard.html:411:13)
```

**原因**：
- `showSection` 函數使用了全域 `event` 對象
- 從導航列點擊時有 `event`，但從 `searchSymbol` 等函數調用時沒有

**錯誤代碼**：
```javascript
function showSection(name) {
    // ...
    event.target.closest('.nav-link').classList.add('bg-blue-50');  // ❌ event 未定義
}
```

**修復代碼**：
```javascript
function showSection(name, evt) {
    document.querySelectorAll('.section').forEach(s => s.classList.add('hidden'));
    const section = document.getElementById(`section-${name}`);
    if (section) {
        section.classList.remove('hidden');
    }
    
    document.querySelectorAll('.nav-link').forEach(l => {
        l.classList.remove('bg-blue-50', 'text-gray-700');
        l.classList.add('text-gray-600');
    });
    
    // ✅ 只有點擊導航時才更新高亮
    if (evt && evt.target) {
        const navLink = evt.target.closest('.nav-link');
        if (navLink) {
            navLink.classList.add('bg-blue-50', 'text-gray-700');
            navLink.classList.remove('text-gray-600');
        }
    }
    // ...
}
```

**HTML 調用也要修改**：
```html
<!-- ❌ 錯誤 -->
<a onclick="showSection('dashboard')">

<!-- ✅ 正確 -->
<a onclick="showSection('dashboard', event)">
```

---

### Bug 2：API 資料格式不符

**錯誤訊息**：
```
TypeError: Cannot read properties of undefined (reading 'stock')
    at loadSentiment (dashboard.html:299:60)
```

**原因**：
- 前端期望 `data.data.stock` 格式
- 後端 API 實際返回 `data.stock` 格式

**錯誤代碼**：
```javascript
// ❌ 前端期望
updateSentimentCard('stock', data.data.stock);
updateSentimentCard('crypto', data.data.crypto);
```

**修復代碼**：
```javascript
// ✅ 符合 API 實際返回格式
updateSentimentCard('stock', data.stock);
updateSentimentCard('crypto', data.crypto);
```

**API 實際返回格式**：
```json
{
  "success": true,
  "stock": { "value": 45, "classification": "neutral" },
  "crypto": { "value": 32, "classification": "fear" }
}
```

---

### Bug 3：搜尋結果資料格式

**原因**：
- 前端期望 `data.data` 包含股票資料
- 後端直接返回資料在頂層

**錯誤代碼**：
```javascript
// ❌ 錯誤
renderStockResult(data.data, isCrypto);
```

**修復代碼**：
```javascript
// ✅ 正確 - 資料直接在頂層
renderStockResult(data, isCrypto);
```

---

## 後端 Bug

### Bug 4：技術指標欄位名大小寫不一致

**原因**：
- `indicator_service.py` 產生小寫欄位名：`ma20`, `rsi`, `macd_dif`
- `stock.py` / `crypto.py` 讀取大寫欄位名：`MA20`, `RSI`, `MACD_DIF`

**錯誤代碼**：
```python
# ❌ routers/stock.py 使用大寫
ma20 = float(latest.get('MA20', 0)) if 'MA20' in latest else None
rsi_value = float(latest.get('RSI', 50)) if 'RSI' in latest else 50
macd_dif = float(latest.get('MACD_DIF', 0)) if 'MACD_DIF' in latest else 0
```

**修復代碼**：
```python
# ✅ 使用小寫，符合 indicator_service 產生的欄位名
ma20 = float(latest.get('ma20', 0)) if 'ma20' in latest else None
ma50 = float(latest.get('ma50', 0)) if 'ma50' in latest else None
ma200 = float(latest.get('ma200', 0)) if 'ma200' in latest else None
rsi_value = float(latest.get('rsi', 50)) if 'rsi' in latest else 50
macd_dif = float(latest.get('macd_dif', 0)) if 'macd_dif' in latest else 0
macd_dea = float(latest.get('macd_dea', 0)) if 'macd_dea' in latest else 0
macd_hist = float(latest.get('macd_hist', 0)) if 'macd_hist' in latest else 0
```

**indicator_service.py 產生的欄位名參考**：
```python
df[f"ma{self.ma_short}"]  # ma20
df[f"ma{self.ma_mid}"]    # ma50
df[f"ma{self.ma_long}"]   # ma200
df["rsi"]                  # rsi
df["macd_dif"]            # macd_dif
df["macd_dea"]            # macd_dea
df["macd_hist"]           # macd_hist
df["kd_k"]                # kd_k
df["kd_d"]                # kd_d
```

---

### Bug 5：方法名稱錯誤

**原因**：調用不存在的方法名

**錯誤代碼**：
```python
# ❌ routers/stock.py
df = yahoo_finance.get_stock_data(symbol, period="1y")  # 方法不存在

# ❌ routers/crypto.py
df = coingecko.get_historical_data(symbol, days=365)  # 方法不存在
```

**修復代碼**：
```python
# ✅ routers/stock.py - 使用正確的方法名
df = yahoo_finance.get_stock_history(symbol, period="1y")

# ✅ routers/crypto.py - 使用正確的方法名
df = coingecko.get_ohlc(symbol, days=365)
```

**data_sources 可用方法參考**：

| 檔案 | 可用方法 |
|------|----------|
| yahoo_finance.py | `get_stock_info()`, `get_stock_history()`, `get_current_price()` |
| coingecko.py | `get_coin_info()`, `get_market_chart()`, `get_ohlc()`, `get_current_price()`, `validate_symbol()` |

---

## Async/Await 問題

### Bug 6：Settings API 缺少 await

**錯誤訊息**：
```
'coroutine' object has no attribute 'scalar_one_or_none'
```

**原因**：
- 使用 `AsyncSession` 但沒有 `await` 資料庫操作

**錯誤代碼**：
```python
# ❌ 缺少 await
settings = db.execute(stmt).scalar_one_or_none()
db.commit()
db.refresh(settings)
```

**修復代碼**：
```python
# ✅ 加上 await
result = await db.execute(stmt)
settings = result.scalar_one_or_none()
await db.commit()
await db.refresh(settings)
```

---

## 部署注意事項

### 1. 瀏覽器快取問題

修改前端檔案後，用戶可能看到舊版本。

**解決方法**：
- 按 `Ctrl + Shift + R` 強制重新整理
- 開啟無痕視窗測試
- 在檔案名加上版本號：`dashboard.html?v=1.0.1`

### 2. Railway 部署檢查

部署後檢查 log 確認：
- 容器啟動成功
- API 端點返回 200 OK
- 沒有 500 錯誤

### 3. API 測試方法

直接在瀏覽器測試 API：
```
https://your-domain.railway.app/api/stock/AAPL
https://your-domain.railway.app/api/crypto/BTC
https://your-domain.railway.app/api/market/sentiment
```

### 4. 前端 Console 調試

按 `F12` 開啟開發者工具，查看：
- Console 錯誤訊息
- Network 請求狀態
- API 回應內容

---

## 修復檔案清單

| 檔案 | 修復內容 |
|------|----------|
| `static/dashboard.html` | showSection 參數、API 資料格式 |
| `app/routers/stock.py` | 方法名、欄位名大小寫 |
| `app/routers/crypto.py` | 方法名、欄位名大小寫 |
| `app/routers/settings.py` | async/await 完整版 |

---

## 快速檢查清單

- [ ] `indicator_service` 欄位名是小寫
- [ ] `routers` 讀取欄位名也用小寫
- [ ] API 方法名與 data_sources 一致
- [ ] 前端資料格式與 API 返回一致
- [ ] `showSection` 等函數的 event 參數可選
- [ ] AsyncSession 的操作都有 await

---

> 文件維護：每次修復 bug 後更新此文件
```

──────────────────────────────────────────────────────────────────────
### 📄 README.md  ⭐⭐⭐
> SELA 部署包 2026-01-15
──────────────────────────────────────────────────────────────────────

```md
# SELA 部署包 2026-01-15

## 包含功能
1. ✅ 追蹤清單 500 錯誤修復（target_price 遷移）
2. ✅ Token 有效期調整（一般用戶 10 分鐘 / 管理員 60 分鐘）
3. ✅ 目標價功能前端（🎯 按鈕 + 達標變色）

## 目錄結構
```
app/
├── config.py              # 新增 JWT_EXPIRE_MINUTES_USER/ADMIN
├── database.py            # 新增 target_price 遷移
└── services/
    └── auth_service.py    # Token 過期時間依角色設定
static/
└── dashboard.html         # 目標價 UI + 動態閒置時間
```

## 部署步驟
```bash
cd /Users/sela/Documents/Python/自動選股系統

# 解壓到專案目錄（會覆蓋對應檔案）
unzip -o deploy-2026-01-15.zip

# 部署
git add .
git commit -m "feat: Token有效期調整 + 目標價功能 + 遷移修復"
git push
```

## 驗證
- 一般用戶登入：閒置計時器顯示 10:00
- 管理員登入：閒置計時器顯示 60:00
- 追蹤清單：🎯 按鈕可設定目標價
```

======================================================================
## ⚙️ 設定檔
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/config.py  ⭐⭐
> 應用程式設定檔
──────────────────────────────────────────────────────────────────────

```py
"""
應用程式設定檔
"""
from pydantic_settings import BaseSettings
from pathlib import Path
from typing import Optional, List


class Settings(BaseSettings):
    """應用程式設定"""
    
    # 應用程式
    APP_NAME: str = "SELA 自動選股系統"
    APP_VERSION: str = "0.8.2"  # Phase 4 訊號偵測 + LINE 推播
    APP_ENV: str = "development"
    DEBUG: bool = True
    
    # 資料庫
    DATABASE_URL: str = "sqlite+aiosqlite:///./stock_analysis.db"
    
    # LINE Login (階段四)
    LINE_LOGIN_CHANNEL_ID: Optional[str] = None
    LINE_LOGIN_CHANNEL_SECRET: Optional[str] = None
    LINE_LOGIN_CALLBACK_URL: Optional[str] = None
    
    # LINE Messaging (階段六)
    LINE_MESSAGING_CHANNEL_ACCESS_TOKEN: Optional[str] = None
    
    # JWT (階段四)
    JWT_SECRET_KEY: str = "your-secret-key-change-in-production"
    JWT_EXPIRE_DAYS: int = 7  # 保留向後相容
    
    # 🆕 Token 過期時間（分鐘）
    JWT_EXPIRE_MINUTES_USER: int = 10      # 一般用戶 10 分鐘
    JWT_EXPIRE_MINUTES_ADMIN: int = 60     # 管理員 1 小時
    
    # 管理員設定
    # 初始管理員的 LINE User ID（用逗號分隔多個）
    ADMIN_LINE_USER_IDS: str = "U0f094e89838337e64ba0ca2f68161f3a"
    
    # 資料更新設定
    STOCK_DATA_CACHE_HOURS: int = 4  # 股價資料快取時間（小時）
    CRYPTO_DATA_CACHE_MINUTES: int = 15  # 幣價資料快取時間（分鐘）
    HISTORY_DEFAULT_YEARS: int = 10  # 歷史資料預設年數
    
    # 技術指標預設參數
    MA_SHORT: int = 20
    MA_MID: int = 50
    MA_LONG: int = 200
    RSI_PERIOD: int = 14
    RSI_OVERBOUGHT: int = 70
    RSI_OVERSOLD: int = 30
    MACD_FAST: int = 12
    MACD_SLOW: int = 26
    MACD_SIGNAL: int = 9
    KD_PERIOD: int = 9
    BOLLINGER_PERIOD: int = 20
    BOLLINGER_STD: float = 2.0
    
    # 通知設定
    BREAKOUT_THRESHOLD: float = 2.0  # 突破預警門檻 (%)
    VOLUME_ALERT_RATIO: float = 2.0  # 量比警戒倍數
    
    def get_admin_line_ids(self) -> List[str]:
        """取得管理員 LINE User ID 列表"""
        if not self.ADMIN_LINE_USER_IDS:
            return []
        return [x.strip() for x in self.ADMIN_LINE_USER_IDS.split(",") if x.strip()]
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"


# 全域設定實例
settings = Settings()

# 專案路徑
BASE_DIR = Path(__file__).resolve().parent.parent
DATA_DIR = BASE_DIR / "data"
CHARTS_DIR = BASE_DIR / "charts"

# 確保目錄存在
DATA_DIR.mkdir(exist_ok=True)
CHARTS_DIR.mkdir(exist_ok=True)
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/settings.py  ⭐⭐
> 設定管理 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
設定管理 API 路由
"""
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.database import get_async_session
from app.services.auth_service import AuthService
from app.models.user import User
from app.models.user_settings import (
    UserIndicatorSettings,
    UserAlertSettings,
    UserIndicatorParams,
)
from app.schemas.schemas import (
    IndicatorSettingsUpdate,
    IndicatorSettingsResponse,
    AlertSettingsUpdate,
    AlertSettingsResponse,
    IndicatorParamsUpdate,
    IndicatorParamsResponse,
    ResponseBase,
)

router = APIRouter(prefix="/api/settings", tags=["設定"])


async def get_current_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
) -> User:
    """依賴注入：取得當前用戶"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(
            status_code=401,
            detail="未提供認證 Token"
        )
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        raise HTTPException(
            status_code=401,
            detail="無效的 Token"
        )
    
    return user


# ==================== 指標顯示設定 ====================

@router.get("/indicators", summary="取得指標顯示設定", response_model=IndicatorSettingsResponse)
async def get_indicator_settings(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶的指標顯示設定
    """
    stmt = select(UserIndicatorSettings).where(
        UserIndicatorSettings.user_id == user.id
    )
    result = await db.execute(stmt)
    settings = result.scalar_one_or_none()
    
    if not settings:
        # 建立預設設定
        settings = UserIndicatorSettings.create_default(user.id)
        db.add(settings)
        await db.commit()
        await db.refresh(settings)
    
    return IndicatorSettingsResponse(
        success=True,
        data=settings.to_dict(),
    )


@router.put("/indicators", summary="更新指標顯示設定", response_model=IndicatorSettingsResponse)
async def update_indicator_settings(
    data: IndicatorSettingsUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    更新用戶的指標顯示設定
    """
    stmt = select(UserIndicatorSettings).where(
        UserIndicatorSettings.user_id == user.id
    )
    result = await db.execute(stmt)
    settings = result.scalar_one_or_none()
    
    if not settings:
        settings = UserIndicatorSettings.create_default(user.id)
        db.add(settings)
    
    # 更新設定
    update_data = data.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(settings, key, value)
    
    await db.commit()
    await db.refresh(settings)
    
    return IndicatorSettingsResponse(
        success=True,
        message="設定已更新",
        data=settings.to_dict(),
    )


# ==================== 通知設定 ====================

@router.get("/alerts", summary="取得通知設定", response_model=AlertSettingsResponse)
async def get_alert_settings(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶的通知設定
    """
    stmt = select(UserAlertSettings).where(
        UserAlertSettings.user_id == user.id
    )
    result = await db.execute(stmt)
    settings = result.scalar_one_or_none()
    
    if not settings:
        settings = UserAlertSettings.create_default(user.id)
        db.add(settings)
        await db.commit()
        await db.refresh(settings)
    
    return AlertSettingsResponse(
        success=True,
        data=settings.to_dict(),
    )


@router.put("/alerts", summary="更新通知設定", response_model=AlertSettingsResponse)
async def update_alert_settings(
    data: AlertSettingsUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    更新用戶的通知設定
    """
    stmt = select(UserAlertSettings).where(
        UserAlertSettings.user_id == user.id
    )
    result = await db.execute(stmt)
    settings = result.scalar_one_or_none()
    
    if not settings:
        settings = UserAlertSettings.create_default(user.id)
        db.add(settings)
    
    # 更新設定
    update_data = data.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(settings, key, value)
    
    await db.commit()
    await db.refresh(settings)
    
    return AlertSettingsResponse(
        success=True,
        message="設定已更新",
        data=settings.to_dict(),
    )


# ==================== 指標參數設定 ====================

@router.get("/params", summary="取得指標參數", response_model=IndicatorParamsResponse)
async def get_indicator_params(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶的指標參數設定
    """
    stmt = select(UserIndicatorParams).where(
        UserIndicatorParams.user_id == user.id
    )
    result = await db.execute(stmt)
    params = result.scalar_one_or_none()
    
    if not params:
        params = UserIndicatorParams.create_default(user.id)
        db.add(params)
        await db.commit()
        await db.refresh(params)
    
    return IndicatorParamsResponse(
        success=True,
        data=params.to_dict(),
    )


@router.put("/params", summary="更新指標參數", response_model=IndicatorParamsResponse)
async def update_indicator_params(
    data: IndicatorParamsUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    更新用戶的指標參數設定
    
    可自訂參數包括：
    - 均線週期 (ma_short, ma_mid, ma_long)
    - RSI 參數 (rsi_period, rsi_overbought, rsi_oversold)
    - MACD 參數 (macd_fast, macd_slow, macd_signal)
    - KD 週期 (kd_period)
    - 布林通道 (bollinger_period, bollinger_std)
    - 警戒值 (breakout_threshold, volume_alert_ratio)
    """
    stmt = select(UserIndicatorParams).where(
        UserIndicatorParams.user_id == user.id
    )
    result = await db.execute(stmt)
    params = result.scalar_one_or_none()
    
    if not params:
        params = UserIndicatorParams.create_default(user.id)
        db.add(params)
    
    # 更新參數
    update_data = data.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(params, key, value)
    
    await db.commit()
    await db.refresh(params)
    
    return IndicatorParamsResponse(
        success=True,
        message="參數已更新",
        data=params.to_dict(),
    )


# ==================== 預設模板 ====================

TEMPLATES = {
    "minimal": {
        "indicators": {
            "show_ma": True,
            "show_rsi": False,
            "show_macd": False,
            "show_kd": False,
            "show_bollinger": False,
            "show_obv": False,
            "show_volume": True,
        },
        "alerts": {
            "alert_ma_cross": True,
            "alert_ma_breakout": True,
            "alert_rsi": False,
            "alert_macd": False,
            "alert_kd": False,
            "alert_bollinger": False,
            "alert_volume": False,
            "alert_sentiment": False,
        },
    },
    "standard": {
        "indicators": {
            "show_ma": True,
            "show_rsi": True,
            "show_macd": True,
            "show_kd": False,
            "show_bollinger": True,
            "show_obv": False,
            "show_volume": True,
        },
        "alerts": {
            "alert_ma_cross": True,
            "alert_ma_breakout": True,
            "alert_rsi": True,
            "alert_macd": True,
            "alert_kd": False,
            "alert_bollinger": False,
            "alert_volume": False,
            "alert_sentiment": True,
        },
    },
    "full": {
        "indicators": {
            "show_ma": True,
            "show_rsi": True,
            "show_macd": True,
            "show_kd": True,
            "show_bollinger": True,
            "show_obv": True,
            "show_volume": True,
        },
        "alerts": {
            "alert_ma_cross": True,
            "alert_ma_breakout": True,
            "alert_rsi": True,
            "alert_macd": True,
            "alert_kd": True,
            "alert_bollinger": True,
            "alert_volume": True,
            "alert_sentiment": True,
        },
    },
    "short_term": {
        "indicators": {
            "show_ma": True,
            "show_rsi": True,
            "show_macd": True,
            "show_kd": True,
            "show_bollinger": True,
            "show_obv": False,
            "show_volume": True,
        },
        "alerts": {
            "alert_ma_cross": True,
            "alert_ma_breakout": True,
            "alert_rsi": True,
            "alert_macd": True,
            "alert_kd": True,
            "alert_bollinger": True,
            "alert_volume": True,
            "alert_sentiment": False,
        },
        "params": {
            "ma_short": 5,
            "ma_mid": 10,
            "ma_long": 20,
        },
    },
}


@router.post("/template/{template_name}", summary="套用預設模板", response_model=ResponseBase)
async def apply_template(
    template_name: str,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    套用預設設定模板
    
    可用模板：
    - **minimal**: 極簡 (只顯示均線和成交量)
    - **standard**: 標準 (預設，含主要指標)
    - **full**: 完整 (顯示所有指標)
    - **short_term**: 短線 (使用較短的均線週期)
    """
    if template_name not in TEMPLATES:
        raise HTTPException(
            status_code=400,
            detail=f"不存在的模板: {template_name}"
        )
    
    template = TEMPLATES[template_name]
    
    # 更新指標設定
    if "indicators" in template:
        stmt = select(UserIndicatorSettings).where(
            UserIndicatorSettings.user_id == user.id
        )
        result = await db.execute(stmt)
        ind_settings = result.scalar_one_or_none()
        if not ind_settings:
            ind_settings = UserIndicatorSettings.create_default(user.id)
            db.add(ind_settings)
        
        for key, value in template["indicators"].items():
            setattr(ind_settings, key, value)
    
    # 更新通知設定
    if "alerts" in template:
        stmt = select(UserAlertSettings).where(
            UserAlertSettings.user_id == user.id
        )
        result = await db.execute(stmt)
        alert_settings = result.scalar_one_or_none()
        if not alert_settings:
            alert_settings = UserAlertSettings.create_default(user.id)
            db.add(alert_settings)
        
        for key, value in template["alerts"].items():
            setattr(alert_settings, key, value)
    
    # 更新參數設定
    if "params" in template:
        stmt = select(UserIndicatorParams).where(
            UserIndicatorParams.user_id == user.id
        )
        result = await db.execute(stmt)
        params = result.scalar_one_or_none()
        if not params:
            params = UserIndicatorParams.create_default(user.id)
            db.add(params)
        
        for key, value in template["params"].items():
            setattr(params, key, value)
    
    await db.commit()
    
    return ResponseBase(
        success=True,
        message=f"已套用模板: {template_name}",
    )
```

──────────────────────────────────────────────────────────────────────
### 📄 Procfile  ⭐⭐
──────────────────────────────────────────────────────────────────────

```text
web: uvicorn app.main:app --host 0.0.0.0 --port $PORT
```

──────────────────────────────────────────────────────────────────────
### 📄 requirements.txt  ⭐⭐⭐
> Core Framework
──────────────────────────────────────────────────────────────────────

```text
# Core Framework
fastapi>=0.109.0
uvicorn[standard]>=0.27.0
python-dotenv>=1.0.0

# Database
sqlalchemy>=2.0.0
aiosqlite>=0.19.0
greenlet>=3.0.0
asyncpg>=0.29.0        # PostgreSQL async driver
psycopg2-binary>=2.9.9  # PostgreSQL sync driver

# Data Sources
yfinance>=0.2.36
requests>=2.31.0

# Data Processing
pandas>=2.2.0
numpy>=1.26.0
# pandas-ta>=0.3.14b  # 已在 indicator_service.py 手動實作指標計算

# Chart Generation
matplotlib>=3.8.0
mplfinance>=0.12.9b7

# Authentication
python-jose[cryptography]>=3.3.0
httpx>=0.26.0

# Utilities
pydantic>=2.5.0
pydantic-settings>=2.1.0
rich>=13.7.0  # CLI 美化輸出

# Testing
pytest>=8.0.0
pytest-asyncio>=0.23.0
apscheduler>=3.10.0
feedparser
```

======================================================================
## 🚀 程式進入點
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/main.py  ⭐⭐⭐
> FastAPI 主程式
──────────────────────────────────────────────────────────────────────

```py
"""
FastAPI 主程式
股票技術分析系統 API
"""
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import RedirectResponse
import logging
import os
from datetime import datetime

from app.config import settings
from app.database import init_db
from app.logging_config import setup_logging

# 初始化日誌系統（在其他 import 之前）
setup_logging(
    log_level="DEBUG" if settings.DEBUG else "INFO",
    log_to_file=True
)

# 確保所有 models 被載入，這樣 Base.metadata 才會包含所有表格
from app.models import (
    User, Watchlist, StockPrice, CryptoPrice, 
    MarketSentiment, Notification,
    UserIndicatorSettings, UserAlertSettings, UserIndicatorParams,
    IndexPrice, DividendHistory,
    Comparison,
    StockPriceCache,
    PortfolioTransaction, PortfolioHolding, ExchangeRate,
)
from app.models.user import LoginLog, TokenBlacklist, SystemConfig

from app.routers import (
    auth_router,
    stock_router,
    crypto_router,
    watchlist_router,
    settings_router,
    admin_router,
    compare_router,
    portfolio_router,
)
from app.routers.market import router as market_router
from app.routers.subscription import router as subscription_router  # 📡 訂閱精選

# 排程器
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

logger = logging.getLogger(__name__)

# 建立排程器
scheduler = AsyncIOScheduler()


# ============================================================
# 🆕 交易時間判斷（優化版）
# ============================================================

def is_tw_market_hours() -> bool:
    """判斷是否在台股交易時間（週一到週五 09:00-13:30 台北時間）"""
    from datetime import timezone, timedelta
    tw_tz = timezone(timedelta(hours=8))
    now = datetime.now(tw_tz)
    
    # 週末不開盤
    if now.weekday() >= 5:
        return False
    
    # 09:00 - 13:30
    market_open = now.replace(hour=9, minute=0, second=0, microsecond=0)
    market_close = now.replace(hour=13, minute=30, second=0, microsecond=0)
    
    return market_open <= now <= market_close


def is_us_market_hours() -> bool:
    """判斷是否在美股交易時間（週一到週五 21:30-05:00 台北時間）"""
    from datetime import timezone, timedelta
    tw_tz = timezone(timedelta(hours=8))
    now = datetime.now(tw_tz)
    
    # 週末不開盤（週六 05:00 後、週日全天）
    if now.weekday() == 6:  # 週日
        return False
    if now.weekday() == 5 and now.hour >= 5:  # 週六 05:00 後
        return False
    
    # 21:30 - 05:00 (跨日)
    hour = now.hour
    minute = now.minute
    
    if hour >= 21 and minute >= 30:
        return True
    if hour >= 22:
        return True
    if hour < 5:
        return True
    
    return False


def is_any_market_open() -> bool:
    """判斷是否有任何市場開盤"""
    return is_tw_market_hours() or is_us_market_hours()


# ============================================================
# 價格快取更新函數（優化版）
# ============================================================

def update_price_cache():
    """
    排程任務：更新價格快取
    🆕 優化：只在交易時間執行
    """
    # 檢查是否有市場開盤
    if not is_any_market_open():
        logger.debug("[排程] 非交易時間，跳過價格更新")
        return
    
    from app.database import SyncSessionLocal
    from app.services.price_cache_service import PriceCacheService

    logger.info("[排程] 開始更新價格快取...")
    db = SyncSessionLocal()
    try:
        service = PriceCacheService(db)
        result = service.update_all(force=False)
        logger.info(f"[排程] 價格快取更新完成: {result['total_updated']} 筆")
    except Exception as e:
        logger.error(f"[排程] 價格快取更新失敗: {e}")
    finally:
        db.close()


def update_price_cache_force():
    """強制更新所有價格（收盤後）"""
    from app.database import SyncSessionLocal
    from app.services.price_cache_service import PriceCacheService

    logger.info("[排程] 強制更新所有價格快取...")
    db = SyncSessionLocal()
    try:
        service = PriceCacheService(db)
        result = service.update_all(force=True)
        logger.info(f"[排程] 價格快取強制更新完成: {result['total_updated']} 筆")
    except Exception as e:
        logger.error(f"[排程] 價格快取強制更新失敗: {e}")
    finally:
        db.close()


# ============================================================
# 匯率更新函數
# ============================================================

def update_exchange_rate():
    """排程任務：更新 USD/TWD 匯率"""
    from app.database import SyncSessionLocal
    from app.services.exchange_rate_service import update_exchange_rate_sync

    logger.info("[排程] 開始更新匯率...")
    db = SyncSessionLocal()
    try:
        rate = update_exchange_rate_sync(db)
        logger.info(f"[排程] 匯率更新完成: USD/TWD = {rate:.4f}")
    except Exception as e:
        logger.error(f"[排程] 匯率更新失敗: {e}")
    finally:
        db.close()


# ============================================================
# 📡 訂閱源抓取函數
# ============================================================

def fetch_subscription_sources():
    """排程任務：抓取訂閱源更新"""
    from app.database import SyncSessionLocal
    from app.services.subscription_service import SubscriptionService

    logger.info("[排程] 開始抓取訂閱源...")
    db = SyncSessionLocal()
    try:
        service = SubscriptionService(db)
        result = service.fetch_all_sources(backfill=False)
        logger.info(f"[排程] 訂閱源抓取完成: {result}")
    except Exception as e:
        logger.error(f"[排程] 訂閱源抓取失敗: {e}")
    finally:
        db.close()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """應用程式生命週期管理"""
    # 啟動時
    logger.info(f"Starting {settings.APP_NAME} v{settings.APP_VERSION}")

    # ★★★ 診斷資料庫連線 ★★★
    from app.database import database_url, is_postgres
    db_type = "PostgreSQL" if is_postgres(database_url) else "SQLite"
    logger.info(f"★★★ Database Type: {db_type} ★★★")
    if is_postgres(database_url):
        # 隱藏密碼
        safe_url = database_url.split("@")[-1] if "@" in database_url else database_url
        logger.info(f"★★★ Database Host: {safe_url} ★★★")
    else:
        logger.warning("⚠️ 使用 SQLite！資料會在重新部署後遺失！")
        logger.warning("⚠️ 請設定 DATABASE_URL 環境變數指向 PostgreSQL")

    await init_db()
    logger.info("Database initialized")

    # ============================================================
    # 🆕 優化後的排程設定
    # ============================================================

    # 價格快取：每 30 分鐘（原本 10 分鐘）
    # 內部會判斷交易時間，非交易時間自動跳過
    scheduler.add_job(
        update_price_cache,
        'interval',
        minutes=30,  # 🆕 從 10 分鐘改為 30 分鐘
        id='price_cache_update',
        name='價格快取更新(每30分鐘)',
    )

    # 台股收盤後（週一到週五 13:35）
    scheduler.add_job(
        update_price_cache_force,
        CronTrigger(day_of_week='mon-fri', hour=13, minute=35),
        id='tw_close_update',
        name='台股收盤更新',
    )

    # 美股收盤後（週二到週六 05:05）
    scheduler.add_job(
        update_price_cache_force,
        CronTrigger(day_of_week='tue-sat', hour=5, minute=5),
        id='us_close_update',
        name='美股收盤更新',
    )

    # ============================================================
    # 匯率排程（每天 2 次：09:00、17:00）
    # 🆕 從 3 次改為 2 次
    # ============================================================

    scheduler.add_job(
        update_exchange_rate,
        CronTrigger(hour=9, minute=0),
        id='exchange_rate_morning',
        name='匯率更新(早)',
    )

    scheduler.add_job(
        update_exchange_rate,
        CronTrigger(hour=17, minute=0),
        id='exchange_rate_evening',
        name='匯率更新(晚)',
    )

    # ============================================================
    # 📡 訂閱源排程
    # 🆕 從每小時改為每天 3 次（08:00、12:00、20:00）
    # ============================================================

    scheduler.add_job(
        fetch_subscription_sources,
        CronTrigger(hour=8, minute=0),
        id='subscription_fetch_morning',
        name='訂閱源抓取(早)',
    )

    scheduler.add_job(
        fetch_subscription_sources,
        CronTrigger(hour=12, minute=0),
        id='subscription_fetch_noon',
        name='訂閱源抓取(中)',
    )

    scheduler.add_job(
        fetch_subscription_sources,
        CronTrigger(hour=20, minute=0),
        id='subscription_fetch_evening',
        name='訂閱源抓取(晚)',
    )

    # 啟動排程器
    scheduler.start()
    logger.info("排程器已啟動（優化版：價格快取30分鐘 + 交易時間判斷）")

    # 🆕 啟動時只更新匯率，價格讓排程處理（減少啟動負擔）
    try:
        update_exchange_rate()
        # 只在交易時間才更新價格
        if is_any_market_open():
            update_price_cache()
    except Exception as e:
        logger.error(f"啟動時更新失敗: {e}")

    yield

    # 關閉時
    scheduler.shutdown()
    logger.info("Shutting down...")


# 建立 FastAPI 應用程式
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="""
## 📈 SELA 自動選股系統 API

多用戶股票與加密貨幣技術分析平台

### 功能特色

- **技術指標**: MA, RSI, MACD, KD, 布林通道, OBV
- **智能訊號**: 黃金交叉、死亡交叉、超買超賣、突破預警
- **綜合評分**: 多指標共振分析
- **市場情緒**: CNN Fear & Greed / Alternative.me
- **圖表生成**: 完整技術分析圖表
- **報酬率比較**: 多標的年化報酬率 (CAGR) 比較
- **個人投資記錄**: 交易紀錄、持股管理、損益追蹤
- **訂閱精選**: 自動追蹤投資專家精選股票 📡

### 認證方式

使用 LINE Login 登入，取得 JWT Token 後在 Header 帶入：
```
Authorization: Bearer {token}
```
    """,
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan,
)

# CORS 設定
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 正式環境應限制來源
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 註冊路由
app.include_router(auth_router)
app.include_router(stock_router)
app.include_router(crypto_router)
app.include_router(watchlist_router)
app.include_router(settings_router)
app.include_router(admin_router)
app.include_router(market_router)
app.include_router(compare_router)
app.include_router(portfolio_router)
app.include_router(subscription_router)  # 📡 訂閱精選

# 掛載靜態檔案
static_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "static")
if os.path.exists(static_path):
    app.mount("/static", StaticFiles(directory=static_path, html=True), name="static")


# 根路徑 - 重導向到登入頁
@app.get("/", tags=["系統"])
async def root():
    """重導向到首頁"""
    return RedirectResponse(url="/static/index.html")


# API 狀態
@app.get("/api", tags=["系統"])
async def api_root():
    """API 根路徑"""
    return {
        "name": settings.APP_NAME,
        "version": settings.APP_VERSION,
        "status": "running",
        "docs": "/docs",
    }


# 健康檢查
@app.get("/health", tags=["系統"])
async def health_check():
    """健康檢查"""
    return {
        "status": "healthy",
        "version": settings.APP_VERSION,
    }


# 🆕 排程狀態 API
@app.get("/api/admin/scheduler-status", tags=["管理"])
async def scheduler_status():
    """查看排程器狀態"""
    jobs = []
    for job in scheduler.get_jobs():
        jobs.append({
            "id": job.id,
            "name": job.name,
            "next_run": job.next_run_time.isoformat() if job.next_run_time else None,
        })
    
    return {
        "running": scheduler.running,
        "jobs": jobs,
        "market_status": {
            "tw_open": is_tw_market_hours(),
            "us_open": is_us_market_hours(),
            "any_open": is_any_market_open(),
        }
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.DEBUG,
    )
```

======================================================================
## 🌐 API / 路由
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/__init__.py  ⭐⭐⭐
> API 路由模組
──────────────────────────────────────────────────────────────────────

```py
"""
API 路由模組
"""
from app.routers.auth import router as auth_router
from app.routers.stock import router as stock_router
from app.routers.crypto import router as crypto_router
from app.routers.watchlist import router as watchlist_router
from app.routers.settings import router as settings_router
from app.routers.admin import router as admin_router
from app.routers.compare import router as compare_router
from app.routers.portfolio import router as portfolio_router  # 🆕 個人投資記錄

__all__ = [
    "auth_router",
    "stock_router",
    "crypto_router",
    "watchlist_router",
    "settings_router",
    "admin_router",
    "compare_router",
    "portfolio_router",  # 🆕 個人投資記錄
]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/admin.py  ⭐⭐⭐
> 管理員 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
管理員 API 路由
"""
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, update, delete
from sqlalchemy.orm import selectinload
from typing import Optional
from datetime import datetime, timedelta
import logging

from app.database import get_async_session
from app.models.user import User, LoginLog, TokenBlacklist, SystemConfig
from app.services.auth_service import AuthService
from app.services.exchange_rate_service import update_exchange_rate_sync  # 🆕 匯率更新
from app.config import settings

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/admin", tags=["管理員"])


async def get_admin_user(request: Request, db: AsyncSession = Depends(get_async_session)) -> User:
    """驗證管理員身份"""
    # 從 Header 取得 Token
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="未提供認證 Token")
    
    token = auth_header.split(" ")[1]
    
    # 驗證 Token 並取得用戶
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        raise HTTPException(status_code=401, detail="無效的 Token")
    
    # 檢查是否為管理員
    if not user.is_admin:
        # 檢查是否在環境變數的初始管理員名單中
        admin_ids = settings.get_admin_line_ids()
        if user.line_user_id not in admin_ids:
            raise HTTPException(status_code=403, detail="需要管理員權限")
        
        # 自動設定為管理員
        user.is_admin = True
        await db.commit()
        logger.info(f"Auto-promoted user {user.id} to admin")
    
    return user


@router.get("/stats", summary="系統統計")
async def get_stats(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得系統統計資料"""
    # 用戶統計
    total_users = await db.scalar(select(func.count(User.id)))
    active_users = await db.scalar(select(func.count(User.id)).where(User.is_active == True))
    blocked_users = await db.scalar(select(func.count(User.id)).where(User.is_blocked == True))
    admin_users = await db.scalar(select(func.count(User.id)).where(User.is_admin == True))
    
    # 總登入次數
    total_logins = await db.scalar(
        select(func.count(LoginLog.id))
        .where(LoginLog.action == "login")
    )
    
    # 今日登入
    today = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
    today_logins = await db.scalar(
        select(func.count(LoginLog.id))
        .where(LoginLog.action == "login")
        .where(LoginLog.created_at >= today)
    )
    
    # 近 7 天活躍用戶
    week_ago = datetime.utcnow() - timedelta(days=7)
    weekly_active = await db.scalar(
        select(func.count(func.distinct(LoginLog.user_id)))
        .where(LoginLog.created_at >= week_ago)
    )
    
    return {
        "success": True,
        "stats": {
            "total_users": total_users or 0,
            "active_users": active_users or 0,
            "blocked_users": blocked_users or 0,
            "admin_users": admin_users or 0,
            "total_logins": total_logins or 0,
            "today_logins": today_logins or 0,
            "weekly_active_users": weekly_active or 0,
        }
    }


@router.get("/users", summary="用戶列表")
async def list_users(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    search: Optional[str] = None,
    blocked_only: bool = False,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得用戶列表（含登入次數）"""
    query = select(User).order_by(User.last_login.desc())
    
    # 搜尋
    if search:
        query = query.where(
            (User.display_name.ilike(f"%{search}%")) |
            (User.email.ilike(f"%{search}%")) |
            (User.line_user_id.ilike(f"%{search}%"))
        )
    
    # 只顯示封鎖用戶
    if blocked_only:
        query = query.where(User.is_blocked == True)
    
    # 計算總數
    count_query = select(func.count()).select_from(query.subquery())
    total = await db.scalar(count_query)
    
    # 分頁
    query = query.offset((page - 1) * page_size).limit(page_size)
    result = await db.execute(query)
    users = result.scalars().all()
    
    # 取得每個用戶的登入次數
    user_ids = [u.id for u in users]
    login_counts = {}
    if user_ids:
        login_count_result = await db.execute(
            select(LoginLog.user_id, func.count(LoginLog.id).label('count'))
            .where(LoginLog.user_id.in_(user_ids))
            .where(LoginLog.action == "login")
            .group_by(LoginLog.user_id)
        )
        for row in login_count_result:
            login_counts[row.user_id] = row.count
    
    # 組合結果
    users_data = []
    for u in users:
        user_dict = u.to_dict()
        user_dict["login_count"] = login_counts.get(u.id, 0)
        users_data.append(user_dict)
    
    return {
        "success": True,
        "users": users_data,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total": total or 0,
            "total_pages": ((total or 0) + page_size - 1) // page_size,
        }
    }


@router.get("/users/{user_id}", summary="用戶詳情")
async def get_user_detail(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得用戶詳細資訊"""
    result = await db.execute(
        select(User).where(User.id == user_id)
    )
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    # 取得最近登入記錄
    logs_result = await db.execute(
        select(LoginLog)
        .where(LoginLog.user_id == user_id)
        .order_by(LoginLog.created_at.desc())
        .limit(20)
    )
    logs = logs_result.scalars().all()
    
    return {
        "success": True,
        "user": user.to_dict(),
        "recent_logs": [log.to_dict() for log in logs],
    }


@router.get("/logs", summary="登入日誌")
async def list_logs(
    page: int = Query(1, ge=1),
    page_size: int = Query(50, ge=1, le=100),
    user_id: Optional[int] = None,
    action: Optional[str] = None,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得登入日誌"""
    query = select(LoginLog).order_by(LoginLog.created_at.desc())
    
    if user_id:
        query = query.where(LoginLog.user_id == user_id)
    
    if action:
        query = query.where(LoginLog.action == action)
    
    # 計算總數
    count_query = select(func.count()).select_from(query.subquery())
    total = await db.scalar(count_query)
    
    # 分頁
    query = query.offset((page - 1) * page_size).limit(page_size)
    result = await db.execute(query)
    logs = result.scalars().all()
    
    # 取得用戶名稱
    user_ids = list(set(log.user_id for log in logs))
    if user_ids:
        users_result = await db.execute(
            select(User).where(User.id.in_(user_ids))
        )
        users_map = {u.id: u.display_name for u in users_result.scalars().all()}
    else:
        users_map = {}
    
    logs_data = []
    for log in logs:
        log_dict = log.to_dict()
        log_dict["user_name"] = users_map.get(log.user_id, "Unknown")
        logs_data.append(log_dict)
    
    return {
        "success": True,
        "logs": logs_data,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total": total or 0,
            "total_pages": ((total or 0) + page_size - 1) // page_size,
        }
    }


@router.post("/users/{user_id}/block", summary="封鎖用戶")
async def block_user(
    user_id: int,
    reason: str = Query("", description="封鎖原因"),
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """封鎖用戶"""
    if user_id == admin.id:
        raise HTTPException(status_code=400, detail="不能封鎖自己")
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    user.is_blocked = True
    user.blocked_reason = reason
    user.blocked_at = datetime.utcnow()
    
    # 記錄日誌
    log = LoginLog(
        user_id=user_id,
        action="blocked",
        ip_address=f"by_admin:{admin.id}",
    )
    db.add(log)
    
    await db.commit()
    
    logger.info(f"User {user_id} blocked by admin {admin.id}, reason: {reason}")
    
    return {"success": True, "message": f"已封鎖用戶 {user.display_name}"}


@router.post("/users/{user_id}/unblock", summary="解除封鎖")
async def unblock_user(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """解除用戶封鎖"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    user.is_blocked = False
    user.blocked_reason = None
    user.blocked_at = None
    
    # 記錄日誌
    log = LoginLog(
        user_id=user_id,
        action="unblocked",
        ip_address=f"by_admin:{admin.id}",
    )
    db.add(log)
    
    await db.commit()
    
    logger.info(f"User {user_id} unblocked by admin {admin.id}")
    
    return {"success": True, "message": f"已解除封鎖 {user.display_name}"}


@router.post("/users/{user_id}/set-admin", summary="設為管理員")
async def set_admin(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """設定用戶為管理員"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    user.is_admin = True
    await db.commit()
    
    logger.info(f"User {user_id} promoted to admin by {admin.id}")
    
    return {"success": True, "message": f"已將 {user.display_name} 設為管理員"}


@router.post("/users/{user_id}/remove-admin", summary="移除管理員")
async def remove_admin(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """移除管理員權限"""
    if user_id == admin.id:
        raise HTTPException(status_code=400, detail="不能移除自己的管理員權限")
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    user.is_admin = False
    await db.commit()
    
    logger.info(f"User {user_id} admin removed by {admin.id}")
    
    return {"success": True, "message": f"已移除 {user.display_name} 的管理員權限"}


@router.post("/users/{user_id}/kick", summary="踢出用戶")
async def kick_user(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """踢出單一用戶（使其 Token 失效）"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    # 增加 token 版本，使舊 token 失效
    # 這裡我們用時間戳記錄
    config_key = f"user_token_version:{user_id}"
    result = await db.execute(
        select(SystemConfig).where(SystemConfig.key == config_key)
    )
    config = result.scalar_one_or_none()
    
    if config:
        config.value = str(int(datetime.utcnow().timestamp()))
    else:
        config = SystemConfig(
            key=config_key,
            value=str(int(datetime.utcnow().timestamp())),
            description=f"Token version for user {user_id}"
        )
        db.add(config)
    
    # 記錄日誌
    log = LoginLog(
        user_id=user_id,
        action="kicked",
        ip_address=f"by_admin:{admin.id}",
    )
    db.add(log)
    
    await db.commit()
    
    logger.info(f"User {user_id} kicked by admin {admin.id}")
    
    return {"success": True, "message": f"已踢出用戶 {user.display_name}"}


@router.post("/kick-all", summary="踢出所有用戶")
async def kick_all_users(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """踢出所有用戶（使所有 Token 失效）"""
    # 設定全域 token 版本
    config_key = "global_token_version"
    result = await db.execute(
        select(SystemConfig).where(SystemConfig.key == config_key)
    )
    config = result.scalar_one_or_none()
    
    new_version = str(int(datetime.utcnow().timestamp()))
    
    if config:
        config.value = new_version
    else:
        config = SystemConfig(
            key=config_key,
            value=new_version,
            description="Global token version for kick-all"
        )
        db.add(config)
    
    # 記錄日誌
    log = LoginLog(
        user_id=admin.id,
        action="kick_all",
        ip_address=f"admin:{admin.id}",
    )
    db.add(log)
    
    await db.commit()
    
    logger.warning(f"All users kicked by admin {admin.id}")
    
    return {
        "success": True,
        "message": "已踢出所有用戶，所有人需要重新登入",
        "new_version": new_version
    }


@router.delete("/users/{user_id}", summary="刪除用戶")
async def delete_user(
    user_id: int,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """刪除用戶（危險操作）"""
    if user_id == admin.id:
        raise HTTPException(status_code=400, detail="不能刪除自己")
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="用戶不存在")
    
    display_name = user.display_name
    
    await db.delete(user)
    await db.commit()
    
    logger.warning(f"User {user_id} ({display_name}) deleted by admin {admin.id}")
    
    return {"success": True, "message": f"已刪除用戶 {display_name}"}


@router.get("/debug/watchlists", summary="診斷追蹤清單")
async def debug_watchlists(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    診斷追蹤清單（查看所有用戶的追蹤清單數量）
    """
    from app.models.watchlist import Watchlist
    
    # 統計每個用戶的追蹤清單數量
    result = await db.execute(
        select(
            Watchlist.user_id,
            func.count(Watchlist.id).label('count')
        ).group_by(Watchlist.user_id)
    )
    user_counts = result.all()
    
    # 取得用戶資訊
    user_data = []
    for user_id, count in user_counts:
        user_result = await db.execute(select(User).where(User.id == user_id))
        user = user_result.scalar_one_or_none()
        user_data.append({
            "user_id": user_id,
            "display_name": user.display_name if user else "未知",
            "line_user_id": user.line_user_id[:10] + "..." if user else "未知",
            "watchlist_count": count
        })
    
    # 總數
    total = await db.scalar(select(func.count(Watchlist.id)))
    
    return {
        "success": True,
        "total_watchlist_items": total,
        "users": user_data
    }


# ============== 訊號檢查與推播 ==============

@router.post("/signals/check", summary="執行訊號檢查")
async def run_signal_check(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    手動執行訊號檢查
    
    檢查所有用戶追蹤的股票，偵測技術指標訊號並發送 LINE 通知
    """
    from app.services.notification_service import notification_service
    
    try:
        result = await notification_service.run_signal_check(db)
        
        return {
            "success": True,
            "message": "訊號檢查完成",
            "result": result
        }
    except Exception as e:
        logger.error(f"訊號檢查失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/signals/test/{symbol}", summary="測試單一股票訊號")
async def test_signal_detection(
    symbol: str,
    admin: User = Depends(get_admin_user),
):
    """
    測試單一股票的訊號偵測（不發送通知）
    """
    from app.services.signal_service import signal_service
    from app.services.indicator_service import indicator_service
    from app.data_sources.yahoo_finance import yahoo_finance
    
    symbol = symbol.upper()
    
    try:
        # 取得股價資料
        df = yahoo_finance.get_stock_history(symbol, period="6mo")
        
        if df is None or df.empty:
            raise HTTPException(status_code=404, detail=f"找不到股票: {symbol}")
        
        # 計算技術指標
        indicators = indicator_service.calculate_all_indicators(df)
        
        if not indicators:
            raise HTTPException(status_code=500, detail="無法計算技術指標")
        
        # 偵測訊號
        signals = signal_service.detect_signals(symbol, indicators, "stock")
        
        # 格式化輸出
        signals_data = []
        for s in signals:
            signals_data.append({
                "type": s.signal_type.value,
                "indicator": s.indicator,
                "message": s.message,
                "price": s.price,
                "details": s.details,
            })
        
        return {
            "success": True,
            "symbol": symbol,
            "current_price": indicators.get("current_price"),
            "signals_count": len(signals),
            "signals": signals_data,
            "indicators_summary": {
                "ma20": indicators.get("ma", {}).get("ma20"),
                "ma50": indicators.get("ma", {}).get("ma50"),
                "rsi": indicators.get("rsi", {}).get("value"),
                "macd_status": indicators.get("macd", {}).get("status"),
                "kd_k": indicators.get("kd", {}).get("k"),
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"測試訊號偵測失敗 {symbol}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/notify/test", summary="測試 LINE 推播")
async def test_line_push(
    message: str = Query("這是測試訊息", description="測試訊息內容"),
    admin: User = Depends(get_admin_user),
):
    """
    測試 LINE 推播功能（發送給管理員自己）
    """
    from app.services.line_notify_service import line_notify_service
    
    if not line_notify_service.enabled:
        raise HTTPException(
            status_code=400, 
            detail="LINE Messaging API 未設定，請設定 LINE_MESSAGING_CHANNEL_ACCESS_TOKEN 環境變數"
        )
    
    try:
        test_message = f"🔔 SELA 系統測試\n\n{message}\n\n⏰ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        success = await line_notify_service.push_text_message(
            admin.line_user_id,
            test_message
        )
        
        if success:
            return {
                "success": True,
                "message": "測試訊息已發送，請檢查 LINE"
            }
        else:
            raise HTTPException(status_code=500, detail="LINE 推播失敗")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"測試 LINE 推播失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/notifications", summary="通知記錄")
async def list_notifications(
    page: int = Query(1, ge=1),
    page_size: int = Query(50, ge=1, le=100),
    user_id: Optional[int] = None,
    symbol: Optional[str] = None,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得通知記錄"""
    from app.models.notification import Notification
    
    query = select(Notification).order_by(Notification.triggered_at.desc())
    
    if user_id:
        query = query.where(Notification.user_id == user_id)
    
    if symbol:
        query = query.where(Notification.symbol == symbol.upper())
    
    # 計算總數
    count_query = select(func.count()).select_from(query.subquery())
    total = await db.scalar(count_query)
    
    # 分頁
    query = query.offset((page - 1) * page_size).limit(page_size)
    result = await db.execute(query)
    notifications = result.scalars().all()
    
    # 取得用戶名稱
    user_ids = list(set(n.user_id for n in notifications))
    if user_ids:
        users_result = await db.execute(
            select(User).where(User.id.in_(user_ids))
        )
        users_map = {u.id: u.display_name for u in users_result.scalars().all()}
    else:
        users_map = {}
    
    notifications_data = []
    for n in notifications:
        n_dict = n.to_dict()
        n_dict["user_name"] = users_map.get(n.user_id, "Unknown")
        notifications_data.append(n_dict)
    
    return {
        "success": True,
        "notifications": notifications_data,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total": total or 0,
            "total_pages": ((total or 0) + page_size - 1) // page_size,
        }
    }


@router.post("/signal/detect", summary="偵測訊號（測試）")
async def detect_signals(
    admin: User = Depends(get_admin_user),
):
    """
    手動執行訊號偵測（不發送通知）
    用於測試訊號偵測功能
    """
    from app.tasks.scheduler import scheduler_service
    
    try:
        result = scheduler_service.run_signal_detection_only()
        
        return {
            "success": True,
            "signals_count": len(result.get("signals", [])),
            "by_symbol": result.get("by_symbol", {}),
            "message": f"偵測到 {len(result.get('signals', []))} 個交叉訊號"
        }
    except Exception as e:
        logger.error(f"訊號偵測失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/signal/notify", summary="發送訊號通知")
async def send_signal_notifications(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    手動執行訊號偵測並發送通知
    會偵測所有追蹤股票的交叉訊號，並發送 LINE 推播給相關用戶
    """
    from app.tasks.scheduler import scheduler_service
    
    try:
        # 使用同步 session
        sync_db = scheduler_service._get_db()
        result = scheduler_service._detect_and_notify(sync_db)
        sync_db.close()
        
        return {
            "success": True,
            "signals_detected": result.get("signals_count", 0),
            "notifications_sent": result.get("notifications_sent", 0),
            "errors": result.get("errors", []),
            "message": f"偵測到 {result.get('signals_count', 0)} 個訊號，發送 {result.get('notifications_sent', 0)} 則通知"
        }
    except Exception as e:
        logger.error(f"訊號通知失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/signal/test-push", summary="測試 LINE 推播")
async def test_line_push(
    message: str = Query("這是測試訊息", description="測試訊息內容"),
    admin: User = Depends(get_admin_user),
):
    """
    測試 LINE 推播功能
    發送測試訊息給管理員自己
    """
    from app.services.line_notify_service import line_notify_service
    
    if not line_notify_service.enabled:
        return {
            "success": False,
            "message": "LINE Messaging API 未啟用，請設定 LINE_MESSAGING_CHANNEL_ACCESS_TOKEN"
        }
    
    try:
        test_message = f"📊 SELA 系統測試\n\n{message}\n\n⏰ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        success = await line_notify_service.push_text_message(admin.line_user_id, test_message)
        
        return {
            "success": success,
            "message": "測試訊息已發送" if success else "發送失敗",
            "line_user_id": admin.line_user_id[:10] + "..."
        }
    except Exception as e:
        logger.error(f"測試推播失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/signal/status", summary="通知系統狀態")
async def get_signal_status(
    admin: User = Depends(get_admin_user),
):
    """
    取得訊號通知系統狀態
    """
    from app.services.line_notify_service import line_notify_service
    from app.tasks.scheduler import scheduler_service
    from app.config import settings
    
    return {
        "success": True,
        "status": {
            "line_messaging_enabled": line_notify_service.enabled,
            "line_messaging_token_set": bool(settings.LINE_MESSAGING_CHANNEL_ACCESS_TOKEN),
            "scheduler_last_run": scheduler_service.last_run.isoformat() if scheduler_service.last_run else None,
            "scheduler_last_result": scheduler_service.last_result,
        }
    }


@router.post("/signal/detect", summary="手動偵測訊號")
async def detect_signals_manual(
    admin: User = Depends(get_admin_user),
):
    """
    手動執行訊號偵測（不發送通知）
    用於測試訊號偵測邏輯
    """
    from app.tasks.scheduler import scheduler_service
    
    try:
        result = scheduler_service.run_signal_detection_only()
        
        return {
            "success": True,
            "message": f"偵測完成，共 {len(result.get('signals', []))} 個訊號",
            "signals_by_symbol": result.get("by_symbol", {}),
            "total_signals": len(result.get("signals", [])),
        }
    except Exception as e:
        logger.error(f"訊號偵測失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/signal/notify", summary="手動發送通知")
async def send_notifications_manual(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    手動執行訊號偵測並發送通知
    等同於每日排程任務
    """
    from app.tasks.scheduler import scheduler_service
    
    try:
        result = scheduler_service.run_daily_update()
        
        return {
            "success": result.get("success", False),
            "message": "每日更新任務已執行",
            "result": {
                "stocks_updated": result.get("stocks_updated", 0),
                "signals_detected": result.get("signals_detected", 0),
                "notifications_sent": result.get("notifications_sent", 0),
                "errors": result.get("errors", []),
            }
        }
    except Exception as e:
        logger.error(f"通知任務失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/notifications", summary="通知記錄")
async def list_notifications(
    page: int = Query(1, ge=1),
    page_size: int = Query(50, ge=1, le=100),
    user_id: Optional[int] = None,
    symbol: Optional[str] = None,
    sent_only: bool = False,
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得通知記錄
    """
    from app.models.notification import Notification
    
    query = select(Notification).order_by(Notification.triggered_at.desc())
    
    if user_id:
        query = query.where(Notification.user_id == user_id)
    
    if symbol:
        query = query.where(Notification.symbol == symbol.upper())
    
    if sent_only:
        query = query.where(Notification.sent == True)
    
    # 計算總數
    count_query = select(func.count()).select_from(query.subquery())
    total = await db.scalar(count_query)
    
    # 分頁
    query = query.offset((page - 1) * page_size).limit(page_size)
    result = await db.execute(query)
    notifications = result.scalars().all()
    
    # 取得用戶名稱
    user_ids = list(set(n.user_id for n in notifications))
    users_map = {}
    if user_ids:
        users_result = await db.execute(select(User).where(User.id.in_(user_ids)))
        users_map = {u.id: u.display_name for u in users_result.scalars().all()}
    
    notifications_data = []
    for n in notifications:
        n_dict = n.to_dict()
        n_dict["user_name"] = users_map.get(n.user_id, "Unknown")
        notifications_data.append(n_dict)
    
    return {
        "success": True,
        "notifications": notifications_data,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total": total or 0,
            "total_pages": ((total or 0) + page_size - 1) // page_size,
        }
    }


# ============================================================
# 🆕 管理員觸發更新 API
# ============================================================

@router.post("/update-exchange-rate", summary="更新匯率")
async def admin_update_exchange_rate(
    admin: User = Depends(get_admin_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    管理員手動觸發 USD/TWD 匯率更新
    """
    from app.database import SyncSessionLocal
    
    logger.info(f"管理員 {admin.display_name} 觸發匯率更新")
    
    try:
        sync_db = SyncSessionLocal()
        try:
            rate = update_exchange_rate_sync(sync_db)
            return {
                "success": True,
                "message": f"匯率已更新: USD/TWD = {rate:.4f}",
                "rate": rate,
            }
        finally:
            sync_db.close()
    except Exception as e:
        logger.error(f"匯率更新失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/update-indices", summary="更新四大指數")
async def admin_update_indices(
    admin: User = Depends(get_admin_user),
):
    """
    管理員手動觸發四大指數更新
    """
    from app.services.index_service import update_all_indices
    
    logger.info(f"管理員 {admin.display_name} 觸發四大指數更新")
    
    try:
        result = update_all_indices()
        return {
            "success": True,
            "message": "四大指數已更新",
            "updated": result.get("updated", 0),
            "errors": result.get("errors", []),
        }
    except Exception as e:
        logger.error(f"四大指數更新失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/update-price-cache", summary="更新價格快取")
async def admin_update_price_cache(
    admin: User = Depends(get_admin_user),
):
    """
    管理員手動觸發追蹤清單價格快取更新
    """
    from app.database import SyncSessionLocal
    from app.services.price_cache_service import PriceCacheService
    
    logger.info(f"管理員 {admin.display_name} 觸發價格快取更新")
    
    try:
        sync_db = SyncSessionLocal()
        try:
            service = PriceCacheService(sync_db)
            result = service.update_all(force=True)
            return {
                "success": True,
                "message": "價格快取已更新",
                "total_updated": result.get("total_updated", 0),
                "errors": result.get("errors", []),
            }
        finally:
            sync_db.close()
    except Exception as e:
        logger.error(f"價格快取更新失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/auth.py  ⭐⭐⭐
> 認證 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
認證 API 路由
LINE Login 整合
"""
from fastapi import APIRouter, Depends, HTTPException, Query, Request, BackgroundTasks
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
import secrets
import hashlib
import hmac
import time
import urllib.parse
import logging

from app.database import get_async_session
from app.services.auth_service import AuthService
from app.schemas.schemas import LoginResponse, UserResponse, ErrorResponse
from app.config import settings

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/auth", tags=["認證"])

# 版本標識
AUTH_VERSION = "2.1.0-admin-update"


# ============================================================
# 🆕 管理員登入自動更新
# ============================================================

async def trigger_admin_updates():
    """
    管理員登入觸發的背景更新
    - 更新所有追蹤股票價格
    - 更新市場情緒指數
    """
    from app.database import SessionLocal
    
    logger.info("🔄 管理員登入，觸發自動更新...")
    
    try:
        db = SessionLocal()
        
        # 1. 更新股票價格快取
        try:
            from app.services.price_cache_service import PriceCacheService
            cache_service = PriceCacheService(db)
            result = cache_service.update_all_prices()
            logger.info(f"✅ 股票價格更新完成: {result}")
        except Exception as e:
            logger.error(f"❌ 股票價格更新失敗: {e}")
        
        # 2. 更新市場情緒
        try:
            from app.services.market_service import market_service
            market_service.update_fear_greed()
            logger.info("✅ 市場情緒更新完成")
        except Exception as e:
            logger.error(f"❌ 市場情緒更新失敗: {e}")
        
        # 3. 抓取訂閱精選（如果有）
        try:
            from app.services.subscription_service import SubscriptionService
            sub_service = SubscriptionService(db)
            sub_result = sub_service.fetch_all_sources(backfill=False)
            logger.info(f"✅ 訂閱精選更新完成: {sub_result}")
        except Exception as e:
            logger.warning(f"⚠️ 訂閱精選更新跳過: {e}")
        
        db.close()
        logger.info("🎉 管理員自動更新全部完成")
        
    except Exception as e:
        logger.error(f"❌ 管理員自動更新失敗: {e}")


@router.get("/version", summary="認證模組版本")
async def auth_version():
    """回傳認證模組版本，用於確認部署"""
    return {
        "auth_version": AUTH_VERSION,
        "state_method": "HMAC",
        "jwt_key_set": bool(settings.JWT_SECRET_KEY and settings.JWT_SECRET_KEY != "your-secret-key-change-in-production"),
        "admin_auto_update": True,  # 🆕
    }


def create_state_token() -> str:
    """建立 state token (HMAC 簽名，有效期 10 分鐘)"""
    # 格式: timestamp.nonce.signature
    timestamp = str(int(time.time()))
    nonce = secrets.token_hex(8)  # 16 字元

    # 簽名
    message = f"{timestamp}.{nonce}"
    signature = hmac.new(
        settings.JWT_SECRET_KEY.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()[:16]  # 只取前 16 字元

    state = f"{timestamp}.{nonce}.{signature}"
    logger.info(f"Created state: {state}")
    return state


def verify_state_token(state: str) -> bool:
    """驗證 state token"""
    logger.info(f"Verifying state: {state}")
    try:
        parts = state.split(".")
        logger.info(f"State parts count: {len(parts)}")

        if len(parts) != 3:
            logger.warning(f"Invalid state format, expected 3 parts, got {len(parts)}")
            return False

        timestamp, nonce, signature = parts
        logger.info(f"timestamp={timestamp}, nonce={nonce}, signature={signature}")

        # 檢查是否過期 (10 分鐘)
        time_diff = int(time.time()) - int(timestamp)
        logger.info(f"Time difference: {time_diff} seconds")
        if time_diff > 600:
            logger.warning(f"State expired, time_diff={time_diff}")
            return False

        # 驗證簽名
        message = f"{timestamp}.{nonce}"
        expected_signature = hmac.new(
            settings.JWT_SECRET_KEY.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()[:16]

        logger.info(f"Expected signature: {expected_signature}")
        result = hmac.compare_digest(signature, expected_signature)
        logger.info(f"Signature match: {result}")

        return result
    except Exception as e:
        logger.error(f"State verification error: {e}")
        return False


@router.get("/line", summary="LINE 登入")
async def line_login():
    """
    導向 LINE 登入授權頁面
    """
    if not settings.LINE_LOGIN_CHANNEL_ID:
        raise HTTPException(
            status_code=500,
            detail="LINE Login 尚未設定"
        )

    # 產生 state
    state = create_state_token()

    # URL encode callback URL
    callback_url = urllib.parse.quote(settings.LINE_LOGIN_CALLBACK_URL, safe='')

    # 建立授權 URL
    auth_url = (
        "https://access.line.me/oauth2/v2.1/authorize"
        f"?response_type=code"
        f"&client_id={settings.LINE_LOGIN_CHANNEL_ID}"
        f"&redirect_uri={callback_url}"
        f"&state={state}"
        f"&scope=profile%20openid%20email"
    )

    logger.info(f"Redirecting to LINE with state: {state}")

    return RedirectResponse(url=auth_url)


@router.get("/line/callback", summary="LINE 登入回調")
async def line_callback(
    request: Request,
    background_tasks: BackgroundTasks,  # 🆕 加入 BackgroundTasks
    code: str = Query(..., description="授權碼"),
    state: str = Query(..., description="State"),
    db: AsyncSession = Depends(get_async_session),
):
    """
    LINE 登入回調處理
    
    - 驗證 state
    - 用 code 換取 access token
    - 取得用戶資料
    - 建立/更新用戶
    - 🆕 管理員登入時觸發背景更新
    - 回傳 HTML 頁面儲存 Token 並跳轉
    """
    from fastapi.responses import HTMLResponse

    # 驗證 state (使用 JWT 驗證)
    if not verify_state_token(state):
        raise HTTPException(
            status_code=400,
            detail="Invalid state"
        )

    # 取得客戶端資訊
    client_ip = request.client.host if request.client else None
    user_agent = request.headers.get("user-agent")

    # 執行登入流程
    auth_service = AuthService(db)
    result = await auth_service.login_with_line(code, client_ip, user_agent)

    if not result:
        # 可能是被封鎖的用戶
        html_content = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>SELA 自動選股系統</title>
            <style>
                body {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 100vh;
                    margin: 0;
                    background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                }
                .card {
                    background: white;
                    padding: 3rem;
                    border-radius: 1rem;
                    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
                    text-align: center;
                }
                h2 { color: #dc2626; margin: 0 0 1rem; }
                p { color: #64748b; margin: 0; }
                a { color: #3b82f6; }
            </style>
        </head>
        <body>
            <div class="card">
                <h2>⚠️ 登入失敗</h2>
                <p>您的帳號已被停用或登入過程發生錯誤</p>
                <p style="margin-top: 1rem;"><a href="/static/index.html">返回首頁</a></p>
            </div>
        </body>
        </html>
        """
        return HTMLResponse(content=html_content, status_code=403)

    # 回傳 HTML 頁面，將 Token 存入 localStorage 並跳轉到儀表板
    token = result["token"]
    user = result["user"]

    # 記錄登入成功的 log
    logger.info(f"=== 登入成功，準備跳轉 ===")
    logger.info(f"用戶 ID: {user.id}, LINE ID: {user.line_user_id}, 名稱: {user.display_name}")

    # 🆕 管理員登入觸發自動更新
    is_admin = getattr(user, 'is_admin', False)
    if is_admin:
        logger.info(f"🔑 管理員 {user.display_name} 登入，觸發背景更新")
        background_tasks.add_task(trigger_admin_updates)

    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>SELA 自動選股系統</title>
        <style>
            body {{
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                margin: 0;
                background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }}
            .card {{
                background: white;
                padding: 3rem;
                border-radius: 1rem;
                box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
                text-align: center;
            }}
            .logo {{
                background-color: #FA7A35;
                color: white;
                font-weight: bold;
                font-size: 1.5rem;
                padding: 0.5rem 1rem;
                border-radius: 0.5rem;
                display: inline-block;
                margin-bottom: 1.5rem;
            }}
            .spinner {{
                width: 50px;
                height: 50px;
                border: 4px solid #e2e8f0;
                border-top: 4px solid #FA7A35;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin: 0 auto 1.5rem;
            }}
            @keyframes spin {{
                0% {{ transform: rotate(0deg); }}
                100% {{ transform: rotate(360deg); }}
            }}
            h2 {{ color: #1e293b; margin: 0 0 0.5rem; }}
            p {{ color: #64748b; margin: 0; }}
            .admin-badge {{
                background: #fef3c7;
                color: #92400e;
                padding: 0.25rem 0.75rem;
                border-radius: 1rem;
                font-size: 0.75rem;
                margin-top: 0.5rem;
                display: inline-block;
            }}
        </style>
    </head>
    <body>
        <div class="card">
            <div class="logo">SELA</div>
            <div class="spinner"></div>
            <h2>登入成功！</h2>
            <p>歡迎回來，{user.display_name}</p>
            {'<div class="admin-badge">🔄 管理員模式 - 正在背景更新數據</div>' if is_admin else ''}
        </div>
        <script>
            // ★★★ 重要：先清除所有舊資料，避免 A 用戶看到 B 用戶的資料 ★★★
            localStorage.clear();
            sessionStorage.clear();
            
            // 設定新的用戶資料
            localStorage.setItem('token', '{token}');
            localStorage.setItem('user', JSON.stringify({{
                id: {user.id},
                display_name: "{user.display_name}",
                picture_url: "{user.picture_url or ''}",
                line_user_id: "{user.line_user_id}",
                is_admin: {'true' if is_admin else 'false'}
            }}));
            localStorage.setItem('login_time', new Date().toISOString());
            
            console.log('登入成功: 用戶 ID = {user.id}, LINE ID = {user.line_user_id}, 管理員 = {str(is_admin).lower()}');
            
            setTimeout(function() {{
                window.location.href = '/static/dashboard.html';
            }}, 1500);
        </script>
    </body>
    </html>
    """

    return HTMLResponse(content=html_content)


@router.post("/logout", summary="登出")
async def logout():
    """
    登出（前端清除 Token 即可）
    """
    return {"success": True, "message": "已登出"}


@router.get("/me", summary="取得當前用戶", response_model=UserResponse)
async def get_current_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得當前登入用戶資訊
    
    需要在 Header 帶入 Authorization: Bearer {token}
    """
    # 從 Header 取得 Token
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(
            status_code=401,
            detail="未提供認證 Token"
        )

    token = auth_header.split(" ")[1]

    # 驗證 Token 並取得用戶
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)

    if not user:
        raise HTTPException(
            status_code=401,
            detail="無效的 Token"
        )

    return UserResponse.model_validate(user)
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/compare.py  ⭐⭐⭐
> 報酬率比較 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
報酬率比較 API 路由
"""
from typing import List, Optional
from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException, Query, Request
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession
import logging

from app.database import get_async_session
from app.services.compare_service import compare_service, ComparisonCRUD
from app.services.auth_service import AuthService
from app.models.user import User

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/compare", tags=["Compare"])


# ==================== 認證依賴 ====================

async def get_current_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
) -> User:
    """依賴注入：取得當前用戶"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        logger.warning("Compare API: 未提供認證 Token")
        raise HTTPException(
            status_code=401,
            detail="未提供認證 Token"
        )
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        logger.warning("Compare API: Token 驗證失敗")
        raise HTTPException(
            status_code=401,
            detail="無效的 Token"
        )
    
    return user


async def get_optional_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
) -> Optional[User]:
    """依賴注入：取得當前用戶（可選，未登入返回 None）"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        return None
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    return user


# ==================== Schemas ====================

class CompareRequest(BaseModel):
    """比較請求"""
    symbols: List[str] = Field(..., min_length=1, max_length=5, description="標的代號列表")
    periods: List[str] = Field(default=["1y", "3y", "5y", "10y"], description="時間週期")
    custom_range: Optional[dict] = Field(default=None, description="自訂區間 {start, end}")
    benchmark: str = Field(default="^GSPC", description="基準指數")
    sort_by: str = Field(default="5y", description="排序依據")
    sort_order: str = Field(default="desc", pattern="^(asc|desc)$", description="排序方向")


class SaveComparisonRequest(BaseModel):
    """儲存比較組合請求"""
    name: str = Field(..., min_length=1, max_length=100, description="組合名稱")
    symbols: List[str] = Field(..., min_length=1, max_length=5, description="標的代號列表")
    benchmark: str = Field(default="^GSPC", description="基準指數")


class UpdateComparisonRequest(BaseModel):
    """更新比較組合請求"""
    name: Optional[str] = Field(default=None, max_length=100)
    symbols: Optional[List[str]] = Field(default=None, max_length=5)
    benchmark: Optional[str] = Field(default=None)


# ==================== 公開 API ====================

@router.post("/cagr", summary="計算年化報酬率比較")
async def compare_cagr(request: CompareRequest):
    """
    比較多個標的的年化報酬率 (CAGR)
    
    - 支援股票、加密貨幣、指數混合比較
    - 最多 5 個標的
    - 可選時間週期：1年、3年、5年、10年、自訂區間
    """
    result = await compare_service.compare_cagr(
        symbols=request.symbols,
        periods=request.periods,
        custom_range=request.custom_range,
        benchmark=request.benchmark,
        sort_by=request.sort_by,
        sort_order=request.sort_order,
    )
    
    if not result.get("success"):
        raise HTTPException(status_code=400, detail=result.get("error", "比較失敗"))
    
    return result


@router.get("/presets", summary="取得預設組合列表")
async def get_presets():
    """取得所有預設比較組合"""
    presets = compare_service.get_presets()
    return {
        "success": True,
        "presets": presets,
    }


@router.get("/presets/{preset_id}", summary="取得預設組合詳情")
async def get_preset_detail(preset_id: str):
    """取得預設組合的詳細內容"""
    preset = compare_service.get_preset_detail(preset_id)
    
    if not preset:
        raise HTTPException(status_code=404, detail="找不到該預設組合")
    
    return {
        "success": True,
        "preset": preset,
    }


@router.get("/benchmarks", summary="取得基準指數選項")
async def get_benchmarks():
    """取得可用的基準指數選項"""
    benchmarks = compare_service.get_benchmark_options()
    return {
        "success": True,
        "benchmarks": [
            {"symbol": k, "name": v}
            for k, v in benchmarks.items()
        ],
    }


# ==================== 用戶儲存的組合 API ====================

@router.get("/saved", summary="取得我的比較組合")
async def get_saved_comparisons(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得當前用戶儲存的所有比較組合"""
    crud = ComparisonCRUD(db)
    comparisons = await crud.get_user_comparisons(user.id)
    
    return {
        "success": True,
        "comparisons": [c.to_dict() for c in comparisons],
    }


@router.post("/saved", summary="儲存比較組合")
async def save_comparison(
    request: SaveComparisonRequest,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """儲存新的比較組合"""
    crud = ComparisonCRUD(db)
    
    # 檢查用戶已有的組合數量（限制最多 10 個）
    existing = await crud.get_user_comparisons(user.id)
    if len(existing) >= 10:
        raise HTTPException(status_code=400, detail="最多只能儲存 10 個比較組合")
    
    # 正規化 symbols
    symbols = [s.upper().strip() for s in request.symbols]
    
    comparison = await crud.create_comparison(
        user_id=user.id,
        name=request.name,
        symbols=symbols,
        benchmark=request.benchmark,
    )
    
    return {
        "success": True,
        "message": "比較組合已儲存",
        "comparison": comparison.to_dict(),
    }


@router.get("/saved/{comparison_id}", summary="取得單一比較組合")
async def get_saved_comparison(
    comparison_id: int,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得單一比較組合詳情"""
    crud = ComparisonCRUD(db)
    comparison = await crud.get_comparison(comparison_id, user.id)
    
    if not comparison:
        raise HTTPException(status_code=404, detail="找不到該比較組合")
    
    return {
        "success": True,
        "comparison": comparison.to_dict(),
    }


@router.put("/saved/{comparison_id}", summary="更新比較組合")
async def update_saved_comparison(
    comparison_id: int,
    request: UpdateComparisonRequest,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """更新儲存的比較組合"""
    crud = ComparisonCRUD(db)
    
    # 正規化 symbols
    symbols = None
    if request.symbols:
        symbols = [s.upper().strip() for s in request.symbols]
    
    comparison = await crud.update_comparison(
        comparison_id=comparison_id,
        user_id=user.id,
        name=request.name,
        symbols=symbols,
        benchmark=request.benchmark,
    )
    
    if not comparison:
        raise HTTPException(status_code=404, detail="找不到該比較組合")
    
    return {
        "success": True,
        "message": "比較組合已更新",
        "comparison": comparison.to_dict(),
    }


@router.delete("/saved/{comparison_id}", summary="刪除比較組合")
async def delete_saved_comparison(
    comparison_id: int,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """刪除儲存的比較組合"""
    crud = ComparisonCRUD(db)
    deleted = await crud.delete_comparison(comparison_id, user.id)
    
    if not deleted:
        raise HTTPException(status_code=404, detail="找不到該比較組合")
    
    return {
        "success": True,
        "message": "比較組合已刪除",
    }


# ==================== 快速比較 (結合 preset + 計算) ====================

@router.get("/quick/{preset_id}", summary="快速比較預設組合")
async def quick_compare_preset(
    preset_id: str,
    benchmark: str = Query(default="^GSPC", description="基準指數"),
    sort_by: str = Query(default="5y", description="排序依據"),
):
    """
    快速比較預設組合
    直接載入預設組合並計算 CAGR
    """
    preset = compare_service.get_preset_detail(preset_id)
    
    if not preset:
        raise HTTPException(status_code=404, detail="找不到該預設組合")
    
    result = await compare_service.compare_cagr(
        symbols=preset["symbols"],
        periods=["1y", "3y", "5y", "10y"],
        benchmark=benchmark,
        sort_by=sort_by,
        sort_order="desc",
    )
    
    result["preset"] = preset
    return result
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/crypto.py  ⭐⭐⭐
> 加密貨幣和市場情緒 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
加密貨幣和市場情緒 API 路由
"""
from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import FileResponse
import pandas as pd
import logging

from app.schemas.schemas import MarketSentimentResponse

router = APIRouter(tags=["加密貨幣"])
logger = logging.getLogger(__name__)

# 加密貨幣對應的 Yahoo Finance 代號
CRYPTO_YAHOO_MAP = {
    "BTC": "BTC-USD",
    "ETH": "ETH-USD",
    "BITCOIN": "BTC-USD",
    "ETHEREUM": "ETH-USD",
}


@router.get("/api/crypto/{symbol}", summary="查詢加密貨幣")
async def get_crypto_analysis(
    symbol: str,
    refresh: bool = Query(False, description="是否強制更新資料"),
):
    """
    查詢單一加密貨幣的技術分析報告
    
    - **symbol**: 加密貨幣代號 (BTC, ETH)
    - **refresh**: 是否強制更新資料
    """
    from app.data_sources.coingecko import coingecko
    from app.data_sources.yahoo_finance import yahoo_finance
    from app.services.indicator_service import indicator_service
    
    symbol = symbol.upper()
    logger.info(f"開始查詢加密貨幣: {symbol}")
    
    # 驗證代號
    yahoo_symbol = CRYPTO_YAHOO_MAP.get(symbol)
    if not yahoo_symbol and not coingecko.validate_symbol(symbol):
        logger.warning(f"不支援的加密貨幣: {symbol}")
        raise HTTPException(
            status_code=400,
            detail=f"不支援的加密貨幣: {symbol}，目前僅支援 BTC 和 ETH"
        )
    
    df = None
    info = None
    data_source = None
    
    # 優先嘗試 CoinGecko
    try:
        logger.info(f"嘗試從 CoinGecko 取得 {symbol} 資料...")
        df = coingecko.get_ohlc(symbol, days=365)
        if df is not None and not df.empty:
            info = coingecko.get_coin_info(symbol)
            data_source = "CoinGecko"
            logger.info(f"成功從 CoinGecko 取得 {len(df)} 筆資料")
    except Exception as e:
        logger.warning(f"CoinGecko API 失敗: {e}")
    
    # 如果 CoinGecko 失敗，使用 Yahoo Finance 備用
    if df is None or df.empty:
        yahoo_symbol = CRYPTO_YAHOO_MAP.get(symbol, f"{symbol}-USD")
        logger.info(f"CoinGecko 失敗，嘗試 Yahoo Finance: {yahoo_symbol}")
        
        try:
            df = yahoo_finance.get_stock_history(yahoo_symbol, period="1y")
            if df is not None and not df.empty:
                data_source = "Yahoo Finance"
                logger.info(f"成功從 Yahoo Finance 取得 {len(df)} 筆資料")
                # 從 Yahoo Finance 取得基本資訊
                try:
                    yf_info = yahoo_finance.get_stock_info(yahoo_symbol)
                    if yf_info:
                        info = {
                            "name": yf_info.get("shortName") or yf_info.get("name") or symbol,
                            "market_cap": yf_info.get("market_cap") or yf_info.get("marketCap"),
                            "total_volume": yf_info.get("total_volume"),
                        }
                except Exception as e:
                    logger.warning(f"取得 Yahoo Finance info 失敗: {e}")
                    info = {"name": symbol}
        except Exception as e:
            logger.error(f"Yahoo Finance 也失敗: {e}")
    
    # 如果兩個都失敗
    if df is None or df.empty:
        raise HTTPException(
            status_code=503,
            detail=f"無法取得 {symbol} 資料。CoinGecko 和 Yahoo Finance 都無法連接。請稍後再試。"
        )
    
    logger.info(f"使用 {data_source} 資料，共 {len(df)} 筆")
    
    # 確保有必要的欄位 (在 try 塊外面先處理)
    if 'volume' not in df.columns:
        df['volume'] = 0
        logger.warning(f"{symbol} 沒有 volume 資料，已填入 0")
    
    # 確保 volume 不是 None 或 NaN
    df['volume'] = df['volume'].fillna(0).astype(float)
    
    try:
        # 計算技術指標
        df = indicator_service.calculate_all_indicators(df)
        
        # 取得最新資料
        latest = df.iloc[-1]
        current_price = float(latest['close'])
        
        # 漲跌幅計算
        def calc_change(days):
            try:
                if len(df) > days:
                    old_price = float(df.iloc[-days-1]['close'])
                    return round((current_price - old_price) / old_price * 100, 2)
            except:
                pass
            return None
        
        # 均線資訊 (加密貨幣用 MA7/25/99)
        ma7 = float(df['close'].tail(7).mean()) if len(df) >= 7 else None
        ma25 = float(df['close'].tail(25).mean()) if len(df) >= 25 else None
        ma99 = float(df['close'].tail(99).mean()) if len(df) >= 99 else None
        
        # 判斷均線排列
        alignment = "neutral"
        if ma7 and ma25 and ma99:
            if current_price > ma7 > ma25 > ma99:
                alignment = "bullish"
            elif current_price < ma7 < ma25 < ma99:
                alignment = "bearish"
        
        # RSI (小寫: rsi)
        rsi_value = float(latest.get('rsi', 50)) if 'rsi' in latest else 50
        rsi_status = "overbought" if rsi_value > 70 else "oversold" if rsi_value < 30 else "neutral"
        
        # MACD (小寫: macd_dif, macd_dea)
        macd_dif = float(latest.get('macd_dif', 0)) if 'macd_dif' in latest else 0
        macd_dea = float(latest.get('macd_dea', 0)) if 'macd_dea' in latest else 0
        macd_status = "bullish" if macd_dif > macd_dea else "bearish"
        
        # 綜合評分
        buy_score = 0
        sell_score = 0
        
        if alignment == "bullish":
            buy_score += 1
        elif alignment == "bearish":
            sell_score += 1
        
        if rsi_value < 30:
            buy_score += 1
        elif rsi_value > 70:
            sell_score += 1
        
        if macd_status == "bullish":
            buy_score += 1
        else:
            sell_score += 1
        
        rating = "bullish" if buy_score > sell_score else "bearish" if sell_score > buy_score else "neutral"
        
        return {
            "success": True,
            "symbol": symbol,
            "name": info.get("name", symbol) if info else symbol,
            "asset_type": "crypto",
            "price": {
                "current": current_price,
                "ath": info.get("ath") if info else None,
                "from_ath_pct": info.get("ath_change_percentage") if info else None,
            },
            "change": {
                "day": calc_change(1),
                "week": calc_change(7),
                "month": calc_change(30),
                "year": calc_change(365),
            },
            "market": {
                "market_cap": info.get("market_cap") if info else None,
                "market_cap_rank": info.get("market_cap_rank") if info else None,
                "volume_24h": info.get("total_volume") if info else None,
            },
            "indicators": {
                "ma": {
                    "ma7": ma7,
                    "ma25": ma25,
                    "ma99": ma99,
                    "alignment": alignment,
                    "price_vs_ma7": "above" if ma7 and current_price > ma7 else "below",
                    "price_vs_ma25": "above" if ma25 and current_price > ma25 else "below",
                    "price_vs_ma99": "above" if ma99 and current_price > ma99 else "below",
                },
                "rsi": {
                    "value": rsi_value,
                    "period": 14,
                    "status": rsi_status,
                },
                "macd": {
                    "dif": macd_dif,
                    "macd": macd_dea,
                    "status": macd_status,
                },
            },
            "score": {
                "buy": buy_score,
                "sell": sell_score,
                "rating": rating,
            },
            "chart_data": {
                "dates": [str(d) for d in df['date'].tail(365).tolist()] if 'date' in df.columns else [],
                "prices": [float(p) for p in df['close'].tail(365).tolist()] if 'close' in df.columns else [],
                "ma20": [float(v) if not pd.isna(v) else None for v in df['ma20'].tail(365).tolist()] if 'ma20' in df.columns else [],
                "ma50": [float(v) if not pd.isna(v) else None for v in df['ma50'].tail(365).tolist()] if 'ma50' in df.columns else [],
                "ma200": [float(v) if not pd.isna(v) else None for v in df['ma200'].tail(365).tolist()] if 'ma200' in df.columns else [],
                "ma250": [float(v) if not pd.isna(v) else None for v in df['ma250'].tail(365).tolist()] if 'ma250' in df.columns else [],
            },
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"查詢 {symbol} 時發生錯誤: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"查詢失敗: {str(e)}"
        )


@router.get("/api/crypto/{symbol}/chart", summary="取得加密貨幣圖表")
async def get_crypto_chart(
    symbol: str,
    days: int = Query(120, ge=30, le=365, description="顯示天數"),
):
    """
    生成加密貨幣技術分析圖表
    
    - **symbol**: 加密貨幣代號 (BTC, ETH)
    - **days**: 顯示天數 (30-365)
    
    回傳 PNG 圖片
    """
    from app.data_sources.coingecko import coingecko
    from app.services.chart_service import chart_service
    
    symbol = symbol.upper()
    
    df = coingecko.get_ohlc(symbol, days=days)
    
    if df is None or df.empty:
        raise HTTPException(
            status_code=404,
            detail=f"找不到加密貨幣: {symbol}"
        )
    
    # 取得名稱
    info = coingecko.get_coin_info(symbol)
    name = info.get("name", "") if info else ""
    
    # 生成圖表
    chart_path = chart_service.plot_stock_analysis(
        df,
        symbol=symbol,
        name=name,
        days=days,
        show_kd=False,
    )
    
    return FileResponse(
        chart_path,
        media_type="image/png",
        filename=f"{symbol}_chart.png",
    )


@router.get("/api/market/sentiment", summary="取得市場情緒", response_model=MarketSentimentResponse)
async def get_market_sentiment(
    market: str = Query("all", description="市場類型 (stock, crypto, all)"),
):
    """
    取得市場情緒指數
    
    - **market**: 市場類型
      - `stock`: 美股 CNN Fear & Greed Index
      - `crypto`: 加密貨幣 Alternative.me
      - `all`: 兩者都取得
    
    情緒指數範圍 0-100：
    - 0-25: 極度恐懼
    - 26-45: 恐懼
    - 46-55: 中性
    - 56-75: 貪婪
    - 76-100: 極度貪婪
    """
    from app.data_sources.fear_greed import fear_greed
    
    result = {}
    
    if market in ("all", "stock"):
        stock_sentiment = fear_greed.get_stock_fear_greed()
        if stock_sentiment:
            result["stock"] = stock_sentiment
    
    if market in ("all", "crypto"):
        crypto_sentiment = fear_greed.get_crypto_fear_greed()
        if crypto_sentiment:
            result["crypto"] = crypto_sentiment
    
    return MarketSentimentResponse(
        success=True,
        stock=result.get("stock"),
        crypto=result.get("crypto"),
    )
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/market.py  ⭐⭐⭐
> 市場資料 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
市場資料 API 路由
三大指數、市場情緒、排程任務
"""
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from sqlalchemy.orm import Session
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
import logging

from app.database import get_db, get_async_session
from app.services.market_service import MarketService
from app.services.auth_service import AuthService
from app.tasks.scheduler import scheduler_service
from app.models.index_price import INDEX_SYMBOLS

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/market", tags=["market"])


# ==================== 認證依賴 ====================

async def get_current_user_optional(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
):
    """取得當前用戶（選擇性，未登入返回 None）"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        return None
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    return user


async def get_current_admin(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
):
    """取得當前管理員（必須是管理員）"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="未提供認證 Token")
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        raise HTTPException(status_code=401, detail="無效的 Token")
    
    if not user.is_admin:
        raise HTTPException(status_code=403, detail="需要管理員權限")
    
    return user


# ==================== 三大指數 ====================

@router.get("/indices")
async def get_indices(
    db: Session = Depends(get_db),
):
    """
    取得三大指數最新資料
    
    Returns:
        - S&P 500 (^GSPC)
        - 道瓊工業 (^DJI)
        - 納斯達克 (^IXIC)
    """
    try:
        market_service = MarketService(db)
        indices = market_service.get_latest_indices()
        
        return {
            "success": True,
            "data": {
                "indices": indices,
                "symbols": INDEX_SYMBOLS,
            }
        }
    except Exception as e:
        logger.error(f"取得指數失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/indices/{symbol}/history")
async def get_index_history(
    symbol: str,
    days: int = Query(default=365, ge=1, le=3650),
    db: Session = Depends(get_db),
):
    """
    取得指數歷史資料
    
    Args:
        symbol: 指數代號 (^GSPC, ^DJI, ^IXIC)
        days: 天數 (預設 365，最多 3650)
    """
    # 驗證 symbol
    if symbol not in INDEX_SYMBOLS:
        raise HTTPException(
            status_code=400,
            detail=f"無效的指數代號，可用: {list(INDEX_SYMBOLS.keys())}"
        )
    
    try:
        market_service = MarketService(db)
        history = market_service.get_index_history(symbol, days)
        
        return {
            "success": True,
            "data": {
                "symbol": symbol,
                "name": INDEX_SYMBOLS[symbol]["name"],
                "name_zh": INDEX_SYMBOLS[symbol]["name_zh"],
                "days": days,
                "count": len(history),
                "history": history,
            }
        }
    except Exception as e:
        logger.error(f"取得指數歷史失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ==================== 市場情緒 ====================

@router.get("/sentiment")
async def get_sentiment(
    db: Session = Depends(get_db),
):
    """
    取得市場情緒（美股 + 幣圈）
    """
    try:
        market_service = MarketService(db)
        sentiment = market_service.get_latest_sentiment()
        
        return {
            "success": True,
            "data": sentiment,
        }
    except Exception as e:
        logger.error(f"取得情緒失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/sentiment/{market}/history")
async def get_sentiment_history(
    market: str,
    days: int = Query(default=365, ge=1, le=365),
    db: Session = Depends(get_db),
):
    """
    取得情緒歷史資料
    
    Args:
        market: 市場類型 (stock, crypto)
        days: 天數 (預設 365，最多 365)
    """
    if market not in ["stock", "crypto"]:
        raise HTTPException(
            status_code=400,
            detail="無效的市場類型，可用: stock, crypto"
        )
    
    try:
        market_service = MarketService(db)
        history = market_service.get_sentiment_history(market, days)
        
        return {
            "success": True,
            "data": {
                "market": market,
                "days": days,
                "count": len(history),
                "history": history,
            }
        }
    except Exception as e:
        logger.error(f"取得情緒歷史失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ==================== 管理員功能：排程任務 ====================

@router.post("/admin/update")
async def trigger_daily_update(
    current_user = Depends(get_current_admin),
    db: Session = Depends(get_db),
):
    """
    [管理員] 手動觸發每日更新
    """
    try:
        result = scheduler_service.run_daily_update()
        
        return {
            "success": result.get("success", False),
            "data": result,
        }
    except Exception as e:
        logger.error(f"執行更新失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/admin/initialize")
async def initialize_historical_data(
    years: int = Query(default=10, ge=1, le=10),
    current_user = Depends(get_current_admin),
    db: Session = Depends(get_db),
):
    """
    [管理員] 初始化歷史資料
    
    首次部署時執行，抓取：
    - 三大指數 N 年歷史
    - 幣圈情緒 365 天歷史
    """
    try:
        result = scheduler_service.initialize_historical_data(years=years)
        
        return {
            "success": result.get("success", False),
            "data": result,
        }
    except Exception as e:
        logger.error(f"初始化失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/admin/update-indices")
async def update_indices(
    period: str = Query(default="5d", pattern="^(5d|1mo|3mo|1y|5y|10y)$"),
    current_user = Depends(get_current_admin),
    db: Session = Depends(get_db),
):
    """
    [管理員] 更新三大指數資料
    """
    try:
        market_service = MarketService(db)
        result = market_service.fetch_and_save_all_indices(period=period)
        
        return {
            "success": True,
            "data": {
                "period": period,
                "indices": result,
            }
        }
    except Exception as e:
        logger.error(f"更新指數失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/admin/update-sentiment")
async def update_sentiment(
    current_user = Depends(get_current_admin),
    db: Session = Depends(get_db),
):
    """
    [管理員] 更新今日市場情緒
    """
    try:
        market_service = MarketService(db)
        result = market_service.update_today_sentiment()
        
        return {
            "success": True,
            "data": result,
        }
    except Exception as e:
        logger.error(f"更新情緒失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/admin/init-crypto-sentiment")
async def init_crypto_sentiment(
    days: int = Query(default=365, ge=1, le=365),
    current_user = Depends(get_current_admin),
    db: Session = Depends(get_db),
):
    """
    [管理員] 初始化幣圈情緒歷史
    """
    try:
        market_service = MarketService(db)
        count = market_service.fetch_and_save_crypto_history(days=days)
        
        return {
            "success": True,
            "data": {
                "days_requested": days,
                "records_added": count,
            }
        }
    except Exception as e:
        logger.error(f"初始化幣圈情緒失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/admin/scheduler-status")
async def get_scheduler_status(
    current_user = Depends(get_current_admin),
):
    """
    [管理員] 取得排程狀態
    """
    return {
        "success": True,
        "data": scheduler_service.get_status(),
    }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/portfolio.py  ⭐⭐⭐
> 個人投資記錄 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
個人投資記錄 API 路由
"""
from datetime import date
from typing import Optional, List
from pydantic import BaseModel, Field
import logging

from fastapi import APIRouter, Depends, HTTPException, Request, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.database import get_async_session
from app.services.auth_service import AuthService
from app.services.portfolio_service import PortfolioService
from app.services.exchange_rate_service import get_exchange_rate, set_exchange_rate
from app.models.user import User

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/portfolio", tags=["個人投資記錄"])


# ============================================================
# Pydantic Schemas
# ============================================================

class TransactionCreate(BaseModel):
    """新增交易請求"""
    symbol: str = Field(..., min_length=1, max_length=20, description="股票代碼")
    name: Optional[str] = Field(None, max_length=100, description="股票名稱")
    market: str = Field(..., pattern="^(tw|us)$", description="市場 (tw/us)")
    transaction_type: str = Field(..., pattern="^(buy|sell)$", description="交易類型 (buy/sell)")
    quantity: int = Field(..., gt=0, description="股數（台股：張×1000 + 零股）")
    price: float = Field(..., gt=0, description="成交價")
    fee: Optional[float] = Field(0, ge=0, description="手續費")
    tax: Optional[float] = Field(0, ge=0, description="交易稅")
    transaction_date: date = Field(..., description="交易日期")
    note: Optional[str] = Field(None, max_length=500, description="備註")


class TransactionUpdate(BaseModel):
    """更新交易請求"""
    symbol: Optional[str] = Field(None, min_length=1, max_length=20)
    name: Optional[str] = Field(None, max_length=100)
    market: Optional[str] = Field(None, pattern="^(tw|us)$")
    transaction_type: Optional[str] = Field(None, pattern="^(buy|sell)$")
    quantity: Optional[int] = Field(None, gt=0)
    price: Optional[float] = Field(None, gt=0)
    fee: Optional[float] = Field(None, ge=0)
    tax: Optional[float] = Field(None, ge=0)
    transaction_date: Optional[date] = None
    note: Optional[str] = Field(None, max_length=500)


class ExchangeRateUpdate(BaseModel):
    """更新匯率請求"""
    rate: float = Field(..., gt=0, description="USD/TWD 匯率")


# ============================================================
# 依賴注入
# ============================================================

async def get_current_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
) -> User:
    """驗證用戶身份"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="未提供認證 Token")
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        raise HTTPException(status_code=401, detail="無效的 Token")
    
    return user


# ============================================================
# 匯率 API
# ============================================================

@router.get("/exchange-rate", summary="取得匯率")
async def get_rate(
    db: AsyncSession = Depends(get_async_session),
):
    """取得目前的 USD/TWD 匯率"""
    rate_info = await get_exchange_rate(db)
    return {
        "success": True,
        "data": rate_info,
    }


@router.put("/exchange-rate", summary="設定匯率")
async def update_rate(
    data: ExchangeRateUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """手動設定 USD/TWD 匯率"""
    rate_info = await set_exchange_rate(db, data.rate)
    return {
        "success": True,
        "message": "匯率已更新",
        "data": rate_info,
    }


# ============================================================
# 交易紀錄 API
# ============================================================

@router.post("/transactions", summary="新增交易紀錄")
async def create_transaction(
    data: TransactionCreate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    新增一筆股票交易紀錄
    
    - **symbol**: 股票代碼（如 AAPL、2330）
    - **market**: 市場類型（tw=台股, us=美股）
    - **transaction_type**: buy=買入, sell=賣出
    - **quantity**: 總股數（台股：張×1000 + 零股）
    - **price**: 成交價
    - **fee**: 手續費（可選）
    - **tax**: 交易稅（可選，賣出時）
    """
    logger.info(f"新增交易: user={user.id}, {data.transaction_type} {data.quantity} {data.symbol}")
    
    try:
        service = PortfolioService(db)
        transaction = await service.create_transaction(
            user_id=user.id,
            symbol=data.symbol,
            name=data.name,
            market=data.market,
            transaction_type=data.transaction_type,
            quantity=data.quantity,
            price=data.price,
            fee=data.fee or 0,
            tax=data.tax or 0,
            transaction_date=data.transaction_date,
            note=data.note,
        )
        
        return {
            "success": True,
            "message": "交易紀錄已新增",
            "data": transaction.to_dict(),
        }
        
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"新增交易失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="新增交易失敗")


@router.get("/transactions", summary="取得交易紀錄")
async def get_transactions(
    market: Optional[str] = Query(None, pattern="^(tw|us)$", description="篩選市場"),
    symbol: Optional[str] = Query(None, description="篩選股票"),
    limit: int = Query(100, ge=1, le=500, description="筆數上限"),
    offset: int = Query(0, ge=0, description="偏移量"),
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得用戶的交易紀錄列表"""
    try:
        service = PortfolioService(db)
        transactions = await service.get_transactions(
            user_id=user.id,
            market=market,
            symbol=symbol,
            limit=limit,
            offset=offset,
        )
        
        return {
            "success": True,
            "data": [t.to_dict() for t in transactions],
            "total": len(transactions),
        }
        
    except Exception as e:
        logger.error(f"取得交易紀錄失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="取得交易紀錄失敗")


@router.get("/transactions/{transaction_id}", summary="取得單筆交易")
async def get_transaction(
    transaction_id: int,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """取得單筆交易紀錄詳情"""
    service = PortfolioService(db)
    transaction = await service.get_transaction(transaction_id, user.id)
    
    if not transaction:
        raise HTTPException(status_code=404, detail="找不到交易紀錄")
    
    return {
        "success": True,
        "data": transaction.to_dict(),
    }


@router.put("/transactions/{transaction_id}", summary="更新交易紀錄")
async def update_transaction(
    transaction_id: int,
    data: TransactionUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """更新交易紀錄"""
    logger.info(f"更新交易: user={user.id}, id={transaction_id}")
    
    try:
        service = PortfolioService(db)
        
        # 只傳入有值的欄位
        update_data = {k: v for k, v in data.dict().items() if v is not None}
        
        transaction = await service.update_transaction(
            transaction_id=transaction_id,
            user_id=user.id,
            **update_data,
        )
        
        if not transaction:
            raise HTTPException(status_code=404, detail="找不到交易紀錄")
        
        return {
            "success": True,
            "message": "交易紀錄已更新",
            "data": transaction.to_dict(),
        }
        
    except HTTPException:
        raise
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"更新交易失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="更新交易失敗")


@router.delete("/transactions/{transaction_id}", summary="刪除交易紀錄")
async def delete_transaction(
    transaction_id: int,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """刪除交易紀錄"""
    logger.info(f"刪除交易: user={user.id}, id={transaction_id}")
    
    service = PortfolioService(db)
    success = await service.delete_transaction(transaction_id, user.id)
    
    if not success:
        raise HTTPException(status_code=404, detail="找不到交易紀錄")
    
    return {
        "success": True,
        "message": "交易紀錄已刪除",
    }


# ============================================================
# 持股 API
# ============================================================

@router.get("/holdings", summary="取得持股總覽")
async def get_holdings(
    market: Optional[str] = Query(None, pattern="^(tw|us)$", description="篩選市場"),
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶的持股列表（含現價和損益）
    
    - 現價來自價格快取
    - 包含未實現損益計算
    """
    try:
        service = PortfolioService(db)
        holdings = await service.get_holdings_with_prices(user.id, market)
        
        # 分類
        tw_holdings = [h for h in holdings if h['market'] == 'tw' and h['total_shares'] > 0]
        us_holdings = [h for h in holdings if h['market'] == 'us' and h['total_shares'] > 0]
        
        return {
            "success": True,
            "data": {
                "tw": tw_holdings,
                "us": us_holdings,
            },
            "total": len(tw_holdings) + len(us_holdings),
        }
        
    except Exception as e:
        logger.error(f"取得持股失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="取得持股失敗")


@router.get("/summary", summary="取得投資摘要")
async def get_summary(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得投資組合摘要統計
    
    包含：
    - 匯率資訊
    - 台股統計
    - 美股統計
    - 總計（換算 TWD）
    """
    try:
        service = PortfolioService(db)
        summary = await service.get_summary(user.id)
        
        return {
            "success": True,
            "data": summary,
        }
        
    except Exception as e:
        logger.error(f"取得投資摘要失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="取得投資摘要失敗")
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/stock.py  ⭐⭐⭐
> 股票查詢 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
股票查詢 API 路由

修復: 台股代號自動轉換 (0050 → 0050.TW)
新增: 查詢結果自動快取（含 MA20）
"""
from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import FileResponse
import logging
import pandas as pd
from datetime import datetime

from app.schemas.schemas import StockAnalysisResponse

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/stock", tags=["股票"])


def normalize_tw_symbol(symbol: str) -> str:
    """
    標準化台股代號
    - 純數字 4-6 位 → 自動加 .TW
    - ETF 槓桿/反向 (如 00631L, 00632R) → 自動加 .TW
    - 已有後綴 → 保持不變
    """
    symbol = symbol.strip().upper()
    
    # 如果已經有後綴，不處理
    if '.' in symbol or symbol.startswith('^'):
        return symbol
    
    # 台股代號：4-6 位純數字
    if symbol.isdigit() and 4 <= len(symbol) <= 6:
        return f"{symbol}.TW"
    
    # 台股 ETF 槓桿/反向：數字開頭 + L/R/U 結尾 (如 00631L, 00632R, 00635U)
    if len(symbol) >= 5 and symbol[:-1].isdigit() and symbol[-1] in ('L', 'R', 'U'):
        return f"{symbol}.TW"
    
    return symbol


@router.get("/{symbol}", summary="查詢股票")
async def get_stock_analysis(
    symbol: str,
    refresh: bool = Query(False, description="是否強制更新資料"),
):
    """
    查詢單一股票的技術分析報告
    """
    from app.data_sources.yahoo_finance import yahoo_finance
    from app.services.indicator_service import indicator_service
    
    # 台股代號自動轉換
    symbol = normalize_tw_symbol(symbol)
    original_symbol = symbol
    logger.info(f"開始查詢股票: {symbol}")
    
    try:
        # 取得股票資料 (抓取 10 年以計算長期 CAGR)
        logger.info(f"正在從 Yahoo Finance 取得 {symbol} 資料...")
        df = yahoo_finance.get_stock_history(symbol, period="10y")
        
        # 如果 .TW 找不到，嘗試 .TWO (上櫃股票)
        if (df is None or df.empty) and symbol.endswith('.TW'):
            two_symbol = symbol.replace('.TW', '.TWO')
            logger.info(f"{symbol} 找不到，嘗試上櫃股票: {two_symbol}")
            df = yahoo_finance.get_stock_history(two_symbol, period="10y")
            if df is not None and not df.empty:
                symbol = two_symbol
                logger.info(f"成功找到上櫃股票: {two_symbol}")
        
        if df is None or df.empty:
            logger.warning(f"找不到股票資料: {original_symbol}")
            raise HTTPException(
                status_code=404,
                detail=f"找不到股票: {original_symbol}（已嘗試上市 .TW 和上櫃 .TWO）"
            )
        
        logger.info(f"取得 {len(df)} 筆資料，正在計算技術指標...")
        
        # 取得股票資訊
        info = yahoo_finance.get_stock_info(symbol)
        
        # 保存原始收盤價（用於顯示）
        df['close_raw'] = df['close'].copy()
        
        # 使用調整後價格計算技術指標（處理分割和配息）
        # 這樣 MA 線和圖表才不會有斷崖
        if 'adj_close' in df.columns:
            df['close'] = df['adj_close']
            logger.info(f"{symbol} 使用調整後價格計算指標")
        
        # 計算技術指標（基於調整後價格）
        df = indicator_service.calculate_all_indicators(df)
        
        # 取得最新資料
        latest = df.iloc[-1]
        # 顯示用原始價格（用戶習慣看的價格）
        current_price = float(latest['close_raw'])
        
        logger.info(f"{symbol} 現價: {current_price}")
        
        # 價格資訊（用原始價格顯示 52 週高低）
        high_52w = float(df['close_raw'].tail(252).max()) if len(df) >= 252 else float(df['close_raw'].max())
        low_52w = float(df['close_raw'].tail(252).min()) if len(df) >= 252 else float(df['close_raw'].min())
        
        # 漲跌幅計算（用調整後價格計算，反映真實報酬）
        current_price_adj = float(latest['close'])  # 調整後現價
        def calc_change(days):
            if len(df) > days:
                old_price_adj = float(df.iloc[-days-1]['close'])  # 調整後歷史價格
                return round((current_price_adj - old_price_adj) / old_price_adj * 100, 2)
            return None
        
        # 均線資訊 (indicator_service 用小寫: ma20, ma50, ma200)
        ma20 = float(latest.get('ma20', 0)) if 'ma20' in latest else None
        ma50 = float(latest.get('ma50', 0)) if 'ma50' in latest else None
        ma200 = float(latest.get('ma200', 0)) if 'ma200' in latest else None
        
        # 判斷均線排列（用調整後價格比較）
        alignment = "neutral"
        if ma20 and ma50 and ma200:
            if current_price_adj > ma20 > ma50 > ma200:
                alignment = "bullish"
            elif current_price_adj < ma20 < ma50 < ma200:
                alignment = "bearish"
        
        # RSI (小寫: rsi)
        rsi_value = float(latest.get('rsi', 50)) if 'rsi' in latest else 50
        rsi_status = "overbought" if rsi_value > 70 else "oversold" if rsi_value < 30 else "neutral"
        
        # MACD (小寫: macd_dif, macd_dea, macd_hist)
        macd_dif = float(latest.get('macd_dif', 0)) if 'macd_dif' in latest else 0
        macd_dea = float(latest.get('macd_dea', 0)) if 'macd_dea' in latest else 0
        macd_hist = float(latest.get('macd_hist', 0)) if 'macd_hist' in latest else 0
        macd_status = "bullish" if macd_dif > macd_dea else "bearish"
        
        # 成交量
        volume_today = int(latest['volume']) if 'volume' in latest else 0
        volume_avg = int(df['volume'].tail(20).mean()) if 'volume' in df.columns else 0
        volume_ratio = round(volume_today / volume_avg, 2) if volume_avg > 0 else 1.0
        
        # 綜合評分
        buy_score = 0
        sell_score = 0
        
        if alignment == "bullish":
            buy_score += 1
        elif alignment == "bearish":
            sell_score += 1
        
        if rsi_value < 30:
            buy_score += 1
        elif rsi_value > 70:
            sell_score += 1
        
        if macd_status == "bullish":
            buy_score += 1
        else:
            sell_score += 1
        
        rating = "bullish" if buy_score > sell_score else "bearish" if sell_score > buy_score else "neutral"
        
        logger.info(f"{symbol} 查詢完成，評分: {rating}")
        
        # 確保 name 正確獲取
        stock_name = ""
        if info:
            stock_name = info.get("name", "")
        if not stock_name:
            # 再次嘗試從本地映射表獲取
            from app.data_sources.yahoo_finance import TAIWAN_STOCK_NAMES
            stock_code = symbol.replace(".TW", "").replace(".TWO", "")
            stock_name = TAIWAN_STOCK_NAMES.get(stock_code, symbol)
        
        # 🆕 將查詢結果寫入快取（含 MA20）
        from app.services.cache_helper import cache_stock_price
        
        day_change = calc_change(1)
        prev_close = float(df.iloc[-2]['close_raw']) if len(df) > 1 else None
        change_amount = current_price - prev_close if prev_close else None
        
        cache_stock_price(
            symbol=symbol,
            name=stock_name,
            price=current_price,
            prev_close=prev_close,
            change=change_amount,
            change_pct=day_change,
            ma20=ma20,
            volume=volume_today
        )
        
        return {
            "success": True,
            "symbol": symbol,
            "name": stock_name,
            "asset_type": "stock",
            "price": {
                "current": current_price,
                "high_52w": high_52w,
                "low_52w": low_52w,
                "from_high_pct": round((current_price - high_52w) / high_52w * 100, 2),
                "from_low_pct": round((current_price - low_52w) / low_52w * 100, 2),
            },
            "change": {
                "day": calc_change(1),
                "week": calc_change(5),
                "month": calc_change(20),
                "quarter": calc_change(60),
                "year": calc_change(250),
            },
            "volume": {
                "today": volume_today,
                "avg_20d": volume_avg,
                "ratio": volume_ratio,
            },
            "indicators": {
                "ma": {
                    "ma20": ma20,
                    "ma50": ma50,
                    "ma200": ma200,
                    "alignment": alignment,
                    "price_vs_ma20": "above" if ma20 and current_price > ma20 else "below" if ma20 else None,
                    "price_vs_ma50": "above" if ma50 and current_price > ma50 else "below" if ma50 else None,
                    "price_vs_ma200": "above" if ma200 and current_price > ma200 else "below" if ma200 else None,
                },
                "rsi": {
                    "value": rsi_value,
                    "period": 14,
                    "status": rsi_status,
                },
                "macd": {
                    "dif": macd_dif,
                    "macd": macd_dea,
                    "histogram": macd_hist,
                    "status": macd_status,
                },
            },
            "score": {
                "buy": buy_score,
                "sell": sell_score,
                "rating": rating,
            },
            # 添加圖表數據 (最近 1500 天，支援 5 年範圍)
            "chart_data": {
                "dates": [str(d) for d in df['date'].tail(1500).tolist()],
                "prices": [float(p) for p in df['close'].tail(1500).tolist()],
                "ma20": [float(v) if not pd.isna(v) else None for v in df['ma20'].tail(1500).tolist()] if 'ma20' in df.columns else [],
                "ma50": [float(v) if not pd.isna(v) else None for v in df['ma50'].tail(1500).tolist()] if 'ma50' in df.columns else [],
                "ma200": [float(v) if not pd.isna(v) else None for v in df['ma200'].tail(1500).tolist()] if 'ma200' in df.columns else [],
                "ma250": [float(v) if not pd.isna(v) else None for v in df['ma250'].tail(1500).tolist()] if 'ma250' in df.columns else [],
            },
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"查詢 {symbol} 時發生錯誤: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"查詢失敗: {str(e)}"
        )


@router.get("/{symbol}/chart", summary="取得股票圖表")
async def get_stock_chart(
    symbol: str,
    days: int = Query(120, ge=30, le=365, description="顯示天數"),
):
    """
    生成股票技術分析圖表
    """
    from app.data_sources.yahoo_finance import yahoo_finance
    from app.services.chart_service import chart_service
    
    # 台股代號自動轉換
    symbol = normalize_tw_symbol(symbol)
    
    df = yahoo_finance.get_stock_history(symbol, period="1y")
    
    # 如果 .TW 找不到，嘗試 .TWO
    if (df is None or df.empty) and symbol.endswith('.TW'):
        two_symbol = symbol.replace('.TW', '.TWO')
        df = yahoo_finance.get_stock_history(two_symbol, period="1y")
        if df is not None and not df.empty:
            symbol = two_symbol
    
    if df is None or df.empty:
        raise HTTPException(
            status_code=404,
            detail=f"找不到股票: {symbol}"
        )
    
    # 取得股票名稱
    info = yahoo_finance.get_stock_info(symbol)
    name = info.get("name", "") if info else ""
    
    # 生成圖表
    chart_path = chart_service.plot_stock_analysis(
        df,
        symbol=symbol,
        name=name,
        days=days,
        show_kd=False,
    )
    
    return FileResponse(
        chart_path,
        media_type="image/png",
        filename=f"{symbol}_chart.png",
    )


@router.get("/compare/history", summary="走勢比較")
async def compare_stocks(
    symbols: str = Query(..., description="股票代號，逗號分隔，最多 5 個"),
    days: int = Query(90, ge=7, le=365, description="比較天數"),
):
    """
    取得多支股票的正規化走勢資料（用於比較圖表）
    
    - 價格會正規化為起始日 = 100%
    - 回傳各股票的日期、正規化價格
    """
    from app.data_sources.yahoo_finance import yahoo_finance
    import math
    
    # 解析 symbols，並自動轉換台股代號
    symbol_list = [normalize_tw_symbol(s.strip()) for s in symbols.split(",") if s.strip()]
    
    if len(symbol_list) < 1:
        raise HTTPException(status_code=400, detail="請至少輸入一個代號")
    
    if len(symbol_list) > 5:
        raise HTTPException(status_code=400, detail="最多比較 5 個標的")
    
    logger.info(f"走勢比較: {symbol_list}, {days} 天")
    
    result = {}
    common_dates = None
    
    for symbol in symbol_list:
        try:
            # 判斷是指數還是股票
            if symbol.startswith("^"):
                df = yahoo_finance.get_index_data(symbol, period="2y")
            else:
                df = yahoo_finance.get_stock_history(symbol, period="2y")
                
                # 如果 .TW 找不到，嘗試 .TWO
                if (df is None or df.empty) and symbol.endswith('.TW'):
                    two_symbol = symbol.replace('.TW', '.TWO')
                    df = yahoo_finance.get_stock_history(two_symbol, period="2y")
                    if df is not None and not df.empty:
                        symbol = two_symbol
            
            if df is None or df.empty:
                logger.warning(f"找不到資料: {symbol}")
                continue
            
            # 取最近 N 天
            df = df.tail(days).copy()
            
            if len(df) < 5:
                logger.warning(f"{symbol} 資料不足")
                continue
            
            # 正規化：起始價格 = 100（使用調整後價格以處理分割）
            # 如果沒有 adj_close，用 close
            price_col = "adj_close" if "adj_close" in df.columns else "close"
            start_price = df.iloc[0][price_col]
            if start_price == 0 or pd.isna(start_price):
                continue
            
            df["normalized"] = (df[price_col] / start_price) * 100
            
            # 清理 NaN
            df = df.dropna(subset=["normalized"])
            
            # 取得名稱
            if symbol.startswith("^"):
                from app.models.index_price import INDEX_SYMBOLS
                info = INDEX_SYMBOLS.get(symbol, {})
                name = info.get("name_zh", symbol)
            else:
                info = yahoo_finance.get_stock_info(symbol)
                name = info.get("name", symbol) if info else symbol
            
            # 轉為列表
            history = []
            for _, row in df.iterrows():
                val = row["normalized"]
                # 檢查 NaN/Inf
                if math.isnan(val) or math.isinf(val):
                    continue
                history.append({
                    "date": row["date"].isoformat() if hasattr(row["date"], "isoformat") else str(row["date"]),
                    "value": round(val, 2),
                    "price": round(float(row["close"]), 2),  # 顯示用原始價格
                })
            
            if history:
                end_price_adj = float(df.iloc[-1][price_col])
                result[symbol] = {
                    "symbol": symbol,
                    "name": name,
                    "start_price": round(float(df.iloc[0]["close"]), 2),  # 顯示用原始價格
                    "end_price": round(float(df.iloc[-1]["close"]), 2),   # 顯示用原始價格
                    "change_pct": round((end_price_adj / start_price - 1) * 100, 2),  # 計算用調整後價格
                    "data": history,
                }
                
                # 記錄日期用於對齊
                dates = set(h["date"] for h in history)
                if common_dates is None:
                    common_dates = dates
                else:
                    common_dates = common_dates.intersection(dates)
        
        except Exception as e:
            logger.error(f"處理 {symbol} 失敗: {e}")
            continue
    
    if not result:
        raise HTTPException(status_code=404, detail="找不到任何有效資料")
    
    return {
        "success": True,
        "data": {
            "symbols": list(result.keys()),
            "days": days,
            "stocks": result,
        }
    }


@router.get("/{symbol}/returns", summary="年化報酬率")
async def get_stock_returns(
    symbol: str,
):
    """
    計算股票的歷史年化報酬率 (CAGR)
    
    計算方式：含配息再投入的總報酬率
    - 分割調整：已處理
    - 配息還原：在計算時將配息加回
    
    回傳 1Y, 3Y, 5Y, 10Y 的 CAGR
    """
    from app.data_sources.yahoo_finance import yahoo_finance
    from datetime import date, timedelta
    import math
    
    # 台股代號自動轉換
    symbol = normalize_tw_symbol(symbol)
    original_symbol = symbol
    logger.info(f"計算年化報酬率: {symbol}")
    
    try:
        # 取得 10 年股價歷史
        df = yahoo_finance.get_stock_history(symbol, period="10y")
        
        # 如果 .TW 找不到，嘗試 .TWO
        if (df is None or df.empty) and symbol.endswith('.TW'):
            two_symbol = symbol.replace('.TW', '.TWO')
            df = yahoo_finance.get_stock_history(two_symbol, period="10y")
            if df is not None and not df.empty:
                symbol = two_symbol
        
        if df is None or df.empty:
            raise HTTPException(status_code=404, detail=f"找不到股票: {original_symbol}")
        
        # 確保有 date 欄位
        if 'date' not in df.columns:
            df = df.reset_index()
            if 'Date' in df.columns:
                df = df.rename(columns={'Date': 'date'})
        
        df['date'] = pd.to_datetime(df['date']).dt.date
        df = df.sort_values('date').reset_index(drop=True)
        
        # 取得配息歷史
        dividends_df = yahoo_finance.get_dividends(symbol, period="10y")
        
        # 建立配息字典 {date: amount}
        dividends = {}
        if dividends_df is not None and not dividends_df.empty:
            for _, row in dividends_df.iterrows():
                div_date = row['date']
                if isinstance(div_date, str):
                    div_date = datetime.strptime(div_date, '%Y-%m-%d').date()
                dividends[div_date] = float(row['amount'])
        
        logger.info(f"{symbol} 配息記錄: {len(dividends)} 筆")
        
        # 取得股票名稱
        info = yahoo_finance.get_stock_info(symbol)
        stock_name = info.get("name", symbol) if info else symbol
        
        # 現價（顯示用，用原始收盤價）
        current_price_display = float(df.iloc[-1]['close'])
        current_date = df.iloc[-1]['date']
        
        # ===== 計算含息調整價格（用於報酬率計算） =====
        # 從最新日期往前，每遇到一次配息就調整之前的價格
        df['adj_close_with_div'] = df['adj_close'].astype(float)
        date_to_idx = {row['date']: idx for idx, row in df.iterrows()}
        
        # 找出在資料範圍內的配息
        min_date = df['date'].min()
        max_date = df['date'].max()
        relevant_divs = [(d, amt) for d, amt in dividends.items() 
                        if min_date < d <= max_date]
        
        if relevant_divs:
            # 從最新到最舊處理配息
            for div_date, div_amount in sorted(relevant_divs, reverse=True):
                if div_date in date_to_idx:
                    ex_idx = date_to_idx[div_date]
                    if ex_idx > 0:
                        # 除息前一天的價格
                        prev_price = df.loc[ex_idx - 1, 'adj_close_with_div']
                        if prev_price > div_amount and div_amount > 0:
                            # 還原因子
                            adjustment_factor = prev_price / (prev_price - div_amount)
                            # 調整除息日之前的所有價格
                            df.loc[:ex_idx-1, 'adj_close_with_div'] = df.loc[:ex_idx-1, 'adj_close_with_div'] / adjustment_factor
        
        # 含息調整後現價
        current_price_adj = float(df.iloc[-1]['adj_close_with_div'])
        
        # 計算不同期間的報酬率
        periods = [
            ("1Y", 1),
            ("3Y", 3),
            ("5Y", 5),
            ("10Y", 10),
        ]
        
        results = {}
        
        for period_name, years in periods:
            target_date = current_date - timedelta(days=years * 365)
            
            # 找到最接近目標日期的股價
            past_df = df[df['date'] <= target_date]
            
            if past_df.empty or len(past_df) < 10:
                results[period_name] = None
                continue
            
            start_row = past_df.iloc[-1]
            # 使用含息調整後價格計算報酬率
            start_price_adj = float(start_row['adj_close_with_div'])
            start_date = start_row['date']
            
            if start_price_adj <= 0:
                results[period_name] = None
                continue
            
            # 實際年數（更精確）
            actual_days = (current_date - start_date).days
            actual_years = actual_days / 365.25
            
            if actual_years < 0.5:
                results[period_name] = None
                continue
            
            # CAGR 計算（含息調整後價格）
            cagr = (current_price_adj / start_price_adj) ** (1 / actual_years) - 1
            
            # 計算期間內的配息統計（參考用）
            period_dividends = {d: amt for d, amt in dividends.items() 
                              if start_date < d <= current_date}
            
            total_dividends_per_share = sum(period_dividends.values())
            
            logger.info(f"{symbol} {period_name}: 起始日={start_date}, 起始價(含息調整)={start_price_adj:.2f}, 現價(含息調整)={current_price_adj:.2f}, CAGR={cagr*100:.2f}%")
            
            # 檢查數值有效性
            def safe_pct(val):
                if val is None or math.isnan(val) or math.isinf(val):
                    return None
                return round(val * 100, 2)
            
            results[period_name] = {
                "years": round(actual_years, 1),
                "start_date": start_date.isoformat(),
                "start_price": round(float(start_row['close']), 2),  # 顯示原始起始價
                "end_price": round(current_price_display, 2),  # 顯示原始現價
                "cagr": safe_pct(cagr),
                "dividend_count": len(period_dividends),
                "total_dividends": round(total_dividends_per_share, 4),
            }
        
        return {
            "success": True,
            "data": {
                "symbol": symbol,
                "name": stock_name,
                "current_price": round(current_price_display, 2),
                "current_date": current_date.isoformat(),
                "returns": results,
                "note": "CAGR 已包含分割調整及配息再投入效果"
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"計算年化報酬率失敗 {symbol}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{symbol}/debug-prices", summary="Debug: 查看價格調整資訊")
async def debug_prices(
    symbol: str,
    years: int = Query(5, description="查詢年數"),
):
    """
    Debug 用：查看原始價格、分割調整、配息資訊
    """
    from app.data_sources.yahoo_finance import yahoo_finance
    from datetime import date, timedelta
    import yfinance as yf
    
    # 台股代號自動轉換
    symbol = normalize_tw_symbol(symbol)
    
    # 如果 .TW 找不到，嘗試 .TWO
    df = yahoo_finance.get_stock_history(symbol, period=f"{years}y")
    if (df is None or df.empty) and symbol.endswith('.TW'):
        two_symbol = symbol.replace('.TW', '.TWO')
        df = yahoo_finance.get_stock_history(two_symbol, period=f"{years}y")
        if df is not None and not df.empty:
            symbol = two_symbol
    
    try:
        if df is None or df.empty:
            raise HTTPException(status_code=404, detail=f"找不到股票: {symbol}")
        
        # 取得配息記錄
        ticker = yf.Ticker(symbol)
        dividends = ticker.dividends
        div_records = []
        total_div = 0
        if dividends is not None and len(dividends) > 0:
            for date_idx, amount in dividends.items():
                div_date = date_idx.date() if hasattr(date_idx, 'date') else pd.to_datetime(date_idx).date()
                div_records.append({
                    "date": str(div_date),
                    "amount": round(float(amount), 4)
                })
                total_div += float(amount)
        
        # 取得分割記錄
        splits = ticker.splits
        split_records = []
        if splits is not None and len(splits) > 0:
            for date_idx, ratio in splits.items():
                split_records.append({
                    "date": str(date_idx.date()),
                    "ratio": float(ratio)
                })
        
        # 取樣價格比較
        sample_prices = []
        indices = [0]
        for y in range(years, 0, -1):
            target_date = date.today() - timedelta(days=y*365)
            closest = df[df['date'] <= target_date]
            if not closest.empty:
                indices.append(closest.index[-1])
        indices.append(len(df) - 1)
        indices = sorted(set(indices))
        
        for idx in indices:
            if idx < len(df):
                row = df.iloc[idx]
                sample_prices.append({
                    "date": str(row['date']),
                    "close_raw": round(float(row['close']), 2),
                    "close_split_adj": round(float(row['adj_close']), 2),
                })
        
        # 計算報酬率比較
        first_raw = float(df.iloc[0]['close'])
        first_adj = float(df.iloc[0]['adj_close'])
        last_raw = float(df.iloc[-1]['close'])
        last_adj = float(df.iloc[-1]['adj_close'])
        
        raw_return = (last_raw / first_raw - 1) * 100 if first_raw > 0 else 0
        split_adj_return = (last_adj / first_adj - 1) * 100 if first_adj > 0 else 0
        
        return {
            "success": True,
            "symbol": symbol,
            "total_records": len(df),
            "date_range": {
                "start": str(df.iloc[0]['date']),
                "end": str(df.iloc[-1]['date'])
            },
            "splits": split_records,
            "dividends": div_records[-10:] if len(div_records) > 10 else div_records,  # 最近 10 筆
            "dividend_count": len(div_records),
            "total_dividends": round(total_div, 4),
            "sample_prices": sample_prices,
            "returns": {
                "raw_return_pct": round(raw_return, 2),
                "split_adj_return_pct": round(split_adj_return, 2),
            },
            "note": "close_raw=原始價格, close_split_adj=分割調整後(圖表用), 年化報酬另含配息還原"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Debug prices 失敗 {symbol}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/subscription.py  ⭐⭐⭐
> 訂閱精選 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
訂閱精選 API 路由
"""
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Optional
import logging

from app.database import get_db, get_async_session
from app.services.subscription_service import SubscriptionService
from app.models.subscription import SubscriptionSource, AutoPick
from app.models.price_cache import StockPriceCache

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/subscription", tags=["訂閱精選"])


# ============================================================
# 認證（複用 watchlist 的認證邏輯）
# ============================================================

async def get_current_user(request: Request, db: AsyncSession = Depends(get_async_session)):
    """從 watchlist.py 複用的認證"""
    from app.services.auth_service import AuthService
    from app.models.user import User
    
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="未提供認證 Token")
    
    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)
    
    if not user:
        raise HTTPException(status_code=401, detail="無效的 Token")
    
    return user


# ============================================================
# 訂閱源
# ============================================================

@router.get("/sources", summary="取得所有訂閱源")
def get_sources(db: Session = Depends(get_db)):
    """取得所有可訂閱的來源"""
    from datetime import datetime
    
    service = SubscriptionService(db)
    sources = service.get_all_sources(enabled_only=True)
    
    # 計算每個來源的有效精選數量
    results = []
    for source in sources:
        source_dict = source.to_dict()
        # 計算未過期的精選數量
        picks_count = db.query(AutoPick).filter(
            AutoPick.source_id == source.id,
            AutoPick.expires_at > datetime.now()
        ).count()
        source_dict["picks_count"] = picks_count
        results.append(source_dict)
    
    return {
        "success": True,
        "data": results,
    }


@router.get("/sources/{slug}", summary="取得單一訂閱源")
def get_source(slug: str, db: Session = Depends(get_db)):
    """取得單一訂閱源詳情"""
    service = SubscriptionService(db)
    source = service.get_source_by_slug(slug)
    
    if not source:
        raise HTTPException(status_code=404, detail="找不到訂閱源")
    
    return {
        "success": True,
        "data": source.to_dict(),
    }


# ============================================================
# 用戶訂閱
# ============================================================

@router.get("/my", summary="我的訂閱")
async def get_my_subscriptions(
    user = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """取得用戶訂閱的來源"""
    service = SubscriptionService(db)
    sources = service.get_user_subscriptions(user.id)
    
    return {
        "success": True,
        "data": [s.to_dict() for s in sources],
    }


@router.post("/subscribe/{source_id}", summary="訂閱來源")
async def subscribe_source(
    source_id: int,
    user = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """訂閱指定來源"""
    service = SubscriptionService(db)
    
    # 檢查來源是否存在
    source = db.query(SubscriptionSource).filter(
        SubscriptionSource.id == source_id
    ).first()
    if not source:
        raise HTTPException(status_code=404, detail="找不到訂閱源")
    
    result = service.subscribe(user.id, source_id)
    
    if not result:
        return {
            "success": True,
            "message": "已經訂閱過了",
        }
    
    return {
        "success": True,
        "message": f"成功訂閱 {source.name}",
    }


@router.delete("/unsubscribe/{source_id}", summary="取消訂閱")
async def unsubscribe_source(
    source_id: int,
    user = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """取消訂閱指定來源"""
    service = SubscriptionService(db)
    result = service.unsubscribe(user.id, source_id)
    
    if not result:
        raise HTTPException(status_code=404, detail="未訂閱此來源")
    
    return {
        "success": True,
        "message": "已取消訂閱",
    }


# ============================================================
# 精選列表
# ============================================================

@router.get("/picks", summary="我的訂閱精選")
async def get_my_picks(
    user = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    取得用戶訂閱的所有精選
    包含價格資訊（從快取）
    """
    service = SubscriptionService(db)
    picks = service.get_user_picks(user.id)
    
    if not picks:
        return {
            "success": True,
            "data": [],
            "message": "尚未訂閱任何來源，或目前沒有精選",
        }
    
    # 取得價格快取
    symbols = [p["symbol"] for p in picks]
    cache_map = {}
    
    if symbols:
        caches = db.query(StockPriceCache).filter(
            StockPriceCache.symbol.in_(symbols)
        ).all()
        cache_map = {c.symbol: c for c in caches}
    
    # 組合價格
    for pick in picks:
        cache = cache_map.get(pick["symbol"])
        pick["price"] = float(cache.price) if cache and cache.price else None
        pick["change_pct"] = float(cache.change_pct) if cache and cache.change_pct else None
        pick["price_updated_at"] = cache.updated_at.isoformat() if cache and cache.updated_at else None
    
    return {
        "success": True,
        "data": picks,
        "total": len(picks),
    }


@router.get("/picks/{source_slug}", summary="特定來源的精選")
def get_source_picks(
    source_slug: str,
    db: Session = Depends(get_db),
):
    """取得特定來源的所有精選（公開）"""
    service = SubscriptionService(db)
    source = service.get_source_by_slug(source_slug)
    
    if not source:
        raise HTTPException(status_code=404, detail="找不到訂閱源")
    
    picks = service.get_active_picks(source_id=source.id)
    
    # 取得價格
    symbols = [p.symbol for p in picks]
    cache_map = {}
    if symbols:
        caches = db.query(StockPriceCache).filter(
            StockPriceCache.symbol.in_(symbols)
        ).all()
        cache_map = {c.symbol: c for c in caches}
    
    results = []
    for pick in picks:
        pick_dict = pick.to_dict()
        cache = cache_map.get(pick.symbol)
        pick_dict["price"] = float(cache.price) if cache and cache.price else None
        pick_dict["change_pct"] = float(cache.change_pct) if cache and cache.change_pct else None
        results.append(pick_dict)
    
    return {
        "success": True,
        "source": source.to_dict(),
        "data": results,
        "total": len(results),
    }


# ============================================================
# 管理 API（管理員用）
# ============================================================

@router.post("/admin/fetch", summary="手動抓取")
def admin_fetch(
    backfill: bool = False,
    db: Session = Depends(get_db),
):
    """
    手動觸發抓取
    - backfill=True: 回溯 30 天
    - backfill=False: 只抓新的
    """
    service = SubscriptionService(db)
    result = service.fetch_all_sources(backfill=backfill)
    
    return {
        "success": True,
        "message": "抓取完成",
        "data": result,
    }


@router.post("/admin/init", summary="初始化訂閱源")
def admin_init(db: Session = Depends(get_db)):
    """初始化預設訂閱源"""
    service = SubscriptionService(db)
    service.init_default_sources()
    
    return {
        "success": True,
        "message": "初始化完成",
    }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/routers/watchlist.py  ⭐⭐⭐
> 追蹤清單 API 路由
──────────────────────────────────────────────────────────────────────

```py
"""
追蹤清單 API 路由
包含價格快取功能
"""
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import List, Optional
from pydantic import BaseModel
import logging

from app.database import get_async_session
from app.services.auth_service import AuthService
from app.services.watchlist_service import WatchlistService
from app.schemas.schemas import (
    WatchlistAdd,
    WatchlistUpdate,
    WatchlistItem,
    WatchlistResponse,
    WatchlistListResponse,
    WatchlistOverviewResponse,
    ResponseBase,
)
from app.models.user import User
from app.models.watchlist import Watchlist
from app.models.price_cache import StockPriceCache

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/watchlist", tags=["追蹤清單"])


# 🆕 目標價更新 Schema
class TargetPriceUpdate(BaseModel):
    target_price: Optional[float] = None


async def get_current_user(
    request: Request,
    db: AsyncSession = Depends(get_async_session),
) -> User:
    """依賴注入：取得當前用戶"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        logger.warning("Watchlist API: 未提供認證 Token")
        raise HTTPException(
            status_code=401,
            detail="未提供認證 Token"
        )

    token = auth_header.split(" ")[1]
    auth_service = AuthService(db)
    user = await auth_service.get_user_from_token(token)

    if not user:
        logger.warning("Watchlist API: Token 驗證失敗")
        raise HTTPException(
            status_code=401,
            detail="無效的 Token"
        )

    logger.debug(f"Watchlist API: 驗證成功 user_id={user.id}, line_id={user.line_user_id}")
    return user


# ============================================================
# 🆕 價格快取 API
# ============================================================

@router.get("/with-prices", summary="追蹤清單（含即時價格）")
async def get_watchlist_with_prices(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶追蹤清單，包含即時價格（從快取讀取）
    
    - 價格來自 stock_price_cache 表
    - 每 10 分鐘由排程更新
    - 回應時間：毫秒級
    - 🆕 包含目標價及是否達標
    """
    logger.info(f"API: 追蹤清單(含價格) - user_id={user.id}")

    try:
        # 1. 取得用戶的追蹤清單
        stmt = (
            select(Watchlist)
            .where(Watchlist.user_id == user.id)
            .order_by(Watchlist.added_at.desc())
        )
        result = await db.execute(stmt)
        watchlist_items = list(result.scalars().all())

        if not watchlist_items:
            return {
                "success": True,
                "data": [],
                "total": 0,
            }

        # 2. 取得所有 symbol
        symbols = [item.symbol for item in watchlist_items]

        # 3. 從快取批次取得價格
        cache_stmt = select(StockPriceCache).where(
            StockPriceCache.symbol.in_(symbols)
        )
        cache_result = await db.execute(cache_stmt)
        cached_prices = {r.symbol: r for r in cache_result.scalars().all()}

        # 4. 組合資料
        data = []
        for item in watchlist_items:
            cache = cached_prices.get(item.symbol)

            # 防呆：檢查 ma20 欄位是否存在
            ma20_value = None
            if cache and hasattr(cache, 'ma20') and cache.ma20 is not None:
                ma20_value = float(cache.ma20)

            # 🆕 計算是否達到目標價
            current_price = float(cache.price) if cache and cache.price else None
            target_price = float(item.target_price) if item.target_price else None
            target_reached = False
            
            if current_price and target_price:
                target_reached = current_price >= target_price

            data.append({
                "id": item.id,
                "symbol": item.symbol,
                "asset_type": item.asset_type,
                "note": item.note,
                "target_price": target_price,  # 🆕
                "target_reached": target_reached,  # 🆕
                "added_at": item.added_at.isoformat() if item.added_at else None,
                # 價格資訊（從快取）
                "name": cache.name if cache else None,
                "price": current_price,
                "change": float(cache.change) if cache and cache.change else None,
                "change_pct": float(cache.change_pct) if cache and cache.change_pct else None,
                "ma20": ma20_value,
                "price_updated_at": cache.updated_at.isoformat() if cache and cache.updated_at else None,
            })

        return {
            "success": True,
            "data": data,
            "total": len(data),
        }

    except Exception as e:
        logger.error(f"取得追蹤清單(含價格)失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/cache-status", summary="快取狀態")
async def get_cache_status(
    db: AsyncSession = Depends(get_async_session),
):
    """查看價格快取狀態"""
    try:
        from app.services.price_cache_service import get_market_status

        stmt = select(StockPriceCache)
        result = await db.execute(stmt)
        all_cache = list(result.scalars().all())

        if not all_cache:
            return {
                "success": True,
                "total_cached": 0,
                "message": "快取為空，請等待排程更新",
                "market_status": get_market_status(),
            }

        updates = [c.updated_at for c in all_cache if c.updated_at]
        tw_stocks = [c for c in all_cache if c.symbol.endswith(('.TW', '.TWO'))]
        us_stocks = [c for c in all_cache if c.asset_type == 'stock' and not c.symbol.endswith(('.TW', '.TWO'))]
        crypto = [c for c in all_cache if c.asset_type == 'crypto']

        return {
            "success": True,
            "total_cached": len(all_cache),
            "tw_stocks": len(tw_stocks),
            "us_stocks": len(us_stocks),
            "crypto": len(crypto),
            "oldest_update": min(updates).isoformat() if updates else None,
            "newest_update": max(updates).isoformat() if updates else None,
            "market_status": get_market_status(),
        }

    except Exception as e:
        logger.error(f"查詢快取狀態失敗: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================
# 🆕 目標價 API
# ============================================================

@router.put("/{item_id}/target-price", summary="設定目標價")
async def set_target_price(
    item_id: int,
    data: TargetPriceUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    設定追蹤標的的目標價格
    
    - 設定後，當現價達到或超過目標價會變色提醒
    - 傳入 null 可清除目標價
    """
    logger.info(f"API: 設定目標價 - user_id={user.id}, item_id={item_id}, target={data.target_price}")

    try:
        # 查詢該追蹤項目
        stmt = select(Watchlist).where(
            Watchlist.id == item_id,
            Watchlist.user_id == user.id
        )
        result = await db.execute(stmt)
        item = result.scalar_one_or_none()

        if not item:
            raise HTTPException(status_code=404, detail="找不到該追蹤項目")

        # 更新目標價
        item.target_price = data.target_price
        await db.commit()

        return {
            "success": True,
            "message": "目標價已更新" if data.target_price else "目標價已清除",
            "data": {
                "id": item.id,
                "symbol": item.symbol,
                "target_price": float(item.target_price) if item.target_price else None,
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"設定目標價失敗: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================
# 原有的端點
# ============================================================

@router.get("", summary="取得追蹤清單", response_model=WatchlistListResponse)
async def get_watchlist(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得用戶的追蹤清單
    """
    logger.info(f"API: 取得追蹤清單 - user_id={user.id}, line_id={user.line_user_id}")

    service = WatchlistService(db)
    items = await service.get_watchlist(user.id)

    return WatchlistListResponse(
        success=True,
        data=[WatchlistItem.model_validate(item) for item in items],
        total=len(items),
    )


@router.post("", summary="新增追蹤", response_model=WatchlistResponse)
async def add_to_watchlist(
    data: WatchlistAdd,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    新增標的到追蹤清單
    
    - **symbol**: 股票代號 (如 AAPL) 或加密貨幣 (如 BTC)
    - **note**: 自訂備註（選填）
    """
    logger.info(f"API: 新增追蹤 - user_id={user.id}, line_id={user.line_user_id}, symbol={data.symbol}")

    service = WatchlistService(db)
    result = await service.add_to_watchlist(
        user_id=user.id,
        symbol=data.symbol,
        note=data.note,
    )

    if not result["success"]:
        raise HTTPException(
            status_code=400,
            detail=result["message"]
        )

    return WatchlistResponse(
        success=True,
        message=result["message"],
        data=WatchlistItem.model_validate(result["watchlist"]),
    )


@router.delete("/{symbol}", summary="移除追蹤", response_model=ResponseBase)
async def remove_from_watchlist(
    symbol: str,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    從追蹤清單移除標的
    """
    logger.info(f"API: 移除追蹤 - user_id={user.id}, line_id={user.line_user_id}, symbol={symbol}")

    service = WatchlistService(db)
    result = await service.remove_from_watchlist(
        user_id=user.id,
        symbol=symbol,
    )

    if not result["success"]:
        raise HTTPException(
            status_code=404,
            detail=result["message"]
        )

    return ResponseBase(
        success=True,
        message=result["message"],
    )


@router.put("/{symbol}", summary="更新備註", response_model=ResponseBase)
async def update_watchlist_note(
    symbol: str,
    data: WatchlistUpdate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    更新追蹤標的的備註
    """
    logger.info(f"API: 更新備註 - user_id={user.id}, symbol={symbol}")

    service = WatchlistService(db)
    result = await service.update_note(
        user_id=user.id,
        symbol=symbol,
        note=data.note,
    )

    if not result["success"]:
        raise HTTPException(
            status_code=404,
            detail=result["message"]
        )

    return ResponseBase(
        success=True,
        message=result["message"],
    )


@router.get("/overview", summary="追蹤清單總覽")
async def get_watchlist_overview(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    取得追蹤清單總覽
    
    包含所有追蹤標的的基本資訊
    """
    logger.info(f"API: 追蹤清單總覽 - user_id={user.id}, line_id={user.line_user_id}")

    service = WatchlistService(db)
    items = await service.get_watchlist(user.id)

    return {
        "success": True,
        "data": [
            {
                "id": item.id,
                "symbol": item.symbol,
                "asset_type": item.asset_type,
                "note": item.note,
                "target_price": float(item.target_price) if item.target_price else None,
                "added_at": item.added_at.isoformat() if item.added_at else None,
            }
            for item in items
        ],
        "total": len(items),
    }
```

======================================================================
## 📦 資料模型
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/database.py  ⭐⭐
> 資料庫連線與 Session 管理
──────────────────────────────────────────────────────────────────────

```py
"""
資料庫連線與 Session 管理
支援 SQLite (開發) 和 PostgreSQL (生產)
"""
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import NullPool

from app.config import settings


def get_async_url(url: str) -> str:
    """將一般的資料庫 URL 轉換為 async 格式"""
    if url.startswith("sqlite:///") and "+aiosqlite" not in url:
        return url.replace("sqlite:///", "sqlite+aiosqlite:///")
    elif url.startswith("postgresql://") and "+asyncpg" not in url:
        return url.replace("postgresql://", "postgresql+asyncpg://")
    elif url.startswith("postgres://"):
        # Railway 使用 postgres:// 但 SQLAlchemy 需要 postgresql://
        return url.replace("postgres://", "postgresql+asyncpg://")
    return url


def get_sync_url(url: str) -> str:
    """確保是同步格式的 URL"""
    url = url.replace("+aiosqlite", "").replace("+asyncpg", "")
    # 修正 Railway 的 postgres:// 格式
    if url.startswith("postgres://"):
        url = url.replace("postgres://", "postgresql://")
    return url


def is_postgres(url: str) -> bool:
    """檢查是否為 PostgreSQL"""
    return "postgresql" in url or "postgres" in url


# 取得資料庫 URL
database_url = settings.DATABASE_URL

# 非同步引擎 (FastAPI 用)
async_database_url = get_async_url(database_url)

# PostgreSQL 需要特別的連線池設定
if is_postgres(database_url):
    async_engine = create_async_engine(
        async_database_url,
        echo=settings.DEBUG,
        poolclass=NullPool,  # Railway 建議使用 NullPool
    )
else:
    async_engine = create_async_engine(
        async_database_url,
        echo=settings.DEBUG,
    )

# 非同步 Session
AsyncSessionLocal = async_sessionmaker(
    bind=async_engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

# 同步引擎 (CLI 用)
sync_database_url = get_sync_url(database_url)

if is_postgres(database_url):
    sync_engine = create_engine(
        sync_database_url,
        echo=settings.DEBUG,
        poolclass=NullPool,
    )
else:
    sync_engine = create_engine(
        sync_database_url,
        echo=settings.DEBUG,
    )

# ============================================================
# 🆕 自動資料庫遷移
# ============================================================
def run_auto_migrations():
    """啟動時自動執行資料庫遷移"""
    migrations = [
        # 2026-01-14: MA20 排序功能
        {
            "name": "add_ma20_to_price_cache",
            "check_sql": "SELECT column_name FROM information_schema.columns WHERE table_name='stock_price_cache' AND column_name='ma20'",
            "migrate_sql": "ALTER TABLE stock_price_cache ADD COLUMN ma20 NUMERIC(12, 4)",
        },
        # 2026-01-14: 訂閱精選功能 - 訂閱源表
        {
            "name": "create_subscription_sources",
            "check_sql": "SELECT table_name FROM information_schema.tables WHERE table_name='subscription_sources'",
            "migrate_sql": """
                CREATE TABLE subscription_sources (
                    id SERIAL PRIMARY KEY,
                    name VARCHAR(100) NOT NULL,
                    slug VARCHAR(50) UNIQUE NOT NULL,
                    url VARCHAR(500) NOT NULL,
                    type VARCHAR(20) DEFAULT 'substack',
                    description TEXT,
                    enabled BOOLEAN DEFAULT true,
                    last_fetched_at TIMESTAMP,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """,
        },
        # 2026-01-14: 訂閱精選功能 - 自動精選表
        {
            "name": "create_auto_picks",
            "check_sql": "SELECT table_name FROM information_schema.tables WHERE table_name='auto_picks'",
            "migrate_sql": """
                CREATE TABLE auto_picks (
                    id SERIAL PRIMARY KEY,
                    source_id INTEGER REFERENCES subscription_sources(id),
                    symbol VARCHAR(20) NOT NULL,
                    article_url VARCHAR(500),
                    article_title VARCHAR(300),
                    article_date DATE,
                    first_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    expires_at TIMESTAMP,
                    mention_count INTEGER DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(source_id, symbol)
                )
            """,
        },
        # 2026-01-14: 訂閱精選功能 - 用戶訂閱表
        {
            "name": "create_user_subscriptions",
            "check_sql": "SELECT table_name FROM information_schema.tables WHERE table_name='user_subscriptions'",
            "migrate_sql": """
                CREATE TABLE user_subscriptions (
                    id SERIAL PRIMARY KEY,
                    user_id INTEGER REFERENCES users(id),
                    source_id INTEGER REFERENCES subscription_sources(id),
                    subscribed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(user_id, source_id)
                )
            """,
        },
        # 2026-01-15: P1 目標價功能
        {
            "name": "add_target_price_to_watchlists",
            "check_sql": "SELECT column_name FROM information_schema.columns WHERE table_name='watchlists' AND column_name='target_price'",
            "migrate_sql": "ALTER TABLE watchlists ADD COLUMN target_price NUMERIC(12, 4) DEFAULT NULL",
        },
    ]
    
    try:
        with sync_engine.connect() as conn:
            for migration in migrations:
                try:
                    result = conn.execute(text(migration["check_sql"])).fetchone()
                    if not result:
                        conn.execute(text(migration["migrate_sql"]))
                        conn.commit()
                        print(f"✅ Migration: {migration['name']} completed")
                except Exception as e:
                    print(f"⚠️ Migration {migration['name']} skipped: {e}")
    except Exception as e:
        print(f"⚠️ Auto migration warning: {e}")

# 啟動時執行遷移
run_auto_migrations()
# ============================================================

# 同步 Session
SyncSessionLocal = sessionmaker(
    bind=sync_engine,
    autocommit=False,
    autoflush=False,
)

# 為了向後相容，保留 SessionLocal 別名
SessionLocal = SyncSessionLocal

# ORM Base
Base = declarative_base()


async def get_async_session():
    """FastAPI 依賴注入用"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()


def get_sync_session():
    """CLI 用同步 Session"""
    session = SyncSessionLocal()
    try:
        return session
    except Exception:
        session.close()
        raise


async def init_db():
    """初始化資料庫（建立所有表格）"""
    async with async_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


def init_db_sync():
    """同步初始化資料庫"""
    Base.metadata.create_all(bind=sync_engine)


# FastAPI 依賴注入用（同步版本，用於某些 API）
def get_db():
    """FastAPI 依賴注入用（同步 Session）"""
    db = SyncSessionLocal()
    try:
        yield db
    finally:
        db.close()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/__init__.py  ⭐⭐
> 資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
資料模型
"""
from app.models.stock_price import StockPrice
from app.models.crypto_price import CryptoPrice
from app.models.market_sentiment import MarketSentiment
from app.models.user import User, LoginLog, TokenBlacklist, SystemConfig
from app.models.watchlist import Watchlist
from app.models.user_settings import (
    UserIndicatorSettings,
    UserAlertSettings,
    UserIndicatorParams,
)
from app.models.notification import Notification
from app.models.index_price import IndexPrice, INDEX_SYMBOLS
from app.models.dividend_history import DividendHistory
from app.models.comparison import Comparison
from app.models.price_cache import StockPriceCache
from app.models.portfolio import PortfolioTransaction, PortfolioHolding, ExchangeRate  # 🆕 個人投資記錄

__all__ = [
    "StockPrice",
    "CryptoPrice", 
    "MarketSentiment",
    "User",
    "LoginLog",
    "TokenBlacklist",
    "SystemConfig",
    "Watchlist",
    "UserIndicatorSettings",
    "UserAlertSettings",
    "UserIndicatorParams",
    "Notification",
    "IndexPrice",
    "INDEX_SYMBOLS",
    "DividendHistory",
    "Comparison",
    "StockPriceCache",
    "PortfolioTransaction",  # 🆕 個人投資記錄
    "PortfolioHolding",      # 🆕 個人投資記錄
    "ExchangeRate",          # 🆕 匯率
]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/comparison.py  ⭐⭐
> 報酬率比較組合 Model
──────────────────────────────────────────────────────────────────────

```py
"""
報酬率比較組合 Model
儲存用戶的自訂比較組合
"""
from datetime import datetime
from typing import List, Optional
import json

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship

from app.database import Base


class Comparison(Base):
    """用戶儲存的比較組合"""
    __tablename__ = "comparisons"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    name = Column(String(100), nullable=False)  # 組合名稱
    symbols_json = Column(Text, nullable=False)  # JSON 格式儲存 ["AAPL","MSFT"]
    benchmark = Column(String(20), nullable=True, default="^GSPC")  # 基準指數
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 關聯
    user = relationship("User", backref="comparisons")
    
    @property
    def symbols(self) -> List[str]:
        """取得標的列表"""
        try:
            return json.loads(self.symbols_json)
        except (json.JSONDecodeError, TypeError):
            return []
    
    @symbols.setter
    def symbols(self, value: List[str]):
        """設定標的列表"""
        self.symbols_json = json.dumps(value)
    
    def to_dict(self) -> dict:
        """轉換為字典"""
        return {
            "id": self.id,
            "user_id": self.user_id,
            "name": self.name,
            "symbols": self.symbols,
            "benchmark": self.benchmark,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
    
    def __repr__(self):
        return f"<Comparison(id={self.id}, name='{self.name}', symbols={self.symbols})>"
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/crypto_price.py  ⭐⭐
> 加密貨幣價格歷史資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
加密貨幣價格歷史資料模型
"""
from sqlalchemy import Column, Integer, String, Date, Numeric, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


class CryptoPrice(Base):
    """加密貨幣價格歷史"""
    
    __tablename__ = "crypto_prices"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(10), nullable=False, index=True)  # BTC, ETH
    date = Column(Date, nullable=False, index=True)
    price = Column(Numeric(18, 8))  # USD 價格
    volume_24h = Column(Numeric(18, 2))  # 24 小時成交量
    market_cap = Column(Numeric(18, 2))  # 市值
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_crypto_symbol_date', 'symbol', 'date', unique=True),
    )
    
    def __repr__(self):
        return f"<CryptoPrice(symbol={self.symbol}, date={self.date}, price={self.price})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "symbol": self.symbol,
            "date": self.date.isoformat() if self.date else None,
            "price": float(self.price) if self.price else None,
            "volume_24h": float(self.volume_24h) if self.volume_24h else None,
            "market_cap": float(self.market_cap) if self.market_cap else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/dividend_history.py  ⭐⭐
> 股票配息歷史資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
股票配息歷史資料模型
用於計算含息年化報酬率
"""
from sqlalchemy import Column, Integer, String, Date, Numeric, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


class DividendHistory(Base):
    """股票配息歷史"""
    
    __tablename__ = "dividend_history"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(10), nullable=False, index=True)
    date = Column(Date, nullable=False, index=True)  # 除息日
    amount = Column(Numeric(10, 4), nullable=False)  # 每股配息金額
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_dividend_symbol_date', 'symbol', 'date', unique=True),
    )
    
    def __repr__(self):
        return f"<DividendHistory(symbol={self.symbol}, date={self.date}, amount={self.amount})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "symbol": self.symbol,
            "date": self.date.isoformat() if self.date else None,
            "amount": float(self.amount) if self.amount else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/index_price.py  ⭐⭐
> 市場指數價格歷史資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
市場指數價格歷史資料模型
支援 S&P 500, 道瓊, 納斯達克, 台股加權
"""
from sqlalchemy import Column, Integer, String, Date, Numeric, BigInteger, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


# 指數代號對照
INDEX_SYMBOLS = {
    "^GSPC": {"name": "S&P 500", "name_zh": "標普500"},
    "^DJI": {"name": "Dow Jones", "name_zh": "道瓊工業"},
    "^IXIC": {"name": "NASDAQ", "name_zh": "納斯達克"},
    "^TWII": {"name": "TAIEX", "name_zh": "台股加權"},
}


class IndexPrice(Base):
    """市場指數價格歷史"""
    
    __tablename__ = "index_prices"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(10), nullable=False, index=True)  # ^GSPC, ^DJI, ^IXIC
    name = Column(String(50))  # S&P 500, Dow Jones, NASDAQ
    date = Column(Date, nullable=False, index=True)
    open = Column(Numeric(12, 2))
    high = Column(Numeric(12, 2))
    low = Column(Numeric(12, 2))
    close = Column(Numeric(12, 2))
    volume = Column(BigInteger)
    change = Column(Numeric(10, 2))  # 漲跌點數
    change_pct = Column(Numeric(6, 2))  # 漲跌幅 %
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_index_symbol_date', 'symbol', 'date', unique=True),
    )
    
    def __repr__(self):
        return f"<IndexPrice(symbol={self.symbol}, date={self.date}, close={self.close})>"
    
    @property
    def name_zh(self) -> str:
        """取得中文名稱"""
        info = INDEX_SYMBOLS.get(self.symbol, {})
        return info.get("name_zh", self.name or self.symbol)
    
    def to_dict(self):
        def safe_float(val):
            """安全轉換 float，處理 NaN 和 Infinity"""
            if val is None:
                return None
            try:
                f = float(val)
                # 檢查 NaN 和 Infinity
                import math
                if math.isnan(f) or math.isinf(f):
                    return None
                return f
            except (ValueError, TypeError):
                return None
        
        return {
            "id": self.id,
            "symbol": self.symbol,
            "name": self.name,
            "name_zh": self.name_zh,
            "date": self.date.isoformat() if self.date else None,
            "open": safe_float(self.open),
            "high": safe_float(self.high),
            "low": safe_float(self.low),
            "close": safe_float(self.close),
            "volume": self.volume,
            "change": safe_float(self.change),
            "change_pct": safe_float(self.change_pct),
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/market_sentiment.py  ⭐⭐
> 市場情緒指數資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
市場情緒指數資料模型
"""
from sqlalchemy import Column, Integer, String, Date, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


class MarketSentiment(Base):
    """市場情緒指數"""
    
    __tablename__ = "market_sentiment"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    date = Column(Date, nullable=False, index=True)
    market = Column(String(10), nullable=False)  # stock / crypto
    value = Column(Integer)  # 0-100
    classification = Column(String(20))  # extreme_fear, fear, neutral, greed, extreme_greed
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_sentiment_market_date', 'market', 'date', unique=True),
    )
    
    def __repr__(self):
        return f"<MarketSentiment(market={self.market}, date={self.date}, value={self.value})>"
    
    @staticmethod
    def get_classification(value: int) -> str:
        """根據數值取得分類"""
        if value <= 25:
            return "extreme_fear"
        elif value <= 45:
            return "fear"
        elif value <= 55:
            return "neutral"
        elif value <= 75:
            return "greed"
        else:
            return "extreme_greed"
    
    @staticmethod
    def get_classification_zh(value: int) -> str:
        """根據數值取得中文分類"""
        if value <= 25:
            return "極度恐懼"
        elif value <= 45:
            return "恐懼"
        elif value <= 55:
            return "中性"
        elif value <= 75:
            return "貪婪"
        else:
            return "極度貪婪"
    
    def to_dict(self):
        return {
            "id": self.id,
            "date": self.date.isoformat() if self.date else None,
            "market": self.market,
            "value": self.value,
            "classification": self.classification,
            "classification_zh": self.get_classification_zh(self.value) if self.value else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/notification.py  ⭐⭐
> 通知記錄資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
通知記錄資料模型
"""
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean, Numeric, Text, Index
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.database import Base


class Notification(Base):
    """通知記錄"""
    
    __tablename__ = "notifications"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    symbol = Column(String(10), nullable=False)
    asset_type = Column(String(10), nullable=False)  # stock / crypto
    alert_type = Column(String(30), nullable=False)  # 通知類型
    indicator = Column(String(20))  # 相關指標
    message = Column(Text)  # 通知內容
    price_at_trigger = Column(Numeric(18, 8))  # 觸發時價格
    triggered_at = Column(DateTime, server_default=func.now())
    sent = Column(Boolean, default=False)  # 是否已發送
    sent_at = Column(DateTime)  # 發送時間
    
    # 關聯
    user = relationship("User")
    
    __table_args__ = (
        Index('idx_notification_user', 'user_id'),
        Index('idx_notification_symbol', 'symbol'),
        Index('idx_notification_triggered', 'triggered_at'),
    )
    
    # 通知類型常數
    ALERT_TYPES = {
        "ma_golden_cross": "均線黃金交叉",
        "ma_death_cross": "均線死亡交叉",
        "approaching_breakout": "接近向上突破",
        "approaching_breakdown": "接近向下跌破",
        "breakout": "已突破",
        "breakdown": "已跌破",
        "rsi_overbought": "RSI 超買",
        "rsi_oversold": "RSI 超賣",
        "macd_golden_cross": "MACD 黃金交叉",
        "macd_death_cross": "MACD 死亡交叉",
        "kd_golden_cross": "KD 黃金交叉",
        "kd_death_cross": "KD 死亡交叉",
        "bollinger_breakout": "布林上軌突破",
        "bollinger_breakdown": "布林下軌跌破",
        "volume_surge": "成交量暴增",
        "sentiment_extreme_fear": "極度恐懼",
        "sentiment_extreme_greed": "極度貪婪",
    }
    
    def __repr__(self):
        return f"<Notification(user_id={self.user_id}, symbol={self.symbol}, alert_type={self.alert_type})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "symbol": self.symbol,
            "asset_type": self.asset_type,
            "alert_type": self.alert_type,
            "alert_type_zh": self.ALERT_TYPES.get(self.alert_type, self.alert_type),
            "indicator": self.indicator,
            "message": self.message,
            "price_at_trigger": float(self.price_at_trigger) if self.price_at_trigger else None,
            "triggered_at": self.triggered_at.isoformat() if self.triggered_at else None,
            "sent": self.sent,
            "sent_at": self.sent_at.isoformat() if self.sent_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/portfolio.py  ⭐⭐
> 個人投資記錄模型
──────────────────────────────────────────────────────────────────────

```py
"""
個人投資記錄模型
用於記錄用戶的股票買賣交易及匯率
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Optional

from sqlalchemy import Column, Integer, String, Date, Numeric, DateTime, ForeignKey, Index, Text, Float
from sqlalchemy.sql import func

from app.database import Base


class PortfolioTransaction(Base):
    """交易紀錄"""
    
    __tablename__ = "portfolio_transactions"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    
    # 股票資訊
    symbol = Column(String(20), nullable=False)           # 股票代碼
    name = Column(String(100))                            # 股票名稱
    market = Column(String(10), nullable=False)           # tw / us
    
    # 交易資訊
    transaction_type = Column(String(10), nullable=False) # buy / sell
    quantity = Column(Integer, nullable=False)            # 總股數（台股：張×1000 + 零股）
    price = Column(Numeric(12, 4), nullable=False)        # 成交價
    fee = Column(Numeric(10, 2), default=0)               # 手續費
    tax = Column(Numeric(10, 2), default=0)               # 交易稅（賣出時）
    transaction_date = Column(Date, nullable=False)       # 交易日期
    
    # 備註
    note = Column(Text)
    
    # 時間戳
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # 索引
    __table_args__ = (
        Index('idx_portfolio_user', 'user_id'),
        Index('idx_portfolio_symbol', 'symbol'),
        Index('idx_portfolio_market', 'market'),
        Index('idx_portfolio_date', 'transaction_date'),
        Index('idx_portfolio_user_symbol', 'user_id', 'symbol'),
    )
    
    @property
    def total_amount(self) -> float:
        """交易總額（不含手續費）"""
        return float(self.quantity) * float(self.price)
    
    @property
    def total_cost(self) -> float:
        """總成本（含手續費、稅）"""
        base = self.total_amount
        fee = float(self.fee or 0)
        tax = float(self.tax or 0)
        
        if self.transaction_type == "buy":
            return base + fee
        else:  # sell
            return base - fee - tax
    
    def format_quantity_display(self) -> str:
        """格式化顯示股數（台股顯示張+零股）"""
        if self.market == 'tw':
            lots = self.quantity // 1000
            odd = self.quantity % 1000
            if lots > 0 and odd > 0:
                return f"{lots}張{odd}股"
            elif lots > 0:
                return f"{lots}張"
            else:
                return f"{odd}股"
        else:
            return f"{self.quantity}股"
    
    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "user_id": self.user_id,
            "symbol": self.symbol,
            "name": self.name,
            "market": self.market,
            "transaction_type": self.transaction_type,
            "quantity": self.quantity,
            "quantity_display": self.format_quantity_display(),
            "price": float(self.price),
            "fee": float(self.fee or 0),
            "tax": float(self.tax or 0),
            "total_amount": self.total_amount,
            "total_cost": self.total_cost,
            "transaction_date": self.transaction_date.isoformat() if self.transaction_date else None,
            "note": self.note,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }


class PortfolioHolding(Base):
    """
    持股彙總
    由交易紀錄計算而來，用於快速查詢
    """
    
    __tablename__ = "portfolio_holdings"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    symbol = Column(String(20), nullable=False)
    name = Column(String(100))
    market = Column(String(10), nullable=False)
    
    # 持股資訊
    total_shares = Column(Integer, default=0)              # 總持股
    avg_cost = Column(Numeric(12, 4), default=0)           # 平均成本
    total_invested = Column(Numeric(14, 2), default=0)     # 總投入金額
    realized_profit = Column(Numeric(14, 2), default=0)    # 已實現損益
    
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_holding_user_symbol', 'user_id', 'symbol', 'market', unique=True),
        Index('idx_holding_user', 'user_id'),
    )
    
    def format_quantity_display(self) -> str:
        """格式化顯示股數（台股顯示張+零股）"""
        if self.market == 'tw':
            lots = self.total_shares // 1000
            odd = self.total_shares % 1000
            if lots > 0 and odd > 0:
                return f"{lots}張{odd}股"
            elif lots > 0:
                return f"{lots}張"
            else:
                return f"{odd}股"
        else:
            return f"{self.total_shares}股"
    
    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "user_id": self.user_id,
            "symbol": self.symbol,
            "name": self.name,
            "market": self.market,
            "total_shares": self.total_shares,
            "quantity_display": self.format_quantity_display(),
            "avg_cost": float(self.avg_cost) if self.avg_cost else 0,
            "total_invested": float(self.total_invested) if self.total_invested else 0,
            "realized_profit": float(self.realized_profit) if self.realized_profit else 0,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }


class ExchangeRate(Base):
    """匯率表"""
    
    __tablename__ = "exchange_rates"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    from_currency = Column(String(10), nullable=False)    # USD
    to_currency = Column(String(10), nullable=False)      # TWD
    rate = Column(Float, nullable=False)                  # 匯率
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_exchange_pair', 'from_currency', 'to_currency', unique=True),
    )
    
    def to_dict(self) -> dict:
        return {
            "from_currency": self.from_currency,
            "to_currency": self.to_currency,
            "rate": self.rate,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/price_cache.py  ⭐⭐
> 股票價格快取 Model
──────────────────────────────────────────────────────────────────────

```py
"""
股票價格快取 Model
用於追蹤清單的即時價格顯示（全系統共用）

更新：加入 MA20 欄位支援排序功能
"""
from sqlalchemy import Column, String, Numeric, BigInteger, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


class StockPriceCache(Base):
    """
    股票即時價格快取
    
    - 全系統共用，不分用戶
    - 每 10 分鐘由排程批次更新
    - 追蹤清單頁面直接從這裡讀取
    """
    
    __tablename__ = "stock_price_cache"
    
    # 主鍵：股票代號（如 0050.TW, AAPL）
    symbol = Column(String(20), primary_key=True)
    
    # 股票名稱
    name = Column(String(100))
    
    # 價格資訊
    price = Column(Numeric(12, 4))           # 最新價格
    prev_close = Column(Numeric(12, 4))      # 前收盤價（用於計算漲跌）
    change = Column(Numeric(12, 4))          # 漲跌金額
    change_pct = Column(Numeric(8, 4))       # 漲跌幅 %
    
    # 🆕 技術指標（用於排序）
    ma20 = Column(Numeric(12, 4))            # 20日均線
    
    # 成交量
    volume = Column(BigInteger)
    
    # 資產類型：stock / crypto
    asset_type = Column(String(10), default="stock")
    
    # 更新時間
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_cache_asset_type', 'asset_type'),
        Index('idx_cache_updated', 'updated_at'),
    )
    
    def __repr__(self):
        return f"<StockPriceCache(symbol={self.symbol}, price={self.price}, change_pct={self.change_pct}%)>"
    
    def to_dict(self):
        return {
            "symbol": self.symbol,
            "name": self.name,
            "price": float(self.price) if self.price else None,
            "prev_close": float(self.prev_close) if self.prev_close else None,
            "change": float(self.change) if self.change else None,
            "change_pct": float(self.change_pct) if self.change_pct else None,
            "ma20": float(self.ma20) if self.ma20 else None,
            "volume": self.volume,
            "asset_type": self.asset_type,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/stock_price.py  ⭐⭐
> 股票價格歷史資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
股票價格歷史資料模型
"""
from sqlalchemy import Column, Integer, String, Date, Numeric, BigInteger, DateTime, Index
from sqlalchemy.sql import func
from app.database import Base


class StockPrice(Base):
    """美股價格歷史"""
    
    __tablename__ = "stock_prices"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(10), nullable=False, index=True)
    date = Column(Date, nullable=False, index=True)
    open = Column(Numeric(12, 4))
    high = Column(Numeric(12, 4))
    low = Column(Numeric(12, 4))
    close = Column(Numeric(12, 4))
    volume = Column(BigInteger)
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_stock_symbol_date', 'symbol', 'date', unique=True),
    )
    
    def __repr__(self):
        return f"<StockPrice(symbol={self.symbol}, date={self.date}, close={self.close})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "symbol": self.symbol,
            "date": self.date.isoformat() if self.date else None,
            "open": float(self.open) if self.open else None,
            "high": float(self.high) if self.high else None,
            "low": float(self.low) if self.low else None,
            "close": float(self.close) if self.close else None,
            "volume": self.volume,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/subscription.py  ⭐⭐
> 訂閱精選相關 Model
──────────────────────────────────────────────────────────────────────

```py
"""
訂閱精選相關 Model
- SubscriptionSource: 訂閱源（如美股大叔）
- AutoPick: 自動抓取的標的
- UserSubscription: 用戶訂閱關係
"""
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, Date, ForeignKey, UniqueConstraint
from sqlalchemy.orm import relationship
from datetime import datetime, timedelta

from app.database import Base


class SubscriptionSource(Base):
    """訂閱源"""
    __tablename__ = "subscription_sources"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(100), nullable=False)          # "美股大叔"
    slug = Column(String(50), unique=True, nullable=False)  # "uncle-stock"
    url = Column(String(500), nullable=False)           # RSS feed URL
    type = Column(String(20), default="substack")       # substack, rss, etc.
    description = Column(Text)
    enabled = Column(Boolean, default=True)
    last_fetched_at = Column(DateTime)                  # 最後抓取時間
    created_at = Column(DateTime, default=datetime.now)
    
    # 關聯
    auto_picks = relationship("AutoPick", back_populates="source")
    subscribers = relationship("UserSubscription", back_populates="source")
    
    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "slug": self.slug,
            "url": self.url,
            "type": self.type,
            "description": self.description,
            "enabled": self.enabled,
            "last_fetched_at": self.last_fetched_at.isoformat() if self.last_fetched_at else None,
        }


class AutoPick(Base):
    """自動抓取的標的"""
    __tablename__ = "auto_picks"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    source_id = Column(Integer, ForeignKey("subscription_sources.id"), nullable=False)
    symbol = Column(String(20), nullable=False)         # 股票代碼
    article_url = Column(String(500))                   # 出處連結
    article_title = Column(String(300))                 # 文章標題
    article_date = Column(Date)                         # 文章日期
    first_seen_at = Column(DateTime, default=datetime.now)  # 首次發現
    last_seen_at = Column(DateTime, default=datetime.now)   # 最近提及
    expires_at = Column(DateTime)                       # last_seen_at + 30天
    mention_count = Column(Integer, default=1)          # 提及次數
    created_at = Column(DateTime, default=datetime.now)
    
    # 關聯
    source = relationship("SubscriptionSource", back_populates="auto_picks")
    
    # 複合唯一：同來源 + 同代碼
    __table_args__ = (
        UniqueConstraint('source_id', 'symbol', name='uq_source_symbol'),
    )
    
    def update_mention(self, article_url: str = None, article_title: str = None, article_date: Date = None):
        """更新提及：重算過期時間、累加計數"""
        self.last_seen_at = datetime.now()
        self.expires_at = datetime.now() + timedelta(days=30)
        self.mention_count += 1
        if article_url:
            self.article_url = article_url
        if article_title:
            self.article_title = article_title
        if article_date:
            self.article_date = article_date
    
    @property
    def is_active(self) -> bool:
        """是否仍在有效期內"""
        if not self.expires_at:
            return False
        return self.expires_at > datetime.now()
    
    @property
    def days_remaining(self) -> int:
        """剩餘天數"""
        if not self.expires_at:
            return 0
        delta = self.expires_at - datetime.now()
        return max(0, delta.days)
    
    def to_dict(self):
        return {
            "id": self.id,
            "source_id": self.source_id,
            "symbol": self.symbol,
            "article_url": self.article_url,
            "article_title": self.article_title,
            "article_date": self.article_date.isoformat() if self.article_date else None,
            "first_seen_at": self.first_seen_at.isoformat() if self.first_seen_at else None,
            "last_seen_at": self.last_seen_at.isoformat() if self.last_seen_at else None,
            "expires_at": self.expires_at.isoformat() if self.expires_at else None,
            "days_remaining": self.days_remaining,
            "mention_count": self.mention_count,
            "is_active": self.is_active,
        }


class UserSubscription(Base):
    """用戶訂閱關係"""
    __tablename__ = "user_subscriptions"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    source_id = Column(Integer, ForeignKey("subscription_sources.id"), nullable=False)
    subscribed_at = Column(DateTime, default=datetime.now)
    
    # 關聯
    source = relationship("SubscriptionSource", back_populates="subscribers")
    
    # 複合唯一
    __table_args__ = (
        UniqueConstraint('user_id', 'source_id', name='uq_user_source'),
    )
    
    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "source_id": self.source_id,
            "subscribed_at": self.subscribed_at.isoformat() if self.subscribed_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/user.py  ⭐⭐
> 用戶資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
用戶資料模型
"""
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.database import Base


class User(Base):
    """用戶資料"""
    
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    line_user_id = Column(String(50), unique=True, nullable=False, index=True)
    display_name = Column(String(100))
    picture_url = Column(String(500))
    email = Column(String(200))
    is_active = Column(Boolean, default=True)
    is_admin = Column(Boolean, default=False)  # 管理員
    is_blocked = Column(Boolean, default=False)  # 封鎖
    blocked_reason = Column(String(200))  # 封鎖原因
    blocked_at = Column(DateTime)  # 封鎖時間
    created_at = Column(DateTime, server_default=func.now())
    last_login = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # 關聯
    watchlists = relationship("Watchlist", back_populates="user", cascade="all, delete-orphan")
    indicator_settings = relationship("UserIndicatorSettings", back_populates="user", uselist=False, cascade="all, delete-orphan")
    alert_settings = relationship("UserAlertSettings", back_populates="user", uselist=False, cascade="all, delete-orphan")
    login_logs = relationship("LoginLog", back_populates="user", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<User(id={self.id}, line_user_id={self.line_user_id}, display_name={self.display_name})>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "line_user_id": self.line_user_id,
            "display_name": self.display_name,
            "picture_url": self.picture_url,
            "email": self.email,
            "is_active": self.is_active,
            "is_admin": self.is_admin,
            "is_blocked": self.is_blocked,
            "blocked_reason": self.blocked_reason,
            "blocked_at": self.blocked_at.isoformat() if self.blocked_at else None,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "last_login": self.last_login.isoformat() if self.last_login else None,
        }


class LoginLog(Base):
    """登入日誌"""
    
    __tablename__ = "login_logs"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    action = Column(String(20), nullable=False)  # login, logout, token_refresh
    ip_address = Column(String(50))
    user_agent = Column(String(500))
    created_at = Column(DateTime, server_default=func.now())
    
    # 關聯
    user = relationship("User", back_populates="login_logs")
    
    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "action": self.action,
            "ip_address": self.ip_address,
            "user_agent": self.user_agent,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }


class TokenBlacklist(Base):
    """Token 黑名單（用於踢出用戶）"""
    
    __tablename__ = "token_blacklist"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    token_jti = Column(String(100), unique=True, nullable=False, index=True)  # JWT ID
    user_id = Column(Integer, index=True)
    reason = Column(String(100))  # kicked, logout, blocked
    created_at = Column(DateTime, server_default=func.now())
    expires_at = Column(DateTime)  # Token 過期時間（過期後可清理）
    
    def to_dict(self):
        return {
            "id": self.id,
            "token_jti": self.token_jti,
            "user_id": self.user_id,
            "reason": self.reason,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }


class SystemConfig(Base):
    """系統設定"""
    
    __tablename__ = "system_config"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    key = Column(String(50), unique=True, nullable=False, index=True)
    value = Column(Text)
    description = Column(String(200))
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    def to_dict(self):
        return {
            "id": self.id,
            "key": self.key,
            "value": self.value,
            "description": self.description,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/user_settings.py  ⭐⭐
> 用戶設定資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
用戶設定資料模型
包含指標顯示設定、通知設定、參數設定
"""
from sqlalchemy import Column, Integer, Boolean, ForeignKey, Numeric
from sqlalchemy.orm import relationship
from app.database import Base


class UserIndicatorSettings(Base):
    """用戶指標顯示設定"""
    
    __tablename__ = "user_indicator_settings"
    
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), primary_key=True)
    show_ma = Column(Boolean, default=True)
    show_rsi = Column(Boolean, default=True)
    show_macd = Column(Boolean, default=True)
    show_kd = Column(Boolean, default=False)
    show_bollinger = Column(Boolean, default=True)
    show_obv = Column(Boolean, default=False)
    show_volume = Column(Boolean, default=True)
    
    # 關聯
    user = relationship("User", back_populates="indicator_settings")
    
    def __repr__(self):
        return f"<UserIndicatorSettings(user_id={self.user_id})>"
    
    def to_dict(self):
        return {
            "show_ma": self.show_ma,
            "show_rsi": self.show_rsi,
            "show_macd": self.show_macd,
            "show_kd": self.show_kd,
            "show_bollinger": self.show_bollinger,
            "show_obv": self.show_obv,
            "show_volume": self.show_volume,
        }
    
    @classmethod
    def create_default(cls, user_id: int):
        """建立預設設定"""
        return cls(user_id=user_id)


class UserAlertSettings(Base):
    """用戶通知設定"""
    
    __tablename__ = "user_alert_settings"
    
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), primary_key=True)
    alert_ma_cross = Column(Boolean, default=True)      # 均線交叉通知
    alert_ma_breakout = Column(Boolean, default=True)   # 均線突破通知
    alert_rsi = Column(Boolean, default=True)           # RSI 超買超賣通知
    alert_macd = Column(Boolean, default=True)          # MACD 交叉通知
    alert_kd = Column(Boolean, default=False)           # KD 交叉通知
    alert_bollinger = Column(Boolean, default=False)    # 布林突破通知
    alert_volume = Column(Boolean, default=False)       # 量能異常通知
    alert_sentiment = Column(Boolean, default=True)     # 情緒極端通知
    
    # 關聯
    user = relationship("User", back_populates="alert_settings")
    
    def __repr__(self):
        return f"<UserAlertSettings(user_id={self.user_id})>"
    
    def to_dict(self):
        return {
            "alert_ma_cross": self.alert_ma_cross,
            "alert_ma_breakout": self.alert_ma_breakout,
            "alert_rsi": self.alert_rsi,
            "alert_macd": self.alert_macd,
            "alert_kd": self.alert_kd,
            "alert_bollinger": self.alert_bollinger,
            "alert_volume": self.alert_volume,
            "alert_sentiment": self.alert_sentiment,
        }
    
    @classmethod
    def create_default(cls, user_id: int):
        """建立預設設定"""
        return cls(user_id=user_id)


class UserIndicatorParams(Base):
    """用戶指標參數設定"""
    
    __tablename__ = "user_indicator_params"
    
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), primary_key=True)
    
    # 均線
    ma_short = Column(Integer, default=20)
    ma_mid = Column(Integer, default=50)
    ma_long = Column(Integer, default=200)
    
    # RSI
    rsi_period = Column(Integer, default=14)
    rsi_overbought = Column(Integer, default=70)
    rsi_oversold = Column(Integer, default=30)
    
    # MACD
    macd_fast = Column(Integer, default=12)
    macd_slow = Column(Integer, default=26)
    macd_signal = Column(Integer, default=9)
    
    # KD
    kd_period = Column(Integer, default=9)
    
    # 布林通道
    bollinger_period = Column(Integer, default=20)
    bollinger_std = Column(Numeric(3, 1), default=2.0)
    
    # 警戒值
    breakout_threshold = Column(Numeric(4, 2), default=2.00)  # 突破預警門檻 (%)
    volume_alert_ratio = Column(Numeric(3, 1), default=2.0)   # 量比警戒倍數
    
    # 關聯
    user = relationship("User")
    
    def __repr__(self):
        return f"<UserIndicatorParams(user_id={self.user_id})>"
    
    def to_dict(self):
        return {
            "ma_short": self.ma_short,
            "ma_mid": self.ma_mid,
            "ma_long": self.ma_long,
            "rsi_period": self.rsi_period,
            "rsi_overbought": self.rsi_overbought,
            "rsi_oversold": self.rsi_oversold,
            "macd_fast": self.macd_fast,
            "macd_slow": self.macd_slow,
            "macd_signal": self.macd_signal,
            "kd_period": self.kd_period,
            "bollinger_period": self.bollinger_period,
            "bollinger_std": float(self.bollinger_std) if self.bollinger_std else 2.0,
            "breakout_threshold": float(self.breakout_threshold) if self.breakout_threshold else 2.0,
            "volume_alert_ratio": float(self.volume_alert_ratio) if self.volume_alert_ratio else 2.0,
        }
    
    @classmethod
    def create_default(cls, user_id: int):
        """建立預設設定"""
        return cls(user_id=user_id)
```

──────────────────────────────────────────────────────────────────────
### 📄 app/models/watchlist.py  ⭐⭐
> 追蹤清單資料模型
──────────────────────────────────────────────────────────────────────

```py
"""
追蹤清單資料模型
"""
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Index, Numeric
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.database import Base


class Watchlist(Base):
    """用戶追蹤清單"""
    __tablename__ = "watchlists"

    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    symbol = Column(String(10), nullable=False)
    asset_type = Column(String(10), nullable=False)  # stock / crypto
    note = Column(String(200))  # 自訂備註
    target_price = Column(Numeric(12, 4), nullable=True)  # 🆕 目標價格
    added_at = Column(DateTime, server_default=func.now())

    # 關聯
    user = relationship("User", back_populates="watchlists")

    __table_args__ = (
        Index('idx_watchlist_user', 'user_id'),
        Index('idx_watchlist_unique', 'user_id', 'symbol', 'asset_type', unique=True),
    )

    def __repr__(self):
        return f"<Watchlist(user_id={self.user_id}, symbol={self.symbol}, asset_type={self.asset_type})>"

    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "symbol": self.symbol,
            "asset_type": self.asset_type,
            "note": self.note,
            "target_price": float(self.target_price) if self.target_price else None,
            "added_at": self.added_at.isoformat() if self.added_at else None,
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/schemas/__init__.py  ⭐⭐
> Pydantic Schemas
──────────────────────────────────────────────────────────────────────

```py
"""
Pydantic Schemas
"""
from app.schemas.schemas import *
```

──────────────────────────────────────────────────────────────────────
### 📄 app/schemas/schemas.py  ⭐⭐
> Pydantic Schemas
──────────────────────────────────────────────────────────────────────

```py
"""
Pydantic Schemas
API 請求/回應資料模型
"""
from pydantic import BaseModel, Field
from typing import Optional, List, Any, Dict
from datetime import datetime


# ==================== 通用 ====================

class ResponseBase(BaseModel):
    """基礎回應"""
    success: bool = True
    message: Optional[str] = None


class ErrorResponse(BaseModel):
    """錯誤回應"""
    success: bool = False
    error: Dict[str, str]


# ==================== 用戶 ====================

class UserBase(BaseModel):
    """用戶基本資訊"""
    display_name: Optional[str] = None
    picture_url: Optional[str] = None
    email: Optional[str] = None


class UserResponse(UserBase):
    """用戶回應"""
    id: int
    line_user_id: str
    is_active: bool
    is_admin: bool = False  # 管理員權限
    created_at: Optional[datetime] = None
    last_login: Optional[datetime] = None
    
    class Config:
        from_attributes = True


class LoginResponse(ResponseBase):
    """登入回應"""
    token: str
    user: UserResponse
    is_new_user: bool = False


# ==================== 追蹤清單 ====================

class WatchlistAdd(BaseModel):
    """新增追蹤清單請求"""
    symbol: str = Field(..., min_length=1, max_length=10)
    note: Optional[str] = Field(None, max_length=200)


class WatchlistUpdate(BaseModel):
    """更新追蹤清單請求"""
    note: Optional[str] = Field(None, max_length=200)


class WatchlistItem(BaseModel):
    """追蹤清單項目"""
    id: int
    symbol: str
    asset_type: str
    note: Optional[str] = None
    added_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True


class WatchlistResponse(ResponseBase):
    """追蹤清單回應"""
    data: Optional[WatchlistItem] = None


class WatchlistListResponse(ResponseBase):
    """追蹤清單列表回應"""
    data: List[WatchlistItem] = []
    total: int = 0


class WatchlistOverviewItem(BaseModel):
    """追蹤清單總覽項目"""
    id: int
    symbol: str
    name: Optional[str] = None
    price: Optional[float] = None
    change_day: Optional[float] = None
    change_24h: Optional[float] = None
    ma_alignment: Optional[str] = None
    rsi: Optional[float] = None
    score: Optional[Dict[str, Any]] = None
    note: Optional[str] = None
    added_at: Optional[str] = None


class SentimentItem(BaseModel):
    """情緒指數項目"""
    value: int
    classification: str
    classification_zh: str
    timestamp: str
    market: str


class WatchlistOverviewResponse(ResponseBase):
    """追蹤清單總覽回應"""
    stocks: List[WatchlistOverviewItem] = []
    crypto: List[WatchlistOverviewItem] = []
    sentiment: Optional[Dict[str, SentimentItem]] = None
    total_count: int = 0


# ==================== 設定 ====================

class IndicatorSettingsUpdate(BaseModel):
    """指標顯示設定更新"""
    show_ma: Optional[bool] = None
    show_rsi: Optional[bool] = None
    show_macd: Optional[bool] = None
    show_kd: Optional[bool] = None
    show_bollinger: Optional[bool] = None
    show_obv: Optional[bool] = None
    show_volume: Optional[bool] = None


class IndicatorSettingsResponse(ResponseBase):
    """指標顯示設定回應"""
    data: Dict[str, bool] = {}


class AlertSettingsUpdate(BaseModel):
    """通知設定更新"""
    alert_ma_cross: Optional[bool] = None
    alert_ma_breakout: Optional[bool] = None
    alert_rsi: Optional[bool] = None
    alert_macd: Optional[bool] = None
    alert_kd: Optional[bool] = None
    alert_bollinger: Optional[bool] = None
    alert_volume: Optional[bool] = None
    alert_sentiment: Optional[bool] = None


class AlertSettingsResponse(ResponseBase):
    """通知設定回應"""
    data: Dict[str, bool] = {}


class IndicatorParamsUpdate(BaseModel):
    """指標參數更新"""
    ma_short: Optional[int] = Field(None, ge=5, le=50)
    ma_mid: Optional[int] = Field(None, ge=20, le=100)
    ma_long: Optional[int] = Field(None, ge=50, le=300)
    rsi_period: Optional[int] = Field(None, ge=5, le=30)
    rsi_overbought: Optional[int] = Field(None, ge=60, le=90)
    rsi_oversold: Optional[int] = Field(None, ge=10, le=40)
    macd_fast: Optional[int] = Field(None, ge=5, le=20)
    macd_slow: Optional[int] = Field(None, ge=15, le=40)
    macd_signal: Optional[int] = Field(None, ge=5, le=15)
    kd_period: Optional[int] = Field(None, ge=5, le=20)
    bollinger_period: Optional[int] = Field(None, ge=10, le=30)
    bollinger_std: Optional[float] = Field(None, ge=1.0, le=3.0)
    breakout_threshold: Optional[float] = Field(None, ge=0.5, le=5.0)
    volume_alert_ratio: Optional[float] = Field(None, ge=1.0, le=5.0)


class IndicatorParamsResponse(ResponseBase):
    """指標參數回應"""
    data: Dict[str, Any] = {}


# ==================== 股票/加密貨幣 ====================

class PriceInfo(BaseModel):
    """價格資訊"""
    current: float
    high_52w: Optional[float] = None
    low_52w: Optional[float] = None
    ath: Optional[float] = None
    from_high_pct: Optional[float] = None
    from_low_pct: Optional[float] = None
    from_ath_pct: Optional[float] = None


class ChangeInfo(BaseModel):
    """漲跌幅資訊"""
    day: Optional[float] = None
    week: Optional[float] = None
    month: Optional[float] = None
    quarter: Optional[float] = None
    year: Optional[float] = None


class VolumeInfo(BaseModel):
    """成交量資訊"""
    today: Optional[int] = None
    avg_20d: Optional[int] = None
    ratio: Optional[float] = None


class SignalItem(BaseModel):
    """訊號項目"""
    type: str
    indicator: str
    description: str


class ScoreInfo(BaseModel):
    """評分資訊"""
    buy_score: int = 0
    sell_score: int = 0
    rating: str = "neutral"
    details: List[str] = []


class StockAnalysisResponse(ResponseBase):
    """股票分析回應"""
    symbol: str
    name: str
    asset_type: str = "stock"
    price: PriceInfo
    change: ChangeInfo
    volume: Optional[VolumeInfo] = None
    indicators: Dict[str, Any] = {}
    signals: List[SignalItem] = []
    score: ScoreInfo
    updated_at: Optional[str] = None


class CryptoAnalysisResponse(ResponseBase):
    """加密貨幣分析回應"""
    symbol: str
    name: str
    asset_type: str = "crypto"
    price: PriceInfo
    change: ChangeInfo
    market: Optional[Dict[str, Any]] = None
    indicators: Dict[str, Any] = {}
    signals: List[SignalItem] = []
    score: ScoreInfo
    updated_at: Optional[str] = None


# ==================== 市場情緒 ====================

class MarketSentimentResponse(ResponseBase):
    """市場情緒回應"""
    stock: Optional[SentimentItem] = None
    crypto: Optional[SentimentItem] = None
```

======================================================================
## 🧠 核心邏輯
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/services/__init__.py  ⭐⭐⭐
> 商業邏輯服務模組
──────────────────────────────────────────────────────────────────────

```py
"""
商業邏輯服務模組
"""
from app.services.indicator_service import indicator_service, IndicatorService
from app.services.stock_service import StockService
from app.services.crypto_service import CryptoService
from app.services.chart_service import chart_service, ChartService
from app.services.auth_service import AuthService, AuthServiceSync
from app.services.watchlist_service import WatchlistService
from app.services.market_service import MarketService
from app.services.signal_service import signal_service, SignalService, SignalType
from app.services.line_notify_service import line_notify_service, LineNotifyService

__all__ = [
    "indicator_service",
    "IndicatorService",
    "StockService",
    "CryptoService",
    "chart_service",
    "ChartService",
    "AuthService",
    "AuthServiceSync",
    "WatchlistService",
    "MarketService",
    "signal_service",
    "SignalService",
    "SignalType",
    "line_notify_service",
    "LineNotifyService",
]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/auth_service.py  ⭐⭐⭐
> 認證服務
──────────────────────────────────────────────────────────────────────

```py
"""
認證服務
LINE Login 整合 + JWT Token 管理
"""
import httpx
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from jose import jwt, JWTError
from sqlalchemy.orm import Session
from sqlalchemy import select
import logging
import secrets
import uuid

from app.config import settings
from app.models.user import User, LoginLog, SystemConfig
from app.models.user_settings import UserIndicatorSettings, UserAlertSettings, UserIndicatorParams

logger = logging.getLogger(__name__)

# JWT 設定
JWT_ALGORITHM = "HS256"


class AuthService:
    """認證服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    # ==================== LINE Login ====================
    
    def get_line_auth_url(self, state: str = None) -> str:
        """
        取得 LINE 授權 URL
        
        Args:
            state: 防 CSRF 的隨機字串
            
        Returns:
            LINE 授權頁面 URL
        """
        if not state:
            state = secrets.token_urlsafe(32)
        
        params = {
            "response_type": "code",
            "client_id": settings.LINE_LOGIN_CHANNEL_ID,
            "redirect_uri": settings.LINE_LOGIN_CALLBACK_URL,
            "state": state,
            "scope": "profile openid email",
        }
        
        query_string = "&".join(f"{k}={v}" for k, v in params.items())
        return f"https://access.line.me/oauth2/v2.1/authorize?{query_string}"
    
    async def exchange_code_for_token(self, code: str) -> Optional[Dict[str, Any]]:
        """
        用 authorization code 換取 access token
        
        Args:
            code: LINE 回傳的 authorization code
            
        Returns:
            包含 access_token, id_token 等的字典
        """
        url = "https://api.line.me/oauth2/v2.1/token"
        
        data = {
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": settings.LINE_LOGIN_CALLBACK_URL,
            "client_id": settings.LINE_LOGIN_CHANNEL_ID,
            "client_secret": settings.LINE_LOGIN_CHANNEL_SECRET,
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(url, data=data)
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error(f"LINE token 交換失敗: {e}")
            return None
    
    async def get_line_profile(self, access_token: str) -> Optional[Dict[str, Any]]:
        """
        用 access token 取得 LINE 用戶資料
        
        Args:
            access_token: LINE access token
            
        Returns:
            用戶資料字典 (userId, displayName, pictureUrl, statusMessage)
        """
        url = "https://api.line.me/v2/profile"
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    url,
                    headers={"Authorization": f"Bearer {access_token}"}
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error(f"取得 LINE 用戶資料失敗: {e}")
            return None
    
    async def verify_id_token(self, id_token: str) -> Optional[Dict[str, Any]]:
        """
        驗證 LINE ID Token
        
        Args:
            id_token: LINE ID Token
            
        Returns:
            解碼後的 token payload
        """
        url = "https://api.line.me/oauth2/v2.1/verify"
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    url,
                    data={
                        "id_token": id_token,
                        "client_id": settings.LINE_LOGIN_CHANNEL_ID,
                    }
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error(f"LINE ID Token 驗證失敗: {e}")
            return None
    
    # ==================== 用戶管理 ====================
    
    async def get_user_by_line_id(self, line_user_id: str) -> Optional[User]:
        """根據 LINE User ID 取得用戶"""
        stmt = select(User).where(User.line_user_id == line_user_id)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_user_by_id(self, user_id: int) -> Optional[User]:
        """根據 ID 取得用戶"""
        stmt = select(User).where(User.id == user_id)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def create_user(
        self,
        line_user_id: str,
        display_name: str = None,
        picture_url: str = None,
        email: str = None,
    ) -> User:
        """
        建立新用戶
        
        會自動建立預設設定，並檢查是否為初始管理員
        """
        # 檢查是否為初始管理員
        admin_ids = settings.get_admin_line_ids()
        is_admin = line_user_id in admin_ids
        
        user = User(
            line_user_id=line_user_id,
            display_name=display_name,
            picture_url=picture_url,
            email=email,
            is_admin=is_admin,
        )
        self.db.add(user)
        await self.db.flush()  # 取得 user.id
        
        # 建立預設設定
        indicator_settings = UserIndicatorSettings.create_default(user.id)
        alert_settings = UserAlertSettings.create_default(user.id)
        params = UserIndicatorParams.create_default(user.id)
        
        self.db.add(indicator_settings)
        self.db.add(alert_settings)
        self.db.add(params)
        
        await self.db.commit()
        await self.db.refresh(user)
        
        logger.info(f"新用戶建立: {user.id} ({display_name}), admin={is_admin}")
        return user
    
    async def update_user_login(self, user: User, display_name: str = None, picture_url: str = None):
        """更新用戶登入資訊"""
        if display_name:
            user.display_name = display_name
        if picture_url:
            user.picture_url = picture_url
        user.last_login = datetime.utcnow()
        
        # 檢查是否需要升級為管理員（使用 getattr 和 setattr 避免欄位不存在的錯誤）
        try:
            if not getattr(user, 'is_admin', False):
                admin_ids = settings.get_admin_line_ids()
                if user.line_user_id in admin_ids:
                    user.is_admin = True
                    logger.info(f"用戶 {user.id} 升級為管理員")
        except Exception as e:
            logger.warning(f"is_admin check failed: {e}")
        
        await self.db.commit()
    
    async def log_login(self, user_id: int, action: str = "login", ip_address: str = None, user_agent: str = None):
        """記錄登入日誌"""
        try:
            log = LoginLog(
                user_id=user_id,
                action=action,
                ip_address=ip_address,
                user_agent=user_agent[:500] if user_agent else None,
            )
            self.db.add(log)
            await self.db.commit()
        except Exception as e:
            # 如果 login_logs 表不存在，忽略錯誤
            logger.warning(f"log_login failed (table may not exist): {e}")
    
    async def login_with_line(self, code: str, ip_address: str = None, user_agent: str = None) -> Optional[Dict[str, Any]]:
        """
        LINE Login 完整流程
        
        Args:
            code: LINE 回傳的 authorization code
            
        Returns:
            {
                "user": User,
                "token": str,
                "is_new_user": bool
            }
        """
        logger.info(f"=== LINE Login 開始 ===")
        logger.info(f"IP: {ip_address}, UA: {user_agent[:100] if user_agent else 'N/A'}")
        
        # 1. 換取 access token
        token_data = await self.exchange_code_for_token(code)
        if not token_data:
            logger.error("LINE token 交換失敗")
            return None
        
        access_token = token_data.get("access_token")
        logger.info(f"LINE token 交換成功")
        
        # 2. 取得用戶資料
        profile = await self.get_line_profile(access_token)
        if not profile:
            logger.error("取得 LINE 用戶資料失敗")
            return None
        
        line_user_id = profile.get("userId")
        display_name = profile.get("displayName")
        picture_url = profile.get("pictureUrl")
        
        logger.info(f"LINE 用戶資料: line_id={line_user_id}, name={display_name}")
        
        # 3. 檢查用戶是否存在
        user = await self.get_user_by_line_id(line_user_id)
        is_new_user = False
        
        if user:
            logger.info(f"既有用戶登入: db_id={user.id}, line_id={user.line_user_id}, name={user.display_name}")
            
            # 檢查是否被封鎖（使用 getattr 避免欄位不存在的錯誤）
            if getattr(user, 'is_blocked', False):
                logger.warning(f"封鎖用戶嘗試登入: {user.id} ({display_name})")
                return None
            
            # 更新登入資訊
            await self.update_user_login(user, display_name, picture_url)
            logger.info(f"用戶登入資訊已更新: db_id={user.id}")
        else:
            # 建立新用戶
            logger.info(f"建立新用戶: line_id={line_user_id}, name={display_name}")
            
            # 嘗試從 ID token 取得 email
            email = None
            if token_data.get("id_token"):
                id_token_data = await self.verify_id_token(token_data["id_token"])
                if id_token_data:
                    email = id_token_data.get("email")
            
            user = await self.create_user(
                line_user_id=line_user_id,
                display_name=display_name,
                picture_url=picture_url,
                email=email,
            )
            is_new_user = True
            logger.info(f"新用戶建立成功: db_id={user.id}, line_id={user.line_user_id}")
        
        # 4. 記錄登入日誌
        await self.log_login(user.id, "login", ip_address, user_agent)
        logger.info(f"登入日誌已記錄: user_id={user.id}")
        
        # 5. 產生 JWT Token
        jwt_token = self.create_jwt_token(user)
        
        logger.info(f"=== LINE Login 完成 ===")
        logger.info(f"用戶: db_id={user.id}, line_id={user.line_user_id}, name={user.display_name}, is_new={is_new_user}")
        
        return {
            "user": user,
            "token": jwt_token,
            "is_new_user": is_new_user,
        }
    
    # ==================== JWT Token ====================
    
    def create_jwt_token(self, user: User) -> str:
        """
        建立 JWT Token
        
        Args:
            user: 用戶物件
            
        Returns:
            JWT Token 字串
        
        🆕 過期時間：
        - 一般用戶：10 分鐘
        - 管理員：1 小時
        """
        is_admin = getattr(user, 'is_admin', False)
        
        # 根據用戶角色設定過期時間
        if is_admin:
            expire_minutes = settings.JWT_EXPIRE_MINUTES_ADMIN  # 60 分鐘
        else:
            expire_minutes = settings.JWT_EXPIRE_MINUTES_USER   # 10 分鐘
        
        expire = datetime.utcnow() + timedelta(minutes=expire_minutes)
        issued_at = datetime.utcnow()
        
        payload = {
            "sub": str(user.id),
            "line_user_id": user.line_user_id,
            "display_name": user.display_name,
            "is_admin": is_admin,
            "exp": expire,
            "iat": issued_at,
            "jti": str(uuid.uuid4()),  # 唯一 Token ID
            "expire_minutes": expire_minutes,  # 🆕 告訴前端過期時間
        }
        
        token = jwt.encode(payload, settings.JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
        logger.info(f"JWT Token 建立: user_id={user.id}, is_admin={is_admin}, expire={expire_minutes}分鐘")
        return token
    
    def verify_jwt_token(self, token: str) -> Optional[Dict[str, Any]]:
        """
        驗證 JWT Token
        
        Args:
            token: JWT Token 字串
            
        Returns:
            Token payload 或 None
        """
        try:
            payload = jwt.decode(
                token,
                settings.JWT_SECRET_KEY,
                algorithms=[JWT_ALGORITHM]
            )
            return payload
        except JWTError as e:
            logger.warning(f"JWT 驗證失敗: {e}")
            return None
    
    async def check_token_valid(self, user_id: int, issued_at: int) -> bool:
        """
        檢查 Token 是否仍然有效（未被踢出）
        
        Args:
            user_id: 用戶 ID
            issued_at: Token 簽發時間戳
            
        Returns:
            True 如果 Token 有效
        """
        try:
            # 檢查全域 token 版本
            result = await self.db.execute(
                select(SystemConfig).where(SystemConfig.key == "global_token_version")
            )
            global_config = result.scalar_one_or_none()
            
            if global_config and global_config.value:
                global_version = int(global_config.value)
                if issued_at < global_version:
                    return False
            
            # 檢查用戶 token 版本
            result = await self.db.execute(
                select(SystemConfig).where(SystemConfig.key == f"user_token_version:{user_id}")
            )
            user_config = result.scalar_one_or_none()
            
            if user_config and user_config.value:
                user_version = int(user_config.value)
                if issued_at < user_version:
                    return False
        except Exception as e:
            # 如果 system_config 表不存在，忽略錯誤，預設 token 有效
            logger.warning(f"check_token_valid error (table may not exist): {e}")
        
        return True
    
    async def get_user_from_token(self, token: str) -> Optional[User]:
        """
        從 JWT Token 取得用戶
        
        Args:
            token: JWT Token 字串
            
        Returns:
            User 物件或 None
        """
        payload = self.verify_jwt_token(token)
        if not payload:
            logger.warning("Token 驗證失敗: payload 為空")
            return None
        
        user_id = payload.get("sub")
        token_line_user_id = payload.get("line_user_id")
        
        if not user_id:
            logger.warning("Token 驗證失敗: 缺少 user_id")
            return None
        
        user_id = int(user_id)
        
        # 檢查 Token 是否被踢出
        issued_at = payload.get("iat")
        if issued_at:
            if isinstance(issued_at, datetime):
                issued_at = int(issued_at.timestamp())
            
            is_valid = await self.check_token_valid(user_id, issued_at)
            if not is_valid:
                logger.info(f"Token 已被踢出: user_id={user_id}")
                return None
        
        user = await self.get_user_by_id(user_id)
        
        if not user:
            logger.warning(f"Token 驗證失敗: 用戶不存在 user_id={user_id}")
            return None
        
        # ★★★ 重要：驗證 Token 中的 line_user_id 與資料庫一致 ★★★
        if token_line_user_id and user.line_user_id != token_line_user_id:
            logger.error(f"Token 驗證失敗: LINE ID 不一致! token={token_line_user_id}, db={user.line_user_id}")
            return None
        
        # 檢查用戶是否被封鎖（使用 getattr 避免欄位不存在的錯誤）
        if getattr(user, 'is_blocked', False):
            logger.info(f"封鎖用戶嘗試存取: user_id={user_id}")
            return None
        
        logger.debug(f"Token 驗證成功: user_id={user_id}, line_id={user.line_user_id}")
        return user


# ==================== 同步版本（CLI 用）====================

class AuthServiceSync:
    """同步版認證服務（CLI 用）"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def get_user_by_id(self, user_id: int) -> Optional[User]:
        """根據 ID 取得用戶"""
        stmt = select(User).where(User.id == user_id)
        return self.db.execute(stmt).scalar_one_or_none()
    
    def get_user_by_line_id(self, line_user_id: str) -> Optional[User]:
        """根據 LINE User ID 取得用戶"""
        stmt = select(User).where(User.line_user_id == line_user_id)
        return self.db.execute(stmt).scalar_one_or_none()
    
    def create_demo_user(self, name: str = "Demo User") -> User:
        """建立測試用戶（開發用）"""
        demo_line_id = f"demo_{secrets.token_hex(8)}"
        
        user = User(
            line_user_id=demo_line_id,
            display_name=name,
        )
        self.db.add(user)
        self.db.flush()
        
        # 建立預設設定
        self.db.add(UserIndicatorSettings.create_default(user.id))
        self.db.add(UserAlertSettings.create_default(user.id))
        self.db.add(UserIndicatorParams.create_default(user.id))
        
        self.db.commit()
        self.db.refresh(user)
        return user
    
    def verify_jwt_token(self, token: str) -> Optional[Dict[str, Any]]:
        """驗證 JWT Token"""
        try:
            payload = jwt.decode(
                token,
                settings.JWT_SECRET_KEY,
                algorithms=[JWT_ALGORITHM]
            )
            return payload
        except JWTError:
            return None
    
    def get_user_from_token(self, token: str) -> Optional[User]:
        """從 JWT Token 取得用戶"""
        payload = self.verify_jwt_token(token)
        if not payload:
            return None
        user_id = payload.get("sub")
        if not user_id:
            return None
        return self.get_user_by_id(int(user_id))
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/cache_helper.py  ⭐⭐⭐
> 價格快取輔助模組
──────────────────────────────────────────────────────────────────────

```py
"""
價格快取輔助模組

查詢股票時自動將結果寫入快取
- 查詢過的股票會被快取
- 但不會自動更新（只有追蹤清單才會）
- 支援 MA20 欄位用於排序
"""
import logging
from datetime import datetime
from typing import Optional

logger = logging.getLogger(__name__)


def cache_stock_price(
    symbol: str,
    name: str,
    price: float,
    prev_close: Optional[float] = None,
    change: Optional[float] = None,
    change_pct: Optional[float] = None,
    ma20: Optional[float] = None,
    volume: Optional[int] = None,
    asset_type: str = "stock"
):
    """
    將查詢結果寫入快取（背景執行，不影響主流程）
    
    Args:
        symbol: 股票代碼 (如 0050.TW, AAPL)
        name: 股票名稱
        price: 最新價格
        prev_close: 前收盤價
        change: 漲跌金額
        change_pct: 漲跌幅 %
        ma20: 20日均線（用於排序）
        volume: 成交量
        asset_type: 資產類型 (stock/crypto)
    """
    try:
        from app.database import SessionLocal
        from app.models.price_cache import StockPriceCache
        
        db = SessionLocal()
        try:
            cache = db.query(StockPriceCache).filter(
                StockPriceCache.symbol == symbol
            ).first()
            
            if cache:
                # 更新現有快取
                cache.name = name or cache.name
                cache.price = price
                if prev_close is not None:
                    cache.prev_close = prev_close
                if change is not None:
                    cache.change = change
                if change_pct is not None:
                    cache.change_pct = change_pct
                if ma20 is not None:
                    cache.ma20 = ma20
                if volume is not None:
                    cache.volume = volume
                cache.updated_at = datetime.now()
                logger.debug(f"更新快取: {symbol} = {price}, MA20={ma20}")
            else:
                # 新增快取
                cache = StockPriceCache(
                    symbol=symbol,
                    name=name,
                    price=price,
                    prev_close=prev_close,
                    change=change,
                    change_pct=change_pct,
                    ma20=ma20,
                    volume=volume,
                    asset_type=asset_type,
                )
                db.add(cache)
                logger.info(f"新增快取: {symbol} = {price}, MA20={ma20}")
            
            db.commit()
        finally:
            db.close()
    except Exception as e:
        # 快取失敗不影響主流程
        logger.warning(f"快取 {symbol} 失敗（不影響查詢）: {e}")


def cache_crypto_price(
    symbol: str,
    name: str,
    price: float,
    change_pct: Optional[float] = None,
    volume: Optional[int] = None
):
    """
    快取加密貨幣價格（加密貨幣不需要 MA20）
    """
    cache_stock_price(
        symbol=symbol,
        name=name,
        price=price,
        change_pct=change_pct,
        volume=volume,
        asset_type="crypto"
    )
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/chart_service.py  ⭐⭐⭐
> 圖表繪製服務
──────────────────────────────────────────────────────────────────────

```py
"""
圖表繪製服務
使用 matplotlib + mplfinance 繪製技術分析圖表
"""
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.patches import Circle
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple
import logging

from app.config import settings, CHARTS_DIR

logger = logging.getLogger(__name__)

# 設定中文字體
plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS', 'DejaVu Sans']
plt.rcParams['axes.unicode_minus'] = False

# 顏色定義
COLORS = {
    "price": "#2196F3",      # 價格線 - 藍色
    "ma_short": "#FF9800",   # MA20 - 橙色
    "ma_mid": "#9C27B0",     # MA50 - 紫色
    "ma_long": "#F44336",    # MA200 - 紅色
    "volume_up": "#4CAF50",  # 上漲成交量 - 綠色
    "volume_down": "#F44336", # 下跌成交量 - 紅色
    "bb_fill": "#E3F2FD",    # 布林通道填充 - 淺藍
    "bb_line": "#90CAF9",    # 布林通道線 - 藍色
    "rsi": "#673AB7",        # RSI - 深紫
    "macd_dif": "#2196F3",   # MACD DIF - 藍色
    "macd_dea": "#FF9800",   # MACD DEA - 橙色
    "macd_hist_pos": "#4CAF50",  # MACD 正柱 - 綠色
    "macd_hist_neg": "#F44336",  # MACD 負柱 - 紅色
    "kd_k": "#2196F3",       # K 線 - 藍色
    "kd_d": "#FF9800",       # D 線 - 橙色
    "golden_cross": "#4CAF50",   # 黃金交叉 - 綠色
    "death_cross": "#F44336",    # 死亡交叉 - 紅色
    "grid": "#E0E0E0",       # 網格線
    "overbought": "#FFCDD2", # 超買區 - 淺紅
    "oversold": "#C8E6C9",   # 超賣區 - 淺綠
}


class ChartService:
    """圖表繪製服務"""
    
    def __init__(self, output_dir: Path = None):
        self.output_dir = output_dir or CHARTS_DIR
        self.output_dir.mkdir(exist_ok=True)
    
    def plot_stock_analysis(
        self,
        df: pd.DataFrame,
        symbol: str,
        name: str = "",
        show_ma: bool = True,
        show_bollinger: bool = True,
        show_volume: bool = True,
        show_rsi: bool = True,
        show_macd: bool = True,
        show_kd: bool = False,
        show_signals: bool = True,
        days: int = 120,
        save_path: Optional[str] = None,
    ) -> str:
        """
        繪製完整股票分析圖表
        
        Args:
            df: 含有價格和指標的 DataFrame
            symbol: 股票代號
            name: 股票名稱
            show_ma: 顯示均線
            show_bollinger: 顯示布林通道
            show_volume: 顯示成交量
            show_rsi: 顯示 RSI
            show_macd: 顯示 MACD
            show_kd: 顯示 KD
            show_signals: 標記交叉訊號
            days: 顯示天數
            save_path: 儲存路徑（不指定則自動生成）
            
        Returns:
            圖表檔案路徑
        """
        # 只取最近 N 天資料
        if len(df) > days:
            df = df.tail(days).copy()
        else:
            df = df.copy()
        
        # 確保 date 欄位正確
        if 'date' in df.columns:
            df['date'] = pd.to_datetime(df['date'])
            df = df.set_index('date')
        
        # 計算子圖數量
        n_subplots = 1  # 主圖
        if show_volume:
            n_subplots += 1
        if show_rsi:
            n_subplots += 1
        if show_macd:
            n_subplots += 1
        if show_kd:
            n_subplots += 1
        
        # 設定子圖高度比例
        height_ratios = [3]  # 主圖
        if show_volume:
            height_ratios.append(1)
        if show_rsi:
            height_ratios.append(1)
        if show_macd:
            height_ratios.append(1.2)
        if show_kd:
            height_ratios.append(1)
        
        # 建立圖表
        fig, axes = plt.subplots(
            n_subplots, 1,
            figsize=(14, 3 + n_subplots * 2),
            gridspec_kw={'height_ratios': height_ratios},
            sharex=True,
        )
        
        if n_subplots == 1:
            axes = [axes]
        
        ax_idx = 0
        
        # === 主圖：價格 + 均線 + 布林通道 ===
        ax_main = axes[ax_idx]
        ax_idx += 1
        
        self._plot_price(ax_main, df, show_ma, show_bollinger, show_signals)
        
        # 標題
        title = f"{symbol}"
        if name:
            title += f" - {name}"
        title += f"\n最後更新: {df.index[-1].strftime('%Y-%m-%d')} | 收盤: ${df['close'].iloc[-1]:.2f}"
        ax_main.set_title(title, fontsize=14, fontweight='bold', pad=10)
        
        # === 成交量 ===
        if show_volume:
            self._plot_volume(axes[ax_idx], df)
            ax_idx += 1
        
        # === RSI ===
        if show_rsi and 'rsi' in df.columns:
            self._plot_rsi(axes[ax_idx], df)
            ax_idx += 1
        
        # === MACD ===
        if show_macd and 'macd_dif' in df.columns:
            self._plot_macd(axes[ax_idx], df)
            ax_idx += 1
        
        # === KD ===
        if show_kd and 'kd_k' in df.columns:
            self._plot_kd(axes[ax_idx], df)
            ax_idx += 1
        
        # 調整布局
        plt.tight_layout()
        
        # 儲存圖表
        if not save_path:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            save_path = self.output_dir / f"{symbol}_{timestamp}.png"
        
        plt.savefig(save_path, dpi=150, bbox_inches='tight', facecolor='white')
        plt.close(fig)
        
        logger.info(f"圖表已儲存: {save_path}")
        return str(save_path)
    
    def _plot_price(
        self,
        ax: plt.Axes,
        df: pd.DataFrame,
        show_ma: bool,
        show_bollinger: bool,
        show_signals: bool,
    ):
        """繪製價格主圖"""
        # 布林通道（先畫，作為背景）
        if show_bollinger and 'bb_upper' in df.columns:
            ax.fill_between(
                df.index,
                df['bb_lower'],
                df['bb_upper'],
                color=COLORS['bb_fill'],
                alpha=0.5,
                label='布林通道',
            )
            ax.plot(df.index, df['bb_middle'], color=COLORS['bb_line'], 
                   linewidth=0.8, linestyle='--', alpha=0.7)
        
        # 價格線
        ax.plot(df.index, df['close'], color=COLORS['price'], 
               linewidth=1.5, label='收盤價')
        
        # 均線
        if show_ma:
            ma_short = f"ma{settings.MA_SHORT}"
            ma_mid = f"ma{settings.MA_MID}"
            ma_long = f"ma{settings.MA_LONG}"
            
            if ma_short in df.columns:
                ax.plot(df.index, df[ma_short], color=COLORS['ma_short'],
                       linewidth=1, label=f'MA{settings.MA_SHORT}')
            if ma_mid in df.columns:
                ax.plot(df.index, df[ma_mid], color=COLORS['ma_mid'],
                       linewidth=1, label=f'MA{settings.MA_MID}')
            if ma_long in df.columns:
                ax.plot(df.index, df[ma_long], color=COLORS['ma_long'],
                       linewidth=1, label=f'MA{settings.MA_LONG}')
        
        # 標記交叉訊號
        if show_signals and show_ma:
            self._mark_crossovers(ax, df)
        
        # 設定
        ax.set_ylabel('價格 ($)', fontsize=10)
        ax.legend(loc='upper left', fontsize=8)
        ax.grid(True, color=COLORS['grid'], linestyle='-', linewidth=0.5, alpha=0.7)
        ax.set_xlim(df.index[0], df.index[-1])
    
    def _mark_crossovers(self, ax: plt.Axes, df: pd.DataFrame):
        """標記均線交叉點"""
        ma_short = f"ma{settings.MA_SHORT}"
        ma_mid = f"ma{settings.MA_MID}"
        
        if ma_short not in df.columns or ma_mid not in df.columns:
            return
        
        for i in range(1, len(df)):
            # 黃金交叉
            if (df[ma_short].iloc[i-1] < df[ma_mid].iloc[i-1] and 
                df[ma_short].iloc[i] > df[ma_mid].iloc[i]):
                ax.scatter(df.index[i], df['close'].iloc[i], 
                          color=COLORS['golden_cross'], s=100, marker='^', 
                          zorder=5, edgecolors='white', linewidths=1)
            
            # 死亡交叉
            elif (df[ma_short].iloc[i-1] > df[ma_mid].iloc[i-1] and 
                  df[ma_short].iloc[i] < df[ma_mid].iloc[i]):
                ax.scatter(df.index[i], df['close'].iloc[i], 
                          color=COLORS['death_cross'], s=100, marker='v', 
                          zorder=5, edgecolors='white', linewidths=1)
    
    def _plot_volume(self, ax: plt.Axes, df: pd.DataFrame):
        """繪製成交量"""
        colors = []
        for i in range(len(df)):
            if i == 0:
                colors.append(COLORS['volume_up'])
            elif df['close'].iloc[i] >= df['close'].iloc[i-1]:
                colors.append(COLORS['volume_up'])
            else:
                colors.append(COLORS['volume_down'])
        
        ax.bar(df.index, df['volume'], color=colors, alpha=0.7, width=0.8)
        
        # 20日均量線
        if 'volume_ma20' in df.columns:
            ax.plot(df.index, df['volume_ma20'], color='orange', 
                   linewidth=1, label='20日均量')
            ax.legend(loc='upper left', fontsize=8)
        
        ax.set_ylabel('成交量', fontsize=10)
        ax.grid(True, color=COLORS['grid'], linestyle='-', linewidth=0.5, alpha=0.7)
        
        # 格式化 Y 軸
        ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'{x/1e6:.1f}M'))
    
    def _plot_rsi(self, ax: plt.Axes, df: pd.DataFrame):
        """繪製 RSI"""
        # 超買超賣區域
        ax.axhspan(settings.RSI_OVERBOUGHT, 100, color=COLORS['overbought'], alpha=0.3)
        ax.axhspan(0, settings.RSI_OVERSOLD, color=COLORS['oversold'], alpha=0.3)
        
        # 中線
        ax.axhline(y=50, color='gray', linestyle='--', linewidth=0.8, alpha=0.5)
        ax.axhline(y=settings.RSI_OVERBOUGHT, color='red', linestyle='--', linewidth=0.8, alpha=0.5)
        ax.axhline(y=settings.RSI_OVERSOLD, color='green', linestyle='--', linewidth=0.8, alpha=0.5)
        
        # RSI 線
        ax.plot(df.index, df['rsi'], color=COLORS['rsi'], linewidth=1.2, label='RSI')
        
        # 設定
        ax.set_ylabel('RSI', fontsize=10)
        ax.set_ylim(0, 100)
        ax.legend(loc='upper left', fontsize=8)
        ax.grid(True, color=COLORS['grid'], linestyle='-', linewidth=0.5, alpha=0.7)
        
        # 標記最新值
        latest_rsi = df['rsi'].iloc[-1]
        if not pd.isna(latest_rsi):
            ax.annotate(f'{latest_rsi:.1f}', 
                       xy=(df.index[-1], latest_rsi),
                       xytext=(5, 0), textcoords='offset points',
                       fontsize=9, color=COLORS['rsi'])
    
    def _plot_macd(self, ax: plt.Axes, df: pd.DataFrame):
        """繪製 MACD"""
        # 零軸
        ax.axhline(y=0, color='gray', linestyle='-', linewidth=0.8)
        
        # MACD 柱狀圖
        colors = [COLORS['macd_hist_pos'] if v >= 0 else COLORS['macd_hist_neg'] 
                 for v in df['macd_hist']]
        ax.bar(df.index, df['macd_hist'], color=colors, alpha=0.6, width=0.8)
        
        # DIF 和 DEA 線
        ax.plot(df.index, df['macd_dif'], color=COLORS['macd_dif'], 
               linewidth=1.2, label='DIF')
        ax.plot(df.index, df['macd_dea'], color=COLORS['macd_dea'], 
               linewidth=1.2, label='DEA')
        
        # 標記交叉點
        for i in range(1, len(df)):
            if pd.isna(df['macd_dif'].iloc[i]) or pd.isna(df['macd_dea'].iloc[i]):
                continue
            # 黃金交叉
            if (df['macd_dif'].iloc[i-1] < df['macd_dea'].iloc[i-1] and 
                df['macd_dif'].iloc[i] > df['macd_dea'].iloc[i]):
                ax.scatter(df.index[i], df['macd_dif'].iloc[i], 
                          color=COLORS['golden_cross'], s=50, marker='^', zorder=5)
            # 死亡交叉
            elif (df['macd_dif'].iloc[i-1] > df['macd_dea'].iloc[i-1] and 
                  df['macd_dif'].iloc[i] < df['macd_dea'].iloc[i]):
                ax.scatter(df.index[i], df['macd_dif'].iloc[i], 
                          color=COLORS['death_cross'], s=50, marker='v', zorder=5)
        
        # 設定
        ax.set_ylabel('MACD', fontsize=10)
        ax.legend(loc='upper left', fontsize=8)
        ax.grid(True, color=COLORS['grid'], linestyle='-', linewidth=0.5, alpha=0.7)
    
    def _plot_kd(self, ax: plt.Axes, df: pd.DataFrame):
        """繪製 KD"""
        # 超買超賣區域
        ax.axhspan(80, 100, color=COLORS['overbought'], alpha=0.3)
        ax.axhspan(0, 20, color=COLORS['oversold'], alpha=0.3)
        
        # 中線
        ax.axhline(y=50, color='gray', linestyle='--', linewidth=0.8, alpha=0.5)
        ax.axhline(y=80, color='red', linestyle='--', linewidth=0.8, alpha=0.5)
        ax.axhline(y=20, color='green', linestyle='--', linewidth=0.8, alpha=0.5)
        
        # K 和 D 線
        ax.plot(df.index, df['kd_k'], color=COLORS['kd_k'], linewidth=1.2, label='K')
        ax.plot(df.index, df['kd_d'], color=COLORS['kd_d'], linewidth=1.2, label='D')
        
        # 設定
        ax.set_ylabel('KD', fontsize=10)
        ax.set_ylim(0, 100)
        ax.legend(loc='upper left', fontsize=8)
        ax.grid(True, color=COLORS['grid'], linestyle='-', linewidth=0.5, alpha=0.7)
        ax.set_xlabel('日期', fontsize=10)
    
    def plot_candlestick(
        self,
        df: pd.DataFrame,
        symbol: str,
        name: str = "",
        days: int = 60,
        save_path: Optional[str] = None,
    ) -> str:
        """
        繪製 K 線圖（使用 mplfinance）
        
        Args:
            df: OHLCV DataFrame
            symbol: 股票代號
            name: 股票名稱
            days: 顯示天數
            save_path: 儲存路徑
            
        Returns:
            圖表檔案路徑
        """
        try:
            import mplfinance as mpf
        except ImportError:
            logger.warning("mplfinance 未安裝，使用替代方案")
            return self._plot_candlestick_fallback(df, symbol, name, days, save_path)
        
        # 準備資料
        if len(df) > days:
            df = df.tail(days).copy()
        else:
            df = df.copy()
        
        # 確保索引為 DatetimeIndex
        if 'date' in df.columns:
            df['date'] = pd.to_datetime(df['date'])
            df = df.set_index('date')
        
        # 確保欄位名稱正確（mplfinance 需要大寫）
        df = df.rename(columns={
            'open': 'Open',
            'high': 'High',
            'low': 'Low',
            'close': 'Close',
            'volume': 'Volume',
        })
        
        # 準備均線
        ma_short = f"ma{settings.MA_SHORT}"
        ma_mid = f"ma{settings.MA_MID}"
        ma_long = f"ma{settings.MA_LONG}"
        
        addplots = []
        if ma_short in df.columns:
            addplots.append(mpf.make_addplot(df[ma_short], color=COLORS['ma_short']))
        if ma_mid in df.columns:
            addplots.append(mpf.make_addplot(df[ma_mid], color=COLORS['ma_mid']))
        if ma_long in df.columns:
            addplots.append(mpf.make_addplot(df[ma_long], color=COLORS['ma_long']))
        
        # 設定樣式
        mc = mpf.make_marketcolors(
            up='#4CAF50',
            down='#F44336',
            edge='inherit',
            wick='inherit',
            volume='inherit',
        )
        style = mpf.make_mpf_style(
            marketcolors=mc,
            gridstyle='-',
            gridcolor=COLORS['grid'],
        )
        
        # 儲存路徑
        if not save_path:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            save_path = self.output_dir / f"{symbol}_kline_{timestamp}.png"
        
        # 標題
        title = f"{symbol}"
        if name:
            title += f" - {name}"
        
        # 繪製
        mpf.plot(
            df,
            type='candle',
            style=style,
            title=title,
            ylabel='價格 ($)',
            ylabel_lower='成交量',
            volume=True,
            addplot=addplots if addplots else None,
            figsize=(14, 8),
            savefig=str(save_path),
        )
        
        logger.info(f"K線圖已儲存: {save_path}")
        return str(save_path)
    
    def _plot_candlestick_fallback(
        self,
        df: pd.DataFrame,
        symbol: str,
        name: str,
        days: int,
        save_path: Optional[str],
    ) -> str:
        """當 mplfinance 不可用時的替代 K 線圖"""
        if len(df) > days:
            df = df.tail(days).copy()
        else:
            df = df.copy()
        
        if 'date' in df.columns:
            df['date'] = pd.to_datetime(df['date'])
            df = df.set_index('date')
        
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 8), 
                                        gridspec_kw={'height_ratios': [3, 1]},
                                        sharex=True)
        
        # K 線
        width = 0.6
        width2 = 0.1
        
        up = df[df['close'] >= df['open']]
        down = df[df['close'] < df['open']]
        
        # 上漲 K 線
        ax1.bar(up.index, up['close'] - up['open'], width, bottom=up['open'], 
               color='#4CAF50', edgecolor='#4CAF50')
        ax1.bar(up.index, up['high'] - up['close'], width2, bottom=up['close'], 
               color='#4CAF50')
        ax1.bar(up.index, up['low'] - up['open'], width2, bottom=up['open'], 
               color='#4CAF50')
        
        # 下跌 K 線
        ax1.bar(down.index, down['close'] - down['open'], width, bottom=down['open'], 
               color='#F44336', edgecolor='#F44336')
        ax1.bar(down.index, down['high'] - down['open'], width2, bottom=down['open'], 
               color='#F44336')
        ax1.bar(down.index, down['low'] - down['close'], width2, bottom=down['close'], 
               color='#F44336')
        
        # 標題
        title = f"{symbol}"
        if name:
            title += f" - {name}"
        ax1.set_title(title, fontsize=14, fontweight='bold')
        ax1.set_ylabel('價格 ($)')
        ax1.grid(True, alpha=0.3)
        
        # 成交量
        colors = ['#4CAF50' if df['close'].iloc[i] >= df['open'].iloc[i] 
                 else '#F44336' for i in range(len(df))]
        ax2.bar(df.index, df['volume'], color=colors, alpha=0.7)
        ax2.set_ylabel('成交量')
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if not save_path:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            save_path = self.output_dir / f"{symbol}_kline_{timestamp}.png"
        
        plt.savefig(save_path, dpi=150, bbox_inches='tight', facecolor='white')
        plt.close(fig)
        
        return str(save_path)


# 建立預設實例
chart_service = ChartService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/compare_service.py  ⭐⭐⭐
> 報酬率比較服務
──────────────────────────────────────────────────────────────────────

```py
"""
報酬率比較服務
計算並比較多個標的的年化報酬率 (CAGR)

修復：
1. 台股代號自動加 .TW / .TWO
2. 使用調整後價格(adj_close)計算，避免分割影響
3. 加入配息還原，反映真實報酬
"""
import logging
from datetime import datetime, date, timedelta
from typing import List, Dict, Any, Optional, Tuple
import json
import math

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
import pandas as pd

from app.models.comparison import Comparison
from app.data_sources.yahoo_finance import yahoo_finance
from app.data_sources.coingecko import coingecko, CRYPTO_MAP

logger = logging.getLogger(__name__)


# 預設比較組合
PRESET_GROUPS = {
    "us_tech": {
        "name": "美國科技股",
        "symbols": ["AAPL", "MSFT", "GOOGL", "AMZN", "NVDA"],
        "description": "美國五大科技巨頭"
    },
    "crypto_major": {
        "name": "主流加密貨幣",
        "symbols": ["BTC", "ETH", "SOL", "BNB", "XRP"],
        "description": "市值前五大加密貨幣"
    },
    "index": {
        "name": "大盤指數",
        "symbols": ["^GSPC", "^IXIC", "^DJI"],
        "description": "美國三大指數"
    },
    "etf_popular": {
        "name": "熱門 ETF",
        "symbols": ["SPY", "QQQ", "VOO", "VTI", "IWM"],
        "description": "最受歡迎的 ETF"
    },
    "dividend": {
        "name": "高股息股票",
        "symbols": ["JNJ", "PG", "KO", "PEP", "VZ"],
        "description": "穩定配息的藍籌股"
    },
    "tw_etf": {
        "name": "台股 ETF",
        "symbols": ["0050", "0056", "00878", "00919", "006208"],
        "description": "台灣熱門 ETF"
    },
    "tw_tech": {
        "name": "台灣科技股",
        "symbols": ["2330", "2454", "2317", "3711", "2308"],
        "description": "台灣科技權值股"
    }
}

# 基準指數選項
BENCHMARK_OPTIONS = {
    "^GSPC": "S&P 500",
    "^IXIC": "納斯達克",
    "^DJI": "道瓊工業",
    "": "無"
}

# 支援的加密貨幣
SUPPORTED_CRYPTO = set(k for k in CRYPTO_MAP.keys() if k not in ("BITCOIN", "ETHEREUM"))


class CompareService:
    """報酬率比較服務"""
    
    def __init__(self):
        self.max_symbols = 5  # 最多比較 5 個
    
    def _normalize_symbol(self, symbol: str) -> str:
        """
        標準化股票代號
        - 台股代號（純數字 4-6 位）自動加 .TW
        - 其他保持原樣
        """
        symbol = symbol.strip().upper()
        
        # 如果已經有後綴，不處理
        if '.' in symbol or symbol.startswith('^'):
            return symbol
        
        # 檢查是否為加密貨幣
        if symbol in SUPPORTED_CRYPTO:
            return symbol
        
        # 台股代號：4-6 位純數字
        if symbol.isdigit() and 4 <= len(symbol) <= 6:
            return f"{symbol}.TW"
        
        return symbol
    
    def _get_asset_type(self, symbol: str) -> str:
        """判斷資產類型"""
        symbol_upper = symbol.upper()
        
        # 先檢查原始代號是否為加密貨幣
        base_symbol = symbol_upper.replace('.TW', '').replace('.TWO', '')
        if base_symbol in SUPPORTED_CRYPTO:
            return "crypto"
        
        if symbol_upper.startswith("^"):
            return "index"
        elif symbol_upper.endswith(".TW") or symbol_upper.endswith(".TWO"):
            return "tw_stock"
        else:
            return "stock"
    
    def _get_period_days(self, period: str) -> int:
        """取得時間週期對應的天數"""
        period_map = {
            "1y": 365,
            "3y": 365 * 3,
            "5y": 365 * 5,
            "10y": 365 * 10,
        }
        return period_map.get(period, 365)
    
    async def _fetch_price_data(
        self,
        symbol: str,
        days: int = 3650,  # 預設抓 10 年
    ) -> Tuple[Optional[pd.DataFrame], Optional[Dict]]:
        """
        抓取價格資料
        
        Returns:
            (DataFrame, info_dict) 或 (None, None)
        """
        asset_type = self._get_asset_type(symbol)
        
        try:
            if asset_type == "crypto":
                # 加密貨幣用 CoinGecko
                df = coingecko.get_crypto_history(symbol, days=days)
                info = coingecko.get_crypto_info(symbol)
                if info:
                    info_dict = {
                        "name": info.get("name", symbol),
                        "type": "crypto",
                        "current_price": info.get("current_price"),
                    }
                else:
                    info_dict = {"name": symbol, "type": "crypto", "current_price": None}
                return df, info_dict
            else:
                # 股票/指數/ETF 用 Yahoo Finance
                period = "10y" if days >= 3650 else ("5y" if days >= 1825 else "1y")
                df = yahoo_finance.get_stock_history(symbol, period=period)
                
                # 如果 .TW 找不到，嘗試 .TWO (上櫃股票)
                if (df is None or df.empty) and symbol.endswith('.TW'):
                    two_symbol = symbol.replace('.TW', '.TWO')
                    logger.info(f"{symbol} 找不到，嘗試上櫃股票: {two_symbol}")
                    df = yahoo_finance.get_stock_history(two_symbol, period=period)
                    if df is not None and not df.empty:
                        symbol = two_symbol
                        logger.info(f"成功找到上櫃股票: {two_symbol}")
                
                info = yahoo_finance.get_stock_info(symbol)
                
                # 取得現價（用原始收盤價）
                current_price = None
                if df is not None and not df.empty:
                    current_price = float(df['close'].iloc[-1])
                
                if info:
                    info_dict = {
                        "name": info.get("name", symbol),
                        "type": asset_type,
                        "current_price": current_price or info.get("current_price"),
                        "symbol": symbol,  # 可能已經改成 .TWO
                    }
                else:
                    info_dict = {
                        "name": symbol, 
                        "type": asset_type, 
                        "current_price": current_price,
                        "symbol": symbol,
                    }
                
                return df, info_dict
            
        except Exception as e:
            logger.error(f"抓取 {symbol} 資料失敗: {e}")
            return None, None
    
    def _calculate_cagr_with_dividends(
        self,
        symbol: str,
        df: pd.DataFrame,
        years: int,
    ) -> Optional[float]:
        """
        計算含配息調整的 CAGR
        
        使用 adj_close（分割調整）+ 配息還原
        這和股票查詢頁面的計算方式一致
        """
        if df is None or df.empty:
            return None
        
        try:
            # 確保有 date 欄位
            if 'date' not in df.columns:
                df = df.reset_index()
                if 'Date' in df.columns:
                    df = df.rename(columns={'Date': 'date'})
            
            df['date'] = pd.to_datetime(df['date']).dt.date
            df = df.sort_values('date').reset_index(drop=True)
            
            current_date = df['date'].iloc[-1]
            target_date = current_date - timedelta(days=years * 365)
            
            # 找到目標日期之前的資料
            past_df = df[df['date'] <= target_date]
            
            if past_df.empty or len(past_df) < 10:
                return None
            
            # 優先使用 adj_close，沒有則用 close
            price_col = 'adj_close' if 'adj_close' in df.columns else 'close'
            
            start_row = past_df.iloc[-1]
            start_price = float(start_row[price_col])
            start_date = start_row['date']
            
            current_price = float(df.iloc[-1][price_col])
            
            if start_price <= 0:
                return None
            
            # 取得配息資料並調整
            try:
                dividends_df = yahoo_finance.get_dividends(symbol, period=f"{years + 1}y")
                
                if dividends_df is not None and not dividends_df.empty:
                    # 建立含配息調整的價格序列
                    df_adj = df.copy()
                    df_adj['adj_with_div'] = df_adj[price_col].astype(float)
                    
                    date_to_idx = {row['date']: idx for idx, row in df_adj.iterrows()}
                    
                    # 篩選在計算範圍內的配息
                    min_date = df_adj['date'].min()
                    max_date = df_adj['date'].max()
                    
                    dividends = {}
                    for _, row in dividends_df.iterrows():
                        div_date = row['date']
                        if isinstance(div_date, str):
                            div_date = datetime.strptime(div_date, '%Y-%m-%d').date()
                        elif hasattr(div_date, 'date'):
                            div_date = div_date.date()
                        if min_date < div_date <= max_date:
                            dividends[div_date] = float(row['amount'])
                    
                    # 從最新到最舊處理配息（配息還原調整）
                    for div_date, div_amount in sorted(dividends.items(), reverse=True):
                        if div_date in date_to_idx:
                            ex_idx = date_to_idx[div_date]
                            if ex_idx > 0:
                                prev_price = df_adj.loc[ex_idx - 1, 'adj_with_div']
                                if prev_price > div_amount and div_amount > 0:
                                    adjustment_factor = prev_price / (prev_price - div_amount)
                                    df_adj.loc[:ex_idx-1, 'adj_with_div'] = df_adj.loc[:ex_idx-1, 'adj_with_div'] / adjustment_factor
                    
                    # 使用調整後的價格計算
                    start_price = float(df_adj[df_adj['date'] <= target_date].iloc[-1]['adj_with_div'])
                    current_price = float(df_adj.iloc[-1]['adj_with_div'])
                    
                    logger.debug(f"{symbol} 配息調整: 找到 {len(dividends)} 筆配息")
                    
            except Exception as e:
                logger.warning(f"{symbol} 配息調整失敗，使用基本計算: {e}")
            
            # 實際年數（更精確）
            actual_days = (current_date - start_date).days
            actual_years = actual_days / 365.25
            
            if actual_years < 0.5:
                return None
            
            # CAGR 公式
            cagr = (current_price / start_price) ** (1 / actual_years) - 1
            
            # 檢查有效性
            if math.isnan(cagr) or math.isinf(cagr):
                return None
            
            return round(cagr * 100, 2)
            
        except Exception as e:
            logger.error(f"計算 {symbol} CAGR 失敗: {e}")
            return None
    
    def _calculate_custom_cagr(
        self,
        df: pd.DataFrame,
        start_date: date,
        end_date: date,
    ) -> Optional[float]:
        """計算自訂區間的 CAGR"""
        if df is None or df.empty:
            return None
        
        try:
            # 確保日期欄位
            if 'date' in df.columns:
                df = df.set_index('date')
            
            # 篩選日期範圍
            mask = (df.index >= pd.Timestamp(start_date)) & (df.index <= pd.Timestamp(end_date))
            filtered_df = df[mask]
            
            if len(filtered_df) < 2:
                return None
            
            # 優先使用 adj_close
            price_col = 'adj_close' if 'adj_close' in filtered_df.columns else 'close'
            
            start_price = float(filtered_df[price_col].iloc[0])
            end_price = float(filtered_df[price_col].iloc[-1])
            
            # 計算年數
            days = (end_date - start_date).days
            years = days / 365.0
            
            if years <= 0 or start_price <= 0:
                return None
            
            # CAGR 公式
            cagr = (end_price / start_price) ** (1 / years) - 1
            return round(cagr * 100, 2)
            
        except Exception as e:
            logger.error(f"計算自訂 CAGR 失敗: {e}")
            return None
    
    async def compare_cagr(
        self,
        symbols: List[str],
        periods: List[str] = None,
        custom_range: Dict[str, str] = None,
        benchmark: str = "^GSPC",
        sort_by: str = "5y",
        sort_order: str = "desc",
    ) -> Dict[str, Any]:
        """
        比較多個標的的年化報酬率
        
        Args:
            symbols: 標的代號列表 (最多 5 個)
            periods: 時間週期 ["1y", "3y", "5y", "10y"]
            custom_range: 自訂區間 {"start": "2020-01-01", "end": "2024-12-31"}
            benchmark: 基準指數
            sort_by: 排序依據
            sort_order: 排序方向 "asc" / "desc"
            
        Returns:
            比較結果
        """
        # 驗證
        if not symbols:
            return {"success": False, "error": "請至少選擇一個標的"}
        
        if len(symbols) > self.max_symbols:
            return {"success": False, "error": f"最多只能比較 {self.max_symbols} 個標的"}
        
        if periods is None:
            periods = ["1y", "3y", "5y"]
        
        # 正規化代號（處理台股等）
        symbols = [self._normalize_symbol(s) for s in symbols]
        logger.info(f"標準化後的代號: {symbols}")
        
        # 計算需要的天數
        max_days = 3650  # 10 年
        if custom_range:
            try:
                start_date = datetime.strptime(custom_range["start"], "%Y-%m-%d").date()
                end_date = datetime.strptime(custom_range["end"], "%Y-%m-%d").date()
                custom_days = (date.today() - start_date).days
                max_days = max(max_days, custom_days)
            except (ValueError, KeyError):
                custom_range = None
        
        results = []
        
        # 處理每個標的
        for symbol in symbols:
            df, info = await self._fetch_price_data(symbol, max_days)
            
            # 如果有 symbol 更新（例如 .TW -> .TWO），使用更新後的
            actual_symbol = info.get("symbol", symbol) if info else symbol
            
            if df is None or info is None:
                results.append({
                    "symbol": actual_symbol,
                    "name": actual_symbol,
                    "type": self._get_asset_type(actual_symbol),
                    "current_price": None,
                    "cagr": {p: None for p in periods},
                    "error": "無法取得資料"
                })
                continue
            
            # 計算各週期 CAGR（使用含配息的計算）
            cagr_results = {}
            for period in periods:
                period_years = {"1y": 1, "3y": 3, "5y": 5, "10y": 10}.get(period)
                if period_years:
                    cagr_results[period] = self._calculate_cagr_with_dividends(
                        actual_symbol, df, period_years
                    )
            
            # 自訂區間
            if custom_range:
                cagr_results["custom"] = self._calculate_custom_cagr(
                    df, start_date, end_date
                )
            
            results.append({
                "symbol": actual_symbol,
                "name": info.get("name", actual_symbol),
                "type": info.get("type", "stock"),
                "current_price": info.get("current_price"),
                "cagr": cagr_results,
            })
        
        # 計算基準指數
        benchmark_data = None
        if benchmark:
            benchmark_df, benchmark_info = await self._fetch_price_data(benchmark, max_days)
            if benchmark_df is not None:
                benchmark_cagr = {}
                for period in periods:
                    period_years = {"1y": 1, "3y": 3, "5y": 5, "10y": 10}.get(period)
                    if period_years:
                        benchmark_cagr[period] = self._calculate_cagr_with_dividends(
                            benchmark, benchmark_df, period_years
                        )
                
                benchmark_data = {
                    "symbol": benchmark,
                    "name": BENCHMARK_OPTIONS.get(benchmark, benchmark),
                    "cagr": benchmark_cagr,
                }
                
                # 計算 vs benchmark
                for result in results:
                    result["vs_benchmark"] = {}
                    for period in periods:
                        result_cagr = result["cagr"].get(period)
                        bench_cagr = benchmark_cagr.get(period)
                        if result_cagr is not None and bench_cagr is not None:
                            result["vs_benchmark"][period] = round(result_cagr - bench_cagr, 2)
                        else:
                            result["vs_benchmark"][period] = None
        
        # 排序
        def get_sort_value(item):
            val = item.get("cagr", {}).get(sort_by)
            return val if val is not None else float('-inf')
        
        results.sort(key=get_sort_value, reverse=(sort_order == "desc"))
        
        # 加入排名
        for i, result in enumerate(results):
            result["rank"] = i + 1
        
        return {
            "success": True,
            "comparison": results,
            "benchmark": benchmark_data,
            "periods": periods + (["custom"] if custom_range else []),
            "custom_range": custom_range,
            "sort_by": sort_by,
            "generated_at": datetime.now().isoformat(),
            "note": "CAGR 已包含分割調整及配息再投入效果"
        }
    
    def get_presets(self) -> List[Dict[str, Any]]:
        """取得預設組合列表"""
        return [
            {
                "id": key,
                "name": value["name"],
                "description": value["description"],
                "symbols": value["symbols"],
                "count": len(value["symbols"]),
            }
            for key, value in PRESET_GROUPS.items()
        ]
    
    def get_preset_detail(self, preset_id: str) -> Optional[Dict[str, Any]]:
        """取得預設組合詳情"""
        if preset_id not in PRESET_GROUPS:
            return None
        
        preset = PRESET_GROUPS[preset_id]
        return {
            "id": preset_id,
            "name": preset["name"],
            "description": preset["description"],
            "symbols": preset["symbols"],
        }


class ComparisonCRUD:
    """比較組合 CRUD 操作"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_user_comparisons(self, user_id: int) -> List[Comparison]:
        """取得用戶的比較組合"""
        result = await self.db.execute(
            select(Comparison)
            .where(Comparison.user_id == user_id)
            .order_by(Comparison.updated_at.desc())
        )
        return result.scalars().all()
    
    async def get_comparison_by_id(self, comparison_id: int, user_id: int) -> Optional[Comparison]:
        """取得單一比較組合"""
        result = await self.db.execute(
            select(Comparison)
            .where(and_(Comparison.id == comparison_id, Comparison.user_id == user_id))
        )
        return result.scalar_one_or_none()
    
    async def create_comparison(
        self,
        user_id: int,
        name: str,
        symbols: List[str],
        benchmark: str = None,
    ) -> Comparison:
        """建立比較組合"""
        comparison = Comparison(
            user_id=user_id,
            name=name,
            _symbols=json.dumps(symbols),
            benchmark=benchmark,
        )
        self.db.add(comparison)
        await self.db.commit()
        await self.db.refresh(comparison)
        return comparison
    
    async def update_comparison(
        self,
        comparison: Comparison,
        name: str = None,
        symbols: List[str] = None,
        benchmark: str = None,
    ) -> Comparison:
        """更新比較組合"""
        if name is not None:
            comparison.name = name
        if symbols is not None:
            comparison._symbols = json.dumps(symbols)
        if benchmark is not None:
            comparison.benchmark = benchmark
        
        await self.db.commit()
        await self.db.refresh(comparison)
        return comparison
    
    async def delete_comparison(self, comparison: Comparison) -> bool:
        """刪除比較組合"""
        await self.db.delete(comparison)
        await self.db.commit()
        return True
    
    async def count_user_comparisons(self, user_id: int) -> int:
        """計算用戶的比較組合數量"""
        result = await self.db.execute(
            select(Comparison)
            .where(Comparison.user_id == user_id)
        )
        return len(result.scalars().all())


# 單例
compare_service = CompareService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/compare_service_patch.py  ⭐⭐⭐
> compare_service.py 台股名稱修復補丁
──────────────────────────────────────────────────────────────────────

```py
"""
compare_service.py 台股名稱修復補丁

問題位置: _fetch_price_data 方法中的名稱取得邏輯
問題代碼 (約第 7529-7542 行):
    if info:
        info_dict = {
            "name": info.get("name", symbol),  # ⚠️ 這裡直接用 info，會有亂碼
            ...
        }

修復: 台股優先使用 TAIWAN_STOCK_NAMES 字典
"""

# ============================================================
# 步驟 1: 在 compare_service.py 開頭加入導入
# ============================================================
# 找到現有的 import 區塊，在最後加入：

# from app.data_sources.taiwan_stocks import TAIWAN_STOCK_NAMES, is_taiwan_stock


# ============================================================
# 步驟 2: 修改 _fetch_price_data 方法
# ============================================================
# 找到這段代碼 (約在 7529-7542 行):

"""
原始代碼:
                if info:
                    info_dict = {
                        "name": info.get("name", symbol),
                        "type": asset_type,
                        "current_price": current_price or info.get("current_price"),
                        "symbol": symbol,
                    }
                else:
                    info_dict = {
                        "name": symbol, 
                        "type": asset_type, 
                        "current_price": current_price,
                        "symbol": symbol,
                    }
"""

# 替換為:

"""
修復後代碼:
                # ========== 修復: 台股優先使用本地名稱字典 ==========
                name = symbol
                if is_taiwan_stock(symbol):
                    stock_code = symbol.replace('.TW', '').replace('.TWO', '')
                    name = TAIWAN_STOCK_NAMES.get(stock_code, symbol)
                elif info:
                    name = info.get("name", symbol)
                # ================================================
                
                if info:
                    info_dict = {
                        "name": name,  # 使用修復後的名稱
                        "type": asset_type,
                        "current_price": current_price or info.get("current_price"),
                        "symbol": symbol,
                    }
                else:
                    info_dict = {
                        "name": name,  # 使用修復後的名稱
                        "type": asset_type, 
                        "current_price": current_price,
                        "symbol": symbol,
                    }
"""


# ============================================================
# 完整的修復後 _fetch_price_data 方法 (可直接複製替換)
# ============================================================

async def _fetch_price_data(
    self,
    symbol: str,
    days: int = 3650,
):
    """
    抓取價格資料 (修復版 - 解決台股名稱亂碼)
    
    Returns:
        (DataFrame, info_dict) 或 (None, None)
    """
    asset_type = self._get_asset_type(symbol)
    
    try:
        if asset_type == "crypto":
            # 加密貨幣用 CoinGecko
            df = coingecko.get_crypto_history(symbol, days=days)
            info = coingecko.get_crypto_info(symbol)
            if info:
                info_dict = {
                    "name": info.get("name", symbol),
                    "type": "crypto",
                    "current_price": info.get("current_price"),
                }
            else:
                info_dict = {"name": symbol, "type": "crypto", "current_price": None}
            return df, info_dict
        else:
            # 股票/指數/ETF 用 Yahoo Finance
            period = "10y" if days >= 3650 else ("5y" if days >= 1825 else "1y")
            df = yahoo_finance.get_stock_history(symbol, period=period)
            
            # 如果 .TW 找不到，嘗試 .TWO (上櫃股票)
            if (df is None or df.empty) and symbol.endswith('.TW'):
                two_symbol = symbol.replace('.TW', '.TWO')
                logger.info(f"{symbol} 找不到，嘗試上櫃股票: {two_symbol}")
                df = yahoo_finance.get_stock_history(two_symbol, period=period)
                if df is not None and not df.empty:
                    symbol = two_symbol
                    logger.info(f"成功找到上櫃股票: {two_symbol}")
            
            info = yahoo_finance.get_stock_info(symbol)
            
            # 取得現價（用原始收盤價）
            current_price = None
            if df is not None and not df.empty:
                current_price = float(df['close'].iloc[-1])
            
            # ========== 修復: 台股優先使用本地名稱字典 ==========
            name = symbol
            if is_taiwan_stock(symbol):
                stock_code = symbol.replace('.TW', '').replace('.TWO', '')
                name = TAIWAN_STOCK_NAMES.get(stock_code, symbol)
                logger.debug(f"台股名稱修復: {symbol} -> {name}")
            elif info:
                name = info.get("name", symbol)
            # ================================================
            
            if info:
                info_dict = {
                    "name": name,  # 使用修復後的名稱
                    "type": asset_type,
                    "current_price": current_price or info.get("current_price"),
                    "symbol": symbol,
                }
            else:
                info_dict = {
                    "name": name,  # 使用修復後的名稱
                    "type": asset_type, 
                    "current_price": current_price,
                    "symbol": symbol,
                }
            
            return df, info_dict
        
    except Exception as e:
        logger.error(f"抓取 {symbol} 資料失敗: {e}")
        return None, None
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/crypto_service.py  ⭐⭐⭐
> 加密貨幣服務
──────────────────────────────────────────────────────────────────────

```py
"""
加密貨幣服務
整合 CoinGecko 資料、快取和技術指標計算
"""
import pandas as pd
from datetime import datetime, date, timedelta
from typing import Optional, Dict, Any, List
from sqlalchemy.orm import Session
from sqlalchemy import select, and_
import logging

from app.models.crypto_price import CryptoPrice
from app.models.market_sentiment import MarketSentiment
from app.data_sources.coingecko import coingecko
from app.data_sources.fear_greed import fear_greed
from app.services.indicator_service import indicator_service, TrendDirection
from app.config import settings

logger = logging.getLogger(__name__)


class CryptoService:
    """加密貨幣服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def _is_cache_valid(self, symbol: str) -> bool:
        """檢查快取是否有效"""
        today = date.today()
        
        stmt = (
            select(CryptoPrice)
            .where(CryptoPrice.symbol == symbol.upper())
            .order_by(CryptoPrice.date.desc())
            .limit(1)
        )
        result = self.db.execute(stmt).scalar_one_or_none()
        
        if not result:
            return False
        
        # 加密貨幣市場 24/7，檢查更新時間
        if result.updated_at:
            cache_minutes = settings.CRYPTO_DATA_CACHE_MINUTES
            cache_deadline = datetime.now() - timedelta(minutes=cache_minutes)
            if result.updated_at > cache_deadline:
                return True
        
        return False
    
    def _save_prices_to_db(self, df: pd.DataFrame) -> int:
        """儲存價格資料到資料庫"""
        if df is None or df.empty:
            return 0
        
        count = 0
        for _, row in df.iterrows():
            stmt = select(CryptoPrice).where(
                and_(
                    CryptoPrice.symbol == row["symbol"],
                    CryptoPrice.date == row["date"],
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if existing:
                existing.price = row.get("price") or row.get("close")
                existing.volume_24h = row.get("volume_24h")
                existing.market_cap = row.get("market_cap")
            else:
                price = CryptoPrice(
                    symbol=row["symbol"],
                    date=row["date"],
                    price=row.get("price") or row.get("close"),
                    volume_24h=row.get("volume_24h"),
                    market_cap=row.get("market_cap"),
                )
                self.db.add(price)
                count += 1
        
        self.db.commit()
        return count
    
    def _load_prices_from_db(
        self,
        symbol: str,
        days: int = 365,
    ) -> Optional[pd.DataFrame]:
        """從資料庫載入價格資料"""
        start_date = date.today() - timedelta(days=days)
        
        stmt = (
            select(CryptoPrice)
            .where(
                and_(
                    CryptoPrice.symbol == symbol.upper(),
                    CryptoPrice.date >= start_date,
                )
            )
            .order_by(CryptoPrice.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        if not results:
            return None
        
        data = []
        for r in results:
            data.append({
                "symbol": r.symbol,
                "date": r.date,
                "close": float(r.price) if r.price else None,
                "price": float(r.price) if r.price else None,
                "volume": float(r.volume_24h) if r.volume_24h else 0,
                "volume_24h": float(r.volume_24h) if r.volume_24h else None,
                "market_cap": float(r.market_cap) if r.market_cap else None,
                # 加密貨幣沒有 OHLC，用 close 填充
                "open": float(r.price) if r.price else None,
                "high": float(r.price) if r.price else None,
                "low": float(r.price) if r.price else None,
            })
        
        return pd.DataFrame(data)
    
    def fetch_and_cache_crypto(self, symbol: str, days: int = 365) -> bool:
        """抓取加密貨幣資料並快取"""
        df = coingecko.get_market_chart(symbol, days=days)
        if df is None:
            return False
        
        # 轉換欄位名稱以符合資料庫
        df["close"] = df["price"]
        
        self._save_prices_to_db(df)
        return True
    
    def get_crypto_data(
        self,
        symbol: str,
        force_refresh: bool = False,
    ) -> Optional[pd.DataFrame]:
        """取得加密貨幣資料（優先使用快取）"""
        symbol = symbol.upper()
        
        if not coingecko.validate_symbol(symbol):
            logger.warning(f"不支援的加密貨幣: {symbol}")
            return None
        
        # 檢查快取
        if not force_refresh and self._is_cache_valid(symbol):
            logger.info(f"使用快取資料: {symbol}")
            df = self._load_prices_from_db(symbol)
        else:
            logger.info(f"從 CoinGecko 抓取: {symbol}")
            if not self.fetch_and_cache_crypto(symbol):
                df = self._load_prices_from_db(symbol)
                if df is None:
                    return None
            else:
                df = self._load_prices_from_db(symbol)
        
        if df is None or df.empty:
            return None
        
        # 計算技術指標（使用適合加密貨幣的參數）
        df = self._calculate_crypto_indicators(df)
        
        return df
    
    def _calculate_crypto_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """計算加密貨幣技術指標（使用幣圈常用參數）"""
        # 建立幣圈專用的指標服務（使用不同的 MA 週期）
        crypto_indicator = indicator_service.__class__(
            ma_short=7,    # 幣圈短均線
            ma_mid=25,     # 幣圈中均線
            ma_long=99,    # 幣圈長均線
        )
        
        df = crypto_indicator.add_ma_indicators(df)
        df = indicator_service.add_rsi_indicator(df)
        df = indicator_service.add_macd_indicator(df)
        df = indicator_service.add_kd_indicator(df)
        df = indicator_service.add_bollinger_indicator(df)
        
        # 加密貨幣通常沒有真正的成交量資料，跳過 OBV
        if 'volume' in df.columns and df['volume'].sum() > 0:
            df = indicator_service.add_obv_indicator(df)
        
        return df
    
    def get_crypto_analysis(
        self,
        symbol: str,
        force_refresh: bool = False,
    ) -> Optional[Dict[str, Any]]:
        """取得加密貨幣完整分析報告"""
        symbol = symbol.upper()
        
        # 取得資料
        df = self.get_crypto_data(symbol, force_refresh)
        if df is None:
            return None
        
        # 取得詳細資訊
        info = coingecko.get_coin_info(symbol)
        
        # 最新價格
        latest = df.iloc[-1]
        price = float(latest["close"])
        
        # 漲跌幅
        changes = self._calculate_changes(df, info)
        
        # 技術指標
        indicators = self._get_indicators_summary(df, latest)
        
        # 訊號
        signals = indicator_service.get_all_signals(df)
        
        # 評分
        score = indicator_service.calculate_score(df)
        
        return {
            "symbol": symbol,
            "name": info.get("name", symbol) if info else symbol,
            "asset_type": "crypto",
            "price": {
                "current": price,
                "ath": info.get("ath") if info else None,
                "atl": info.get("atl") if info else None,
                "from_ath_pct": info.get("ath_change_percentage") if info else None,
                "high_24h": info.get("high_24h") if info else None,
                "low_24h": info.get("low_24h") if info else None,
            },
            "change": changes,
            "market": {
                "market_cap": info.get("market_cap") if info else None,
                "market_cap_rank": info.get("market_cap_rank") if info else None,
                "volume_24h": info.get("total_volume") if info else None,
                "circulating_supply": info.get("circulating_supply") if info else None,
            },
            "indicators": indicators,
            "signals": [
                {
                    "type": s.type.value,
                    "indicator": s.indicator,
                    "description": s.description,
                }
                for s in signals
            ],
            "score": score,
            "updated_at": datetime.now().isoformat(),
        }
    
    def _calculate_changes(
        self,
        df: pd.DataFrame,
        info: Optional[Dict],
    ) -> Dict[str, float]:
        """計算漲跌幅"""
        changes = {}
        
        # 從 CoinGecko API 取得
        if info:
            changes["day"] = info.get("price_change_percentage_24h")
            changes["week"] = info.get("price_change_percentage_7d")
            changes["month"] = info.get("price_change_percentage_30d")
            changes["year"] = info.get("price_change_percentage_1y")
        
        # 從本地資料計算
        latest_close = df["close"].iloc[-1]
        
        def calc_change(days: int) -> Optional[float]:
            if len(df) <= days:
                return None
            old_close = df["close"].iloc[-(days + 1)]
            if old_close and old_close != 0:
                return round((latest_close - old_close) / old_close * 100, 2)
            return None
        
        # 補充缺失的資料
        if not changes.get("day"):
            changes["day"] = calc_change(1)
        if not changes.get("week"):
            changes["week"] = calc_change(7)
        if not changes.get("month"):
            changes["month"] = calc_change(30)
        
        return changes
    
    def _get_indicators_summary(
        self,
        df: pd.DataFrame,
        latest: pd.Series,
    ) -> Dict[str, Any]:
        """取得指標摘要"""
        price = float(latest["close"])
        
        # MA（幣圈週期）
        ma_info = {
            "ma7": round(latest.get("ma7", 0), 2) if not pd.isna(latest.get("ma7")) else None,
            "ma25": round(latest.get("ma25", 0), 2) if not pd.isna(latest.get("ma25")) else None,
            "ma99": round(latest.get("ma99", 0), 2) if not pd.isna(latest.get("ma99")) else None,
        }
        
        # 判斷均線排列
        ma7 = latest.get("ma7")
        ma25 = latest.get("ma25")
        ma99 = latest.get("ma99")
        
        if not any(pd.isna(x) for x in [ma7, ma25, ma99]):
            if price > ma7 > ma25 > ma99:
                ma_info["alignment"] = "bullish"
            elif price < ma7 < ma25 < ma99:
                ma_info["alignment"] = "bearish"
            else:
                ma_info["alignment"] = "neutral"
        else:
            ma_info["alignment"] = "unknown"
        
        # RSI
        rsi = latest.get("rsi")
        rsi_status, _ = indicator_service.get_rsi_status(rsi)
        rsi_info = {
            "value": round(rsi, 2) if not pd.isna(rsi) else None,
            "status": rsi_status,
        }
        
        # MACD
        macd_dif = latest.get("macd_dif")
        macd_dea = latest.get("macd_dea")
        macd_hist = latest.get("macd_hist")
        macd_info = {
            "dif": round(macd_dif, 4) if not pd.isna(macd_dif) else None,
            "dea": round(macd_dea, 4) if not pd.isna(macd_dea) else None,
            "histogram": round(macd_hist, 4) if not pd.isna(macd_hist) else None,
            "status": "bullish" if macd_hist and macd_hist > 0 else "bearish",
        }
        
        # Bollinger
        bb_upper = latest.get("bb_upper")
        bb_middle = latest.get("bb_middle")
        bb_lower = latest.get("bb_lower")
        bb_info = {
            "upper": round(bb_upper, 2) if not pd.isna(bb_upper) else None,
            "middle": round(bb_middle, 2) if not pd.isna(bb_middle) else None,
            "lower": round(bb_lower, 2) if not pd.isna(bb_lower) else None,
            "position": indicator_service.get_bollinger_position(price, bb_upper, bb_middle, bb_lower),
        }
        
        return {
            "ma": ma_info,
            "rsi": rsi_info,
            "macd": macd_info,
            "bollinger": bb_info,
        }
    
    # ==================== 市場情緒 ====================
    
    def get_market_sentiment(self, market: str = "all") -> Dict[str, Any]:
        """
        取得市場情緒指數
        
        Args:
            market: "stock", "crypto", or "all"
        """
        result = {}
        
        if market in ("all", "stock"):
            stock_sentiment = fear_greed.get_stock_fear_greed()
            if stock_sentiment:
                result["stock"] = stock_sentiment
                # 儲存到資料庫
                self._save_sentiment(stock_sentiment)
        
        if market in ("all", "crypto"):
            crypto_sentiment = fear_greed.get_crypto_fear_greed()
            if crypto_sentiment:
                result["crypto"] = crypto_sentiment
                # 儲存到資料庫
                self._save_sentiment(crypto_sentiment)
        
        return result
    
    def _save_sentiment(self, sentiment_data: Dict[str, Any]):
        """儲存情緒指數到資料庫"""
        try:
            market = sentiment_data.get("market")
            value = sentiment_data.get("value")
            timestamp = sentiment_data.get("timestamp")
            
            if not all([market, value, timestamp]):
                return
            
            sentiment_date = datetime.strptime(timestamp, "%Y-%m-%d").date()
            
            stmt = select(MarketSentiment).where(
                and_(
                    MarketSentiment.market == market,
                    MarketSentiment.date == sentiment_date,
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if existing:
                existing.value = value
                existing.classification = sentiment_data.get("classification")
            else:
                sentiment = MarketSentiment(
                    date=sentiment_date,
                    market=market,
                    value=value,
                    classification=sentiment_data.get("classification"),
                )
                self.db.add(sentiment)
            
            self.db.commit()
        except Exception as e:
            logger.error(f"儲存情緒指數失敗: {e}")
    
    def get_supported_cryptos(self) -> List[Dict[str, str]]:
        """取得支援的加密貨幣列表"""
        from app.data_sources.coingecko import CRYPTO_MAP
        return [
            {"symbol": symbol, "id": coin_id}
            for symbol, coin_id in CRYPTO_MAP.items()
            if symbol not in ("BITCOIN", "ETHEREUM")  # 排除別名
        ]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/exchange_rate_service.py  ⭐⭐⭐
> 匯率服務
──────────────────────────────────────────────────────────────────────

```py
"""
匯率服務
從 Yahoo Finance 抓取 USD/TWD 匯率
"""
import logging
from datetime import datetime
from typing import Optional

import yfinance as yf
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Session

from app.models.portfolio import ExchangeRate

logger = logging.getLogger(__name__)

# 預設匯率
DEFAULT_USD_TWD_RATE = 32.5


def fetch_usd_twd_rate() -> Optional[float]:
    """
    從 Yahoo Finance 抓取 USD/TWD 匯率
    返回 None 表示抓取失敗
    """
    try:
        ticker = yf.Ticker("TWD=X")
        data = ticker.history(period="1d")
        
        if data.empty:
            logger.warning("無法取得 USD/TWD 匯率資料")
            return None
        
        rate = float(data['Close'].iloc[-1])
        logger.info(f"取得 USD/TWD 匯率: {rate:.4f}")
        return rate
        
    except Exception as e:
        logger.error(f"抓取 USD/TWD 匯率失敗: {e}")
        return None


def update_exchange_rate_sync(db: Session) -> float:
    """
    同步更新匯率（供排程使用）
    返回當前匯率
    """
    rate = fetch_usd_twd_rate()
    
    if rate is None:
        # 抓取失敗，使用現有匯率或預設值
        existing = db.query(ExchangeRate).filter_by(
            from_currency="USD",
            to_currency="TWD"
        ).first()
        
        if existing:
            logger.info(f"使用現有匯率: {existing.rate}")
            return existing.rate
        else:
            logger.info(f"使用預設匯率: {DEFAULT_USD_TWD_RATE}")
            return DEFAULT_USD_TWD_RATE
    
    # 更新或新增匯率
    existing = db.query(ExchangeRate).filter_by(
        from_currency="USD",
        to_currency="TWD"
    ).first()
    
    if existing:
        existing.rate = rate
        existing.updated_at = datetime.utcnow()
    else:
        new_rate = ExchangeRate(
            from_currency="USD",
            to_currency="TWD",
            rate=rate,
        )
        db.add(new_rate)
    
    db.commit()
    logger.info(f"匯率已更新: USD/TWD = {rate:.4f}")
    return rate


async def get_exchange_rate(db: AsyncSession) -> dict:
    """
    取得 USD/TWD 匯率
    """
    stmt = select(ExchangeRate).where(
        ExchangeRate.from_currency == "USD",
        ExchangeRate.to_currency == "TWD"
    )
    result = await db.execute(stmt)
    rate_record = result.scalar_one_or_none()
    
    if rate_record:
        return {
            "rate": rate_record.rate,
            "updated_at": rate_record.updated_at.isoformat() if rate_record.updated_at else None,
        }
    else:
        return {
            "rate": DEFAULT_USD_TWD_RATE,
            "updated_at": None,
            "is_default": True,
        }


async def set_exchange_rate(db: AsyncSession, rate: float) -> dict:
    """
    手動設定匯率
    """
    stmt = select(ExchangeRate).where(
        ExchangeRate.from_currency == "USD",
        ExchangeRate.to_currency == "TWD"
    )
    result = await db.execute(stmt)
    rate_record = result.scalar_one_or_none()
    
    if rate_record:
        rate_record.rate = rate
        rate_record.updated_at = datetime.utcnow()
    else:
        rate_record = ExchangeRate(
            from_currency="USD",
            to_currency="TWD",
            rate=rate,
        )
        db.add(rate_record)
    
    await db.commit()
    await db.refresh(rate_record)
    
    return rate_record.to_dict()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/indicator_service.py  ⭐⭐⭐
> 技術指標計算服務
──────────────────────────────────────────────────────────────────────

```py
"""
技術指標計算服務
包含 MA、RSI、MACD、KD、布林通道、OBV 等指標計算
"""
import pandas as pd
import numpy as np
from typing import Dict, Any, Optional, Tuple, List
from dataclasses import dataclass
from enum import Enum

from app.config import settings


class TrendDirection(Enum):
    """趨勢方向"""
    BULLISH = "bullish"      # 多頭
    BEARISH = "bearish"      # 空頭
    NEUTRAL = "neutral"      # 中性


class SignalType(Enum):
    """訊號類型"""
    GOLDEN_CROSS = "golden_cross"      # 黃金交叉
    DEATH_CROSS = "death_cross"        # 死亡交叉
    OVERBOUGHT = "overbought"          # 超買
    OVERSOLD = "oversold"              # 超賣
    BREAKOUT = "breakout"              # 突破
    BREAKDOWN = "breakdown"            # 跌破
    APPROACHING_BREAKOUT = "approaching_breakout"  # 接近突破
    APPROACHING_BREAKDOWN = "approaching_breakdown"  # 接近跌破


@dataclass
class Signal:
    """交易訊號"""
    type: SignalType
    indicator: str
    description: str
    value: Optional[float] = None
    date: Optional[str] = None


class IndicatorService:
    """技術指標計算服務"""
    
    def __init__(
        self,
        ma_short: int = None,
        ma_mid: int = None,
        ma_long: int = None,
        rsi_period: int = None,
        rsi_overbought: int = None,
        rsi_oversold: int = None,
        macd_fast: int = None,
        macd_slow: int = None,
        macd_signal: int = None,
        kd_period: int = None,
        bollinger_period: int = None,
        bollinger_std: float = None,
        breakout_threshold: float = None,
    ):
        """
        初始化指標參數
        若未指定，則使用 config 中的預設值
        """
        self.ma_short = ma_short or settings.MA_SHORT
        self.ma_mid = ma_mid or settings.MA_MID
        self.ma_long = ma_long or settings.MA_LONG
        self.rsi_period = rsi_period or settings.RSI_PERIOD
        self.rsi_overbought = rsi_overbought or settings.RSI_OVERBOUGHT
        self.rsi_oversold = rsi_oversold or settings.RSI_OVERSOLD
        self.macd_fast = macd_fast or settings.MACD_FAST
        self.macd_slow = macd_slow or settings.MACD_SLOW
        self.macd_signal = macd_signal or settings.MACD_SIGNAL
        self.kd_period = kd_period or settings.KD_PERIOD
        self.bollinger_period = bollinger_period or settings.BOLLINGER_PERIOD
        self.bollinger_std = bollinger_std or settings.BOLLINGER_STD
        self.breakout_threshold = breakout_threshold or settings.BREAKOUT_THRESHOLD
    
    # ==================== 移動平均線 (MA) ====================
    
    def calculate_ma(self, df: pd.DataFrame, period: int, column: str = "close") -> pd.Series:
        """計算簡單移動平均線 (SMA)"""
        return df[column].rolling(window=period).mean()
    
    def calculate_ema(self, df: pd.DataFrame, period: int, column: str = "close") -> pd.Series:
        """計算指數移動平均線 (EMA)"""
        return df[column].ewm(span=period, adjust=False).mean()
    
    def add_ma_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        新增移動平均線指標
        
        Returns:
            新增 ma20, ma50, ma200, ma250 欄位的 DataFrame
        """
        df = df.copy()
        df[f"ma{self.ma_short}"] = self.calculate_ma(df, self.ma_short)
        df[f"ma{self.ma_mid}"] = self.calculate_ma(df, self.ma_mid)
        df[f"ma{self.ma_long}"] = self.calculate_ma(df, self.ma_long)
        df["ma250"] = self.calculate_ma(df, 250)  # 添加 MA250
        return df
    
    def get_ma_alignment(self, df: pd.DataFrame) -> Tuple[TrendDirection, str]:
        """
        判斷均線排列
        
        Returns:
            (趨勢方向, 描述)
        """
        if len(df) < self.ma_long:
            return TrendDirection.NEUTRAL, "資料不足"
        
        latest = df.iloc[-1]
        ma_short = latest.get(f"ma{self.ma_short}")
        ma_mid = latest.get(f"ma{self.ma_mid}")
        ma_long = latest.get(f"ma{self.ma_long}")
        price = latest["close"]
        
        if pd.isna(ma_short) or pd.isna(ma_mid) or pd.isna(ma_long):
            return TrendDirection.NEUTRAL, "均線資料不足"
        
        # 多頭排列：價格 > 短均 > 中均 > 長均
        if price > ma_short > ma_mid > ma_long:
            return TrendDirection.BULLISH, "多頭排列"
        
        # 空頭排列：價格 < 短均 < 中均 < 長均
        if price < ma_short < ma_mid < ma_long:
            return TrendDirection.BEARISH, "空頭排列"
        
        return TrendDirection.NEUTRAL, "盤整"
    
    def check_ma_cross(self, df: pd.DataFrame, short_ma: str, long_ma: str) -> Optional[Signal]:
        """
        檢查均線交叉
        
        Args:
            df: 含有均線資料的 DataFrame
            short_ma: 短均線欄位名稱 (如 "ma20")
            long_ma: 長均線欄位名稱 (如 "ma50")
            
        Returns:
            Signal 物件或 None
        """
        if len(df) < 2:
            return None
        
        today = df.iloc[-1]
        yesterday = df.iloc[-2]
        
        short_today = today.get(short_ma)
        short_yesterday = yesterday.get(short_ma)
        long_today = today.get(long_ma)
        long_yesterday = yesterday.get(long_ma)
        
        if any(pd.isna(x) for x in [short_today, short_yesterday, long_today, long_yesterday]):
            return None
        
        # 黃金交叉：短均線由下往上穿越長均線
        if short_yesterday < long_yesterday and short_today > long_today:
            return Signal(
                type=SignalType.GOLDEN_CROSS,
                indicator=f"{short_ma}/{long_ma}",
                description=f"{short_ma.upper()} 黃金交叉 {long_ma.upper()}",
            )
        
        # 死亡交叉：短均線由上往下穿越長均線
        if short_yesterday > long_yesterday and short_today < long_today:
            return Signal(
                type=SignalType.DEATH_CROSS,
                indicator=f"{short_ma}/{long_ma}",
                description=f"{short_ma.upper()} 死亡交叉 {long_ma.upper()}",
            )
        
        return None
    
    def check_price_vs_ma(
        self,
        price: float,
        ma_value: float,
        ma_name: str,
    ) -> Optional[Signal]:
        """
        檢查價格與均線的關係（接近突破/跌破）
        
        Args:
            price: 當前價格
            ma_value: 均線值
            ma_name: 均線名稱 (如 "MA20")
            
        Returns:
            Signal 物件或 None
        """
        if pd.isna(ma_value):
            return None
        
        distance_pct = ((price - ma_value) / ma_value) * 100
        
        # 價格在均線下方，且距離小於門檻 -> 接近向上突破
        if -self.breakout_threshold < distance_pct < 0:
            return Signal(
                type=SignalType.APPROACHING_BREAKOUT,
                indicator=ma_name,
                description=f"接近突破 {ma_name} ({abs(distance_pct):.1f}%)",
                value=distance_pct,
            )
        
        # 價格在均線上方，且距離小於門檻 -> 接近向下跌破
        if 0 < distance_pct < self.breakout_threshold:
            return Signal(
                type=SignalType.APPROACHING_BREAKDOWN,
                indicator=ma_name,
                description=f"接近跌破 {ma_name} ({distance_pct:.1f}%)",
                value=distance_pct,
            )
        
        return None
    
    # ==================== RSI ====================
    
    def calculate_rsi(self, df: pd.DataFrame, period: int = None) -> pd.Series:
        """
        計算 RSI（相對強弱指標）
        
        RSI = 100 - (100 / (1 + RS))
        RS = 平均漲幅 / 平均跌幅
        """
        period = period or self.rsi_period
        
        delta = df["close"].diff()
        gain = delta.where(delta > 0, 0)
        loss = (-delta).where(delta < 0, 0)
        
        avg_gain = gain.rolling(window=period).mean()
        avg_loss = loss.rolling(window=period).mean()
        
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi
    
    def add_rsi_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增 RSI 指標"""
        df = df.copy()
        df["rsi"] = self.calculate_rsi(df)
        return df
    
    def get_rsi_status(self, rsi_value: float) -> Tuple[str, str]:
        """
        取得 RSI 狀態
        
        Returns:
            (狀態, 描述)
        """
        if pd.isna(rsi_value):
            return "unknown", "資料不足"
        
        if rsi_value >= self.rsi_overbought:
            return "overbought", f"超買 ({rsi_value:.1f})"
        elif rsi_value <= self.rsi_oversold:
            return "oversold", f"超賣 ({rsi_value:.1f})"
        else:
            return "neutral", f"中性 ({rsi_value:.1f})"
    
    def check_rsi_signal(self, df: pd.DataFrame) -> Optional[Signal]:
        """檢查 RSI 訊號"""
        if len(df) < 2 or "rsi" not in df.columns:
            return None
        
        rsi_today = df["rsi"].iloc[-1]
        rsi_yesterday = df["rsi"].iloc[-2]
        
        if pd.isna(rsi_today) or pd.isna(rsi_yesterday):
            return None
        
        # 進入超買區
        if rsi_yesterday < self.rsi_overbought <= rsi_today:
            return Signal(
                type=SignalType.OVERBOUGHT,
                indicator="RSI",
                description=f"RSI 進入超買區 ({rsi_today:.1f})",
                value=rsi_today,
            )
        
        # 進入超賣區
        if rsi_yesterday > self.rsi_oversold >= rsi_today:
            return Signal(
                type=SignalType.OVERSOLD,
                indicator="RSI",
                description=f"RSI 進入超賣區 ({rsi_today:.1f})",
                value=rsi_today,
            )
        
        return None
    
    # ==================== MACD ====================
    
    def calculate_macd(self, df: pd.DataFrame) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """
        計算 MACD
        
        Returns:
            (DIF, MACD/DEA, Histogram)
        """
        ema_fast = self.calculate_ema(df, self.macd_fast)
        ema_slow = self.calculate_ema(df, self.macd_slow)
        
        dif = ema_fast - ema_slow
        dea = dif.ewm(span=self.macd_signal, adjust=False).mean()
        histogram = dif - dea
        
        return dif, dea, histogram
    
    def add_macd_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增 MACD 指標"""
        df = df.copy()
        df["macd_dif"], df["macd_dea"], df["macd_hist"] = self.calculate_macd(df)
        return df
    
    def check_macd_signal(self, df: pd.DataFrame) -> Optional[Signal]:
        """檢查 MACD 交叉訊號"""
        if len(df) < 2:
            return None
        
        dif_today = df["macd_dif"].iloc[-1]
        dif_yesterday = df["macd_dif"].iloc[-2]
        dea_today = df["macd_dea"].iloc[-1]
        dea_yesterday = df["macd_dea"].iloc[-2]
        
        if any(pd.isna(x) for x in [dif_today, dif_yesterday, dea_today, dea_yesterday]):
            return None
        
        # 黃金交叉：DIF 由下往上穿越 DEA
        if dif_yesterday < dea_yesterday and dif_today > dea_today:
            position = "零軸上方" if dif_today > 0 else "零軸下方"
            return Signal(
                type=SignalType.GOLDEN_CROSS,
                indicator="MACD",
                description=f"MACD 黃金交叉 ({position})",
                value=dif_today,
            )
        
        # 死亡交叉：DIF 由上往下穿越 DEA
        if dif_yesterday > dea_yesterday and dif_today < dea_today:
            position = "零軸上方" if dif_today > 0 else "零軸下方"
            return Signal(
                type=SignalType.DEATH_CROSS,
                indicator="MACD",
                description=f"MACD 死亡交叉 ({position})",
                value=dif_today,
            )
        
        return None
    
    # ==================== KD ====================
    
    def calculate_kd(self, df: pd.DataFrame) -> Tuple[pd.Series, pd.Series]:
        """
        計算 KD（隨機指標）
        
        RSV = (今日收盤 - N日最低) / (N日最高 - N日最低) × 100
        K = 2/3 × 昨日K + 1/3 × RSV
        D = 2/3 × 昨日D + 1/3 × K
        
        Returns:
            (K, D)
        """
        period = self.kd_period
        
        lowest = df["low"].rolling(window=period).min()
        highest = df["high"].rolling(window=period).max()
        
        rsv = ((df["close"] - lowest) / (highest - lowest)) * 100
        
        # 初始化 K, D
        k = pd.Series(index=df.index, dtype=float)
        d = pd.Series(index=df.index, dtype=float)
        
        # 第一個有效值設為 50
        first_valid = rsv.first_valid_index()
        if first_valid is not None:
            idx = df.index.get_loc(first_valid)
            k.iloc[idx] = 50
            d.iloc[idx] = 50
            
            # 迭代計算
            for i in range(idx + 1, len(df)):
                k.iloc[i] = (2/3) * k.iloc[i-1] + (1/3) * rsv.iloc[i]
                d.iloc[i] = (2/3) * d.iloc[i-1] + (1/3) * k.iloc[i]
        
        return k, d
    
    def add_kd_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增 KD 指標"""
        df = df.copy()
        df["kd_k"], df["kd_d"] = self.calculate_kd(df)
        return df
    
    def check_kd_signal(self, df: pd.DataFrame) -> Optional[Signal]:
        """檢查 KD 交叉訊號"""
        if len(df) < 2:
            return None
        
        k_today = df["kd_k"].iloc[-1]
        k_yesterday = df["kd_k"].iloc[-2]
        d_today = df["kd_d"].iloc[-1]
        d_yesterday = df["kd_d"].iloc[-2]
        
        if any(pd.isna(x) for x in [k_today, k_yesterday, d_today, d_yesterday]):
            return None
        
        # 黃金交叉：K 由下往上穿越 D
        if k_yesterday < d_yesterday and k_today > d_today:
            zone = "超賣區" if k_today < 20 else ("超買區" if k_today > 80 else "中性區")
            return Signal(
                type=SignalType.GOLDEN_CROSS,
                indicator="KD",
                description=f"KD 黃金交叉 ({zone}, K={k_today:.1f})",
                value=k_today,
            )
        
        # 死亡交叉：K 由上往下穿越 D
        if k_yesterday > d_yesterday and k_today < d_today:
            zone = "超賣區" if k_today < 20 else ("超買區" if k_today > 80 else "中性區")
            return Signal(
                type=SignalType.DEATH_CROSS,
                indicator="KD",
                description=f"KD 死亡交叉 ({zone}, K={k_today:.1f})",
                value=k_today,
            )
        
        return None
    
    # ==================== 布林通道 ====================
    
    def calculate_bollinger(self, df: pd.DataFrame) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """
        計算布林通道
        
        Returns:
            (上軌, 中軌, 下軌)
        """
        middle = df["close"].rolling(window=self.bollinger_period).mean()
        std = df["close"].rolling(window=self.bollinger_period).std()
        
        upper = middle + (self.bollinger_std * std)
        lower = middle - (self.bollinger_std * std)
        
        return upper, middle, lower
    
    def add_bollinger_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增布林通道指標"""
        df = df.copy()
        df["bb_upper"], df["bb_middle"], df["bb_lower"] = self.calculate_bollinger(df)
        df["bb_width"] = (df["bb_upper"] - df["bb_lower"]) / df["bb_middle"]
        return df
    
    def get_bollinger_position(self, price: float, upper: float, middle: float, lower: float) -> str:
        """取得價格在布林通道中的位置"""
        if pd.isna(upper) or pd.isna(lower):
            return "unknown"
        
        if price >= upper:
            return "above_upper"
        elif price <= lower:
            return "below_lower"
        elif price >= middle:
            return "upper_half"
        else:
            return "lower_half"
    
    # ==================== OBV ====================
    
    def calculate_obv(self, df: pd.DataFrame) -> pd.Series:
        """
        計算 OBV（能量潮指標）
        
        若今日收盤 > 昨日收盤：OBV = 昨日 OBV + 今日成交量
        若今日收盤 < 昨日收盤：OBV = 昨日 OBV - 今日成交量
        若今日收盤 = 昨日收盤：OBV = 昨日 OBV
        """
        obv = pd.Series(index=df.index, dtype=float)
        obv.iloc[0] = df["volume"].iloc[0]
        
        for i in range(1, len(df)):
            if df["close"].iloc[i] > df["close"].iloc[i-1]:
                obv.iloc[i] = obv.iloc[i-1] + df["volume"].iloc[i]
            elif df["close"].iloc[i] < df["close"].iloc[i-1]:
                obv.iloc[i] = obv.iloc[i-1] - df["volume"].iloc[i]
            else:
                obv.iloc[i] = obv.iloc[i-1]
        
        return obv
    
    def add_obv_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增 OBV 指標"""
        df = df.copy()
        # 檢查是否有 volume 欄位
        if "volume" not in df.columns:
            df["obv"] = None
            return df
        df["obv"] = self.calculate_obv(df)
        return df
    
    def get_obv_trend(self, df: pd.DataFrame, lookback: int = 5) -> str:
        """
        判斷 OBV 趨勢
        
        Args:
            df: 含有 OBV 的 DataFrame
            lookback: 回顧天數
            
        Returns:
            趨勢字串 ("rising", "falling", "flat")
        """
        if "obv" not in df.columns or len(df) < lookback:
            return "unknown"
        
        obv_recent = df["obv"].iloc[-lookback:]
        
        if obv_recent.is_monotonic_increasing:
            return "rising"
        elif obv_recent.is_monotonic_decreasing:
            return "falling"
        else:
            # 比較首尾
            change_pct = (obv_recent.iloc[-1] - obv_recent.iloc[0]) / abs(obv_recent.iloc[0]) * 100
            if change_pct > 5:
                return "rising"
            elif change_pct < -5:
                return "falling"
            else:
                return "flat"
    
    # ==================== 成交量分析 ====================
    
    def calculate_volume_ratio(self, df: pd.DataFrame, ma_period: int = 20) -> pd.Series:
        """計算量比（今日成交量 / N日均量）"""
        avg_volume = df["volume"].rolling(window=ma_period).mean()
        return df["volume"] / avg_volume
    
    def add_volume_indicator(self, df: pd.DataFrame) -> pd.DataFrame:
        """新增成交量指標"""
        df = df.copy()
        # 檢查是否有 volume 欄位
        if "volume" not in df.columns:
            df["volume_ma20"] = None
            df["volume_ratio"] = None
            return df
        df["volume_ma20"] = df["volume"].rolling(window=20).mean()
        df["volume_ratio"] = self.calculate_volume_ratio(df)
        return df
    
    # ==================== 綜合計算 ====================
    
    def calculate_all_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """計算所有技術指標"""
        df = self.add_ma_indicators(df)
        df = self.add_rsi_indicator(df)
        df = self.add_macd_indicator(df)
        df = self.add_kd_indicator(df)
        df = self.add_bollinger_indicator(df)
        df = self.add_obv_indicator(df)
        df = self.add_volume_indicator(df)
        return df
    
    def get_all_signals(self, df: pd.DataFrame) -> List[Signal]:
        """取得所有訊號"""
        signals = []
        
        # MA 交叉
        ma_cross_20_50 = self.check_ma_cross(df, f"ma{self.ma_short}", f"ma{self.ma_mid}")
        if ma_cross_20_50:
            signals.append(ma_cross_20_50)
        
        ma_cross_50_200 = self.check_ma_cross(df, f"ma{self.ma_mid}", f"ma{self.ma_long}")
        if ma_cross_50_200:
            signals.append(ma_cross_50_200)
        
        # RSI
        rsi_signal = self.check_rsi_signal(df)
        if rsi_signal:
            signals.append(rsi_signal)
        
        # MACD
        macd_signal = self.check_macd_signal(df)
        if macd_signal:
            signals.append(macd_signal)
        
        # KD
        kd_signal = self.check_kd_signal(df)
        if kd_signal:
            signals.append(kd_signal)
        
        # 價格接近均線
        if len(df) > 0:
            latest = df.iloc[-1]
            price = latest["close"]
            
            for ma_col in [f"ma{self.ma_short}", f"ma{self.ma_mid}", f"ma{self.ma_long}"]:
                if ma_col in df.columns:
                    signal = self.check_price_vs_ma(price, latest[ma_col], ma_col.upper())
                    if signal:
                        signals.append(signal)
        
        return signals
    
    def calculate_score(self, df: pd.DataFrame) -> Dict[str, Any]:
        """
        計算綜合評分
        
        Returns:
            {
                "buy_score": int,
                "sell_score": int,
                "rating": str,
                "details": list
            }
        """
        buy_score = 0
        sell_score = 0
        details = []
        
        if len(df) < self.ma_long:
            return {
                "buy_score": 0,
                "sell_score": 0,
                "rating": "insufficient_data",
                "details": ["資料不足，無法評分"],
            }
        
        latest = df.iloc[-1]
        
        # 1. 均線排列
        alignment, alignment_desc = self.get_ma_alignment(df)
        if alignment == TrendDirection.BULLISH:
            buy_score += 1
            details.append(f"✅ {alignment_desc}")
        elif alignment == TrendDirection.BEARISH:
            sell_score += 1
            details.append(f"❌ {alignment_desc}")
        
        # 2. RSI
        if "rsi" in df.columns:
            rsi = latest["rsi"]
            if not pd.isna(rsi):
                if rsi <= self.rsi_oversold:
                    buy_score += 1
                    details.append(f"✅ RSI 超賣 ({rsi:.1f})")
                elif rsi >= self.rsi_overbought:
                    sell_score += 1
                    details.append(f"❌ RSI 超買 ({rsi:.1f})")
        
        # 3. MACD
        if "macd_hist" in df.columns and len(df) >= 2:
            hist_today = latest["macd_hist"]
            hist_yesterday = df["macd_hist"].iloc[-2]
            if not pd.isna(hist_today) and not pd.isna(hist_yesterday):
                if hist_today > 0 and hist_today > hist_yesterday:
                    buy_score += 1
                    details.append("✅ MACD 動能增強")
                elif hist_today < 0 and hist_today < hist_yesterday:
                    sell_score += 1
                    details.append("❌ MACD 動能減弱")
        
        # 4. KD
        if "kd_k" in df.columns:
            k = latest["kd_k"]
            d = latest["kd_d"]
            if not pd.isna(k) and not pd.isna(d):
                if k < 20 and k > d:
                    buy_score += 1
                    details.append(f"✅ KD 低檔黃金交叉 (K={k:.1f})")
                elif k > 80 and k < d:
                    sell_score += 1
                    details.append(f"❌ KD 高檔死亡交叉 (K={k:.1f})")
        
        # 5. 布林通道
        if "bb_lower" in df.columns:
            price = latest["close"]
            bb_lower = latest["bb_lower"]
            bb_upper = latest["bb_upper"]
            bb_middle = latest["bb_middle"]
            
            if not pd.isna(bb_lower):
                if price <= bb_lower:
                    buy_score += 1
                    details.append("✅ 觸及布林下軌")
                elif price >= bb_upper:
                    sell_score += 1
                    details.append("❌ 觸及布林上軌")
                elif price < bb_middle and len(df) >= 2:
                    if df["close"].iloc[-2] >= bb_middle:
                        sell_score += 1
                        details.append("❌ 跌破布林中軌")
        
        # 6. 量能
        if "volume_ratio" in df.columns:
            vol_ratio = latest["volume_ratio"]
            if not pd.isna(vol_ratio):
                if vol_ratio >= 2.0:
                    details.append(f"📊 成交量爆增 (量比 {vol_ratio:.1f})")
        
        # 7. OBV
        if "obv" in df.columns:
            obv_trend = self.get_obv_trend(df)
            if obv_trend == "rising":
                buy_score += 1
                details.append("✅ OBV 上升趨勢")
            elif obv_trend == "falling":
                sell_score += 1
                details.append("❌ OBV 下降趨勢")
        
        # 計算評等
        if buy_score >= 5:
            rating = "strong_buy"
        elif buy_score >= 3:
            rating = "buy"
        elif sell_score >= 5:
            rating = "strong_sell"
        elif sell_score >= 3:
            rating = "sell"
        else:
            rating = "neutral"
        
        return {
            "buy_score": buy_score,
            "sell_score": sell_score,
            "rating": rating,
            "details": details,
        }
    
    # ==================== 年化報酬率（CAGR）計算 ====================
    
    def calculate_cagr(
        self,
        df: pd.DataFrame,
        years: float,
    ) -> Optional[float]:
        """
        計算年化複合成長率（CAGR）
        
        公式: CAGR = (終值/初值)^(1/年數) - 1
        
        Args:
            df: 股價 DataFrame（需有 'close' 欄位）
            years: 計算的年數
            
        Returns:
            年化報酬率（百分比），例如 15.5 表示 15.5%
            如果資料不足則返回 None
        """
        if df is None or df.empty:
            return None
        
        # 計算需要的天數（假設一年約 252 個交易日）
        trading_days = int(years * 252)
        
        if len(df) < trading_days:
            return None
        
        try:
            # 取得終值（最新價格）
            end_price = float(df['close'].iloc[-1])
            
            # 取得初值（N年前價格）
            start_price = float(df['close'].iloc[-trading_days])
            
            if start_price <= 0 or end_price <= 0:
                return None
            
            # 計算 CAGR
            cagr = (end_price / start_price) ** (1 / years) - 1
            
            # 轉換為百分比
            return round(cagr * 100, 2)
        except Exception:
            return None
    
    def calculate_all_cagr(
        self,
        df: pd.DataFrame,
    ) -> Dict[str, Optional[float]]:
        """
        計算所有時間範圍的年化報酬率
        
        Returns:
            {
                "cagr_1y": 15.5,   # 1 年年化
                "cagr_3y": 12.3,   # 3 年年化
                "cagr_5y": 18.7,   # 5 年年化
                "cagr_10y": 14.2,  # 10 年年化
            }
        """
        return {
            "cagr_1y": self.calculate_cagr(df, 1),
            "cagr_3y": self.calculate_cagr(df, 3),
            "cagr_5y": self.calculate_cagr(df, 5),
            "cagr_10y": self.calculate_cagr(df, 10),
        }
    
    def calculate_cagr_from_prices(
        self,
        start_price: float,
        end_price: float,
        years: float,
    ) -> Optional[float]:
        """
        從起始和結束價格計算 CAGR
        
        Args:
            start_price: 起始價格
            end_price: 結束價格
            years: 年數
            
        Returns:
            年化報酬率（百分比）
        """
        if start_price <= 0 or end_price <= 0 or years <= 0:
            return None
        
        try:
            cagr = (end_price / start_price) ** (1 / years) - 1
            return round(cagr * 100, 2)
        except Exception:
            return None


# 建立預設實例
indicator_service = IndicatorService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/line_notify_service.py  ⭐⭐⭐
> LINE Messaging API 推播服務
──────────────────────────────────────────────────────────────────────

```py
"""
LINE Messaging API 推播服務
發送技術訊號通知給用戶
"""
import httpx
import logging
from typing import List, Optional, Dict, Any
from datetime import datetime

from app.config import settings

logger = logging.getLogger(__name__)


class LineNotifyService:
    """LINE Messaging API 推播服務"""
    
    PUSH_URL = "https://api.line.me/v2/bot/message/push"
    MULTICAST_URL = "https://api.line.me/v2/bot/message/multicast"
    BROADCAST_URL = "https://api.line.me/v2/bot/message/broadcast"
    
    def __init__(self):
        self.channel_access_token = settings.LINE_MESSAGING_CHANNEL_ACCESS_TOKEN
        self.enabled = bool(self.channel_access_token)
        
        if not self.enabled:
            logger.warning("LINE Messaging API 未設定 Channel Access Token，推播功能停用")
    
    def _get_headers(self) -> Dict[str, str]:
        """取得 API 請求標頭"""
        return {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.channel_access_token}",
        }
    
    async def push_text_message(
        self, 
        user_id: str, 
        message: str
    ) -> bool:
        """
        推送文字訊息給單一用戶
        
        Args:
            user_id: LINE User ID
            message: 訊息內容
            
        Returns:
            是否成功
        """
        if not self.enabled:
            logger.warning("LINE 推播未啟用")
            return False
        
        if not user_id or not message:
            logger.warning("user_id 或 message 為空")
            return False
        
        payload = {
            "to": user_id,
            "messages": [
                {
                    "type": "text",
                    "text": message
                }
            ]
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.PUSH_URL,
                    headers=self._get_headers(),
                    json=payload,
                    timeout=10.0
                )
                
                if response.status_code == 200:
                    logger.info(f"LINE 推播成功: user={user_id[:10]}...")
                    return True
                else:
                    logger.error(f"LINE 推播失敗: {response.status_code} - {response.text}")
                    return False
                    
        except Exception as e:
            logger.error(f"LINE 推播例外: {e}")
            return False
    
    async def push_flex_message(
        self,
        user_id: str,
        alt_text: str,
        flex_content: Dict[str, Any]
    ) -> bool:
        """
        推送 Flex Message 給單一用戶
        
        Args:
            user_id: LINE User ID
            alt_text: 替代文字（手機通知顯示）
            flex_content: Flex Message 內容
            
        Returns:
            是否成功
        """
        if not self.enabled:
            logger.warning("LINE 推播未啟用")
            return False
        
        payload = {
            "to": user_id,
            "messages": [
                {
                    "type": "flex",
                    "altText": alt_text,
                    "contents": flex_content
                }
            ]
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.PUSH_URL,
                    headers=self._get_headers(),
                    json=payload,
                    timeout=10.0
                )
                
                if response.status_code == 200:
                    logger.info(f"LINE Flex 推播成功: user={user_id[:10]}...")
                    return True
                else:
                    logger.error(f"LINE Flex 推播失敗: {response.status_code} - {response.text}")
                    return False
                    
        except Exception as e:
            logger.error(f"LINE Flex 推播例外: {e}")
            return False
    
    async def multicast_text_message(
        self,
        user_ids: List[str],
        message: str
    ) -> bool:
        """
        推送文字訊息給多個用戶（最多 500 人）
        
        Args:
            user_ids: LINE User ID 列表
            message: 訊息內容
            
        Returns:
            是否成功
        """
        if not self.enabled:
            logger.warning("LINE 推播未啟用")
            return False
        
        if not user_ids or not message:
            return False
        
        # LINE API 限制最多 500 人
        if len(user_ids) > 500:
            logger.warning(f"用戶數超過 500，只推送前 500 人")
            user_ids = user_ids[:500]
        
        payload = {
            "to": user_ids,
            "messages": [
                {
                    "type": "text",
                    "text": message
                }
            ]
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.MULTICAST_URL,
                    headers=self._get_headers(),
                    json=payload,
                    timeout=30.0
                )
                
                if response.status_code == 200:
                    logger.info(f"LINE 群發成功: {len(user_ids)} 人")
                    return True
                else:
                    logger.error(f"LINE 群發失敗: {response.status_code} - {response.text}")
                    return False
                    
        except Exception as e:
            logger.error(f"LINE 群發例外: {e}")
            return False
    
    async def broadcast_text_message(self, message: str) -> bool:
        """
        廣播訊息給所有好友
        
        Args:
            message: 訊息內容
            
        Returns:
            是否成功
        """
        if not self.enabled:
            logger.warning("LINE 推播未啟用")
            return False
        
        payload = {
            "messages": [
                {
                    "type": "text",
                    "text": message
                }
            ]
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.BROADCAST_URL,
                    headers=self._get_headers(),
                    json=payload,
                    timeout=30.0
                )
                
                if response.status_code == 200:
                    logger.info("LINE 廣播成功")
                    return True
                else:
                    logger.error(f"LINE 廣播失敗: {response.status_code} - {response.text}")
                    return False
                    
        except Exception as e:
            logger.error(f"LINE 廣播例外: {e}")
            return False
    
    def create_signal_flex_message(
        self,
        symbol: str,
        signals: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        建立訊號通知的 Flex Message
        
        Args:
            symbol: 股票代號
            signals: 訊號列表
            
        Returns:
            Flex Message 內容
        """
        # 訊號顏色對照
        signal_colors = {
            "golden": "#00C853",  # 綠色
            "death": "#FF1744",   # 紅色
            "overbought": "#FF9800",  # 橙色
            "oversold": "#00C853",
            "breakout": "#00C853",
            "breakdown": "#FF1744",
            "surge": "#2196F3",   # 藍色
            "fear": "#FF9800",
            "greed": "#FF1744",
        }
        
        def get_color(signal_type: str) -> str:
            for key, color in signal_colors.items():
                if key in signal_type.lower():
                    return color
            return "#666666"
        
        # 建立訊號列表
        signal_boxes = []
        for s in signals:
            signal_type = s.get("signal_type", "")
            message = s.get("message", "")
            color = get_color(signal_type)
            
            signal_boxes.append({
                "type": "box",
                "layout": "horizontal",
                "contents": [
                    {
                        "type": "text",
                        "text": "●",
                        "size": "sm",
                        "color": color,
                        "flex": 0
                    },
                    {
                        "type": "text",
                        "text": message,
                        "size": "sm",
                        "color": "#333333",
                        "flex": 1,
                        "wrap": True
                    }
                ],
                "margin": "sm"
            })
        
        # Flex Message 結構
        flex_content = {
            "type": "bubble",
            "size": "kilo",
            "header": {
                "type": "box",
                "layout": "vertical",
                "contents": [
                    {
                        "type": "text",
                        "text": f"📊 {symbol}",
                        "weight": "bold",
                        "size": "lg",
                        "color": "#FFFFFF"
                    }
                ],
                "backgroundColor": "#FA7A35",
                "paddingAll": "15px"
            },
            "body": {
                "type": "box",
                "layout": "vertical",
                "contents": signal_boxes,
                "paddingAll": "15px"
            },
            "footer": {
                "type": "box",
                "layout": "vertical",
                "contents": [
                    {
                        "type": "text",
                        "text": datetime.now().strftime("%Y-%m-%d %H:%M"),
                        "size": "xs",
                        "color": "#999999",
                        "align": "end"
                    }
                ],
                "paddingAll": "10px"
            }
        }
        
        return flex_content


# 單例
line_notify_service = LineNotifyService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/market_service.py  ⭐⭐⭐
> 市場服務
──────────────────────────────────────────────────────────────────────

```py
"""
市場服務
處理三大指數、市場情緒的資料存取
"""
import pandas as pd
from datetime import datetime, date, timedelta
from typing import Optional, Dict, Any, List
from sqlalchemy.orm import Session
from sqlalchemy import select, and_, desc
import logging

from app.models.index_price import IndexPrice, INDEX_SYMBOLS
from app.models.market_sentiment import MarketSentiment
from app.models.dividend_history import DividendHistory
from app.models.stock_price import StockPrice
from app.data_sources.yahoo_finance import yahoo_finance
from app.data_sources.fear_greed import fear_greed

logger = logging.getLogger(__name__)


class MarketService:
    """市場服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    # ==================== 三大指數 ====================
    
    def get_latest_indices(self) -> Dict[str, Any]:
        """取得三大指數最新資料，回傳字典格式"""
        result = {}
        
        for symbol, info in INDEX_SYMBOLS.items():
            try:
                stmt = (
                    select(IndexPrice)
                    .where(IndexPrice.symbol == symbol)
                    .order_by(desc(IndexPrice.date))
                    .limit(1)
                )
                latest = self.db.execute(stmt).scalar_one_or_none()
                
                if latest:
                    result[symbol] = latest.to_dict()
                    continue
            except Exception as e:
                logger.warning(f"從資料庫取得 {symbol} 失敗: {e}")
            
            # Fallback: 從 Yahoo Finance API 取得
            try:
                df = yahoo_finance.get_index_data(symbol, period="5d")
                if df is not None and not df.empty:
                    row = df.iloc[-1]
                    result[symbol] = {
                        "symbol": symbol,
                        "name": info["name"],
                        "name_zh": info["name_zh"],
                        "date": str(row["date"]),
                        "close": float(row["close"]),
                        "change": float(row["change"]) if pd.notna(row.get("change")) else None,
                        "change_pct": float(row["change_pct"]) if pd.notna(row.get("change_pct")) else None,
                    }
                    logger.info(f"從 API 取得 {symbol}: {result[symbol]['close']}")
            except Exception as e:
                logger.error(f"從 API 取得 {symbol} 失敗: {e}")
        
        return result
    
    def get_index_history(
        self,
        symbol: str,
        days: int = 365,
    ) -> List[Dict[str, Any]]:
        """取得指數歷史資料"""
        start_date = date.today() - timedelta(days=days)
        
        stmt = (
            select(IndexPrice)
            .where(
                and_(
                    IndexPrice.symbol == symbol,
                    IndexPrice.date >= start_date,
                )
            )
            .order_by(IndexPrice.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        return [r.to_dict() for r in results]
    
    def save_index_data(self, df: pd.DataFrame, symbol: str) -> int:
        """
        儲存指數資料到資料庫
        
        Returns:
            儲存的筆數
        """
        import math
        
        def clean_value(val):
            """清理值，將 NaN/Inf 轉為 None"""
            if val is None:
                return None
            if pd.isna(val):
                return None
            try:
                f = float(val)
                if math.isnan(f) or math.isinf(f):
                    return None
                return f
            except (ValueError, TypeError):
                return None
        
        if df is None or df.empty:
            return 0
        
        count = 0
        index_info = INDEX_SYMBOLS.get(symbol, {})
        
        for _, row in df.iterrows():
            # 檢查是否已存在
            stmt = select(IndexPrice).where(
                and_(
                    IndexPrice.symbol == symbol,
                    IndexPrice.date == row["date"],
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if existing:
                # 更新現有資料
                existing.open = clean_value(row.get("open"))
                existing.high = clean_value(row.get("high"))
                existing.low = clean_value(row.get("low"))
                existing.close = clean_value(row.get("close"))
                existing.volume = row.get("volume")
                existing.change = clean_value(row.get("change"))
                existing.change_pct = clean_value(row.get("change_pct"))
            else:
                # 新增資料
                price = IndexPrice(
                    symbol=symbol,
                    name=index_info.get("name", symbol),
                    date=row["date"],
                    open=clean_value(row.get("open")),
                    high=clean_value(row.get("high")),
                    low=clean_value(row.get("low")),
                    close=clean_value(row.get("close")),
                    volume=row.get("volume"),
                    change=clean_value(row.get("change")),
                    change_pct=clean_value(row.get("change_pct")),
                )
                self.db.add(price)
                count += 1
        
        self.db.commit()
        return count
    
    def fetch_and_save_all_indices(self, period: str = "10y") -> Dict[str, int]:
        """
        抓取並儲存所有三大指數資料
        
        Returns:
            {symbol: 儲存筆數}
        """
        result = {}
        
        for symbol in INDEX_SYMBOLS.keys():
            logger.info(f"抓取指數資料: {symbol}")
            df = yahoo_finance.get_index_data(symbol, period=period)
            
            if df is not None:
                count = self.save_index_data(df, symbol)
                result[symbol] = count
                logger.info(f"{symbol} 新增 {count} 筆資料")
            else:
                result[symbol] = 0
                logger.warning(f"{symbol} 抓取失敗")
        
        return result
    
    # ==================== 市場情緒 ====================
    
    def get_latest_sentiment(self) -> Dict[str, Any]:
        """取得最新的市場情緒"""
        result = {}
        
        for market in ["stock", "crypto"]:
            stmt = (
                select(MarketSentiment)
                .where(MarketSentiment.market == market)
                .order_by(desc(MarketSentiment.date))
                .limit(1)
            )
            latest = self.db.execute(stmt).scalar_one_or_none()
            
            if latest:
                result[market] = latest.to_dict()
            else:
                # 從 API 取得
                if market == "crypto":
                    data = fear_greed.get_crypto_fear_greed()
                else:
                    data = fear_greed.get_stock_fear_greed()
                
                if data:
                    result[market] = data
        
        return result
    
    def get_sentiment_history(
        self,
        market: str,
        days: int = 365,
    ) -> List[Dict[str, Any]]:
        """取得情緒歷史資料"""
        start_date = date.today() - timedelta(days=days)
        
        stmt = (
            select(MarketSentiment)
            .where(
                and_(
                    MarketSentiment.market == market,
                    MarketSentiment.date >= start_date,
                )
            )
            .order_by(MarketSentiment.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        return [r.to_dict() for r in results]
    
    def save_sentiment(
        self,
        market: str,
        value: int,
        target_date: Optional[date] = None,
    ) -> bool:
        """
        儲存市場情緒資料
        """
        if target_date is None:
            target_date = date.today()
        
        # 檢查是否已存在
        stmt = select(MarketSentiment).where(
            and_(
                MarketSentiment.market == market,
                MarketSentiment.date == target_date,
            )
        )
        existing = self.db.execute(stmt).scalar_one_or_none()
        
        classification = MarketSentiment.get_classification(value)
        
        if existing:
            existing.value = value
            existing.classification = classification
        else:
            sentiment = MarketSentiment(
                date=target_date,
                market=market,
                value=value,
                classification=classification,
            )
            self.db.add(sentiment)
        
        self.db.commit()
        return True
    
    def fetch_and_save_crypto_history(self, days: int = 365) -> int:
        """
        抓取並儲存幣圈情緒歷史資料
        
        Returns:
            儲存的筆數
        """
        logger.info(f"抓取幣圈情緒歷史: {days} 天")
        history = fear_greed.get_crypto_fear_greed_history(days)
        
        count = 0
        for item in history:
            try:
                target_date = datetime.strptime(item["date"], "%Y-%m-%d").date()
                
                # 檢查是否已存在
                stmt = select(MarketSentiment).where(
                    and_(
                        MarketSentiment.market == "crypto",
                        MarketSentiment.date == target_date,
                    )
                )
                existing = self.db.execute(stmt).scalar_one_or_none()
                
                if not existing:
                    sentiment = MarketSentiment(
                        date=target_date,
                        market="crypto",
                        value=item["value"],
                        classification=item["classification"],
                    )
                    self.db.add(sentiment)
                    count += 1
            except Exception as e:
                logger.error(f"儲存情緒資料失敗: {e}")
        
        self.db.commit()
        logger.info(f"幣圈情緒歷史新增 {count} 筆")
        return count
    
    def update_today_sentiment(self) -> Dict[str, bool]:
        """
        更新今日的市場情緒
        
        Returns:
            {market: success}
        """
        result = {}
        
        # 美股情緒
        stock_data = fear_greed.get_stock_fear_greed()
        if stock_data and not stock_data.get("is_fallback"):
            result["stock"] = self.save_sentiment("stock", stock_data["value"])
        else:
            result["stock"] = False
        
        # 幣圈情緒
        crypto_data = fear_greed.get_crypto_fear_greed()
        if crypto_data and not crypto_data.get("is_fallback"):
            result["crypto"] = self.save_sentiment("crypto", crypto_data["value"])
        else:
            result["crypto"] = False
        
        return result
    
    # ==================== 配息資料 ====================
    
    def save_dividends(self, df: pd.DataFrame) -> int:
        """
        儲存配息資料
        
        Returns:
            儲存的筆數
        """
        if df is None or df.empty:
            return 0
        
        count = 0
        for _, row in df.iterrows():
            # 檢查是否已存在
            stmt = select(DividendHistory).where(
                and_(
                    DividendHistory.symbol == row["symbol"],
                    DividendHistory.date == row["date"],
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if not existing:
                dividend = DividendHistory(
                    symbol=row["symbol"],
                    date=row["date"],
                    amount=row["amount"],
                )
                self.db.add(dividend)
                count += 1
        
        self.db.commit()
        return count
    
    def fetch_and_save_dividends(self, symbol: str, period: str = "10y") -> int:
        """
        抓取並儲存配息資料
        """
        logger.info(f"抓取配息資料: {symbol}")
        df = yahoo_finance.get_dividends(symbol, period=period)
        
        if df is not None:
            count = self.save_dividends(df)
            logger.info(f"{symbol} 配息新增 {count} 筆")
            return count
        
        return 0
    
    def get_dividends(
        self,
        symbol: str,
        years: int = 10,
    ) -> List[Dict[str, Any]]:
        """取得配息歷史"""
        start_date = date.today() - timedelta(days=years * 365)
        
        stmt = (
            select(DividendHistory)
            .where(
                and_(
                    DividendHistory.symbol == symbol.upper(),
                    DividendHistory.date >= start_date,
                )
            )
            .order_by(DividendHistory.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        return [r.to_dict() for r in results]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/notification_service.py  ⭐⭐⭐
> 通知管理服務
──────────────────────────────────────────────────────────────────────

```py
"""
通知管理服務
整合訊號偵測、通知記錄、LINE 推播
"""
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Set
from sqlalchemy import select, and_, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.user import User
from app.models.watchlist import Watchlist
from app.models.notification import Notification
from app.models.user_settings import UserAlertSettings
from app.services.signal_service import Signal, SignalType, signal_service
from app.services.line_notify_service import line_notify_service
from app.services.indicator_service import indicator_service
from app.data_sources.yahoo_finance import yahoo_finance

logger = logging.getLogger(__name__)


class NotificationService:
    """通知管理服務"""
    
    # 訊號類型與通知設定的對應
    SIGNAL_TO_SETTING = {
        SignalType.MA_GOLDEN_CROSS: "alert_ma_cross",
        SignalType.MA_DEATH_CROSS: "alert_ma_cross",
        SignalType.APPROACHING_BREAKOUT: "alert_ma_breakout",
        SignalType.APPROACHING_BREAKDOWN: "alert_ma_breakout",
        SignalType.BREAKOUT: "alert_ma_breakout",
        SignalType.BREAKDOWN: "alert_ma_breakout",
        SignalType.RSI_OVERBOUGHT: "alert_rsi",
        SignalType.RSI_OVERSOLD: "alert_rsi",
        SignalType.MACD_GOLDEN_CROSS: "alert_macd",
        SignalType.MACD_DEATH_CROSS: "alert_macd",
        SignalType.KD_GOLDEN_CROSS: "alert_kd",
        SignalType.KD_DEATH_CROSS: "alert_kd",
        SignalType.BOLLINGER_BREAKOUT: "alert_bollinger",
        SignalType.BOLLINGER_BREAKDOWN: "alert_bollinger",
        SignalType.VOLUME_SURGE: "alert_volume",
        SignalType.SENTIMENT_EXTREME_FEAR: "alert_sentiment",
        SignalType.SENTIMENT_EXTREME_GREED: "alert_sentiment",
    }
    
    async def get_all_tracked_symbols(self, db: AsyncSession) -> Dict[str, Set[int]]:
        """
        取得所有用戶追蹤的股票（聯集）
        
        Returns:
            {symbol: set(user_ids)} 對應表
        """
        result = await db.execute(
            select(Watchlist.symbol, Watchlist.user_id, Watchlist.asset_type)
            .join(User, Watchlist.user_id == User.id)
            .where(User.is_active == True)
            .where(User.is_blocked == False)
        )
        rows = result.all()
        
        symbol_users = {}
        for symbol, user_id, asset_type in rows:
            key = f"{symbol}|{asset_type}"
            if key not in symbol_users:
                symbol_users[key] = {"symbol": symbol, "asset_type": asset_type, "users": set()}
            symbol_users[key]["users"].add(user_id)
        
        logger.info(f"共 {len(symbol_users)} 個追蹤標的")
        return symbol_users
    
    async def get_user_alert_settings(
        self, 
        db: AsyncSession, 
        user_id: int
    ) -> Dict[str, bool]:
        """取得用戶的通知設定"""
        result = await db.execute(
            select(UserAlertSettings).where(UserAlertSettings.user_id == user_id)
        )
        settings = result.scalar_one_or_none()
        
        if not settings:
            # 使用預設值（全部開啟）
            return {
                "alert_ma_cross": True,
                "alert_ma_breakout": True,
                "alert_rsi": True,
                "alert_macd": True,
                "alert_kd": False,
                "alert_bollinger": False,
                "alert_volume": False,
                "alert_sentiment": True,
            }
        
        return {
            "alert_ma_cross": settings.alert_ma_cross,
            "alert_ma_breakout": settings.alert_ma_breakout,
            "alert_rsi": settings.alert_rsi,
            "alert_macd": settings.alert_macd,
            "alert_kd": settings.alert_kd,
            "alert_bollinger": settings.alert_bollinger,
            "alert_volume": settings.alert_volume,
            "alert_sentiment": settings.alert_sentiment,
        }
    
    async def is_recently_notified(
        self,
        db: AsyncSession,
        user_id: int,
        symbol: str,
        signal_type: str,
        hours: int = 24
    ) -> bool:
        """
        檢查是否最近已通知過（防止重複）
        
        Args:
            user_id: 用戶 ID
            symbol: 股票代號
            signal_type: 訊號類型
            hours: 多少小時內不重複
            
        Returns:
            是否已通知過
        """
        since = datetime.utcnow() - timedelta(hours=hours)
        
        result = await db.execute(
            select(func.count(Notification.id))
            .where(and_(
                Notification.user_id == user_id,
                Notification.symbol == symbol,
                Notification.alert_type == signal_type,
                Notification.triggered_at >= since
            ))
        )
        count = result.scalar()
        return count > 0
    
    async def save_notification(
        self,
        db: AsyncSession,
        user_id: int,
        signal: Signal,
        sent: bool = False
    ) -> Notification:
        """儲存通知記錄"""
        notification = Notification(
            user_id=user_id,
            symbol=signal.symbol,
            asset_type=signal.asset_type,
            alert_type=signal.signal_type.value,
            indicator=signal.indicator,
            message=signal.message,
            price_at_trigger=signal.price if signal.price > 0 else None,
            triggered_at=signal.timestamp,
            sent=sent,
            sent_at=datetime.utcnow() if sent else None,
        )
        db.add(notification)
        await db.commit()
        return notification
    
    async def process_signals_for_user(
        self,
        db: AsyncSession,
        user_id: int,
        line_user_id: str,
        signals: List[Signal]
    ) -> Dict[str, Any]:
        """
        處理用戶的訊號通知
        
        Args:
            db: 資料庫 session
            user_id: 用戶 ID
            line_user_id: LINE User ID
            signals: 訊號列表
            
        Returns:
            處理結果
        """
        if not signals:
            return {"sent": 0, "skipped": 0, "filtered": 0}
        
        # 取得用戶通知設定
        alert_settings = await self.get_user_alert_settings(db, user_id)
        
        sent_count = 0
        skipped_count = 0
        filtered_count = 0
        signals_to_send = []
        
        for signal in signals:
            # 1. 檢查用戶是否開啟此類通知
            setting_key = self.SIGNAL_TO_SETTING.get(signal.signal_type)
            if setting_key and not alert_settings.get(setting_key, True):
                filtered_count += 1
                continue
            
            # 2. 檢查是否最近已通知過
            if await self.is_recently_notified(
                db, user_id, signal.symbol, signal.signal_type.value
            ):
                skipped_count += 1
                continue
            
            signals_to_send.append(signal)
        
        # 3. 發送 LINE 通知
        if signals_to_send and line_user_id:
            # 合併訊息發送
            message = signal_service.format_signals_summary(signals_to_send)
            
            success = await line_notify_service.push_text_message(
                line_user_id, message
            )
            
            # 4. 儲存通知記錄
            for signal in signals_to_send:
                await self.save_notification(db, user_id, signal, sent=success)
                if success:
                    sent_count += 1
        
        return {
            "sent": sent_count,
            "skipped": skipped_count,
            "filtered": filtered_count,
        }
    
    async def run_signal_check(self, db: AsyncSession) -> Dict[str, Any]:
        """
        執行訊號檢查（主要入口）
        
        流程：
        1. 取得所有追蹤的股票
        2. 計算技術指標
        3. 偵測訊號
        4. 根據用戶設定過濾並發送通知
        
        Returns:
            執行結果摘要
        """
        logger.info("=" * 50)
        logger.info("開始執行訊號檢查")
        logger.info("=" * 50)
        
        start_time = datetime.now()
        result = {
            "symbols_checked": 0,
            "signals_detected": 0,
            "notifications_sent": 0,
            "errors": [],
        }
        
        try:
            # 1. 取得所有追蹤的股票
            symbol_users = await self.get_all_tracked_symbols(db)
            
            if not symbol_users:
                logger.info("無追蹤標的，結束檢查")
                return result
            
            all_signals_by_symbol = {}  # {symbol: [signals]}
            
            # 2. 逐一計算指標並偵測訊號
            for key, info in symbol_users.items():
                symbol = info["symbol"]
                asset_type = info["asset_type"]
                
                try:
                    # 取得股價資料
                    if asset_type == "stock":
                        df = yahoo_finance.get_stock_history(symbol, period="6mo")
                    else:
                        # 加密貨幣處理
                        from app.services.crypto_service import crypto_service
                        df = await crypto_service.get_crypto_history(symbol, period="6mo")
                    
                    if df is None or df.empty:
                        logger.warning(f"{symbol} 無法取得資料")
                        continue
                    
                    # 計算技術指標
                    indicators = indicator_service.calculate_all_indicators(df)
                    
                    if not indicators:
                        continue
                    
                    # 偵測訊號
                    signals = signal_service.detect_signals(
                        symbol, indicators, asset_type
                    )
                    
                    if signals:
                        all_signals_by_symbol[key] = {
                            "signals": signals,
                            "users": info["users"],
                        }
                        result["signals_detected"] += len(signals)
                    
                    result["symbols_checked"] += 1
                    
                except Exception as e:
                    logger.error(f"處理 {symbol} 時發生錯誤: {e}")
                    result["errors"].append(f"{symbol}: {str(e)}")
            
            # 3. 發送通知給用戶
            for key, data in all_signals_by_symbol.items():
                signals = data["signals"]
                user_ids = data["users"]
                
                for user_id in user_ids:
                    try:
                        # 取得用戶 LINE ID
                        user_result = await db.execute(
                            select(User).where(User.id == user_id)
                        )
                        user = user_result.scalar_one_or_none()
                        
                        if not user or not user.line_user_id:
                            continue
                        
                        # 處理並發送通知
                        send_result = await self.process_signals_for_user(
                            db, user_id, user.line_user_id, signals
                        )
                        
                        result["notifications_sent"] += send_result["sent"]
                        
                    except Exception as e:
                        logger.error(f"發送通知給用戶 {user_id} 時發生錯誤: {e}")
                        result["errors"].append(f"user_{user_id}: {str(e)}")
            
            # 4. 檢查市場情緒
            try:
                from app.services.market_service import MarketService
                market_service = MarketService()
                sentiment = await market_service.get_current_sentiment()
                
                sentiment_signals = signal_service.detect_sentiment_signals(sentiment)
                
                if sentiment_signals:
                    result["signals_detected"] += len(sentiment_signals)
                    # 情緒訊號發送給所有開啟此通知的用戶
                    # （這裡簡化處理，實際可以更精細控制）
                    logger.info(f"偵測到 {len(sentiment_signals)} 個情緒訊號")
                    
            except Exception as e:
                logger.error(f"檢查市場情緒時發生錯誤: {e}")
            
        except Exception as e:
            logger.error(f"訊號檢查發生嚴重錯誤: {e}", exc_info=True)
            result["errors"].append(f"critical: {str(e)}")
        
        elapsed = (datetime.now() - start_time).total_seconds()
        result["elapsed_seconds"] = round(elapsed, 2)
        
        logger.info(f"訊號檢查完成: {result}")
        return result
    
    async def get_user_notifications(
        self,
        db: AsyncSession,
        user_id: int,
        limit: int = 50,
        unread_only: bool = False
    ) -> List[Dict]:
        """取得用戶的通知歷史"""
        query = select(Notification).where(
            Notification.user_id == user_id
        ).order_by(Notification.triggered_at.desc()).limit(limit)
        
        if unread_only:
            query = query.where(Notification.sent == False)
        
        result = await db.execute(query)
        notifications = result.scalars().all()
        
        return [n.to_dict() for n in notifications]


# 單例
notification_service = NotificationService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/portfolio_service.py  ⭐⭐⭐
> 投資組合業務邏輯服務
──────────────────────────────────────────────────────────────────────

```py
"""
投資組合業務邏輯服務
處理交易紀錄的 CRUD 和持股計算
"""
from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional, Dict, Any
import logging

from sqlalchemy import select, update, delete, func, and_
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.portfolio import PortfolioTransaction, PortfolioHolding, ExchangeRate
from app.models.price_cache import StockPriceCache
from app.services.exchange_rate_service import DEFAULT_USD_TWD_RATE

logger = logging.getLogger(__name__)


class PortfolioService:
    """投資組合服務"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    # ============================================================
    # 交易紀錄 CRUD
    # ============================================================
    
    async def create_transaction(
        self,
        user_id: int,
        symbol: str,
        market: str,
        transaction_type: str,
        quantity: int,
        price: float,
        transaction_date: date,
        name: Optional[str] = None,
        fee: float = 0,
        tax: float = 0,
        note: Optional[str] = None,
    ) -> PortfolioTransaction:
        """新增交易紀錄"""
        
        # 驗證
        if transaction_type not in ("buy", "sell"):
            raise ValueError("transaction_type 必須是 'buy' 或 'sell'")
        if market not in ("tw", "us"):
            raise ValueError("market 必須是 'tw' 或 'us'")
        if quantity <= 0:
            raise ValueError("quantity 必須大於 0")
        if price <= 0:
            raise ValueError("price 必須大於 0")
        
        # 標準化 symbol
        symbol = symbol.upper().strip()
        
        # 建立交易紀錄
        transaction = PortfolioTransaction(
            user_id=user_id,
            symbol=symbol,
            name=name,
            market=market,
            transaction_type=transaction_type,
            quantity=quantity,
            price=Decimal(str(price)),
            fee=Decimal(str(fee)) if fee else Decimal("0"),
            tax=Decimal(str(tax)) if tax else Decimal("0"),
            transaction_date=transaction_date,
            note=note,
        )
        
        self.db.add(transaction)
        await self.db.commit()
        await self.db.refresh(transaction)
        
        logger.info(f"新增交易: user={user_id}, {transaction_type} {quantity} {symbol} @ {price}")
        
        # 更新持股彙總
        await self._update_holding(user_id, symbol, market, name)
        
        return transaction
    
    async def get_transaction(self, transaction_id: int, user_id: int) -> Optional[PortfolioTransaction]:
        """取得單筆交易"""
        stmt = select(PortfolioTransaction).where(
            and_(
                PortfolioTransaction.id == transaction_id,
                PortfolioTransaction.user_id == user_id,
            )
        )
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_transactions(
        self,
        user_id: int,
        market: Optional[str] = None,
        symbol: Optional[str] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[PortfolioTransaction]:
        """取得交易紀錄列表"""
        stmt = select(PortfolioTransaction).where(
            PortfolioTransaction.user_id == user_id
        )
        
        if market:
            stmt = stmt.where(PortfolioTransaction.market == market)
        if symbol:
            stmt = stmt.where(PortfolioTransaction.symbol == symbol.upper())
        
        stmt = stmt.order_by(PortfolioTransaction.transaction_date.desc())
        stmt = stmt.limit(limit).offset(offset)
        
        result = await self.db.execute(stmt)
        return list(result.scalars().all())
    
    async def update_transaction(
        self,
        transaction_id: int,
        user_id: int,
        **kwargs,
    ) -> Optional[PortfolioTransaction]:
        """更新交易紀錄"""
        transaction = await self.get_transaction(transaction_id, user_id)
        if not transaction:
            return None
        
        old_symbol = transaction.symbol
        old_market = transaction.market
        
        # 更新欄位
        allowed_fields = {
            'symbol', 'name', 'market', 'transaction_type',
            'quantity', 'price', 'fee', 'tax', 'transaction_date', 'note'
        }
        
        for key, value in kwargs.items():
            if key in allowed_fields and value is not None:
                if key in ('price', 'fee', 'tax'):
                    value = Decimal(str(value))
                if key == 'symbol':
                    value = value.upper().strip()
                setattr(transaction, key, value)
        
        await self.db.commit()
        await self.db.refresh(transaction)
        
        # 更新持股彙總
        await self._update_holding(user_id, transaction.symbol, transaction.market, transaction.name)
        
        # 如果 symbol 或 market 改變，也要更新舊的
        if old_symbol != transaction.symbol or old_market != transaction.market:
            await self._update_holding(user_id, old_symbol, old_market)
        
        logger.info(f"更新交易: id={transaction_id}")
        return transaction
    
    async def delete_transaction(self, transaction_id: int, user_id: int) -> bool:
        """刪除交易紀錄"""
        transaction = await self.get_transaction(transaction_id, user_id)
        if not transaction:
            return False
        
        symbol = transaction.symbol
        market = transaction.market
        
        await self.db.delete(transaction)
        await self.db.commit()
        
        # 更新持股彙總
        await self._update_holding(user_id, symbol, market)
        
        logger.info(f"刪除交易: id={transaction_id}")
        return True
    
    # ============================================================
    # 持股彙總
    # ============================================================
    
    async def _update_holding(
        self,
        user_id: int,
        symbol: str,
        market: str,
        name: Optional[str] = None,
    ):
        """更新單一股票的持股彙總"""
        
        # 取得該股票的所有交易
        stmt = select(PortfolioTransaction).where(
            and_(
                PortfolioTransaction.user_id == user_id,
                PortfolioTransaction.symbol == symbol,
                PortfolioTransaction.market == market,
            )
        ).order_by(PortfolioTransaction.transaction_date.asc())
        
        result = await self.db.execute(stmt)
        transactions = list(result.scalars().all())
        
        # 計算持股
        total_shares = 0
        total_cost = Decimal("0")
        realized_profit = Decimal("0")
        latest_name = name
        
        for tx in transactions:
            if tx.name:
                latest_name = tx.name
            
            if tx.transaction_type == "buy":
                total_shares += tx.quantity
                total_cost += Decimal(str(tx.quantity)) * tx.price + (tx.fee or Decimal("0"))
            else:  # sell
                if total_shares > 0:
                    # 計算已實現損益（先進先出）
                    avg_cost = total_cost / Decimal(str(total_shares)) if total_shares > 0 else Decimal("0")
                    sell_revenue = Decimal(str(tx.quantity)) * tx.price - (tx.fee or Decimal("0")) - (tx.tax or Decimal("0"))
                    sell_cost = avg_cost * Decimal(str(tx.quantity))
                    realized_profit += sell_revenue - sell_cost
                    
                    # 更新持股和成本
                    total_shares -= tx.quantity
                    total_cost -= sell_cost
                    
                    if total_shares <= 0:
                        total_shares = 0
                        total_cost = Decimal("0")
        
        # 計算平均成本
        avg_cost = total_cost / Decimal(str(total_shares)) if total_shares > 0 else Decimal("0")
        
        # 更新或建立 Holding
        stmt = select(PortfolioHolding).where(
            and_(
                PortfolioHolding.user_id == user_id,
                PortfolioHolding.symbol == symbol,
                PortfolioHolding.market == market,
            )
        )
        result = await self.db.execute(stmt)
        holding = result.scalar_one_or_none()
        
        if total_shares > 0 or realized_profit != 0:
            if holding:
                holding.total_shares = total_shares
                holding.avg_cost = avg_cost
                holding.total_invested = total_cost
                holding.realized_profit = realized_profit
                if latest_name:
                    holding.name = latest_name
            else:
                holding = PortfolioHolding(
                    user_id=user_id,
                    symbol=symbol,
                    name=latest_name,
                    market=market,
                    total_shares=total_shares,
                    avg_cost=avg_cost,
                    total_invested=total_cost,
                    realized_profit=realized_profit,
                )
                self.db.add(holding)
            
            await self.db.commit()
        elif holding:
            # 沒有持股也沒有已實現損益，刪除 Holding
            await self.db.delete(holding)
            await self.db.commit()
    
    async def get_holdings(
        self,
        user_id: int,
        market: Optional[str] = None,
    ) -> List[PortfolioHolding]:
        """取得持股列表"""
        stmt = select(PortfolioHolding).where(
            PortfolioHolding.user_id == user_id
        )
        
        if market:
            stmt = stmt.where(PortfolioHolding.market == market)
        
        stmt = stmt.order_by(PortfolioHolding.symbol)
        
        result = await self.db.execute(stmt)
        return list(result.scalars().all())
    
    async def get_holdings_with_prices(
        self,
        user_id: int,
        market: Optional[str] = None,
    ) -> List[Dict[str, Any]]:
        """取得持股列表（含現價）"""
        holdings = await self.get_holdings(user_id, market)
        
        if not holdings:
            return []
        
        # 取得價格快取
        symbols = [h.symbol for h in holdings]
        cache_stmt = select(StockPriceCache).where(
            StockPriceCache.symbol.in_(symbols)
        )
        cache_result = await self.db.execute(cache_stmt)
        price_cache = {r.symbol: r for r in cache_result.scalars().all()}
        
        # 組合資料
        result = []
        for h in holdings:
            cache = price_cache.get(h.symbol)
            current_price = float(cache.price) if cache and cache.price else None
            
            # 計算未實現損益
            unrealized_profit = None
            unrealized_profit_pct = None
            current_value = None
            
            if current_price and h.total_shares > 0:
                current_value = current_price * h.total_shares
                cost_basis = float(h.avg_cost) * h.total_shares if h.avg_cost else 0
                unrealized_profit = current_value - cost_basis
                if cost_basis > 0:
                    unrealized_profit_pct = (unrealized_profit / cost_basis) * 100
            
            result.append({
                **h.to_dict(),
                "current_price": current_price,
                "current_value": current_value,
                "unrealized_profit": unrealized_profit,
                "unrealized_profit_pct": unrealized_profit_pct,
                "price_change_pct": float(cache.change_pct) if cache and cache.change_pct else None,
            })
        
        return result
    
    async def _get_exchange_rate(self) -> float:
        """取得 USD/TWD 匯率"""
        stmt = select(ExchangeRate).where(
            ExchangeRate.from_currency == "USD",
            ExchangeRate.to_currency == "TWD"
        )
        result = await self.db.execute(stmt)
        rate_record = result.scalar_one_or_none()
        
        return rate_record.rate if rate_record else DEFAULT_USD_TWD_RATE
    
    async def get_summary(self, user_id: int) -> Dict[str, Any]:
        """取得投資摘要（分台股/美股 + 加總）"""
        
        # 取得匯率
        exchange_rate = await self._get_exchange_rate()
        
        # 取得匯率更新時間
        stmt = select(ExchangeRate).where(
            ExchangeRate.from_currency == "USD",
            ExchangeRate.to_currency == "TWD"
        )
        result = await self.db.execute(stmt)
        rate_record = result.scalar_one_or_none()
        rate_updated_at = rate_record.updated_at.isoformat() if rate_record and rate_record.updated_at else None
        
        # 取得台股持股
        tw_holdings = await self.get_holdings_with_prices(user_id, "tw")
        # 取得美股持股
        us_holdings = await self.get_holdings_with_prices(user_id, "us")
        
        # 台股統計
        tw_invested = sum(float(h['total_invested'] or 0) for h in tw_holdings)
        tw_current_value = sum(h['current_value'] or 0 for h in tw_holdings if h['current_value'])
        tw_realized = sum(float(h['realized_profit'] or 0) for h in tw_holdings)
        tw_unrealized = sum(h['unrealized_profit'] or 0 for h in tw_holdings if h['unrealized_profit'])
        tw_positions = len([h for h in tw_holdings if h['total_shares'] > 0])
        
        # 美股統計
        us_invested = sum(float(h['total_invested'] or 0) for h in us_holdings)
        us_current_value = sum(h['current_value'] or 0 for h in us_holdings if h['current_value'])
        us_realized = sum(float(h['realized_profit'] or 0) for h in us_holdings)
        us_unrealized = sum(h['unrealized_profit'] or 0 for h in us_holdings if h['unrealized_profit'])
        us_positions = len([h for h in us_holdings if h['total_shares'] > 0])
        
        # 換算成 TWD 加總
        total_invested_twd = tw_invested + (us_invested * exchange_rate)
        total_current_value_twd = tw_current_value + (us_current_value * exchange_rate)
        total_realized_twd = tw_realized + (us_realized * exchange_rate)
        total_unrealized_twd = tw_unrealized + (us_unrealized * exchange_rate)
        total_profit_twd = total_realized_twd + total_unrealized_twd
        
        # 總報酬率
        total_return_rate = None
        if total_invested_twd > 0:
            total_return_rate = (total_profit_twd / total_invested_twd) * 100
        
        # 台股報酬率
        tw_return_rate = None
        if tw_invested > 0:
            tw_profit = tw_realized + tw_unrealized
            tw_return_rate = (tw_profit / tw_invested) * 100
        
        # 美股報酬率
        us_return_rate = None
        if us_invested > 0:
            us_profit = us_realized + us_unrealized
            us_return_rate = (us_profit / us_invested) * 100
        
        return {
            # 匯率
            "exchange_rate": exchange_rate,
            "exchange_rate_updated_at": rate_updated_at,
            
            # 台股
            "tw": {
                "invested": tw_invested,
                "current_value": tw_current_value,
                "realized_profit": tw_realized,
                "unrealized_profit": tw_unrealized,
                "total_profit": tw_realized + tw_unrealized,
                "return_rate": tw_return_rate,
                "positions": tw_positions,
            },
            
            # 美股
            "us": {
                "invested": us_invested,
                "current_value": us_current_value,
                "realized_profit": us_realized,
                "unrealized_profit": us_unrealized,
                "total_profit": us_realized + us_unrealized,
                "return_rate": us_return_rate,
                "positions": us_positions,
            },
            
            # 加總（TWD）
            "total": {
                "invested_twd": total_invested_twd,
                "current_value_twd": total_current_value_twd,
                "realized_profit_twd": total_realized_twd,
                "unrealized_profit_twd": total_unrealized_twd,
                "total_profit_twd": total_profit_twd,
                "return_rate": total_return_rate,
                "positions": tw_positions + us_positions,
            },
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/price_cache_service.py  ⭐⭐⭐
> 價格快取服務
──────────────────────────────────────────────────────────────────────

```py
"""
價格快取服務
負責批次更新追蹤股票的即時價格

排程邏輯：
- 台股開盤 (09:00-13:30)：每 10 分鐘更新台股
- 美股開盤 (21:30-05:00)：每 10 分鐘更新美股
- 收盤後：不更新（使用收盤價）
- 加密貨幣：24 小時每 10 分鐘更新
"""
import logging
from datetime import datetime, time
from typing import Dict, List, Any
from sqlalchemy.orm import Session
from sqlalchemy import select, distinct
import yfinance as yf

from app.models.price_cache import StockPriceCache
from app.models.watchlist import Watchlist

logger = logging.getLogger(__name__)


# 台股名稱對照（常見的）
TAIWAN_STOCK_NAMES = {
    # ===== 權值股 =====
    "2330": "台積電",
    "2317": "鴻海",
    "2454": "聯發科",
    "2308": "台達電",
    "2412": "中華電",
    "2303": "聯電",
    "2002": "中鋼",
    "1301": "台塑",
    "1303": "南亞",
    "1326": "台化",
    "6505": "台塑化",
    "1101": "台泥",
    "1102": "亞泥",
    "1216": "統一",
    "2207": "和泰車",
    # ===== 金融股 =====
    "2881": "富邦金",
    "2882": "國泰金",
    "2884": "玉山金",
    "2886": "兆豐金",
    "2891": "中信金",
    "2892": "第一金",
    "2880": "華南金",
    "2883": "開發金",
    "2885": "元大金",
    "2887": "台新金",
    "2888": "新光金",
    "2890": "永豐金",
    "5880": "合庫金",
    "5876": "上海商銀",
    # ===== 電子股 =====
    "2912": "統一超",
    "2357": "華碩",
    "2382": "廣達",
    "2395": "研華",
    "3008": "大立光",
    "3711": "日月光投控",
    "2345": "智邦",
    "2379": "瑞昱",
    "2327": "國巨",
    "3034": "聯詠",
    "2301": "光寶科",
    "2408": "南亞科",
    "2474": "可成",
    "3045": "台灣大",
    "4904": "遠傳",
    "3231": "緯創",
    "2356": "英業達",
    "2353": "宏碁",
    "2324": "仁寶",
    "2377": "微星",
    "2376": "技嘉",
    "4938": "和碩",
    "2409": "友達",
    "3481": "群創",
    "6669": "緯穎",
    "3037": "欣興",
    "2344": "華邦電",
    "2337": "旺宏",
    "3443": "創意",
    "6488": "環球晶",
    "5269": "祥碩",
    "6415": "矽力-KY",
    "3661": "世芯-KY",
    "6239": "力成",
    "8046": "南電",
    "3017": "奇鋐",
    "6176": "瑞儀",
    "6285": "啟碁",
    "2492": "華新科",
    "3533": "嘉澤",
    "6531": "愛普",
    "3665": "貿聯-KY",
    "8454": "富邦媒",
    "2383": "台光電",
    "2351": "順德",
    "2354": "鴻準",
    "2360": "致茂",
    "2385": "群光",
    "2388": "威盛",
    "2392": "正崴",
    "2401": "凌陽",
    "2402": "毅嘉",
    # ===== 航運/傳產 =====
    "2603": "長榮",
    "2609": "陽明",
    "2615": "萬海",
    "2618": "長榮航",
    "2610": "華航",
    "2633": "台灣高鐵",
    "9910": "豐泰",
    "9921": "巨大",
    "5871": "中租-KY",
    "9941": "裕融",
    # ===== 生技 =====
    "6446": "藥華藥",
    "6547": "高端疫苗",
    # ===== ETF =====
    "0050": "元大台灣50",
    "0051": "元大中型100",
    "0052": "富邦科技",
    "0053": "元大電子",
    "0055": "元大MSCI金融",
    "0056": "元大高股息",
    "0057": "富邦摩台",
    "006205": "富邦上證",
    "006206": "元大上證50",
    "006208": "富邦台50",
    "00631L": "元大台灣50正2",
    "00632R": "元大台灣50反1",
    "00635U": "元大S&P黃金",
    "00636": "國泰中國A50",
    "00637L": "元大滬深300正2",
    "00639": "富邦深100",
    "00642U": "元大S&P石油",
    "00645": "富邦日本",
    "00646": "元大S&P500",
    "00647L": "元大S&P500正2",
    "00648R": "元大S&P500反1",
    "00650L": "復華香港正2",
    "00655L": "國泰中國A50正2",
    "00657": "國泰日經225",
    "00661": "元大日經225",
    "00662": "富邦NASDAQ",
    "00663L": "國泰臺灣加權正2",
    "00664R": "國泰臺灣加權反1",
    "00668": "國泰美國道瓊",
    "00669R": "國泰美國道瓊反1",
    "00670L": "富邦NASDAQ正2",
    "00675L": "富邦臺灣加權正2",
    "00676R": "富邦臺灣加權反1",
    "00677U": "富邦VIX",
    "00678": "群益NBI生技",
    "00680L": "元大美債20正2",
    "00681R": "元大美債20反1",
    "00682U": "元大美債20年",
    "00690": "兆豐藍籌30",
    "00692": "富邦公司治理",
    "00701": "國泰股利精選30",
    "00713": "元大台灣高息低波",
    "00730": "富邦臺灣優質高息",
    "00733": "富邦臺灣中小",
    "00757": "統一FANG+",
    "00762": "元大全球AI",
    "00770": "國泰北美科技",
    "00850": "元大臺灣ESG永續",
    "00851": "台新全球AI",
    "00852L": "國泰美國費半正2",
    "00875": "國泰網路資安",
    "00876": "元大全球5G",
    "00878": "國泰永續高股息",
    "00881": "國泰台灣5G+",
    "00882": "中信中國高股息",
    "00885": "富邦越南",
    "00886": "元大全球雲端服務",
    "00887": "永豐台灣ESG",
    "00888": "永豐美國費半",
    "00889": "永豐台灣智能車",
    "00891": "中信關鍵半導體",
    "00892": "富邦台灣半導體",
    "00893": "國泰智能電動車",
    "00894": "中信小資高價30",
    "00895": "富邦未來車",
    "00896": "中信綠能電動車",
    "00900": "富邦特選高股息30",
    "00901": "永豐智能車供應鏈",
    "00904": "新光臺灣半導體30",
    "00905": "FT臺灣Smart",
    "00907": "永豐優息存股",
    "00912": "中信臺灣智慧50",
    "00915": "凱基優選高股息30",
    "00916": "國泰全球品牌50",
    "00918": "大華優利高填息30",
    "00919": "群益台灣精選高息",
    "00921": "兆豐龍頭等權重",
    "00922": "國泰台灣領袖50",
    "00923": "群益半導體收益",
    "00929": "復華台灣科技優息",
    "00930": "永豐ESG低碳高息",
    "00931": "統一台灣高息動能",
    "00932": "兆豐永續高息等權",
    "00934": "中信成長高股息",
    "00935": "野村台灣新科技50",
    "00936": "台新臺灣IC設計",
    "00939": "統一台灣高息優選",
    "00940": "元大台灣價值高息",
}



# ============================================================
# 開盤時間判斷（台灣時間）
# ============================================================

def is_tw_market_open() -> bool:
    """判斷台股是否開盤（週一到週五 09:00-13:30）"""
    now = datetime.now()
    if now.weekday() >= 5:
        return False
    return time(9, 0) <= now.time() <= time(13, 30)


def is_us_market_open() -> bool:
    """判斷美股是否開盤（台灣時間 21:30-05:00）"""
    now = datetime.now()
    weekday = now.weekday()
    current_time = now.time()
    
    # 晚上 21:30 後（週一到週五）
    if weekday < 5 and current_time >= time(21, 30):
        return True
    # 凌晨 05:00 前（週二到週六）
    if weekday > 0 and current_time <= time(5, 0):
        return True
    # 週六凌晨
    if weekday == 5 and current_time <= time(5, 0):
        return True
    return False


def get_market_status() -> Dict[str, bool]:
    """取得各市場開盤狀態"""
    return {
        "tw_open": is_tw_market_open(),
        "us_open": is_us_market_open(),
        "crypto_open": True,
    }


# ============================================================
# 價格快取服務
# ============================================================

class PriceCacheService:
    """價格快取服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def get_all_tracked_symbols(self) -> Dict[str, List[str]]:
        """取得所有被追蹤的 symbol（去重，按市場分類）"""
        stmt = select(distinct(Watchlist.symbol), Watchlist.asset_type)
        results = self.db.execute(stmt).all()
        
        tw_stocks = []
        us_stocks = []
        crypto = []
        
        for symbol, asset_type in results:
            if asset_type == "crypto":
                crypto.append(symbol)
            elif symbol.endswith((".TW", ".TWO")):
                tw_stocks.append(symbol)
            else:
                us_stocks.append(symbol)
        
        logger.info(f"追蹤: 台股 {len(tw_stocks)}, 美股 {len(us_stocks)}, 加密貨幣 {len(crypto)}")
        return {"tw_stocks": tw_stocks, "us_stocks": us_stocks, "crypto": crypto}
    
    def batch_update_stock_prices(self, symbols: List[str]) -> Dict[str, Any]:
        """批次更新股票價格（含 MA20）"""
        if not symbols:
            return {"updated": 0, "failed": []}
        
        result = {"updated": 0, "failed": []}
        logger.info(f"開始更新 {len(symbols)} 支股票...")
        
        try:
            # 使用 yfinance 批次取得
            tickers = yf.Tickers(" ".join(symbols))
            
            for symbol in symbols:
                try:
                    ticker = tickers.tickers.get(symbol)
                    if not ticker:
                        result["failed"].append(symbol)
                        continue
                    
                    # 🆕 取得歷史數據（用於計算 MA20）
                    hist = ticker.history(period="1mo")
                    
                    if hist.empty:
                        # 嘗試用 info
                        info = ticker.info
                        if not info:
                            result["failed"].append(symbol)
                            continue
                        
                        price = info.get("regularMarketPrice") or info.get("currentPrice")
                        prev_close = info.get("regularMarketPreviousClose") or info.get("previousClose")
                        volume = info.get("regularMarketVolume") or info.get("volume")
                        name = info.get("shortName") or info.get("longName") or ""
                        ma20 = None
                    else:
                        # 從歷史數據取得
                        price = float(hist['Close'].iloc[-1])
                        prev_close = float(hist['Close'].iloc[-2]) if len(hist) > 1 else None
                        volume = int(hist['Volume'].iloc[-1]) if 'Volume' in hist.columns else None
                        
                        # 🆕 計算 MA20
                        ma20 = None
                        if len(hist) >= 20:
                            ma20 = float(hist['Close'].tail(20).mean())
                        
                        # 取得名稱
                        info = ticker.info
                        name = ""
                        if info:
                            name = info.get("shortName") or info.get("longName") or ""
                    
                    if price is None:
                        result["failed"].append(symbol)
                        continue
                    
                    # 台股名稱
                    if not name and symbol.endswith((".TW", ".TWO")):
                        stock_code = symbol.replace(".TW", "").replace(".TWO", "")
                        name = TAIWAN_STOCK_NAMES.get(stock_code, "")
                    
                    # 計算漲跌
                    change = None
                    change_pct = None
                    if prev_close and prev_close > 0:
                        change = price - prev_close
                        change_pct = (change / prev_close) * 100
                    
                    # 更新快取（含 MA20）
                    self._upsert_cache(
                        symbol=symbol,
                        name=name,
                        price=price,
                        prev_close=prev_close,
                        change=change,
                        change_pct=change_pct,
                        volume=volume,
                        asset_type="stock",
                        ma20=ma20,
                    )
                    result["updated"] += 1
                    
                except Exception as e:
                    logger.error(f"更新 {symbol} 失敗: {e}")
                    result["failed"].append(symbol)
            
            self.db.commit()
            logger.info(f"股票更新完成: 成功 {result['updated']}, 失敗 {len(result['failed'])}")
            
        except Exception as e:
            logger.error(f"批次更新失敗: {e}")
        
        return result
    
    def batch_update_crypto_prices(self, symbols: List[str]) -> Dict[str, Any]:
        """批次更新加密貨幣價格"""
        if not symbols:
            return {"updated": 0, "failed": []}
        
        result = {"updated": 0, "failed": []}
        
        try:
            from app.data_sources.coingecko import coingecko
            
            for symbol in symbols:
                try:
                    data = coingecko.get_price(symbol)
                    if not data or data.get("price") is None:
                        result["failed"].append(symbol)
                        continue
                    
                    self._upsert_cache(
                        symbol=symbol,
                        name=data.get("name", symbol),
                        price=data["price"],
                        prev_close=None,
                        change=None,
                        change_pct=data.get("change_24h"),
                        volume=data.get("volume_24h"),
                        asset_type="crypto",
                        ma20=None,  # 加密貨幣不計算 MA20
                    )
                    result["updated"] += 1
                    
                except Exception as e:
                    logger.error(f"更新 {symbol} 失敗: {e}")
                    result["failed"].append(symbol)
            
            self.db.commit()
            
        except Exception as e:
            logger.error(f"加密貨幣更新失敗: {e}")
        
        return result
    
    def _upsert_cache(self, symbol, name, price, prev_close, change, change_pct, volume, asset_type, ma20=None):
        """更新或新增快取（含 MA20）"""
        cache = self.db.query(StockPriceCache).filter(
            StockPriceCache.symbol == symbol
        ).first()
        
        if cache:
            cache.name = name or cache.name
            cache.price = price
            cache.prev_close = prev_close
            cache.change = change
            cache.change_pct = change_pct
            cache.volume = volume
            if ma20 is not None:
                cache.ma20 = ma20
            cache.updated_at = datetime.now()
        else:
            cache = StockPriceCache(
                symbol=symbol,
                name=name,
                price=price,
                prev_close=prev_close,
                change=change,
                change_pct=change_pct,
                ma20=ma20,
                volume=volume,
                asset_type=asset_type,
            )
            self.db.add(cache)
    
    def update_all(self, force: bool = False) -> Dict[str, Any]:
        """
        更新所有追蹤的價格
        
        - force=True: 強制更新所有
        - force=False: 只更新開盤中的市場
        """
        logger.info("=" * 40)
        logger.info(f"開始更新價格快取 (force={force})")
        logger.info(f"時間: {datetime.now()}")
        
        tw_open = is_tw_market_open()
        us_open = is_us_market_open()
        logger.info(f"台股: {'開盤' if tw_open else '收盤'}, 美股: {'開盤' if us_open else '收盤'}")
        logger.info("=" * 40)
        
        tracked = self.get_all_tracked_symbols()
        
        result = {
            "tw_stocks": {"updated": 0, "failed": [], "skipped": False},
            "us_stocks": {"updated": 0, "failed": [], "skipped": False},
            "crypto": {"updated": 0, "failed": []},
            "timestamp": datetime.now().isoformat(),
        }
        
        # 台股
        if force or tw_open:
            if tracked["tw_stocks"]:
                result["tw_stocks"] = self.batch_update_stock_prices(tracked["tw_stocks"])
        else:
            result["tw_stocks"]["skipped"] = True
        
        # 美股
        if force or us_open:
            if tracked["us_stocks"]:
                result["us_stocks"] = self.batch_update_stock_prices(tracked["us_stocks"])
        else:
            result["us_stocks"]["skipped"] = True
        
        # 加密貨幣（24小時）
        if tracked["crypto"]:
            result["crypto"] = self.batch_update_crypto_prices(tracked["crypto"])
        
        result["total_updated"] = (
            result["tw_stocks"].get("updated", 0) +
            result["us_stocks"].get("updated", 0) +
            result["crypto"].get("updated", 0)
        )
        
        logger.info(f"更新完成: 共 {result['total_updated']} 筆")
        return result
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/rss_fetcher.py  ⭐⭐⭐
> 訂閱源爬蟲服務
──────────────────────────────────────────────────────────────────────

```py
"""
訂閱源爬蟲服務
負責抓取 RSS feed 並解析股票代碼
"""
import re
import logging
import feedparser
from datetime import datetime, timedelta
from typing import List, Dict, Set, Optional
from bs4 import BeautifulSoup
import requests

logger = logging.getLogger(__name__)

# 常見英文詞彙，排除這些（不是股票代碼）
COMMON_WORDS = {
    # 常見詞
    'THE', 'AND', 'FOR', 'ARE', 'BUT', 'NOT', 'YOU', 'ALL', 'CAN', 'HAD',
    'HER', 'WAS', 'ONE', 'OUR', 'OUT', 'HAS', 'HIS', 'HOW', 'ITS', 'MAY',
    'NEW', 'NOW', 'OLD', 'SEE', 'WAY', 'WHO', 'BOY', 'DID', 'GET', 'HIM',
    'LET', 'PUT', 'SAY', 'SHE', 'TOO', 'USE', 'DAY', 'HAS', 'HIM', 'HIS',
    # 金融相關常見詞
    'ETF', 'IPO', 'CEO', 'CFO', 'COO', 'NYSE', 'SEC', 'FED', 'GDP', 'CPI',
    'EPS', 'ROE', 'ROA', 'DCF', 'ATH', 'ATL', 'YOY', 'QOQ', 'MOM', 'TTM',
    'USA', 'USD', 'EUR', 'GBP', 'JPY', 'CNY', 'TWD',
    # 其他
    'AI', 'API', 'AWS', 'CEO', 'CTO', 'FAQ', 'CEO', 'PDF', 'URL', 'RSS',
    'BUY', 'SELL', 'HOLD', 'LONG', 'SHORT',
    # 月份/星期
    'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC',
    'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN',
}

# 已知的有效美股代碼模式（可選：增加白名單）
KNOWN_SYMBOLS = {
    'AAPL', 'MSFT', 'GOOGL', 'GOOG', 'AMZN', 'NVDA', 'META', 'TSLA',
    'BRK', 'UNH', 'JNJ', 'V', 'XOM', 'WMT', 'JPM', 'MA', 'PG', 'HD',
    'CVX', 'MRK', 'ABBV', 'LLY', 'PFE', 'KO', 'PEP', 'COST', 'TMO',
    'AVGO', 'MCD', 'CSCO', 'ACN', 'ABT', 'DHR', 'NKE', 'TXN', 'NEE',
    'PM', 'UNP', 'RTX', 'HON', 'LOW', 'IBM', 'ORCL', 'AMD', 'INTC',
    'QCOM', 'SPGI', 'CAT', 'GE', 'BA', 'SBUX', 'INTU', 'AMAT', 'GS',
    'BLK', 'DE', 'MDLZ', 'AXP', 'ADI', 'ISRG', 'GILD', 'VRTX', 'REGN',
    'BKNG', 'SYK', 'MMC', 'ZTS', 'LRCX', 'ETN', 'CB', 'CI', 'SO',
    'DUK', 'CME', 'PLD', 'BSX', 'CL', 'MO', 'AON', 'APD', 'ICE',
    'SCHW', 'SHW', 'NOC', 'FIS', 'EQIX', 'NSC', 'FCX', 'MCK', 'EMR',
    'PNC', 'GM', 'F', 'RIVN', 'LCID', 'NIO', 'XPEV', 'LI',
    'PLTR', 'SNOW', 'NET', 'DDOG', 'ZS', 'CRWD', 'PANW', 'OKTA',
    'SQ', 'SHOP', 'PYPL', 'COIN', 'HOOD', 'SOFI', 'UPST', 'AFRM',
    'RBLX', 'U', 'TTWO', 'EA', 'ATVI', 'NFLX', 'DIS', 'PARA', 'WBD',
    'ABNB', 'UBER', 'LYFT', 'DASH', 'GRAB', 'SE',
    'ARM', 'SMCI', 'DELL', 'HPQ', 'HPE',
    'CCJ', 'VST', 'LENZ', 'GOOS', 'CAVA', 'QS', 'ONDS',
    # 更多可以持續添加...
}


class RSSFetcher:
    """RSS 爬蟲"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def fetch_feed(self, url: str, since_date: datetime = None) -> List[Dict]:
        """
        抓取 RSS feed
        
        Args:
            url: RSS feed URL
            since_date: 只抓取此日期之後的文章
        
        Returns:
            文章列表 [{title, link, published, content}, ...]
        """
        logger.info(f"抓取 RSS: {url}")
        
        try:
            feed = feedparser.parse(url)
            
            if feed.bozo and feed.bozo_exception:
                logger.warning(f"RSS 解析警告: {feed.bozo_exception}")
            
            articles = []
            for entry in feed.entries:
                # 解析發布日期
                published = None
                if hasattr(entry, 'published_parsed') and entry.published_parsed:
                    published = datetime(*entry.published_parsed[:6])
                elif hasattr(entry, 'updated_parsed') and entry.updated_parsed:
                    published = datetime(*entry.updated_parsed[:6])
                
                # 過濾日期
                if since_date and published and published < since_date:
                    continue
                
                # 取得內容
                content = ""
                if hasattr(entry, 'content') and entry.content:
                    content = entry.content[0].value
                elif hasattr(entry, 'summary'):
                    content = entry.summary
                
                articles.append({
                    'title': entry.get('title', ''),
                    'link': entry.get('link', ''),
                    'published': published,
                    'content': content,
                })
            
            logger.info(f"取得 {len(articles)} 篇文章")
            return articles
            
        except Exception as e:
            logger.error(f"抓取 RSS 失敗: {e}")
            return []
    
    def extract_symbols(self, text: str) -> Set[str]:
        """
        從文章內容提取股票代碼
        
        規則：
        - 1-5 個大寫字母
        - 排除常見英文詞
        - 常見格式：$AAPL, (AAPL), AAPL:
        """
        if not text:
            return set()
        
        # 移除 HTML 標籤
        soup = BeautifulSoup(text, 'html.parser')
        clean_text = soup.get_text()
        
        symbols = set()
        
        # 模式 1: $AAPL 格式（高可信度）
        dollar_pattern = r'\$([A-Z]{1,5})\b'
        for match in re.findall(dollar_pattern, clean_text):
            if match not in COMMON_WORDS:
                symbols.add(match)
        
        # 模式 2: (AAPL) 括號格式（高可信度）
        paren_pattern = r'\(([A-Z]{1,5})\)'
        for match in re.findall(paren_pattern, clean_text):
            if match not in COMMON_WORDS:
                symbols.add(match)
        
        # 模式 3: 獨立的 1-5 大寫字母（需額外過濾）
        # 只抓已知的股票代碼，避免誤判
        word_pattern = r'\b([A-Z]{1,5})\b'
        for match in re.findall(word_pattern, clean_text):
            if match in KNOWN_SYMBOLS:
                symbols.add(match)
        
        return symbols
    
    def fetch_and_parse(self, url: str, since_date: datetime = None) -> List[Dict]:
        """
        抓取並解析，回傳股票代碼列表
        
        Returns:
            [{symbol, article_url, article_title, article_date}, ...]
        """
        articles = self.fetch_feed(url, since_date)
        
        results = []
        for article in articles:
            symbols = self.extract_symbols(article['content'])
            # 標題也找一下
            symbols.update(self.extract_symbols(article['title']))
            
            for symbol in symbols:
                results.append({
                    'symbol': symbol,
                    'article_url': article['link'],
                    'article_title': article['title'],
                    'article_date': article['published'].date() if article['published'] else None,
                })
        
        logger.info(f"解析出 {len(results)} 個股票提及")
        return results


# 單例
rss_fetcher = RSSFetcher()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/signal_service.py  ⭐⭐⭐
> 訊號偵測服務
──────────────────────────────────────────────────────────────────────

```py
"""
訊號偵測服務
偵測技術指標訊號（黃金交叉、死亡交叉、超買超賣等）
"""
import logging
from datetime import datetime, date, timedelta
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)


class SignalType(str, Enum):
    """訊號類型"""
    # 均線
    MA_GOLDEN_CROSS = "ma_golden_cross"
    MA_DEATH_CROSS = "ma_death_cross"
    APPROACHING_BREAKOUT = "approaching_breakout"
    APPROACHING_BREAKDOWN = "approaching_breakdown"
    BREAKOUT = "breakout"
    BREAKDOWN = "breakdown"
    
    # RSI
    RSI_OVERBOUGHT = "rsi_overbought"
    RSI_OVERSOLD = "rsi_oversold"
    
    # MACD
    MACD_GOLDEN_CROSS = "macd_golden_cross"
    MACD_DEATH_CROSS = "macd_death_cross"
    
    # KD
    KD_GOLDEN_CROSS = "kd_golden_cross"
    KD_DEATH_CROSS = "kd_death_cross"
    
    # 布林通道
    BOLLINGER_BREAKOUT = "bollinger_breakout"
    BOLLINGER_BREAKDOWN = "bollinger_breakdown"
    
    # 成交量
    VOLUME_SURGE = "volume_surge"
    
    # 市場情緒
    SENTIMENT_EXTREME_FEAR = "sentiment_extreme_fear"
    SENTIMENT_EXTREME_GREED = "sentiment_extreme_greed"


@dataclass
class Signal:
    """訊號資料"""
    symbol: str
    asset_type: str  # stock / crypto
    signal_type: SignalType
    indicator: str
    message: str
    price: float
    details: Dict[str, Any]
    timestamp: datetime


class SignalService:
    """訊號偵測服務"""
    
    # 訊號類型中文對照
    SIGNAL_NAMES = {
        SignalType.MA_GOLDEN_CROSS: "均線黃金交叉",
        SignalType.MA_DEATH_CROSS: "均線死亡交叉",
        SignalType.APPROACHING_BREAKOUT: "接近向上突破",
        SignalType.APPROACHING_BREAKDOWN: "接近向下跌破",
        SignalType.BREAKOUT: "向上突破",
        SignalType.BREAKDOWN: "向下跌破",
        SignalType.RSI_OVERBOUGHT: "RSI 超買",
        SignalType.RSI_OVERSOLD: "RSI 超賣",
        SignalType.MACD_GOLDEN_CROSS: "MACD 黃金交叉",
        SignalType.MACD_DEATH_CROSS: "MACD 死亡交叉",
        SignalType.KD_GOLDEN_CROSS: "KD 黃金交叉",
        SignalType.KD_DEATH_CROSS: "KD 死亡交叉",
        SignalType.BOLLINGER_BREAKOUT: "突破布林上軌",
        SignalType.BOLLINGER_BREAKDOWN: "跌破布林下軌",
        SignalType.VOLUME_SURGE: "成交量暴增",
        SignalType.SENTIMENT_EXTREME_FEAR: "極度恐懼",
        SignalType.SENTIMENT_EXTREME_GREED: "極度貪婪",
    }
    
    # 訊號 Emoji
    SIGNAL_EMOJI = {
        SignalType.MA_GOLDEN_CROSS: "🟢",
        SignalType.MA_DEATH_CROSS: "🔴",
        SignalType.APPROACHING_BREAKOUT: "⬆️",
        SignalType.APPROACHING_BREAKDOWN: "⬇️",
        SignalType.BREAKOUT: "✅",
        SignalType.BREAKDOWN: "❌",
        SignalType.RSI_OVERBOUGHT: "⚠️",
        SignalType.RSI_OVERSOLD: "🟢",
        SignalType.MACD_GOLDEN_CROSS: "🟢",
        SignalType.MACD_DEATH_CROSS: "🔴",
        SignalType.KD_GOLDEN_CROSS: "🟢",
        SignalType.KD_DEATH_CROSS: "🔴",
        SignalType.BOLLINGER_BREAKOUT: "📈",
        SignalType.BOLLINGER_BREAKDOWN: "📉",
        SignalType.VOLUME_SURGE: "📊",
        SignalType.SENTIMENT_EXTREME_FEAR: "😱",
        SignalType.SENTIMENT_EXTREME_GREED: "🤑",
    }
    
    def __init__(self):
        # 預設參數（可被用戶設定覆蓋）
        self.default_params = {
            "ma_short": 20,
            "ma_mid": 50,
            "ma_long": 200,
            "rsi_period": 14,
            "rsi_overbought": 70,
            "rsi_oversold": 30,
            "macd_fast": 12,
            "macd_slow": 26,
            "macd_signal": 9,
            "kd_period": 9,
            "bollinger_period": 20,
            "bollinger_std": 2.0,
            "breakout_threshold": 2.0,  # 接近突破門檻 (%)
            "volume_alert_ratio": 2.0,  # 量比警戒倍數
        }
    
    def detect_signals(
        self, 
        symbol: str, 
        indicators: Dict[str, Any],
        asset_type: str = "stock",
        params: Optional[Dict] = None
    ) -> List[Signal]:
        """
        偵測股票/加密貨幣的技術指標訊號
        
        Args:
            symbol: 股票/幣種代號
            indicators: 技術指標資料（來自 indicator_service）
            asset_type: stock / crypto
            params: 用戶自訂參數（可選）
            
        Returns:
            偵測到的訊號列表
        """
        signals = []
        p = {**self.default_params, **(params or {})}
        
        current_price = indicators.get("current_price", 0)
        if not current_price:
            logger.warning(f"{symbol} 無法取得現價")
            return signals
        
        now = datetime.now()
        
        # 1. 均線訊號
        ma_signals = self._detect_ma_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(ma_signals)
        
        # 2. RSI 訊號
        rsi_signals = self._detect_rsi_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(rsi_signals)
        
        # 3. MACD 訊號
        macd_signals = self._detect_macd_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(macd_signals)
        
        # 4. KD 訊號
        kd_signals = self._detect_kd_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(kd_signals)
        
        # 5. 布林通道訊號
        bb_signals = self._detect_bollinger_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(bb_signals)
        
        # 6. 成交量訊號
        vol_signals = self._detect_volume_signals(symbol, indicators, current_price, p, now, asset_type)
        signals.extend(vol_signals)
        
        logger.info(f"{symbol} 偵測到 {len(signals)} 個訊號")
        return signals
    
    def _detect_ma_signals(
        self, symbol: str, indicators: Dict, price: float, 
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測均線訊號"""
        signals = []
        ma = indicators.get("ma", {})
        
        if not ma:
            return signals
        
        ma20 = ma.get("ma20")
        ma50 = ma.get("ma50")
        ma200 = ma.get("ma200")
        
        # 均線交叉（需要有前一日資料才能判斷，這裡簡化為檢查當前狀態）
        # 實際上需要比較昨日和今日的 MA 值
        
        # 接近突破/跌破檢測
        threshold_pct = params["breakout_threshold"] / 100
        
        for ma_name, ma_value in [("MA20", ma20), ("MA50", ma50), ("MA200", ma200)]:
            if ma_value is None or ma_value <= 0:
                continue
            
            diff_pct = (price - ma_value) / ma_value
            
            # 接近向上突破（價格在均線下方，差距小於門檻）
            if -threshold_pct < diff_pct < 0:
                signals.append(Signal(
                    symbol=symbol,
                    asset_type=asset_type,
                    signal_type=SignalType.APPROACHING_BREAKOUT,
                    indicator=ma_name,
                    message=f"{symbol} 接近突破 {ma_name} ({ma_value:.2f})，差距 {abs(diff_pct)*100:.1f}%",
                    price=price,
                    details={"ma_name": ma_name, "ma_value": ma_value, "diff_pct": diff_pct},
                    timestamp=now,
                ))
            
            # 接近向下跌破（價格在均線上方，差距小於門檻）
            elif 0 < diff_pct < threshold_pct:
                signals.append(Signal(
                    symbol=symbol,
                    asset_type=asset_type,
                    signal_type=SignalType.APPROACHING_BREAKDOWN,
                    indicator=ma_name,
                    message=f"{symbol} 接近跌破 {ma_name} ({ma_value:.2f})，差距 {diff_pct*100:.1f}%",
                    price=price,
                    details={"ma_name": ma_name, "ma_value": ma_value, "diff_pct": diff_pct},
                    timestamp=now,
                ))
        
        # 黃金交叉/死亡交叉（MA20 vs MA50）
        if ma20 and ma50:
            cross_info = ma.get("cross_info", {})
            if cross_info.get("type") == "golden_cross" and cross_info.get("days_ago", 999) <= 3:
                signals.append(Signal(
                    symbol=symbol,
                    asset_type=asset_type,
                    signal_type=SignalType.MA_GOLDEN_CROSS,
                    indicator="MA20/MA50",
                    message=f"{symbol} MA20 黃金交叉 MA50",
                    price=price,
                    details={"ma20": ma20, "ma50": ma50},
                    timestamp=now,
                ))
            elif cross_info.get("type") == "death_cross" and cross_info.get("days_ago", 999) <= 3:
                signals.append(Signal(
                    symbol=symbol,
                    asset_type=asset_type,
                    signal_type=SignalType.MA_DEATH_CROSS,
                    indicator="MA20/MA50",
                    message=f"{symbol} MA20 死亡交叉 MA50",
                    price=price,
                    details={"ma20": ma20, "ma50": ma50},
                    timestamp=now,
                ))
        
        return signals
    
    def _detect_rsi_signals(
        self, symbol: str, indicators: Dict, price: float,
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測 RSI 訊號"""
        signals = []
        rsi_data = indicators.get("rsi", {})
        
        if not rsi_data:
            return signals
        
        rsi_value = rsi_data.get("value")
        if rsi_value is None:
            return signals
        
        overbought = params["rsi_overbought"]
        oversold = params["rsi_oversold"]
        
        if rsi_value >= overbought:
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.RSI_OVERBOUGHT,
                indicator="RSI",
                message=f"{symbol} RSI 達 {rsi_value:.1f}，進入超買區",
                price=price,
                details={"rsi": rsi_value, "threshold": overbought},
                timestamp=now,
            ))
        elif rsi_value <= oversold:
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.RSI_OVERSOLD,
                indicator="RSI",
                message=f"{symbol} RSI 跌至 {rsi_value:.1f}，進入超賣區",
                price=price,
                details={"rsi": rsi_value, "threshold": oversold},
                timestamp=now,
            ))
        
        return signals
    
    def _detect_macd_signals(
        self, symbol: str, indicators: Dict, price: float,
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測 MACD 訊號"""
        signals = []
        macd_data = indicators.get("macd", {})
        
        if not macd_data:
            return signals
        
        dif = macd_data.get("dif")
        macd = macd_data.get("macd")
        histogram = macd_data.get("histogram")
        status = macd_data.get("status", "")
        
        # 根據 status 判斷（indicator_service 已經計算好）
        if "golden_cross" in status.lower() or status == "bullish_cross":
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.MACD_GOLDEN_CROSS,
                indicator="MACD",
                message=f"{symbol} MACD 黃金交叉",
                price=price,
                details={"dif": dif, "macd": macd, "histogram": histogram},
                timestamp=now,
            ))
        elif "death_cross" in status.lower() or status == "bearish_cross":
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.MACD_DEATH_CROSS,
                indicator="MACD",
                message=f"{symbol} MACD 死亡交叉",
                price=price,
                details={"dif": dif, "macd": macd, "histogram": histogram},
                timestamp=now,
            ))
        
        return signals
    
    def _detect_kd_signals(
        self, symbol: str, indicators: Dict, price: float,
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測 KD 訊號"""
        signals = []
        kd_data = indicators.get("kd", {})
        
        if not kd_data:
            return signals
        
        k = kd_data.get("k")
        d = kd_data.get("d")
        status = kd_data.get("status", "")
        
        # KD 交叉
        if "golden" in status.lower():
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.KD_GOLDEN_CROSS,
                indicator="KD",
                message=f"{symbol} KD 黃金交叉 (K={k:.1f}, D={d:.1f})",
                price=price,
                details={"k": k, "d": d},
                timestamp=now,
            ))
        elif "death" in status.lower():
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.KD_DEATH_CROSS,
                indicator="KD",
                message=f"{symbol} KD 死亡交叉 (K={k:.1f}, D={d:.1f})",
                price=price,
                details={"k": k, "d": d},
                timestamp=now,
            ))
        
        return signals
    
    def _detect_bollinger_signals(
        self, symbol: str, indicators: Dict, price: float,
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測布林通道訊號"""
        signals = []
        bb_data = indicators.get("bollinger", {})
        
        if not bb_data:
            return signals
        
        upper = bb_data.get("upper")
        lower = bb_data.get("lower")
        position = bb_data.get("position", "")
        
        if upper and price >= upper:
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.BOLLINGER_BREAKOUT,
                indicator="Bollinger",
                message=f"{symbol} 突破布林上軌 ({upper:.2f})",
                price=price,
                details={"upper": upper, "lower": lower, "price": price},
                timestamp=now,
            ))
        elif lower and price <= lower:
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.BOLLINGER_BREAKDOWN,
                indicator="Bollinger",
                message=f"{symbol} 跌破布林下軌 ({lower:.2f})",
                price=price,
                details={"upper": upper, "lower": lower, "price": price},
                timestamp=now,
            ))
        
        return signals
    
    def _detect_volume_signals(
        self, symbol: str, indicators: Dict, price: float,
        params: Dict, now: datetime, asset_type: str
    ) -> List[Signal]:
        """偵測成交量訊號"""
        signals = []
        vol_data = indicators.get("volume", {})
        
        if not vol_data:
            return signals
        
        ratio = vol_data.get("ratio")
        alert_ratio = params["volume_alert_ratio"]
        
        if ratio and ratio >= alert_ratio:
            signals.append(Signal(
                symbol=symbol,
                asset_type=asset_type,
                signal_type=SignalType.VOLUME_SURGE,
                indicator="Volume",
                message=f"{symbol} 成交量暴增 (量比 {ratio:.1f})",
                price=price,
                details={"ratio": ratio, "threshold": alert_ratio},
                timestamp=now,
            ))
        
        return signals
    
    def detect_sentiment_signals(
        self, sentiment_data: Dict[str, Any]
    ) -> List[Signal]:
        """
        偵測市場情緒訊號
        
        Args:
            sentiment_data: 情緒資料 {"stock": {...}, "crypto": {...}}
            
        Returns:
            偵測到的訊號列表
        """
        signals = []
        now = datetime.now()
        
        for market, data in sentiment_data.items():
            if not data:
                continue
            
            value = data.get("value")
            if value is None:
                continue
            
            asset_type = "stock" if market == "stock" else "crypto"
            market_name = "美股" if market == "stock" else "幣圈"
            
            if value <= 20:
                signals.append(Signal(
                    symbol=market_name,
                    asset_type=asset_type,
                    signal_type=SignalType.SENTIMENT_EXTREME_FEAR,
                    indicator="Fear & Greed",
                    message=f"{market_name}極度恐懼 ({value})，留意買入機會",
                    price=0,
                    details={"value": value, "classification": data.get("classification")},
                    timestamp=now,
                ))
            elif value >= 80:
                signals.append(Signal(
                    symbol=market_name,
                    asset_type=asset_type,
                    signal_type=SignalType.SENTIMENT_EXTREME_GREED,
                    indicator="Fear & Greed",
                    message=f"{market_name}極度貪婪 ({value})，留意風險",
                    price=0,
                    details={"value": value, "classification": data.get("classification")},
                    timestamp=now,
                ))
        
        return signals
    
    def format_signal_message(self, signal: Signal) -> str:
        """格式化訊號訊息（用於 LINE 推播）"""
        emoji = self.SIGNAL_EMOJI.get(signal.signal_type, "📢")
        return f"{emoji} {signal.message}"
    
    def format_signals_summary(self, signals: List[Signal]) -> str:
        """
        格式化多個訊號為摘要訊息
        
        Args:
            signals: 訊號列表
            
        Returns:
            格式化的訊息文字
        """
        if not signals:
            return ""
        
        # 按股票分組
        by_symbol = {}
        for s in signals:
            if s.symbol not in by_symbol:
                by_symbol[s.symbol] = []
            by_symbol[s.symbol].append(s)
        
        lines = ["📊 技術訊號通知", ""]
        
        for symbol, symbol_signals in by_symbol.items():
            lines.append(f"【{symbol}】")
            for s in symbol_signals:
                emoji = self.SIGNAL_EMOJI.get(s.signal_type, "•")
                name = self.SIGNAL_NAMES.get(s.signal_type, str(s.signal_type))
                if s.price > 0:
                    lines.append(f"  {emoji} {name} @ ${s.price:.2f}")
                else:
                    lines.append(f"  {emoji} {s.message}")
            lines.append("")
        
        lines.append(f"⏰ {datetime.now().strftime('%Y-%m-%d %H:%M')}")
        
        return "\n".join(lines)


# 單例
signal_service = SignalService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/stock_service.py  ⭐⭐⭐
> 股票服務
──────────────────────────────────────────────────────────────────────

```py
"""
股票服務
整合資料抓取、快取和技術指標計算
"""
import pandas as pd
from datetime import datetime, date, timedelta
from typing import Optional, Dict, Any, List
from sqlalchemy.orm import Session
from sqlalchemy import select, and_
import logging

from app.models.stock_price import StockPrice
from app.data_sources.yahoo_finance import yahoo_finance
from app.services.indicator_service import indicator_service, TrendDirection
from app.config import settings

logger = logging.getLogger(__name__)


class StockService:
    """股票服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def _is_cache_valid(self, symbol: str) -> bool:
        """
        檢查快取是否有效
        
        規則：
        1. 有今日資料
        2. 或是週末/假日時有最近交易日資料
        """
        today = date.today()
        
        # 查詢最新資料
        stmt = (
            select(StockPrice)
            .where(StockPrice.symbol == symbol.upper())
            .order_by(StockPrice.date.desc())
            .limit(1)
        )
        result = self.db.execute(stmt).scalar_one_or_none()
        
        if not result:
            return False
        
        # 如果有今日資料，快取有效
        if result.date == today:
            return True
        
        # 檢查是否為週末
        if today.weekday() >= 5:  # 週六=5, 週日=6
            # 週末時，只要有週五的資料就算有效
            friday = today - timedelta(days=(today.weekday() - 4))
            if result.date >= friday:
                return True
        
        # 檢查更新時間是否在快取時間內
        if result.updated_at:
            cache_hours = settings.STOCK_DATA_CACHE_HOURS
            cache_deadline = datetime.now() - timedelta(hours=cache_hours)
            if result.updated_at > cache_deadline:
                return True
        
        return False
    
    def _save_prices_to_db(self, df: pd.DataFrame) -> int:
        """
        儲存價格資料到資料庫
        
        Returns:
            儲存的筆數
        """
        if df is None or df.empty:
            return 0
        
        count = 0
        for _, row in df.iterrows():
            # 檢查是否已存在
            stmt = select(StockPrice).where(
                and_(
                    StockPrice.symbol == row["symbol"],
                    StockPrice.date == row["date"],
                )
            )
            existing = self.db.execute(stmt).scalar_one_or_none()
            
            if existing:
                # 更新現有資料
                existing.open = row["open"]
                existing.high = row["high"]
                existing.low = row["low"]
                existing.close = row["close"]
                existing.volume = row["volume"]
            else:
                # 新增資料
                price = StockPrice(
                    symbol=row["symbol"],
                    date=row["date"],
                    open=row["open"],
                    high=row["high"],
                    low=row["low"],
                    close=row["close"],
                    volume=row["volume"],
                )
                self.db.add(price)
                count += 1
        
        self.db.commit()
        return count
    
    def _load_prices_from_db(
        self,
        symbol: str,
        days: int = 365,
    ) -> Optional[pd.DataFrame]:
        """從資料庫載入價格資料"""
        start_date = date.today() - timedelta(days=days)
        
        stmt = (
            select(StockPrice)
            .where(
                and_(
                    StockPrice.symbol == symbol.upper(),
                    StockPrice.date >= start_date,
                )
            )
            .order_by(StockPrice.date)
        )
        results = self.db.execute(stmt).scalars().all()
        
        if not results:
            return None
        
        data = []
        for r in results:
            data.append({
                "symbol": r.symbol,
                "date": r.date,
                "open": float(r.open) if r.open else None,
                "high": float(r.high) if r.high else None,
                "low": float(r.low) if r.low else None,
                "close": float(r.close) if r.close else None,
                "volume": r.volume,
            })
        
        return pd.DataFrame(data)
    
    def fetch_and_cache_stock(self, symbol: str, period: str = "1y") -> bool:
        """
        抓取股票資料並快取
        
        Returns:
            是否成功
        """
        df = yahoo_finance.get_stock_history(symbol, period=period)
        if df is None:
            return False
        
        self._save_prices_to_db(df)
        return True
    
    def get_stock_data(
        self,
        symbol: str,
        force_refresh: bool = False,
    ) -> Optional[pd.DataFrame]:
        """
        取得股票資料（優先使用快取）
        
        Args:
            symbol: 股票代號
            force_refresh: 是否強制更新
            
        Returns:
            包含價格和技術指標的 DataFrame
        """
        symbol = symbol.upper()
        
        # 檢查快取
        if not force_refresh and self._is_cache_valid(symbol):
            logger.info(f"使用快取資料: {symbol}")
            df = self._load_prices_from_db(symbol)
        else:
            # 從 Yahoo Finance 抓取
            logger.info(f"從 Yahoo Finance 抓取: {symbol}")
            if not self.fetch_and_cache_stock(symbol):
                # 抓取失敗，嘗試使用舊的快取
                df = self._load_prices_from_db(symbol)
                if df is None:
                    return None
            else:
                df = self._load_prices_from_db(symbol)
        
        if df is None or df.empty:
            return None
        
        # 計算技術指標
        df = indicator_service.calculate_all_indicators(df)
        
        return df
    
    def get_stock_analysis(
        self,
        symbol: str,
        force_refresh: bool = False,
    ) -> Optional[Dict[str, Any]]:
        """
        取得股票完整分析報告
        
        Returns:
            分析報告字典
        """
        symbol = symbol.upper()
        
        # 取得資料
        df = self.get_stock_data(symbol, force_refresh)
        if df is None:
            return None
        
        # 取得股票基本資訊
        info = yahoo_finance.get_stock_info(symbol)
        
        # 最新價格資料
        latest = df.iloc[-1]
        price = float(latest["close"])
        
        # 計算漲跌幅
        changes = self._calculate_changes(df)
        
        # 技術指標
        indicators = self._get_indicators_summary(df, latest)
        
        # 訊號
        signals = indicator_service.get_all_signals(df)
        
        # 評分
        score = indicator_service.calculate_score(df)
        
        # 成交量
        volume_info = self._get_volume_info(df, latest)
        
        return {
            "symbol": symbol,
            "name": info.get("name", "N/A") if info else "N/A",
            "asset_type": "stock",
            "price": {
                "current": price,
                "high_52w": info.get("fifty_two_week_high") if info else None,
                "low_52w": info.get("fifty_two_week_low") if info else None,
                "from_high_pct": self._calc_pct_from_high(price, info),
                "from_low_pct": self._calc_pct_from_low(price, info),
            },
            "change": changes,
            "volume": volume_info,
            "indicators": indicators,
            "signals": [
                {
                    "type": s.type.value,
                    "indicator": s.indicator,
                    "description": s.description,
                }
                for s in signals
            ],
            "score": score,
            "updated_at": datetime.now().isoformat(),
        }
    
    def _calculate_changes(self, df: pd.DataFrame) -> Dict[str, float]:
        """計算各時間段漲跌幅"""
        latest_close = df["close"].iloc[-1]
        
        def calc_change(days: int) -> Optional[float]:
            if len(df) <= days:
                return None
            old_close = df["close"].iloc[-(days + 1)]
            return round((latest_close - old_close) / old_close * 100, 2)
        
        return {
            "day": calc_change(1),
            "week": calc_change(5),
            "month": calc_change(20),
            "quarter": calc_change(60),
            "year": calc_change(250) if len(df) > 250 else None,
        }
    
    def _get_indicators_summary(
        self,
        df: pd.DataFrame,
        latest: pd.Series,
    ) -> Dict[str, Any]:
        """取得指標摘要"""
        price = float(latest["close"])
        
        # MA
        ma_short = latest.get(f"ma{settings.MA_SHORT}")
        ma_mid = latest.get(f"ma{settings.MA_MID}")
        ma_long = latest.get(f"ma{settings.MA_LONG}")
        
        alignment, _ = indicator_service.get_ma_alignment(df)
        
        ma_info = {
            f"ma{settings.MA_SHORT}": round(ma_short, 2) if not pd.isna(ma_short) else None,
            f"ma{settings.MA_MID}": round(ma_mid, 2) if not pd.isna(ma_mid) else None,
            f"ma{settings.MA_LONG}": round(ma_long, 2) if not pd.isna(ma_long) else None,
            "alignment": alignment.value,
            f"price_vs_ma{settings.MA_SHORT}": "above" if price > ma_short else "below" if not pd.isna(ma_short) else None,
            f"price_vs_ma{settings.MA_MID}": "above" if price > ma_mid else "below" if not pd.isna(ma_mid) else None,
            f"price_vs_ma{settings.MA_LONG}": "above" if price > ma_long else "below" if not pd.isna(ma_long) else None,
        }
        
        # RSI
        rsi = latest.get("rsi")
        rsi_status, _ = indicator_service.get_rsi_status(rsi)
        rsi_info = {
            "value": round(rsi, 2) if not pd.isna(rsi) else None,
            "status": rsi_status,
        }
        
        # MACD
        macd_dif = latest.get("macd_dif")
        macd_dea = latest.get("macd_dea")
        macd_hist = latest.get("macd_hist")
        macd_info = {
            "dif": round(macd_dif, 4) if not pd.isna(macd_dif) else None,
            "dea": round(macd_dea, 4) if not pd.isna(macd_dea) else None,
            "histogram": round(macd_hist, 4) if not pd.isna(macd_hist) else None,
            "status": "bullish" if macd_hist and macd_hist > 0 else "bearish",
        }
        
        # KD
        kd_k = latest.get("kd_k")
        kd_d = latest.get("kd_d")
        kd_info = {
            "k": round(kd_k, 2) if not pd.isna(kd_k) else None,
            "d": round(kd_d, 2) if not pd.isna(kd_d) else None,
            "status": self._get_kd_status(kd_k),
        }
        
        # Bollinger
        bb_upper = latest.get("bb_upper")
        bb_middle = latest.get("bb_middle")
        bb_lower = latest.get("bb_lower")
        bb_info = {
            "upper": round(bb_upper, 2) if not pd.isna(bb_upper) else None,
            "middle": round(bb_middle, 2) if not pd.isna(bb_middle) else None,
            "lower": round(bb_lower, 2) if not pd.isna(bb_lower) else None,
            "position": indicator_service.get_bollinger_position(price, bb_upper, bb_middle, bb_lower),
        }
        
        # OBV
        obv_trend = indicator_service.get_obv_trend(df)
        obv_info = {
            "trend": obv_trend,
        }
        
        return {
            "ma": ma_info,
            "rsi": rsi_info,
            "macd": macd_info,
            "kd": kd_info,
            "bollinger": bb_info,
            "obv": obv_info,
        }
    
    def _get_kd_status(self, k_value: float) -> str:
        """取得 KD 狀態"""
        if pd.isna(k_value):
            return "unknown"
        if k_value > 80:
            return "overbought"
        elif k_value < 20:
            return "oversold"
        elif k_value > 50:
            return "neutral_high"
        else:
            return "neutral_low"
    
    def _get_volume_info(
        self,
        df: pd.DataFrame,
        latest: pd.Series,
    ) -> Dict[str, Any]:
        """取得成交量資訊"""
        today_vol = latest.get("volume", 0)
        avg_vol = latest.get("volume_ma20")
        vol_ratio = latest.get("volume_ratio")
        
        return {
            "today": int(today_vol) if today_vol else 0,
            "avg_20d": int(avg_vol) if not pd.isna(avg_vol) else None,
            "ratio": round(vol_ratio, 2) if not pd.isna(vol_ratio) else None,
        }
    
    def _calc_pct_from_high(self, price: float, info: Optional[Dict]) -> Optional[float]:
        """計算距離 52 週高點的跌幅"""
        if not info or not info.get("fifty_two_week_high"):
            return None
        high = info["fifty_two_week_high"]
        return round((price - high) / high * 100, 2)
    
    def _calc_pct_from_low(self, price: float, info: Optional[Dict]) -> Optional[float]:
        """計算距離 52 週低點的漲幅"""
        if not info or not info.get("fifty_two_week_low"):
            return None
        low = info["fifty_two_week_low"]
        return round((price - low) / low * 100, 2)
    
    def search_stocks(self, query: str) -> List[Dict[str, str]]:
        """
        搜尋股票（簡單實作，直接驗證代號）
        
        Returns:
            符合的股票列表
        """
        symbol = query.upper().strip()
        
        if yahoo_finance.validate_symbol(symbol):
            info = yahoo_finance.get_stock_info(symbol)
            if info:
                return [{
                    "symbol": info["symbol"],
                    "name": info.get("name", "N/A"),
                }]
        
        return []
    
    def fetch_extended_history(
        self,
        symbol: str,
        years: int = 10,
    ) -> bool:
        """
        抓取並快取延伸歷史資料（支援多年）
        
        Args:
            symbol: 股票代號
            years: 年數 (1, 3, 5, 10)
            
        Returns:
            是否成功
        """
        period_map = {1: "1y", 2: "2y", 5: "5y", 10: "10y"}
        period = period_map.get(years, "10y")
        
        df = yahoo_finance.get_stock_history(symbol, period=period)
        if df is None:
            return False
        
        self._save_prices_to_db(df)
        return True
    
    def get_price_history(
        self,
        symbol: str,
        days: int = 365,
    ) -> Optional[pd.DataFrame]:
        """
        取得股票價格歷史（從資料庫）
        
        Args:
            symbol: 股票代號
            days: 天數
            
        Returns:
            價格 DataFrame
        """
        return self._load_prices_from_db(symbol, days)
    
    def ensure_historical_data(
        self,
        symbol: str,
        years: int = 10,
    ) -> bool:
        """
        確保有足夠的歷史資料
        
        檢查資料庫是否有指定年份的資料，
        如果不足則從 API 抓取補齊
        """
        symbol = symbol.upper()
        days_needed = years * 365
        
        # 檢查資料庫中最早的資料日期
        stmt = (
            select(StockPrice)
            .where(StockPrice.symbol == symbol)
            .order_by(StockPrice.date)
            .limit(1)
        )
        earliest = self.db.execute(stmt).scalar_one_or_none()
        
        if earliest:
            days_available = (date.today() - earliest.date).days
            if days_available >= days_needed * 0.9:  # 90% 就算足夠
                return True
        
        # 資料不足，抓取更多
        logger.info(f"抓取 {symbol} 的 {years} 年歷史資料")
        return self.fetch_extended_history(symbol, years)
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/subscription_service.py  ⭐⭐⭐
> 訂閱精選服務
──────────────────────────────────────────────────────────────────────

```py
"""
訂閱精選服務
負責管理訂閱源、處理抓取結果、用戶訂閱
"""
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from sqlalchemy.orm import Session
from sqlalchemy import and_

from app.models.subscription import SubscriptionSource, AutoPick, UserSubscription
from app.services.rss_fetcher import rss_fetcher

logger = logging.getLogger(__name__)


class SubscriptionService:
    """訂閱精選服務"""
    
    def __init__(self, db: Session):
        self.db = db
    
    # ============================================================
    # 訂閱源管理
    # ============================================================
    
    def get_all_sources(self, enabled_only: bool = True) -> List[SubscriptionSource]:
        """取得所有訂閱源"""
        query = self.db.query(SubscriptionSource)
        if enabled_only:
            query = query.filter(SubscriptionSource.enabled == True)
        return query.all()
    
    def get_source_by_slug(self, slug: str) -> Optional[SubscriptionSource]:
        """根據 slug 取得訂閱源"""
        return self.db.query(SubscriptionSource).filter(
            SubscriptionSource.slug == slug
        ).first()
    
    def create_source(self, name: str, slug: str, url: str, 
                      type: str = "substack", description: str = None) -> SubscriptionSource:
        """建立訂閱源"""
        source = SubscriptionSource(
            name=name,
            slug=slug,
            url=url,
            type=type,
            description=description,
        )
        self.db.add(source)
        self.db.commit()
        self.db.refresh(source)
        logger.info(f"建立訂閱源: {name} ({slug})")
        return source
    
    def init_default_sources(self):
        """初始化預設訂閱源"""
        defaults = [
            {
                "name": "美股大叔",
                "slug": "uncle-stock",
                "url": "https://unclestocknotes.substack.com/feed",
                "type": "substack",
                "description": "美股大叔的投資筆記",
            },
        ]
        
        for source_data in defaults:
            existing = self.get_source_by_slug(source_data["slug"])
            if not existing:
                self.create_source(**source_data)
    
    # ============================================================
    # 抓取與更新
    # ============================================================
    
    def fetch_source(self, source: SubscriptionSource, 
                     since_date: datetime = None, 
                     backfill: bool = False) -> Dict:
        """
        抓取單一訂閱源
        
        Args:
            source: 訂閱源
            since_date: 起始日期
            backfill: 是否為回溯模式（首次抓取）
        
        Returns:
            {new: int, updated: int, symbols: [...]}
        """
        logger.info(f"開始抓取: {source.name}")
        
        # 決定起始日期
        if backfill:
            since_date = datetime.now() - timedelta(days=30)
        elif since_date is None:
            # 使用上次抓取時間，或預設 1 天前
            since_date = source.last_fetched_at or (datetime.now() - timedelta(days=1))
        
        # 抓取 RSS
        picks = rss_fetcher.fetch_and_parse(source.url, since_date)
        
        result = {"new": 0, "updated": 0, "symbols": []}
        
        # 用來追蹤本次處理過的 symbols（避免重複插入）
        processed_symbols = {}
        
        for pick in picks:
            symbol = pick["symbol"]
            
            # 檢查是否在本次迴圈中已處理過
            if symbol in processed_symbols:
                # 更新本次迴圈中的記錄
                existing_pick = processed_symbols[symbol]
                existing_pick.update_mention(
                    article_url=pick["article_url"],
                    article_title=pick["article_title"],
                    article_date=pick["article_date"],
                )
                result["updated"] += 1
                continue
            
            # 檢查資料庫中是否已存在
            existing = self.db.query(AutoPick).filter(
                and_(
                    AutoPick.source_id == source.id,
                    AutoPick.symbol == symbol
                )
            ).first()
            
            if existing:
                # 更新提及
                existing.update_mention(
                    article_url=pick["article_url"],
                    article_title=pick["article_title"],
                    article_date=pick["article_date"],
                )
                processed_symbols[symbol] = existing
                result["updated"] += 1
            else:
                # 新增
                new_pick = AutoPick(
                    source_id=source.id,
                    symbol=symbol,
                    article_url=pick["article_url"],
                    article_title=pick["article_title"],
                    article_date=pick["article_date"],
                    first_seen_at=datetime.now(),
                    last_seen_at=datetime.now(),
                    expires_at=datetime.now() + timedelta(days=30),
                    mention_count=1,
                )
                self.db.add(new_pick)
                processed_symbols[symbol] = new_pick
                result["new"] += 1
            
            if symbol not in result["symbols"]:
                result["symbols"].append(symbol)
        
        # 更新最後抓取時間
        source.last_fetched_at = datetime.now()
        self.db.commit()
        
        logger.info(f"抓取完成: 新增 {result['new']}, 更新 {result['updated']}")
        return result
    
    def fetch_all_sources(self, backfill: bool = False) -> Dict:
        """抓取所有啟用的訂閱源"""
        sources = self.get_all_sources(enabled_only=True)
        
        total_result = {"sources": [], "total_new": 0, "total_updated": 0}
        
        for source in sources:
            result = self.fetch_source(source, backfill=backfill)
            total_result["sources"].append({
                "name": source.name,
                "slug": source.slug,
                **result
            })
            total_result["total_new"] += result["new"]
            total_result["total_updated"] += result["updated"]
        
        return total_result
    
    # ============================================================
    # 用戶訂閱
    # ============================================================
    
    def subscribe(self, user_id: int, source_id: int) -> bool:
        """用戶訂閱來源"""
        existing = self.db.query(UserSubscription).filter(
            and_(
                UserSubscription.user_id == user_id,
                UserSubscription.source_id == source_id
            )
        ).first()
        
        if existing:
            return False  # 已訂閱
        
        subscription = UserSubscription(
            user_id=user_id,
            source_id=source_id,
        )
        self.db.add(subscription)
        self.db.commit()
        logger.info(f"用戶 {user_id} 訂閱了來源 {source_id}")
        return True
    
    def unsubscribe(self, user_id: int, source_id: int) -> bool:
        """用戶取消訂閱"""
        subscription = self.db.query(UserSubscription).filter(
            and_(
                UserSubscription.user_id == user_id,
                UserSubscription.source_id == source_id
            )
        ).first()
        
        if not subscription:
            return False
        
        self.db.delete(subscription)
        self.db.commit()
        logger.info(f"用戶 {user_id} 取消訂閱來源 {source_id}")
        return True
    
    def get_user_subscriptions(self, user_id: int) -> List[SubscriptionSource]:
        """取得用戶訂閱的來源"""
        subscriptions = self.db.query(UserSubscription).filter(
            UserSubscription.user_id == user_id
        ).all()
        
        source_ids = [s.source_id for s in subscriptions]
        if not source_ids:
            return []
        
        return self.db.query(SubscriptionSource).filter(
            SubscriptionSource.id.in_(source_ids)
        ).all()
    
    def is_subscribed(self, user_id: int, source_id: int) -> bool:
        """檢查用戶是否已訂閱"""
        return self.db.query(UserSubscription).filter(
            and_(
                UserSubscription.user_id == user_id,
                UserSubscription.source_id == source_id
            )
        ).first() is not None
    
    # ============================================================
    # 查詢精選
    # ============================================================
    
    def get_active_picks(self, source_id: int = None, limit: int = 50) -> List[AutoPick]:
        """取得有效的精選（未過期）"""
        query = self.db.query(AutoPick).filter(
            AutoPick.expires_at > datetime.now()
        )
        
        if source_id:
            query = query.filter(AutoPick.source_id == source_id)
        
        return query.order_by(AutoPick.last_seen_at.desc()).limit(limit).all()
    
    def get_user_picks(self, user_id: int, limit: int = 50) -> List[Dict]:
        """取得用戶訂閱的所有精選"""
        # 取得用戶訂閱的來源
        subscribed_sources = self.get_user_subscriptions(user_id)
        if not subscribed_sources:
            return []
        
        source_ids = [s.id for s in subscribed_sources]
        
        # 查詢有效的精選
        picks = self.db.query(AutoPick).filter(
            and_(
                AutoPick.source_id.in_(source_ids),
                AutoPick.expires_at > datetime.now()
            )
        ).order_by(AutoPick.last_seen_at.desc()).limit(limit).all()
        
        # 組合結果
        source_map = {s.id: s for s in subscribed_sources}
        results = []
        for pick in picks:
            pick_dict = pick.to_dict()
            pick_dict["source_name"] = source_map[pick.source_id].name
            pick_dict["source_slug"] = source_map[pick.source_id].slug
            results.append(pick_dict)
        
        return results
    
    def get_pick_by_symbol(self, source_id: int, symbol: str) -> Optional[AutoPick]:
        """根據來源和代碼取得精選"""
        return self.db.query(AutoPick).filter(
            and_(
                AutoPick.source_id == source_id,
                AutoPick.symbol == symbol
            )
        ).first()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/services/watchlist_service.py  ⭐⭐⭐
> 追蹤清單服務 (Async 版本)
──────────────────────────────────────────────────────────────────────

```py
"""
追蹤清單服務 (Async 版本)
"""
from typing import Optional, Dict, Any, List
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
import logging

from app.models.watchlist import Watchlist
from app.models.user import User
from app.data_sources.coingecko import CRYPTO_MAP

logger = logging.getLogger(__name__)

# 支援的加密貨幣代號
SUPPORTED_CRYPTO = set(k for k in CRYPTO_MAP.keys() if k not in ("BITCOIN", "ETHEREUM"))


class WatchlistService:
    """追蹤清單服務 (Async)"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    def _get_asset_type(self, symbol: str) -> str:
        """判斷資產類型"""
        return "crypto" if symbol.upper() in SUPPORTED_CRYPTO else "stock"
    
    async def add_to_watchlist(
        self,
        user_id: int,
        symbol: str,
        note: str = None,
    ) -> Dict[str, Any]:
        """
        新增追蹤標的
        
        Args:
            user_id: 用戶 ID
            symbol: 股票/加密貨幣代號
            note: 備註
            
        Returns:
            {
                "success": bool,
                "message": str,
                "watchlist": Watchlist (if success)
            }
        """
        symbol = symbol.upper()
        asset_type = self._get_asset_type(symbol)
        
        logger.info(f"=== 新增追蹤清單 ===")
        logger.info(f"用戶 ID: {user_id}, 代號: {symbol}, 類型: {asset_type}")
        
        # 檢查是否已存在
        existing = await self._get_watchlist_item(user_id, symbol, asset_type)
        if existing:
            logger.info(f"已存在追蹤: user_id={user_id}, symbol={symbol}")
            return {
                "success": False,
                "message": f"{symbol} 已在追蹤清單中",
            }
        
        # 驗證代號是否有效
        if asset_type == "crypto":
            from app.data_sources.coingecko import coingecko
            if not coingecko.validate_symbol(symbol):
                logger.warning(f"無效的加密貨幣: {symbol}")
                return {
                    "success": False,
                    "message": f"不支援的加密貨幣: {symbol}",
                }
        else:
            from app.data_sources.yahoo_finance import yahoo_finance
            if not yahoo_finance.validate_symbol(symbol):
                logger.warning(f"無效的股票代號: {symbol}")
                return {
                    "success": False,
                    "message": f"找不到股票: {symbol}",
                }
        
        # 新增
        watchlist = Watchlist(
            user_id=user_id,
            symbol=symbol,
            asset_type=asset_type,
            note=note,
        )
        self.db.add(watchlist)
        await self.db.commit()
        await self.db.refresh(watchlist)
        
        logger.info(f"★ 追蹤清單寫入成功: id={watchlist.id}, user_id={user_id}, symbol={symbol}")
        
        return {
            "success": True,
            "message": f"已新增 {symbol} 到追蹤清單",
            "watchlist": watchlist,
        }
    
    async def remove_from_watchlist(
        self,
        user_id: int,
        symbol: str = None,
        watchlist_id: int = None,
    ) -> Dict[str, Any]:
        """
        從追蹤清單移除
        
        Args:
            user_id: 用戶 ID
            symbol: 代號（與 watchlist_id 二擇一）
            watchlist_id: 追蹤清單 ID
            
        Returns:
            {"success": bool, "message": str}
        """
        logger.info(f"=== 移除追蹤清單 ===")
        logger.info(f"用戶 ID: {user_id}, 代號: {symbol}, watchlist_id: {watchlist_id}")
        
        if watchlist_id:
            stmt = select(Watchlist).where(
                and_(
                    Watchlist.id == watchlist_id,
                    Watchlist.user_id == user_id,  # ★ 確保只能刪除自己的
                )
            )
        elif symbol:
            symbol = symbol.upper()
            asset_type = self._get_asset_type(symbol)
            stmt = select(Watchlist).where(
                and_(
                    Watchlist.user_id == user_id,  # ★ 確保只能刪除自己的
                    Watchlist.symbol == symbol,
                    Watchlist.asset_type == asset_type,
                )
            )
        else:
            return {
                "success": False,
                "message": "請提供 symbol 或 watchlist_id",
            }
        
        result = await self.db.execute(stmt)
        watchlist = result.scalar_one_or_none()
        
        if not watchlist:
            logger.warning(f"找不到追蹤項目: user_id={user_id}, symbol={symbol}")
            return {
                "success": False,
                "message": "找不到追蹤項目",
            }
        
        # ★★★ 額外驗證：確保 watchlist 的 user_id 與請求的 user_id 一致 ★★★
        if watchlist.user_id != user_id:
            logger.error(f"權限錯誤！嘗試刪除他人資料: 請求 user_id={user_id}, 資料 user_id={watchlist.user_id}")
            return {
                "success": False,
                "message": "權限不足",
            }
        
        symbol = watchlist.symbol
        await self.db.delete(watchlist)
        await self.db.commit()
        
        logger.info(f"★ 追蹤清單刪除成功: user_id={user_id}, symbol={symbol}")
        
        return {
            "success": True,
            "message": f"已從追蹤清單移除 {symbol}",
        }
    
    async def update_note(
        self,
        user_id: int,
        symbol: str,
        note: str,
    ) -> Dict[str, Any]:
        """
        更新備註
        
        Args:
            user_id: 用戶 ID
            symbol: 代號
            note: 新備註
            
        Returns:
            {"success": bool, "message": str}
        """
        symbol = symbol.upper()
        asset_type = self._get_asset_type(symbol)
        
        watchlist = await self._get_watchlist_item(user_id, symbol, asset_type)
        if not watchlist:
            return {
                "success": False,
                "message": f"{symbol} 不在追蹤清單中",
            }
        
        watchlist.note = note
        await self.db.commit()
        
        return {
            "success": True,
            "message": f"已更新 {symbol} 的備註",
        }
    
    async def get_watchlist(self, user_id: int) -> List[Watchlist]:
        """
        取得用戶追蹤清單
        
        Args:
            user_id: 用戶 ID
            
        Returns:
            追蹤清單列表
        """
        logger.debug(f"取得追蹤清單: user_id={user_id}")
        
        stmt = (
            select(Watchlist)
            .where(Watchlist.user_id == user_id)  # ★ 只取得該用戶的資料
            .order_by(Watchlist.added_at.desc())
        )
        result = await self.db.execute(stmt)
        items = list(result.scalars().all())
        
        logger.info(f"取得追蹤清單: user_id={user_id}, 數量={len(items)}")
        for item in items:
            logger.debug(f"  - id={item.id}, symbol={item.symbol}, user_id={item.user_id}")
        
        return items
    
    async def get_watchlist_symbols(self, user_id: int) -> Dict[str, List[str]]:
        """
        取得用戶追蹤的代號列表（用於通知系統）
        
        Returns:
            {
                "stocks": ["AAPL", "TSLA"],
                "crypto": ["BTC", "ETH"]
            }
        """
        watchlists = await self.get_watchlist(user_id)
        
        stocks = []
        cryptos = []
        
        for item in watchlists:
            if item.asset_type == "stock":
                stocks.append(item.symbol)
            else:
                cryptos.append(item.symbol)
        
        return {
            "stocks": stocks,
            "crypto": cryptos,
        }
    
    async def _get_watchlist_item(
        self,
        user_id: int,
        symbol: str,
        asset_type: str,
    ) -> Optional[Watchlist]:
        """取得特定追蹤項目"""
        stmt = select(Watchlist).where(
            and_(
                Watchlist.user_id == user_id,
                Watchlist.symbol == symbol,
                Watchlist.asset_type == asset_type,
            )
        )
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_all_tracked_symbols(self) -> Dict[str, set]:
        """
        取得所有用戶追蹤的代號（用於批次更新）
        
        Returns:
            {
                "stocks": {"AAPL", "TSLA", ...},
                "crypto": {"BTC", "ETH"}
            }
        """
        stmt = select(Watchlist.symbol, Watchlist.asset_type).distinct()
        result = await self.db.execute(stmt)
        results = result.all()
        
        stocks = set()
        cryptos = set()
        
        for symbol, asset_type in results:
            if asset_type == "stock":
                stocks.add(symbol)
            else:
                cryptos.add(symbol)
        
        return {
            "stocks": stocks,
            "crypto": cryptos,
        }
```

======================================================================
## 🔧 工具 / 輔助
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/utils/migrations.py  ⭐
> 資料庫自動遷移
──────────────────────────────────────────────────────────────────────

```py
"""
資料庫自動遷移
在啟動時檢查並添加缺少的欄位
"""
import logging
from sqlalchemy import text
from sqlalchemy.orm import Session

logger = logging.getLogger(__name__)


def run_migrations(db: Session):
    """執行資料庫遷移"""
    migrations = [
        # 2024-01-14: 追蹤清單 MA20 排序功能
        {
            "name": "add_ma20_to_price_cache",
            "check": "SELECT column_name FROM information_schema.columns WHERE table_name='stock_price_cache' AND column_name='ma20'",
            "sql": "ALTER TABLE stock_price_cache ADD COLUMN ma20 NUMERIC(12, 4)",
        },
    ]
    
    for migration in migrations:
        try:
            # 檢查是否已存在
            result = db.execute(text(migration["check"])).fetchone()
            if result:
                logger.debug(f"Migration '{migration['name']}' 已存在，跳過")
                continue
            
            # 執行遷移
            logger.info(f"執行 Migration: {migration['name']}")
            db.execute(text(migration["sql"]))
            db.commit()
            logger.info(f"Migration '{migration['name']}' 完成")
            
        except Exception as e:
            logger.warning(f"Migration '{migration['name']}' 失敗: {e}")
            db.rollback()
```

======================================================================
## 🎨 前端 / 靜態資源
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 frontend/watchlist_with_cache.js  ⭐
> ========== 追蹤清單 - 使用快取版本 ==========
──────────────────────────────────────────────────────────────────────

```js
        // ========== 追蹤清單 - 使用快取版本 ==========
        // 改用 /api/watchlist/with-prices API，直接取得價格
        
        async function loadWatchlist() {
            const container = document.getElementById('watchlistContent');
            
            if (!currentUser || !currentUser.id) {
                console.error('loadWatchlist: 用戶未登入');
                container.innerHTML = '<p class="text-red-500 text-center py-4">請先登入</p>';
                return;
            }
            
            // 顯示載入中
            container.innerHTML = `
                <div class="text-center py-8">
                    <i class="fas fa-spinner fa-spin text-2xl text-blue-600"></i>
                    <p class="mt-2 text-gray-500">載入中...</p>
                </div>
            `;
            
            try {
                // ★ 改用新 API：一次取得清單 + 價格
                const res = await apiRequest('/api/watchlist/with-prices');
                const data = await res.json();
                
                console.log('追蹤清單(含價格):', data);
                
                if (!data.success || !data.data || data.data.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-12">
                            <i class="fas fa-star text-gray-300 text-4xl mb-3"></i>
                            <p class="text-gray-500 mb-4">尚無追蹤的股票</p>
                            <button onclick="showAddWatchlistModal()" class="px-6 py-2 bg-blue-600 text-white rounded-lg">
                                <i class="fas fa-plus mr-2"></i>新增追蹤
                            </button>
                        </div>
                    `;
                    return;
                }
                
                // 顯示快取更新時間（如果有）
                let cacheInfo = '';
                if (data.cache_info && data.cache_info.oldest_update) {
                    const updateTime = new Date(data.cache_info.oldest_update);
                    const now = new Date();
                    const diffMin = Math.round((now - updateTime) / 60000);
                    cacheInfo = `<p class="text-xs text-gray-400 text-right mb-2">價格更新於 ${diffMin} 分鐘前</p>`;
                }
                
                let html = cacheInfo + '<div class="space-y-3">';
                
                for (const item of data.data) {
                    const typeClass = item.asset_type === 'crypto' ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700';
                    const typeText = item.asset_type === 'crypto' ? '幣' : '股';
                    
                    // 價格顯示（直接從 API 回應取得）
                    let priceInfo = '';
                    if (item.price !== null) {
                        const change = item.change_pct || 0;
                        const changeClass = change >= 0 ? 'text-green-600' : 'text-red-600';
                        const changeIcon = change >= 0 ? '▲' : '▼';
                        priceInfo = `
                            <div class="flex items-baseline gap-2 mt-2">
                                <span class="text-xl font-bold text-gray-800">$${item.price.toLocaleString()}</span>
                                <span class="${changeClass} text-sm font-medium">${changeIcon} ${Math.abs(change).toFixed(2)}%</span>
                            </div>
                        `;
                    } else {
                        priceInfo = `
                            <div class="flex items-baseline gap-2 mt-2">
                                <span class="text-gray-400 text-sm">價格未更新</span>
                            </div>
                        `;
                    }
                    
                    // 顯示股票名稱
                    const nameDisplay = item.name ? `<span class="text-gray-500 text-sm ml-2">${item.name}</span>` : '';
                    
                    html += `
                        <div class="stock-card bg-white rounded-xl shadow-sm p-4 border-l-4 ${item.asset_type === 'crypto' ? 'border-purple-500' : 'border-blue-500'}">
                            <div class="flex items-start justify-between">
                                <div class="flex-1">
                                    <div class="flex items-center flex-wrap">
                                        <span class="font-bold text-lg text-gray-800">${item.symbol}</span>
                                        <span class="ml-2 px-2 py-0.5 rounded text-xs ${typeClass}">${typeText}</span>
                                        ${nameDisplay}
                                    </div>
                                    ${priceInfo}
                                    ${item.note ? `<p class="text-gray-500 text-sm mt-2 italic"><i class="fas fa-sticky-note mr-1"></i>${item.note}</p>` : ''}
                                </div>
                                <button onclick="removeFromWatchlist('${item.symbol}')" class="p-2 text-gray-400 hover:text-red-500 touch-target">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                            <div class="flex items-center justify-between mt-3 pt-3 border-t">
                                <span class="text-gray-400 text-xs"><i class="fas fa-clock mr-1"></i>加入於 ${new Date(item.added_at).toLocaleDateString()}</span>
                                <button onclick="searchSymbol('${item.symbol}')" class="px-4 py-2 bg-orange-500 text-white rounded-lg text-sm hover:bg-orange-600 touch-target">
                                    <i class="fas fa-chart-line mr-1"></i>詳細分析
                                </button>
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (e) {
                console.error('載入追蹤清單失敗', e);
                container.innerHTML = '<p class="text-red-500 text-center py-4">載入失敗</p>';
            }
        }
        
        // ========== 首頁追蹤清單快覽 ==========
        async function loadWatchlistOverview() {
            const container = document.getElementById('dashboardWatchlist');
            
            try {
                // ★ 同樣使用快取 API
                const res = await apiRequest('/api/watchlist/with-prices');
                const data = await res.json();
                
                if (!data.success || !data.data || data.data.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-6">
                            <i class="fas fa-star text-gray-300 text-3xl mb-2"></i>
                            <p class="text-gray-500 text-sm">尚無追蹤清單</p>
                            <button onclick="showSection('search')" class="mt-2 text-blue-600 text-sm">前往查詢股票</button>
                        </div>
                    `;
                    return;
                }
                
                // 只顯示前 5 筆
                const items = data.data.slice(0, 5);
                let html = '<div class="space-y-2">';
                
                for (const item of items) {
                    const change = item.change_pct || 0;
                    const changeClass = change >= 0 ? 'text-green-600' : 'text-red-600';
                    const changeText = item.price !== null 
                        ? `<span class="${changeClass} text-sm">${change >= 0 ? '+' : ''}${change.toFixed(2)}%</span>`
                        : '';
                    
                    const priceText = item.price !== null
                        ? `<span class="text-gray-700 font-medium">$${item.price.toLocaleString()}</span>`
                        : '<span class="text-gray-400 text-sm">--</span>';
                    
                    html += `
                        <div class="flex items-center justify-between py-2 border-b last:border-0 cursor-pointer hover:bg-gray-50 -mx-2 px-2 rounded" 
                             onclick="searchSymbol('${item.symbol}')">
                            <div class="flex items-center">
                                <span class="font-medium text-gray-800 w-20">${item.symbol}</span>
                                <span class="text-xs px-2 py-0.5 rounded ${item.asset_type === 'crypto' ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700'}">
                                    ${item.asset_type === 'crypto' ? '幣' : '股'}
                                </span>
                            </div>
                            <div class="text-right">
                                ${priceText}
                                ${changeText}
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                
                // 如果超過 5 筆，顯示「查看全部」
                if (data.data.length > 5) {
                    html += `
                        <div class="text-center mt-3">
                            <button onclick="showSection('watchlist')" class="text-blue-600 text-sm hover:underline">
                                查看全部 (${data.data.length})
                            </button>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
                
            } catch (e) {
                console.error('載入追蹤清單快覽失敗', e);
                container.innerHTML = '<p class="text-red-500 text-center py-4">載入失敗</p>';
            }
        }
```

──────────────────────────────────────────────────────────────────────
### 📄 static/admin.html  ⭐
──────────────────────────────────────────────────────────────────────

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>管理後台 - SELA 自動選股系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" type="image/png" href="/static/logo.png">
    <style>
        .brand-orange { color: #FA7A35; }
        .bg-brand-orange { background-color: #FA7A35; }
        .hover\:bg-brand-orange-dark:hover { background-color: #e56a25; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <!-- 頂部導航 -->
    <nav class="bg-slate-800 text-white shadow-lg">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center space-x-4">
                    <span class="text-xl font-bold bg-brand-orange px-3 py-1 rounded">SELA</span>
                    <span class="text-lg">管理後台</span>
                </div>
                <div class="flex items-center space-x-4">
                    <a href="/static/dashboard.html" class="text-gray-300 hover:text-white">
                        ← 返回儀表板
                    </a>
                    <span id="adminName" class="text-gray-300"></span>
                </div>
            </div>
        </div>
    </nav>

    <!-- 主內容 -->
    <div class="max-w-7xl mx-auto px-4 py-6">
        <!-- 統計卡片 -->
        <div class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
            <div class="bg-white rounded-lg shadow p-4">
                <div class="text-gray-500 text-sm">總用戶數</div>
                <div id="statTotal" class="text-2xl font-bold text-slate-800">-</div>
            </div>
            <div class="bg-white rounded-lg shadow p-4">
                <div class="text-gray-500 text-sm">總登入次數</div>
                <div id="statTotalLogins" class="text-2xl font-bold text-purple-600">-</div>
            </div>
            <div class="bg-white rounded-lg shadow p-4">
                <div class="text-gray-500 text-sm">今日登入</div>
                <div id="statToday" class="text-2xl font-bold text-green-600">-</div>
            </div>
            <div class="bg-white rounded-lg shadow p-4">
                <div class="text-gray-500 text-sm">封鎖用戶</div>
                <div id="statBlocked" class="text-2xl font-bold text-red-600">-</div>
            </div>
            <div class="bg-white rounded-lg shadow p-4">
                <div class="text-gray-500 text-sm">管理員</div>
                <div id="statAdmin" class="text-2xl font-bold text-blue-600">-</div>
            </div>
        </div>
        
        <!-- 系統管理 -->
        <div class="bg-white rounded-lg shadow p-4 mb-6">
            <h3 class="font-bold text-gray-700 mb-4">📊 市場資料管理</h3>
            <div class="flex flex-wrap gap-3">
                <button onclick="initializeData()" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 flex items-center">
                    <span class="mr-2">🔄</span>初始化歷史資料
                </button>
                <button onclick="updateIndices()" class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 flex items-center">
                    <span class="mr-2">📈</span>更新三大指數
                </button>
                <button onclick="updateSentiment()" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 flex items-center">
                    <span class="mr-2">💭</span>更新恐懼貪婪
                </button>
                <button onclick="triggerDailyUpdate()" class="bg-orange-600 text-white px-4 py-2 rounded-lg hover:bg-orange-700 flex items-center">
                    <span class="mr-2">⚡</span>執行每日更新
                </button>
            </div>
            <p id="systemMessage" class="mt-3 text-sm text-gray-500"></p>
        </div>

        <!-- 訊號檢查與推播 -->
        <div class="bg-white rounded-lg shadow p-4 mb-6">
            <h3 class="font-bold text-gray-700 mb-4">🔔 訊號檢查與推播</h3>
            <div class="flex flex-wrap gap-3 mb-3">
                <button onclick="runSignalCheck()" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 flex items-center">
                    <span class="mr-2">🔍</span>偵測訊號（測試）
                </button>
                <button onclick="sendSignalNotifications()" class="bg-orange-600 text-white px-4 py-2 rounded-lg hover:bg-orange-700 flex items-center">
                    <span class="mr-2">📤</span>發送訊號通知
                </button>
                <button onclick="testLineNotify()" class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 flex items-center">
                    <span class="mr-2">📱</span>測試 LINE 推播
                </button>
            </div>
            <div class="flex gap-2 items-center">
                <input type="text" id="testSymbolInput" placeholder="輸入股票代號測試訊號偵測 (如 AAPL)"
                    class="flex-1 px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400">
                <button onclick="testSignalDetection()" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700">
                    測試偵測
                </button>
            </div>
            <p id="signalMessage" class="mt-3 text-sm text-gray-500"></p>
            <div id="signalResult" class="mt-3 hidden">
                <h4 class="font-medium text-gray-700 mb-2">偵測結果：</h4>
                <pre id="signalResultContent" class="bg-gray-100 p-3 rounded text-xs overflow-x-auto"></pre>
            </div>
        </div>

        <!-- 搜尋和篩選 -->
        <div class="bg-white rounded-lg shadow p-4 mb-6">
            <div class="flex flex-col md:flex-row gap-4">
                <div class="flex-1">
                    <input type="text" id="searchInput" placeholder="搜尋用戶名稱、Email 或 LINE ID..."
                        class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-400">
                </div>
                <div class="flex gap-2">
                    <label class="flex items-center">
                        <input type="checkbox" id="blockedOnly" class="mr-2">
                        <span class="text-sm">只顯示封鎖</span>
                    </label>
                    <button onclick="loadUsers()" class="bg-brand-orange text-white px-4 py-2 rounded-lg hover:bg-brand-orange-dark">
                        搜尋
                    </button>
                    <button onclick="kickAllUsers()" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700">
                        踢出全部
                    </button>
                </div>
            </div>
        </div>

        <!-- 用戶列表 -->
        <div class="bg-white rounded-lg shadow overflow-hidden">
            <div class="overflow-x-auto">
                <table class="w-full">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">用戶</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase hidden md:table-cell">Email</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">狀態</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">登入次數</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase hidden md:table-cell">最後登入</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">操作</th>
                        </tr>
                    </thead>
                    <tbody id="userList" class="divide-y divide-gray-200">
                        <!-- 動態載入 -->
                    </tbody>
                </table>
            </div>
            
            <!-- 分頁 -->
            <div class="px-4 py-3 bg-gray-50 flex items-center justify-between">
                <div id="pageInfo" class="text-sm text-gray-500"></div>
                <div class="flex gap-2">
                    <button id="prevPage" onclick="changePage(-1)" class="px-3 py-1 border rounded hover:bg-gray-100" disabled>上一頁</button>
                    <button id="nextPage" onclick="changePage(1)" class="px-3 py-1 border rounded hover:bg-gray-100" disabled>下一頁</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 用戶詳情 Modal -->
    <div id="userModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-xl max-w-lg w-full mx-4 max-h-[90vh] overflow-y-auto">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-bold">用戶詳情</h3>
                    <button onclick="closeModal()" class="text-gray-500 hover:text-gray-700">✕</button>
                </div>
                <div id="modalContent">
                    <!-- 動態載入 -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentPage = 1;
        let totalPages = 1;
        const token = localStorage.getItem('token');
        const user = JSON.parse(localStorage.getItem('user') || '{}');

        // 檢查登入和管理員權限
        if (!token) {
            window.location.href = '/static/index.html';
        }

        document.getElementById('adminName').textContent = user.display_name || '';

        // API 請求
        async function apiRequest(url, options = {}) {
            const response = await fetch(url, {
                ...options,
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });
            
            if (response.status === 401) {
                localStorage.clear();
                window.location.href = '/static/index.html';
                return null;
            }
            
            if (response.status === 403) {
                alert('您沒有管理員權限');
                window.location.href = '/static/dashboard.html';
                return null;
            }
            
            return response.json();
        }

        // 載入統計
        async function loadStats() {
            const data = await apiRequest('/api/admin/stats');
            if (data && data.success) {
                document.getElementById('statTotal').textContent = data.stats.total_users;
                document.getElementById('statTotalLogins').textContent = data.stats.total_logins;
                document.getElementById('statToday').textContent = data.stats.today_logins;
                document.getElementById('statBlocked').textContent = data.stats.blocked_users;
                document.getElementById('statAdmin').textContent = data.stats.admin_users;
            }
        }

        // 載入用戶列表
        async function loadUsers() {
            const search = document.getElementById('searchInput').value;
            const blockedOnly = document.getElementById('blockedOnly').checked;
            
            let url = `/api/admin/users?page=${currentPage}&page_size=20`;
            if (search) url += `&search=${encodeURIComponent(search)}`;
            if (blockedOnly) url += `&blocked_only=true`;
            
            const data = await apiRequest(url);
            if (data && data.success) {
                renderUsers(data.users);
                totalPages = data.pagination.total_pages;
                document.getElementById('pageInfo').textContent = 
                    `第 ${data.pagination.page} / ${totalPages} 頁，共 ${data.pagination.total} 筆`;
                document.getElementById('prevPage').disabled = currentPage <= 1;
                document.getElementById('nextPage').disabled = currentPage >= totalPages;
            }
        }

        // 渲染用戶列表
        function renderUsers(users) {
            const tbody = document.getElementById('userList');
            tbody.innerHTML = users.map(u => `
                <tr class="hover:bg-gray-50">
                    <td class="px-4 py-3">
                        <div class="flex items-center">
                            <img src="${u.picture_url || '/static/logo.png'}" 
                                class="w-10 h-10 rounded-full mr-3" 
                                onerror="this.src='/static/logo.png'">
                            <div>
                                <div class="font-medium text-gray-900">${escapeHtml(u.display_name || '未命名')}</div>
                                <div class="text-xs text-gray-500">ID: ${u.id}</div>
                            </div>
                        </div>
                    </td>
                    <td class="px-4 py-3 text-sm text-gray-500 hidden md:table-cell">
                        ${escapeHtml(u.email || '-')}
                    </td>
                    <td class="px-4 py-3">
                        <div class="flex flex-wrap gap-1">
                            ${u.is_admin ? '<span class="px-2 py-0.5 text-xs rounded-full bg-blue-100 text-blue-800">管理員</span>' : ''}
                            ${u.is_blocked ? '<span class="px-2 py-0.5 text-xs rounded-full bg-red-100 text-red-800">已封鎖</span>' : '<span class="px-2 py-0.5 text-xs rounded-full bg-green-100 text-green-800">正常</span>'}
                        </div>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="px-2 py-1 text-sm font-medium rounded-full bg-purple-100 text-purple-700">${u.login_count || 0}</span>
                    </td>
                    <td class="px-4 py-3 text-sm text-gray-500 hidden md:table-cell">
                        ${formatDate(u.last_login)}
                    </td>
                    <td class="px-4 py-3">
                        <div class="flex gap-1">
                            <button onclick="showUserDetail(${u.id})" 
                                class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 rounded">詳情</button>
                            ${u.is_blocked 
                                ? `<button onclick="unblockUser(${u.id})" class="px-2 py-1 text-xs bg-green-100 hover:bg-green-200 text-green-700 rounded">解封</button>`
                                : `<button onclick="blockUser(${u.id})" class="px-2 py-1 text-xs bg-red-100 hover:bg-red-200 text-red-700 rounded">封鎖</button>`
                            }
                            <button onclick="kickUser(${u.id})" 
                                class="px-2 py-1 text-xs bg-yellow-100 hover:bg-yellow-200 text-yellow-700 rounded">踢出</button>
                        </div>
                    </td>
                </tr>
            `).join('');
        }

        // 顯示用戶詳情
        async function showUserDetail(userId) {
            const data = await apiRequest(`/api/admin/users/${userId}`);
            if (data && data.success) {
                const u = data.user;
                const logs = data.recent_logs;
                
                document.getElementById('modalContent').innerHTML = `
                    <div class="flex items-center mb-4">
                        <img src="${u.picture_url || '/static/logo.png'}" 
                            class="w-16 h-16 rounded-full mr-4"
                            onerror="this.src='/static/logo.png'">
                        <div>
                            <div class="font-bold text-xl">${escapeHtml(u.display_name || '未命名')}</div>
                            <div class="text-gray-500">${escapeHtml(u.email || '無 Email')}</div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div class="bg-gray-50 p-3 rounded">
                            <div class="text-xs text-gray-500">用戶 ID</div>
                            <div class="font-medium">${u.id}</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded">
                            <div class="text-xs text-gray-500">LINE ID</div>
                            <div class="font-medium text-xs break-all">${u.line_user_id}</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded">
                            <div class="text-xs text-gray-500">註冊時間</div>
                            <div class="font-medium">${formatDate(u.created_at)}</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded">
                            <div class="text-xs text-gray-500">最後登入</div>
                            <div class="font-medium">${formatDate(u.last_login)}</div>
                        </div>
                    </div>
                    
                    <div class="flex gap-2 mb-4">
                        ${u.is_admin 
                            ? `<button onclick="removeAdmin(${u.id})" class="flex-1 py-2 bg-gray-200 hover:bg-gray-300 rounded">移除管理員</button>`
                            : `<button onclick="setAdmin(${u.id})" class="flex-1 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded">設為管理員</button>`
                        }
                        ${u.is_blocked 
                            ? `<button onclick="unblockUser(${u.id})" class="flex-1 py-2 bg-green-500 hover:bg-green-600 text-white rounded">解除封鎖</button>`
                            : `<button onclick="blockUser(${u.id})" class="flex-1 py-2 bg-red-500 hover:bg-red-600 text-white rounded">封鎖用戶</button>`
                        }
                    </div>
                    
                    ${u.is_blocked ? `
                        <div class="bg-red-50 p-3 rounded mb-4">
                            <div class="text-red-800 font-medium">封鎖資訊</div>
                            <div class="text-sm text-red-600">原因：${escapeHtml(u.blocked_reason || '未說明')}</div>
                            <div class="text-sm text-red-600">時間：${formatDate(u.blocked_at)}</div>
                        </div>
                    ` : ''}
                    
                    <div class="border-t pt-4">
                        <div class="font-medium mb-2">最近活動記錄</div>
                        <div class="max-h-48 overflow-y-auto">
                            ${logs.length ? logs.map(log => `
                                <div class="flex justify-between py-1 text-sm border-b">
                                    <span class="text-gray-600">${getActionText(log.action)}</span>
                                    <span class="text-gray-400">${formatDate(log.created_at)}</span>
                                </div>
                            `).join('') : '<div class="text-gray-400 text-sm">無記錄</div>'}
                        </div>
                    </div>
                `;
                
                document.getElementById('userModal').classList.remove('hidden');
                document.getElementById('userModal').classList.add('flex');
            }
        }

        function closeModal() {
            document.getElementById('userModal').classList.add('hidden');
            document.getElementById('userModal').classList.remove('flex');
        }

        // 操作函數
        async function blockUser(userId) {
            const reason = prompt('請輸入封鎖原因（可留空）：');
            if (reason === null) return;
            
            const data = await apiRequest(`/api/admin/users/${userId}/block?reason=${encodeURIComponent(reason)}`, {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
                loadUsers();
                loadStats();
                closeModal();
            }
        }

        async function unblockUser(userId) {
            if (!confirm('確定要解除封鎖此用戶嗎？')) return;
            
            const data = await apiRequest(`/api/admin/users/${userId}/unblock`, {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
                loadUsers();
                loadStats();
                closeModal();
            }
        }

        async function kickUser(userId) {
            if (!confirm('確定要踢出此用戶嗎？用戶需要重新登入。')) return;
            
            const data = await apiRequest(`/api/admin/users/${userId}/kick`, {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
            }
        }

        async function kickAllUsers() {
            if (!confirm('⚠️ 確定要踢出所有用戶嗎？所有人（包括您自己）都需要重新登入！')) return;
            if (!confirm('再次確認：這將使所有登入 Token 失效！')) return;
            
            const data = await apiRequest('/api/admin/kick-all', {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
                localStorage.clear();
                window.location.href = '/static/index.html';
            }
        }

        async function setAdmin(userId) {
            if (!confirm('確定要將此用戶設為管理員嗎？')) return;
            
            const data = await apiRequest(`/api/admin/users/${userId}/set-admin`, {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
                loadUsers();
                loadStats();
                closeModal();
            }
        }

        async function removeAdmin(userId) {
            if (!confirm('確定要移除此用戶的管理員權限嗎？')) return;
            
            const data = await apiRequest(`/api/admin/users/${userId}/remove-admin`, {
                method: 'POST'
            });
            if (data && data.success) {
                alert(data.message);
                loadUsers();
                loadStats();
                closeModal();
            }
        }

        function changePage(delta) {
            currentPage += delta;
            loadUsers();
        }

        // 工具函數
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatDate(dateStr) {
            if (!dateStr) return '-';
            const date = new Date(dateStr);
            return date.toLocaleString('zh-TW', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function getActionText(action) {
            const actions = {
                'login': '🔑 登入',
                'logout': '🚪 登出',
                'blocked': '🚫 被封鎖',
                'unblocked': '✅ 解除封鎖',
                'kicked': '👢 被踢出',
                'kick_all': '👢 全員踢出',
            };
            return actions[action] || action;
        }
        
        // ===== 市場資料管理 =====
        
        function showSystemMessage(msg, isError = false) {
            const el = document.getElementById('systemMessage');
            el.textContent = msg;
            el.className = `mt-3 text-sm ${isError ? 'text-red-600' : 'text-green-600'}`;
        }
        
        async function initializeData() {
            if (!confirm('這會初始化三大指數歷史資料（10年）和幣圈情緒歷史（365天），可能需要幾分鐘。確定要執行嗎？')) {
                return;
            }
            
            showSystemMessage('正在初始化資料，請稍候...');
            
            try {
                const data = await apiRequest('/api/market/admin/initialize', { method: 'POST' });
                if (data && data.success) {
                    showSystemMessage(`✅ 初始化完成！指數: ${data.data?.indices || 0} 筆, 情緒: ${data.data?.sentiment || 0} 筆`);
                } else {
                    showSystemMessage(`❌ 初始化失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSystemMessage(`❌ 初始化失敗: ${e.message}`, true);
            }
        }
        
        async function updateIndices() {
            showSystemMessage('正在更新三大指數...');
            
            try {
                const data = await apiRequest('/api/market/admin/update-indices', { method: 'POST' });
                if (data && data.success) {
                    showSystemMessage(`✅ 三大指數更新完成！${data.data?.count || 0} 筆資料`);
                } else {
                    showSystemMessage(`❌ 更新失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSystemMessage(`❌ 更新失敗: ${e.message}`, true);
            }
        }
        
        async function updateSentiment() {
            showSystemMessage('正在更新恐懼貪婪指數...');
            
            try {
                const data = await apiRequest('/api/market/admin/update-sentiment', { method: 'POST' });
                if (data && data.success) {
                    showSystemMessage(`✅ 恐懼貪婪指數更新完成！`);
                } else {
                    showSystemMessage(`❌ 更新失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSystemMessage(`❌ 更新失敗: ${e.message}`, true);
            }
        }
        
        async function triggerDailyUpdate() {
            showSystemMessage('正在執行每日更新...');
            
            try {
                const data = await apiRequest('/api/market/admin/update', { method: 'POST' });
                if (data && data.success) {
                    showSystemMessage(`✅ 每日更新完成！`);
                } else {
                    showSystemMessage(`❌ 更新失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSystemMessage(`❌ 更新失敗: ${e.message}`, true);
            }
        }

        // ========== 訊號檢查相關 ==========
        
        function showSignalMessage(msg, isError = false) {
            const el = document.getElementById('signalMessage');
            el.textContent = msg;
            el.className = isError ? 'mt-3 text-sm text-red-500' : 'mt-3 text-sm text-gray-500';
        }

        async function runSignalCheck() {
            showSignalMessage('正在執行訊號檢查...');
            document.getElementById('signalResult').classList.add('hidden');
            
            try {
                const data = await apiRequest('/api/admin/signal/detect', { method: 'POST' });
                if (data && data.success) {
                    showSignalMessage(`✅ 檢查完成：偵測到 ${data.total_signals} 個訊號`);
                    
                    if (data.signals_by_symbol && Object.keys(data.signals_by_symbol).length > 0) {
                        document.getElementById('signalResult').classList.remove('hidden');
                        document.getElementById('signalResultContent').textContent = 
                            JSON.stringify(data.signals_by_symbol, null, 2);
                    }
                } else {
                    showSignalMessage(`❌ 檢查失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSignalMessage(`❌ 檢查失敗: ${e.message}`, true);
            }
        }

        async function sendSignalNotifications() {
            showSignalMessage('正在發送訊號通知...');
            
            try {
                const data = await apiRequest('/api/admin/signal/notify', { method: 'POST' });
                if (data && data.success) {
                    const r = data.result || {};
                    showSignalMessage(`✅ ${data.message} - 股票更新: ${r.stocks_updated}, 訊號偵測: ${r.signals_detected}, 通知發送: ${r.notifications_sent}`);
                    
                    if (r.errors && r.errors.length > 0) {
                        document.getElementById('signalResult').classList.remove('hidden');
                        document.getElementById('signalResultContent').textContent = 
                            '錯誤記錄:\n' + r.errors.join('\n');
                    }
                } else {
                    showSignalMessage(`❌ 發送失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSignalMessage(`❌ 發送失敗: ${e.message}`, true);
            }
        }

        async function testSignalDetection() {
            const symbol = document.getElementById('testSymbolInput').value.trim();
            if (!symbol) {
                showSignalMessage('請輸入股票代號', true);
                return;
            }
            
            showSignalMessage(`正在測試 ${symbol.toUpperCase()} 的訊號偵測...`);
            document.getElementById('signalResult').classList.add('hidden');
            
            // 使用 detect API 然後過濾特定股票
            try {
                const data = await apiRequest('/api/admin/signal/detect', { method: 'POST' });
                if (data && data.success) {
                    const symbolUpper = symbol.toUpperCase();
                    const symbolSignals = data.signals_by_symbol[symbolUpper] || [];
                    
                    showSignalMessage(`✅ ${symbolUpper} 偵測到 ${symbolSignals.length} 個訊號`);
                    
                    document.getElementById('signalResult').classList.remove('hidden');
                    document.getElementById('signalResultContent').textContent = 
                        JSON.stringify({ symbol: symbolUpper, signals: symbolSignals }, null, 2);
                } else {
                    showSignalMessage(`❌ 偵測失敗: ${data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSignalMessage(`❌ 偵測失敗: ${e.message}`, true);
            }
        }

        async function testLineNotify() {
            showSignalMessage('正在發送測試訊息...');
            
            try {
                const data = await apiRequest('/api/admin/signal/test-push?message=管理員測試訊息', { method: 'POST' });
                if (data && data.success) {
                    showSignalMessage('✅ 測試訊息已發送，請檢查 LINE');
                } else {
                    showSignalMessage(`❌ 發送失敗: ${data?.message || data?.detail || '未知錯誤'}`, true);
                }
            } catch (e) {
                showSignalMessage(`❌ 發送失敗: ${e.message}`, true);
            }
        }

        // 測試股票輸入框 Enter 鍵支援
        document.getElementById('testSymbolInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') testSignalDetection();
        });

        // 搜尋 Enter 鍵支援
        document.getElementById('searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') loadUsers();
        });

        // 初始載入
        loadStats();
        loadUsers();
    </script>
</body>
</html>
```

──────────────────────────────────────────────────────────────────────
### 📄 static/compare-nav.js  ⭐
> *
──────────────────────────────────────────────────────────────────────

```js
/**
 * SELA 報酬率比較功能 - 導航連結注入
 * 將此檔案放到 static/ 目錄，並在 dashboard.html 的 </body> 前引入
 * <script src="/static/compare-nav.js"></script>
 */

(function() {
    'use strict';
    
    // 等待 DOM 載入完成
    document.addEventListener('DOMContentLoaded', function() {
        injectCompareLinks();
    });
    
    // 如果 DOM 已經載入完成，直接執行
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(injectCompareLinks, 100);
    }
    
    function injectCompareLinks() {
        // 桌面版側邊欄連結 HTML
        const desktopLinkHTML = `
            <a href="/static/compare.html" class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-gray-50 rounded-lg">
                <i class="fas fa-chart-bar mr-3"></i>
                <span>報酬率比較</span>
            </a>
        `;
        
        // 手機版側邊欄連結 HTML
        const mobileLinkHTML = `
            <a href="/static/compare.html" class="mobile-nav-link flex items-center px-4 py-3 text-gray-600 hover:bg-gray-50 rounded-lg touch-target">
                <i class="fas fa-chart-bar mr-3 w-6"></i>
                <span>報酬率比較</span>
            </a>
        `;
        
        // 找到「設定」連結並在其後插入
        // 桌面版
        const desktopSettingsLinks = document.querySelectorAll('a.nav-link');
        desktopSettingsLinks.forEach(function(link) {
            if (link.textContent.includes('設定') && !link.nextElementSibling?.textContent?.includes('報酬率')) {
                link.insertAdjacentHTML('afterend', desktopLinkHTML);
            }
        });
        
        // 手機版側邊欄
        const mobileSettingsLinks = document.querySelectorAll('a.mobile-nav-link');
        mobileSettingsLinks.forEach(function(link) {
            if (link.textContent.includes('設定') && !link.nextElementSibling?.textContent?.includes('報酬率')) {
                link.insertAdjacentHTML('afterend', mobileLinkHTML);
            }
        });
        
        // 也可以在儀表板區域加入快捷入口
        addDashboardQuickAccess();
        
        console.log('✅ 報酬率比較連結已注入');
    }
    
    function addDashboardQuickAccess() {
        // 找到儀表板區塊
        const dashboardSection = document.getElementById('section-dashboard');
        if (!dashboardSection) return;
        
        // 檢查是否已經有快捷入口
        if (dashboardSection.querySelector('.compare-quick-access')) return;
        
        // 在儀表板開頭加入快捷卡片
        const quickAccessHTML = `
            <div class="compare-quick-access bg-gradient-to-r from-indigo-500 to-purple-600 rounded-xl shadow-lg p-4 mb-6 text-white">
                <div class="flex items-center justify-between">
                    <div>
                        <h3 class="font-bold text-lg">🏆 報酬率比較</h3>
                        <p class="text-indigo-100 text-sm">比較股票、加密貨幣的年化報酬</p>
                    </div>
                    <a href="/static/compare.html" 
                       class="px-4 py-2 bg-white text-indigo-600 rounded-lg font-medium hover:bg-indigo-50 transition">
                        立即比較 →
                    </a>
                </div>
            </div>
        `;
        
        // 找到第一個子元素並在前面插入
        const firstChild = dashboardSection.querySelector('h2');
        if (firstChild && firstChild.nextElementSibling) {
            firstChild.nextElementSibling.insertAdjacentHTML('beforebegin', quickAccessHTML);
        }
    }
})();
```

──────────────────────────────────────────────────────────────────────
### 📄 static/compare.html  ⭐
──────────────────────────────────────────────────────────────────────

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>報酬率比較 - SELA 自動選股系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="icon" type="image/png" href="/static/logo.png">
    <style>
        :root {
            --brand-orange: #FA7A35;
        }
        .brand-orange { background-color: var(--brand-orange); }
        .brand-orange:hover { background-color: #e86a25; }
        .brand-text { color: var(--brand-orange); }
        .brand-border { border-color: var(--brand-orange); }
        
        .cagr-positive { color: #16a34a; }
        .cagr-negative { color: #dc2626; }
        .cagr-neutral { color: #6b7280; }
        
        .rank-1 { background: linear-gradient(135deg, #ffd700 0%, #ffec8b 100%); }
        .rank-2 { background: linear-gradient(135deg, #c0c0c0 0%, #e8e8e8 100%); }
        .rank-3 { background: linear-gradient(135deg, #cd7f32 0%, #daa06d 100%); }
        
        .loading { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .symbol-tag {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            background: #f3f4f6;
            border-radius: 9999px;
            margin: 0.25rem;
        }
        .symbol-tag button {
            margin-left: 0.5rem;
            color: #9ca3af;
        }
        .symbol-tag button:hover {
            color: #ef4444;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <!-- 頂部導航 -->
    <nav class="bg-slate-800 text-white shadow-lg">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center space-x-4">
                    <a href="/static/dashboard.html" class="flex items-center space-x-2">
                        <img src="/static/logo.png" alt="SELA" class="w-10 h-10 rounded-lg">
                        <span class="font-bold text-xl">SELA</span>
                    </a>
                    <span class="text-gray-400">|</span>
                    <span class="text-lg">📊 報酬率比較</span>
                </div>
                <div class="flex items-center space-x-4">
                    <a href="/static/dashboard.html" class="text-gray-300 hover:text-white">
                        ← 返回儀表板
                    </a>
                    <span id="userName" class="text-gray-300"></span>
                </div>
            </div>
        </div>
    </nav>

    <!-- 主內容 -->
    <div class="max-w-7xl mx-auto px-4 py-6">
        <!-- 說明卡片 -->
        <div class="bg-gradient-to-r from-blue-600 to-indigo-600 rounded-xl shadow-lg p-6 mb-6 text-white">
            <h1 class="text-2xl font-bold mb-2">🏆 年化報酬率 (CAGR) 比較器</h1>
            <p class="text-blue-100">比較股票、加密貨幣、指數的長期投資報酬表現，找出最佳投資標的</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- 左側：選擇標的 -->
            <div class="lg:col-span-1 space-y-4">
                <!-- 快速選擇預設組合 -->
                <div class="bg-white rounded-xl shadow p-4">
                    <h3 class="font-bold text-gray-700 mb-3">🚀 快速比較</h3>
                    <div class="space-y-2" id="presetList">
                        <p class="text-gray-400 text-sm">載入中...</p>
                    </div>
                </div>

                <!-- 自訂標的 -->
                <div class="bg-white rounded-xl shadow p-4">
                    <h3 class="font-bold text-gray-700 mb-3">✏️ 自訂比較</h3>
                    
                    <!-- 已選標的 -->
                    <div class="mb-3">
                        <label class="text-sm text-gray-500 mb-1 block">已選標的 (最多5個)</label>
                        <div id="selectedSymbols" class="min-h-[40px] p-2 bg-gray-50 rounded-lg flex flex-wrap">
                            <span class="text-gray-400 text-sm">尚未選擇</span>
                        </div>
                    </div>
                    
                    <!-- 輸入框 -->
                    <div class="flex gap-2 mb-3">
                        <input type="text" id="symbolInput" placeholder="輸入代號 (如 AAPL, BTC)"
                            class="flex-1 px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400"
                            onkeypress="if(event.key==='Enter') addSymbol()">
                        <button onclick="addSymbol()" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    
                    <!-- 時間週期 -->
                    <div class="mb-3">
                        <label class="text-sm text-gray-500 mb-1 block">比較週期</label>
                        <div class="flex flex-wrap gap-2">
                            <label class="flex items-center">
                                <input type="checkbox" class="period-check mr-1" value="1y" checked> 1年
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" class="period-check mr-1" value="3y" checked> 3年
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" class="period-check mr-1" value="5y" checked> 5年
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" class="period-check mr-1" value="10y"> 10年
                            </label>
                        </div>
                    </div>
                    
                    <!-- 基準指數 -->
                    <div class="mb-4">
                        <label class="text-sm text-gray-500 mb-1 block">基準指數</label>
                        <select id="benchmarkSelect" class="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                            <option value="^GSPC">S&P 500</option>
                            <option value="^IXIC">納斯達克</option>
                            <option value="^DJI">道瓊工業</option>
                            <option value="">無</option>
                        </select>
                    </div>
                    
                    <!-- 排序 -->
                    <div class="mb-4">
                        <label class="text-sm text-gray-500 mb-1 block">排序依據</label>
                        <select id="sortBySelect" class="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                            <option value="1y">1年報酬率</option>
                            <option value="3y">3年報酬率</option>
                            <option value="5y" selected>5年報酬率</option>
                            <option value="10y">10年報酬率</option>
                        </select>
                    </div>
                    
                    <!-- 執行比較按鈕 -->
                    <button onclick="runComparison()" id="compareBtn"
                        class="w-full py-3 brand-orange text-white rounded-lg font-bold hover:opacity-90 transition disabled:opacity-50 disabled:cursor-not-allowed">
                        <i class="fas fa-chart-bar mr-2"></i>開始比較
                    </button>
                </div>
                
                <!-- 我的組合 -->
                <div class="bg-white rounded-xl shadow p-4">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-gray-700">💾 我的組合</h3>
                        <button onclick="saveCurrentComparison()" class="text-blue-600 hover:text-blue-800 text-sm">
                            <i class="fas fa-save mr-1"></i>儲存目前
                        </button>
                    </div>
                    <div id="savedComparisons" class="space-y-2">
                        <p class="text-gray-400 text-sm">登入後可儲存組合</p>
                    </div>
                </div>
            </div>

            <!-- 右側：比較結果 -->
            <div class="lg:col-span-2">
                <div class="bg-white rounded-xl shadow p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="font-bold text-gray-700 text-lg">📊 比較結果</h3>
                        <span id="resultTime" class="text-sm text-gray-400"></span>
                    </div>
                    
                    <div id="comparisonResult">
                        <div class="text-center py-12 text-gray-400">
                            <i class="fas fa-chart-line text-6xl mb-4"></i>
                            <p>選擇標的後點擊「開始比較」</p>
                            <p class="text-sm mt-2">或使用左側的快速比較預設組合</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast 通知 -->
    <div id="toast" class="fixed bottom-4 right-4 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg hidden transition-opacity z-50">
        <span id="toastMessage"></span>
    </div>

    <script>
        const API_BASE = '';
        const token = localStorage.getItem('token');
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        
        // 選中的標的
        let selectedSymbols = [];
        
        // 檢查登入
        if (token && user.display_name) {
            document.getElementById('userName').textContent = user.display_name;
        }
        
        // ==================== 預設組合 ====================
        async function loadPresets() {
            try {
                const res = await fetch(`${API_BASE}/api/compare/presets`);
                const data = await res.json();
                
                if (data.success) {
                    const container = document.getElementById('presetList');
                    container.innerHTML = data.presets.map(preset => `
                        <button onclick="quickCompare('${preset.id}')" 
                            class="w-full text-left px-3 py-2 rounded-lg hover:bg-gray-100 transition flex justify-between items-center">
                            <span>${preset.name}</span>
                            <span class="text-xs text-gray-400">${preset.count}個</span>
                        </button>
                    `).join('');
                }
            } catch (e) {
                console.error('載入預設組合失敗', e);
            }
        }
        
        async function quickCompare(presetId) {
            showLoading();
            try {
                const benchmark = document.getElementById('benchmarkSelect').value;
                const sortBy = document.getElementById('sortBySelect').value;
                
                const res = await fetch(`${API_BASE}/api/compare/quick/${presetId}?benchmark=${benchmark}&sort_by=${sortBy}`);
                const data = await res.json();
                
                if (data.success) {
                    // 更新選中的標的
                    if (data.preset && data.preset.symbols) {
                        selectedSymbols = data.preset.symbols;
                        renderSelectedSymbols();
                    }
                    renderResult(data);
                } else {
                    showToast('比較失敗：' + (data.error || '未知錯誤'));
                }
            } catch (e) {
                showToast('比較失敗：' + e.message);
            }
        }
        
        // ==================== 標的選擇 ====================
        function addSymbol() {
            const input = document.getElementById('symbolInput');
            const symbol = input.value.trim().toUpperCase();
            
            if (!symbol) return;
            
            if (selectedSymbols.length >= 5) {
                showToast('最多只能選擇 5 個標的');
                return;
            }
            
            if (selectedSymbols.includes(symbol)) {
                showToast('已經選擇過此標的');
                return;
            }
            
            selectedSymbols.push(symbol);
            renderSelectedSymbols();
            input.value = '';
        }
        
        function removeSymbol(symbol) {
            selectedSymbols = selectedSymbols.filter(s => s !== symbol);
            renderSelectedSymbols();
        }
        
        function renderSelectedSymbols() {
            const container = document.getElementById('selectedSymbols');
            
            if (selectedSymbols.length === 0) {
                container.innerHTML = '<span class="text-gray-400 text-sm">尚未選擇</span>';
                return;
            }
            
            container.innerHTML = selectedSymbols.map(symbol => `
                <span class="symbol-tag">
                    ${symbol}
                    <button onclick="removeSymbol('${symbol}')" title="移除">
                        <i class="fas fa-times"></i>
                    </button>
                </span>
            `).join('');
        }
        
        // ==================== 執行比較 ====================
        async function runComparison() {
            if (selectedSymbols.length === 0) {
                showToast('請至少選擇一個標的');
                return;
            }
            
            showLoading();
            
            // 取得勾選的週期
            const periods = Array.from(document.querySelectorAll('.period-check:checked'))
                .map(cb => cb.value);
            
            if (periods.length === 0) {
                showToast('請至少選擇一個時間週期');
                return;
            }
            
            const benchmark = document.getElementById('benchmarkSelect').value;
            const sortBy = document.getElementById('sortBySelect').value;
            
            try {
                const res = await fetch(`${API_BASE}/api/compare/cagr`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(token ? { 'Authorization': `Bearer ${token}` } : {})
                    },
                    body: JSON.stringify({
                        symbols: selectedSymbols,
                        periods: periods,
                        benchmark: benchmark,
                        sort_by: sortBy,
                        sort_order: 'desc'
                    })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    renderResult(data);
                } else {
                    showToast('比較失敗：' + (data.detail || data.error || '未知錯誤'));
                    document.getElementById('comparisonResult').innerHTML = `
                        <div class="text-center py-8 text-red-500">
                            <i class="fas fa-exclamation-circle text-4xl mb-2"></i>
                            <p>${data.detail || data.error || '比較失敗'}</p>
                        </div>
                    `;
                }
            } catch (e) {
                showToast('比較失敗：' + e.message);
            }
        }
        
        function showLoading() {
            document.getElementById('comparisonResult').innerHTML = `
                <div class="text-center py-12">
                    <i class="fas fa-spinner fa-spin text-4xl text-blue-500 mb-4"></i>
                    <p class="text-gray-500">正在計算報酬率...</p>
                    <p class="text-gray-400 text-sm mt-1">首次查詢可能需要較長時間</p>
                </div>
            `;
        }
        
        // ==================== 渲染結果 ====================
        function renderResult(data) {
            const container = document.getElementById('comparisonResult');
            const periods = data.periods || ['1y', '3y', '5y'];
            
            // 更新時間
            if (data.generated_at) {
                const time = new Date(data.generated_at).toLocaleString('zh-TW');
                document.getElementById('resultTime').textContent = `更新：${time}`;
            }
            
            // 建立表格
            let html = `
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead>
                            <tr class="bg-gray-50">
                                <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">排名</th>
                                <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">標的</th>
                                <th class="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase">現價</th>
                                ${periods.map(p => `
                                    <th class="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase">${formatPeriod(p)}</th>
                                `).join('')}
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
            `;
            
            data.comparison.forEach((item, index) => {
                const rankClass = index === 0 ? 'rank-1' : index === 1 ? 'rank-2' : index === 2 ? 'rank-3' : '';
                const rankIcon = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}`;
                const typeIcon = item.type === 'crypto' ? '🪙' : item.type === 'index' ? '📈' : '📊';
                
                html += `
                    <tr class="hover:bg-gray-50">
                        <td class="px-4 py-4">
                            <span class="inline-flex items-center justify-center w-8 h-8 rounded-full ${rankClass} font-bold text-sm">
                                ${rankIcon}
                            </span>
                        </td>
                        <td class="px-4 py-4">
                            <div class="flex items-center">
                                <span class="mr-2">${typeIcon}</span>
                                <div>
                                    <div class="font-medium text-gray-900">${item.symbol}</div>
                                    <div class="text-xs text-gray-500">${item.name || ''}</div>
                                </div>
                            </div>
                        </td>
                        <td class="px-4 py-4 text-right">
                            ${item.current_price ? `$${formatNumber(item.current_price)}` : '--'}
                        </td>
                        ${periods.map(p => {
                            const cagr = item.cagr ? item.cagr[p] : null;
                            const vsBench = item.vs_benchmark ? item.vs_benchmark[p] : null;
                            return `
                                <td class="px-4 py-4 text-right">
                                    ${formatCAGR(cagr)}
                                    ${vsBench !== null && vsBench !== undefined ? `
                                        <div class="text-xs ${vsBench >= 0 ? 'text-green-600' : 'text-red-600'}">
                                            ${vsBench >= 0 ? '+' : ''}${vsBench.toFixed(1)}%
                                        </div>
                                    ` : ''}
                                </td>
                            `;
                        }).join('')}
                    </tr>
                `;
            });
            
            html += '</tbody></table></div>';
            
            // 基準指數資訊
            if (data.benchmark) {
                html += `
                    <div class="mt-4 p-3 bg-gray-50 rounded-lg">
                        <span class="text-sm text-gray-500">📌 基準指數：</span>
                        <span class="font-medium">${data.benchmark.name} (${data.benchmark.symbol})</span>
                        <span class="ml-4 text-sm text-gray-500">
                            ${periods.map(p => `${formatPeriod(p)}: ${formatCAGR(data.benchmark.cagr[p], true)}`).join(' | ')}
                        </span>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function formatPeriod(period) {
            const map = { '1y': '1年', '3y': '3年', '5y': '5年', '10y': '10年', 'custom': '自訂' };
            return map[period] || period;
        }
        
        function formatCAGR(value, simple = false) {
            if (value === null || value === undefined) {
                return '<span class="text-gray-400">--</span>';
            }
            
            const colorClass = value > 0 ? 'cagr-positive' : value < 0 ? 'cagr-negative' : 'cagr-neutral';
            const sign = value > 0 ? '+' : '';
            
            if (simple) {
                return `<span class="${colorClass}">${sign}${value.toFixed(1)}%</span>`;
            }
            
            return `<span class="${colorClass} font-medium text-lg">${sign}${value.toFixed(1)}%</span>`;
        }
        
        function formatNumber(num) {
            if (num >= 1000) {
                return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }
            return num.toFixed(2);
        }
        
        // ==================== 儲存組合 ====================
        async function saveCurrentComparison() {
            if (!token) {
                showToast('請先登入');
                return;
            }
            
            if (selectedSymbols.length === 0) {
                showToast('請先選擇標的');
                return;
            }
            
            const name = prompt('請輸入組合名稱：');
            if (!name) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/compare/saved`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        name: name,
                        symbols: selectedSymbols,
                        benchmark: document.getElementById('benchmarkSelect').value
                    })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast('組合已儲存');
                    loadSavedComparisons();
                } else {
                    showToast('儲存失敗：' + (data.detail || '未知錯誤'));
                }
            } catch (e) {
                showToast('儲存失敗：' + e.message);
            }
        }
        
        async function loadSavedComparisons() {
            if (!token) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/compare/saved`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await res.json();
                
                if (data.success && data.comparisons.length > 0) {
                    const container = document.getElementById('savedComparisons');
                    container.innerHTML = data.comparisons.map(c => `
                        <div class="flex justify-between items-center p-2 rounded hover:bg-gray-50">
                            <button onclick="loadSavedComparison(${c.id}, ${JSON.stringify(c.symbols).replace(/"/g, '&quot;')})" 
                                class="text-left flex-1">
                                <div class="font-medium text-sm">${c.name}</div>
                                <div class="text-xs text-gray-400">${c.symbols.join(', ')}</div>
                            </button>
                            <button onclick="deleteSavedComparison(${c.id})" class="text-red-400 hover:text-red-600 ml-2">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `).join('');
                }
            } catch (e) {
                console.error('載入儲存組合失敗', e);
            }
        }
        
        function loadSavedComparison(id, symbols) {
            selectedSymbols = symbols;
            renderSelectedSymbols();
            runComparison();
        }
        
        async function deleteSavedComparison(id) {
            if (!confirm('確定要刪除此組合？')) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/compare/saved/${id}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast('已刪除');
                    loadSavedComparisons();
                }
            } catch (e) {
                showToast('刪除失敗');
            }
        }
        
        // ==================== 工具函數 ====================
        function showToast(message) {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.classList.remove('hidden');
            setTimeout(() => toast.classList.add('hidden'), 3000);
        }
        
        // ==================== 初始化 ====================
        loadPresets();
        if (token) {
            loadSavedComparisons();
        }
    </script>
</body>
</html>
```

──────────────────────────────────────────────────────────────────────
### 📄 static/css/settings.css  ⭐
> *
──────────────────────────────────────────────────────────────────────

⚠️ 僅顯示前 150 行

──────────────────────────────────────────────────────────────────────
### 📄 static/dashboard-mobile.html  ⭐
──────────────────────────────────────────────────────────────────────

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SELA 自動選股系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --brand-orange: #FA7A35;
            --brand-orange-hover: #e86a25;
        }
        
        .brand-orange { background-color: var(--brand-orange); }
        .brand-orange:hover { background-color: var(--brand-orange-hover); }
        .brand-text { color: var(--brand-orange); }
        .brand-border { border-color: var(--brand-orange); }
        
        /* 預設隱藏主內容 */
        #app-content { display: none; }
        
        /* 通用動畫 */
        .transition-all { transition: all 0.3s ease; }
        
        /* ===== 電腦版樣式 (預設) ===== */
        .desktop-sidebar { display: block; }
        .mobile-header-menu { display: none; }
        .mobile-bottom-nav { display: none; }
        .mobile-sidebar-overlay { display: none; }
        .mobile-sidebar { transform: translateX(-100%); }
        
        /* ===== 手機版樣式 ===== */
        @media (max-width: 767px) {
            /* 隱藏電腦版側邊欄 */
            .desktop-sidebar { display: none !important; }
            
            /* 主內容區不需要左邊距 */
            .main-content { margin-left: 0 !important; padding-bottom: 70px; }
            
            /* 顯示手機版元素 */
            .mobile-header-menu { display: flex !important; }
            .mobile-bottom-nav { display: flex !important; }
            
            /* 手機版側邊選單 */
            .mobile-sidebar {
                position: fixed;
                top: 0;
                left: 0;
                width: 280px;
                height: 100vh;
                background: white;
                z-index: 1000;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            }
            
            .mobile-sidebar.open { transform: translateX(0); }
            
            .mobile-sidebar-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 999;
                display: none;
                opacity: 0;
                transition: opacity 0.3s ease;
            }
            
            .mobile-sidebar-overlay.open { display: block; opacity: 1; }
            
            /* 加大觸控區域 */
            .touch-target { min-height: 44px; min-width: 44px; }
            
            /* 卡片樣式 */
            .stock-card {
                background: white;
                border-radius: 12px;
                padding: 16px;
                margin-bottom: 12px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            }
            
            /* 摺疊區塊 */
            .collapsible-content {
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease;
            }
            
            .collapsible-content.open { max-height: 500px; }
            
            /* 全螢幕圖表 */
            .chart-fullscreen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: white;
                z-index: 2000;
                display: none;
            }
            
            .chart-fullscreen.open { display: block; }
            
            /* 強制橫向提示 */
            .rotate-hint {
                display: none;
            }
            
            @media (orientation: portrait) {
                .chart-fullscreen .rotate-hint { display: flex; }
                .chart-fullscreen .chart-container { display: none; }
            }
            
            @media (orientation: landscape) {
                .chart-fullscreen .rotate-hint { display: none; }
                .chart-fullscreen .chart-container { display: block; }
            }
        }
        
        /* 底部導航列 */
        .mobile-bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: white;
            border-top: 1px solid #e5e7eb;
            z-index: 100;
            display: none;
            justify-content: space-around;
            align-items: center;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .bottom-nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            padding: 8px 0;
            color: #6b7280;
            text-decoration: none;
            font-size: 10px;
            transition: color 0.2s;
        }
        
        .bottom-nav-item.active { color: var(--brand-orange); }
        .bottom-nav-item i { font-size: 20px; margin-bottom: 2px; }
        
        /* 載入動畫 */
        .loading { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- 載入畫面 -->
    <div id="loading-screen" class="fixed inset-0 bg-gradient-to-br from-slate-900 to-slate-800 flex items-center justify-center z-50">
        <div class="text-center">
            <img src="/static/logo.png" alt="SELA" class="w-24 h-24 mx-auto mb-4 rounded-xl">
            <p class="text-white text-lg">載入中...</p>
            <i class="fas fa-spinner fa-spin text-white text-2xl mt-4"></i>
        </div>
    </div>

    <!-- 主應用程式內容 -->
    <div id="app-content">
        
        <!-- ===== 手機版側邊選單遮罩 ===== -->
        <div id="sidebarOverlay" class="mobile-sidebar-overlay" onclick="closeMobileSidebar()"></div>
        
        <!-- ===== 手機版側邊選單 ===== -->
        <aside id="mobileSidebar" class="mobile-sidebar">
            <div class="p-4 border-b flex items-center justify-between">
                <div class="flex items-center">
                    <img src="/static/logo.png" alt="SELA" class="w-10 h-10 rounded-lg mr-2">
                    <span class="font-bold text-lg">SELA</span>
                </div>
                <button onclick="closeMobileSidebar()" class="p-2 text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <nav class="p-4 space-y-2">
                <a href="#" onclick="mobileNavTo('dashboard')" class="mobile-nav-link flex items-center px-4 py-3 text-gray-700 bg-blue-50 rounded-lg touch-target" data-section="dashboard">
                    <i class="fas fa-tachometer-alt mr-3 w-5"></i>
                    <span>儀表板</span>
                </a>
                <a href="#" onclick="mobileNavTo('search')" class="mobile-nav-link flex items-center px-4 py-3 text-gray-600 hover:bg-gray-50 rounded-lg touch-target" data-section="search">
                    <i class="fas fa-search mr-3 w-5"></i>
                    <span>股票查詢</span>
                </a>
                <a href="#" onclick="mobileNavTo('watchlist')" class="mobile-nav-link flex items-center px-4 py-3 text-gray-600 hover:bg-gray-50 rounded-lg touch-target" data-section="watchlist">
                    <i class="fas fa-star mr-3 w-5"></i>
                    <span>追蹤清單</span>
                </a>
                <a href="#" onclick="mobileNavTo('sentiment')" class="mobile-nav-link flex items-center px-4 py-3 text-gray-600 hover:bg-gray-50 rounded-lg touch-target" data-section="sentiment">
                    <i class="fas fa-heart-pulse mr-3 w-5"></i>
                    <span>市場情緒</span>
                </a>
                <a href="#" onclick="mobileNavTo('settings')" class="mobile-nav-link flex items-center px-4 py-3 text-gray-600 hover:bg-gray-50 rounded-lg touch-target" data-section="settings">
                    <i class="fas fa-cog mr-3 w-5"></i>
                    <span>設定</span>
                </a>
            </nav>
            <div class="absolute bottom-0 left-0 right-0 p-4 border-t">
                <div class="flex items-center justify-between mb-3">
                    <div class="flex items-center">
                        <img id="sidebarAvatar" class="w-10 h-10 rounded-full mr-3" src="" alt="">
                        <span id="sidebarUserName" class="text-gray-700 font-medium"></span>
                    </div>
                </div>
                <div class="text-xs text-gray-400 mb-2">
                    閒置登出: <span id="sidebarTimer">5:00</span>
                </div>
                <button onclick="logout()" class="w-full py-2 text-red-500 hover:bg-red-50 rounded-lg flex items-center justify-center touch-target">
                    <i class="fas fa-sign-out-alt mr-2"></i>
                    <span>登出</span>
                </button>
            </div>
        </aside>
        
        <!-- ===== 頂部導覽列 ===== -->
        <nav class="bg-white shadow-sm border-b fixed w-full z-50 top-0">
            <div class="px-4 h-14 flex items-center justify-between">
                <!-- 手機版: 漢堡選單按鈕 -->
                <button onclick="openMobileSidebar()" class="mobile-header-menu p-2 -ml-2 text-gray-600 touch-target">
                    <i class="fas fa-bars text-xl"></i>
                </button>
                
                <!-- Logo -->
                <div class="flex items-center">
                    <img src="/static/logo.png" alt="SELA" class="w-8 h-8 rounded-lg mr-2">
                    <span class="font-bold text-lg text-gray-800 hidden sm:inline">自動選股系統</span>
                    <span class="font-bold text-lg text-gray-800 sm:hidden">SELA</span>
                </div>
                
                <!-- 右側資訊 -->
                <div class="flex items-center space-x-2">
                    <span id="sessionTimer" class="text-xs text-gray-400 hidden sm:inline"></span>
                    <span id="userName" class="text-gray-600 text-sm hidden md:inline"></span>
                    <img id="userAvatar" class="w-8 h-8 rounded-full" src="" alt="">
                    <button onclick="logout()" class="text-gray-500 hover:text-red-500 hidden sm:inline p-2" title="登出">
                        <i class="fas fa-sign-out-alt"></i>
                    </button>
                </div>
            </div>
        </nav>

        <!-- ===== 電腦版側邊欄 ===== -->
        <aside class="desktop-sidebar w-64 bg-white shadow-sm min-h-screen fixed top-14">
            <nav class="p-4 space-y-2">
                <a href="#" onclick="showSection('dashboard', event)" class="nav-link flex items-center px-4 py-2 text-gray-700 bg-blue-50 rounded-lg" data-section="dashboard">
                    <i class="fas fa-tachometer-alt mr-3"></i>
                    <span>儀表板</span>
                </a>
                <a href="#" onclick="showSection('search', event)" class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-gray-50 rounded-lg" data-section="search">
                    <i class="fas fa-search mr-3"></i>
                    <span>股票查詢</span>
                </a>
                <a href="#" onclick="showSection('watchlist', event)" class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-gray-50 rounded-lg" data-section="watchlist">
                    <i class="fas fa-star mr-3"></i>
                    <span>追蹤清單</span>
                </a>
                <a href="#" onclick="showSection('sentiment', event)" class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-gray-50 rounded-lg" data-section="sentiment">
                    <i class="fas fa-heart-pulse mr-3"></i>
                    <span>市場情緒</span>
                </a>
                <a href="#" onclick="showSection('settings', event)" class="nav-link flex items-center px-4 py-2 text-gray-600 hover:bg-gray-50 rounded-lg" data-section="settings">
                    <i class="fas fa-cog mr-3"></i>
                    <span>設定</span>
                </a>
            </nav>
        </aside>

        <!-- ===== 主區域 ===== -->
        <main class="main-content md:ml-64 pt-14 p-4 md:p-6 min-h-screen">
            
            <!-- ===== 儀表板區塊 ===== -->
            <section id="section-dashboard" class="section">
                <h2 class="text-xl md:text-2xl font-bold text-gray-800 mb-4 md:mb-6">儀表板</h2>
                
                <!-- 市場情緒卡片 -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6 mb-4 md:mb-6">
                    <!-- 美股情緒 -->
                    <div class="bg-white rounded-xl shadow p-4 md:p-6">
                        <div class="flex items-center justify-between mb-3 md:mb-4">
                            <h3 class="font-semibold text-gray-700 text-sm md:text-base">美股情緒指數</h3>
                            <span id="stockSentimentBadge" class="px-2 md:px-3 py-1 rounded-full text-xs md:text-sm font-medium"></span>
                        </div>
                        <div class="flex items-center">
                            <span id="stockSentimentValue" class="text-3xl md:text-4xl font-bold text-gray-800">--</span>
                            <span class="text-gray-500 ml-2 text-sm">/ 100</span>
                        </div>
                        <div class="mt-3 md:mt-4 bg-gray-200 rounded-full h-2 md:h-3">
                            <div id="stockSentimentBar" class="h-2 md:h-3 rounded-full transition-all" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <!-- 幣圈情緒 -->
                    <div class="bg-white rounded-xl shadow p-4 md:p-6">
                        <div class="flex items-center justify-between mb-3 md:mb-4">
                            <h3 class="font-semibold text-gray-700 text-sm md:text-base">幣圈情緒指數</h3>
                            <span id="cryptoSentimentBadge" class="px-2 md:px-3 py-1 rounded-full text-xs md:text-sm font-medium"></span>
                        </div>
                        <div class="flex items-center">
                            <span id="cryptoSentimentValue" class="text-3xl md:text-4xl font-bold text-gray-800">--</span>
                            <span class="text-gray-500 ml-2 text-sm">/ 100</span>
                        </div>
                        <div class="mt-3 md:mt-4 bg-gray-200 rounded-full h-2 md:h-3">
                            <div id="cryptoSentimentBar" class="h-2 md:h-3 rounded-full transition-all" style="width: 0%"></div>
                        </div>
                    </div>
                </div>

                <!-- 追蹤清單快覽 -->
                <div class="bg-white rounded-xl shadow p-4 md:p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="font-semibold text-gray-700">追蹤清單</h3>
                        <a href="#" onclick="showSection('watchlist')" class="text-blue-600 text-sm hover:underline">查看全部</a>
                    </div>
                    <div id="dashboardWatchlist">
                        <p class="text-gray-500 text-center py-4">載入中...</p>
                    </div>
                </div>
            </section>

            <!-- ===== 股票查詢區塊 ===== -->
            <section id="section-search" class="section hidden">
                <h2 class="text-xl md:text-2xl font-bold text-gray-800 mb-4 md:mb-6">股票查詢</h2>
                
                <!-- 搜尋框 -->
                <div class="bg-white rounded-xl shadow p-4 md:p-6 mb-4 md:mb-6">
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input type="text" id="searchSymbol" placeholder="輸入股票代號（如 AAPL）或加密貨幣（BTC）" 
                            class="flex-1 px-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-base"
                            onkeypress="if(event.key==='Enter')searchStock()">
                        <button onclick="searchStock()" class="brand-orange text-white px-6 py-3 rounded-lg font-medium flex items-center justify-center touch-target">
                            <i class="fas fa-search mr-2"></i>
                            <span>查詢</span>
                        </button>
                    </div>
                    <p class="text-gray-500 text-xs md:text-sm mt-2">支援美股代號及加密貨幣 (BTC, ETH)</p>
                </div>
                
                <!-- 搜尋結果 -->
                <div id="searchResult" class="hidden"></div>
            </section>

            <!-- ===== 追蹤清單區塊 ===== -->
            <section id="section-watchlist" class="section hidden">
                <div class="flex items-center justify-between mb-4 md:mb-6">
                    <h2 class="text-xl md:text-2xl font-bold text-gray-800">追蹤清單</h2>
                    <button onclick="showAddWatchlistModal()" class="brand-orange text-white px-4 py-2 rounded-lg font-medium flex items-center touch-target">
                        <i class="fas fa-plus mr-2"></i>
                        <span class="hidden sm:inline">新增</span>
                    </button>
                </div>
                <div id="watchlistContent">
                    <p class="text-gray-500 text-center py-4">載入中...</p>
                </div>
            </section>

            <!-- ===== 市場情緒區塊 ===== -->
            <section id="section-sentiment" class="section hidden">
                <h2 class="text-xl md:text-2xl font-bold text-gray-800 mb-4 md:mb-6">市場情緒</h2>
                <div id="sentimentContent">
                    <p class="text-gray-500 text-center py-4">載入中...</p>
                </div>
            </section>

            <!-- ===== 設定區塊 ===== -->
            <section id="section-settings" class="section hidden">
                <h2 class="text-xl md:text-2xl font-bold text-gray-800 mb-4 md:mb-6">設定</h2>
                <div id="settingsContent" class="bg-white rounded-xl shadow p-4 md:p-6">
                    <p class="text-gray-500 text-center py-4">載入中...</p>
                </div>
            </section>
            
        </main>

        <!-- ===== 手機版底部導航列 ===== -->
        <nav class="mobile-bottom-nav">
            <a href="#" onclick="mobileNavTo('dashboard')" class="bottom-nav-item active" data-section="dashboard">
                <i class="fas fa-tachometer-alt"></i>
                <span>首頁</span>
            </a>
            <a href="#" onclick="mobileNavTo('search')" class="bottom-nav-item" data-section="search">
                <i class="fas fa-search"></i>
                <span>查詢</span>
            </a>
            <a href="#" onclick="mobileNavTo('watchlist')" class="bottom-nav-item" data-section="watchlist">
                <i class="fas fa-star"></i>
                <span>追蹤</span>
            </a>
            <a href="#" onclick="mobileNavTo('sentiment')" class="bottom-nav-item" data-section="sentiment">
                <i class="fas fa-heart-pulse"></i>
                <span>情緒</span>
            </a>
            <a href="#" onclick="mobileNavTo('settings')" class="bottom-nav-item" data-section="settings">
                <i class="fas fa-cog"></i>
                <span>設定</span>
            </a>
        </nav>

    </div><!-- end app-content -->

    <!-- ===== 全螢幕圖表 ===== -->
    <div id="chartFullscreen" class="chart-fullscreen">
        <!-- 橫向提示 -->
        <div class="rotate-hint fixed inset-0 bg-white flex flex-col items-center justify-center z-10">
            <div class="text-6xl mb-4">📱🔄</div>
            <p class="text-lg text-gray-700 mb-2">請將手機橫向放置</p>
            <p class="text-gray-500 text-sm">以獲得最佳圖表體驗</p>
            <button onclick="closeChartFullscreen()" class="mt-6 px-6 py-2 border border-gray-300 rounded-lg text-gray-600">
                返回
            </button>
        </div>
        <!-- 橫向圖表 -->
        <div class="chart-container h-full flex flex-col">
            <div class="flex items-center justify-between p-3 border-b bg-white">
                <button onclick="closeChartFullscreen()" class="p-2 text-gray-600 touch-target">
                    <i class="fas fa-times text-xl"></i>
                </button>
                <span id="chartFullscreenTitle" class="font-bold text-lg"></span>
                <div class="w-10"></div>
            </div>
            <div class="flex-1 p-2 bg-gray-50">
                <canvas id="fullscreenChart"></canvas>
            </div>
            <div class="flex items-center justify-center gap-2 p-2 bg-white border-t">
                <button onclick="setChartRange(30)" class="chart-range-btn px-3 py-1 text-sm rounded border">1M</button>
                <button onclick="setChartRange(90)" class="chart-range-btn px-3 py-1 text-sm rounded border bg-blue-50 border-blue-500 text-blue-600">3M</button>
                <button onclick="setChartRange(180)" class="chart-range-btn px-3 py-1 text-sm rounded border">6M</button>
                <button onclick="setChartRange(365)" class="chart-range-btn px-3 py-1 text-sm rounded border">1Y</button>
            </div>
        </div>
    </div>

    <!-- ===== 新增追蹤清單 Modal ===== -->
    <div id="addWatchlistModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white rounded-xl w-full max-w-md p-6">
            <h3 class="text-lg font-bold text-gray-800 mb-4">新增追蹤</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-gray-700 mb-2 text-sm">股票/加密貨幣代號</label>
                    <input type="text" id="addSymbol" placeholder="如 AAPL、BTC" 
                        class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 text-base">
                </div>
                <div>
                    <label class="block text-gray-700 mb-2 text-sm">類型</label>
                    <select id="addAssetType" class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 text-base">
                        <option value="stock">股票</option>
                        <option value="crypto">加密貨幣</option>
                    </select>
                </div>
                <div>
                    <label class="block text-gray-700 mb-2 text-sm">備註（選填）</label>
                    <input type="text" id="addNote" placeholder="自訂備註" 
                        class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 text-base">
                </div>
            </div>
            <div class="flex gap-3 mt-6">
                <button onclick="hideAddWatchlistModal()" class="flex-1 px-4 py-3 border rounded-lg hover:bg-gray-50 touch-target">取消</button>
                <button onclick="addToWatchlist()" class="flex-1 px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 touch-target">新增</button>
            </div>
        </div>
    </div>

    <!-- ===== Toast 通知 ===== -->
    <div id="toast" class="fixed bottom-20 md:bottom-4 left-4 right-4 md:left-auto md:right-4 md:w-auto bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg hidden transition-opacity text-center">
        <span id="toastMessage"></span>
    </div>

    <script>
        const API_BASE = '';
        let token = localStorage.getItem('token');
        let currentUser = null;
        let currentChartData = null;
        let fullscreenChartInstance = null;
        
        // ========== 設備檢測 ==========
        const deviceInfo = {
            isMobile: window.innerWidth < 768,
            isTouch: 'ontouchstart' in window,
            isLineApp: /Line\//i.test(navigator.userAgent),
            isIOS: /iPhone|iPad/i.test(navigator.userAgent),
            isAndroid: /Android/i.test(navigator.userAgent),
        };
        
        console.log('Device info:', deviceInfo);
        
        // ========== 自動登出功能 ==========
        const SESSION_TIMEOUT = 5 * 60 * 1000; // 5 分鐘
        let sessionTimer = null;
        let lastActivity = Date.now();
        
        function resetSessionTimer() {
            lastActivity = Date.now();
        }
        
        function checkSessionTimeout() {
            const elapsed = Date.now() - lastActivity;
            const remaining = SESSION_TIMEOUT - elapsed;
            
            if (remaining <= 0) {
                showToast('閒置超過 5 分鐘，已自動登出');
                setTimeout(() => logout(), 1500);
            } else {
                const mins = Math.floor(remaining / 60000);
                const secs = Math.floor((remaining % 60000) / 1000);
                const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;
                
                const timerEl = document.getElementById('sessionTimer');
                const sidebarTimerEl = document.getElementById('sidebarTimer');
                if (timerEl) timerEl.textContent = `閒置登出: ${timeStr}`;
                if (sidebarTimerEl) sidebarTimerEl.textContent = timeStr;
            }
        }
        
        function startSessionMonitor() {
            ['mousedown', 'mousemove', 'keydown', 'scroll', 'touchstart', 'click'].forEach(event => {
                document.addEventListener(event, resetSessionTimer, { passive: true });
            });
            sessionTimer = setInterval(checkSessionTimeout, 1000);
        }
        
        function stopSessionMonitor() {
            if (sessionTimer) {
                clearInterval(sessionTimer);
                sessionTimer = null;
            }
        }
        
        // ========== 登入驗證 ==========
        async function checkAuth() {
            if (!token) {
                window.location.href = '/static/index.html';
                return;
            }

            try {
                const res = await fetch(`${API_BASE}/auth/me`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (!res.ok) throw new Error('Unauthorized');
                
                currentUser = await res.json();
                
                // 更新用戶資訊
                document.getElementById('userName').textContent = currentUser.display_name;
                document.getElementById('userAvatar').src = currentUser.picture_url || 'https://via.placeholder.com/40';
                document.getElementById('sidebarUserName').textContent = currentUser.display_name;
                document.getElementById('sidebarAvatar').src = currentUser.picture_url || 'https://via.placeholder.com/40';
                
                // 顯示主內容
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('app-content').style.display = 'block';
                
                startSessionMonitor();
                loadDashboard();
            } catch (e) {
                localStorage.removeItem('token');
                window.location.href = '/static/index.html';
            }
        }

        function logout() {
            stopSessionMonitor();
            localStorage.removeItem('token');
            window.location.href = '/static/index.html';
        }

        // ========== 手機版選單 ==========
        function openMobileSidebar() {
            document.getElementById('mobileSidebar').classList.add('open');
            document.getElementById('sidebarOverlay').classList.add('open');
            document.body.style.overflow = 'hidden';
        }
        
        function closeMobileSidebar() {
            document.getElementById('mobileSidebar').classList.remove('open');
            document.getElementById('sidebarOverlay').classList.remove('open');
            document.body.style.overflow = '';
        }
        
        function mobileNavTo(section) {
            closeMobileSidebar();
            showSection(section);
            
            // 更新底部導航和側邊選單高亮
            document.querySelectorAll('.bottom-nav-item, .mobile-nav-link').forEach(el => {
                el.classList.remove('active', 'bg-blue-50', 'text-gray-700');
                if (el.dataset.section === section) {
                    el.classList.add('active');
                    if (el.classList.contains('mobile-nav-link')) {
                        el.classList.add('bg-blue-50', 'text-gray-700');
                    }
                } else if (el.classList.contains('mobile-nav-link')) {
                    el.classList.add('text-gray-600');
                }
            });
        }

        // ========== 切換區塊 ==========
        function showSection(name, evt) {
            document.querySelectorAll('.section').forEach(s => s.classList.add('hidden'));
            const section = document.getElementById(`section-${name}`);
            if (section) {
                section.classList.remove('hidden');
            }
            
            // 更新電腦版導航高亮
            document.querySelectorAll('.nav-link').forEach(l => {
                l.classList.remove('bg-blue-50', 'text-gray-700');
                l.classList.add('text-gray-600');
            });
            
            if (evt && evt.target) {
                const navLink = evt.target.closest('.nav-link');
                if (navLink) {
                    navLink.classList.add('bg-blue-50', 'text-gray-700');
                    navLink.classList.remove('text-gray-600');
                }
            }
            
            // 更新底部導航高亮
            document.querySelectorAll('.bottom-nav-item').forEach(el => {
                el.classList.remove('active');
                if (el.dataset.section === name) {
                    el.classList.add('active');
                }
            });

            // 載入對應資料
            if (name === 'watchlist') loadWatchlist();
            if (name === 'sentiment') loadSentimentDetail();
            if (name === 'settings') loadSettings();
        }

        // ========== 載入儀表板 ==========
        async function loadDashboard() {
            await loadSentiment();
            await loadWatchlistOverview();
        }

        // ========== 載入市場情緒 ==========
        async function loadSentiment() {
            try {
                const res = await fetch(`${API_BASE}/api/market/sentiment`);
                const data = await res.json();
                
                if (data.success) {
                    if (data.stock) {
                        updateSentimentCard('stock', data.stock);
                    } else {
                        updateSentimentCard('stock', { value: 50, classification: 'neutral' });
                    }
                    
                    if (data.crypto) {
                        updateSentimentCard('crypto', data.crypto);
                    } else {
                        updateSentimentCard('crypto', { value: 50, classification: 'neutral' });
                    }
                }
            } catch (e) {
                console.error('載入情緒失敗', e);
                updateSentimentCard('stock', { value: 50, classification: 'neutral' });
                updateSentimentCard('crypto', { value: 50, classification: 'neutral' });
            }
        }

        function updateSentimentCard(type, sentiment) {
            if (!sentiment) return;
            
            const value = sentiment.value;
            
            document.getElementById(`${type}SentimentValue`).textContent = value;
            document.getElementById(`${type}SentimentBar`).style.width = `${value}%`;
            
            const badge = document.getElementById(`${type}SentimentBadge`);
            const bar = document.getElementById(`${type}SentimentBar`);
            
            let badgeClass, barClass, label;
            if (value <= 25) {
                badgeClass = 'bg-red-100 text-red-700';
                barClass = 'bg-red-500';
                label = '極度恐懼';
            } else if (value <= 45) {
                badgeClass = 'bg-orange-100 text-orange-700';
                barClass = 'bg-orange-500';
                label = '恐懼';
            } else if (value <= 55) {
                badgeClass = 'bg-gray-100 text-gray-700';
                barClass = 'bg-gray-500';
                label = '中性';
            } else if (value <= 75) {
                badgeClass = 'bg-green-100 text-green-700';
                barClass = 'bg-green-500';
                label = '貪婪';
            } else {
                badgeClass = 'bg-emerald-100 text-emerald-700';
                barClass = 'bg-emerald-500';
                label = '極度貪婪';
            }
            
            badge.className = `px-2 md:px-3 py-1 rounded-full text-xs md:text-sm font-medium ${badgeClass}`;
            badge.textContent = label;
            bar.className = `h-2 md:h-3 rounded-full transition-all ${barClass}`;
        }

        // ========== 追蹤清單快覽 ==========
        async function loadWatchlistOverview() {
            const container = document.getElementById('dashboardWatchlist');
            
            try {
                const res = await fetch(`${API_BASE}/api/watchlist`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await res.json();
                
                if (!data.success || !data.data || data.data.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-6">
                            <i class="fas fa-star text-gray-300 text-3xl mb-2"></i>
                            <p class="text-gray-500 text-sm">尚無追蹤清單</p>
                            <button onclick="showSection('search')" class="mt-2 text-blue-600 text-sm">前往查詢股票</button>
                        </div>
                    `;
                    return;
                }
                
                // 只顯示前 5 筆
                const items = data.data.slice(0, 5);
                let html = '<div class="space-y-2">';
                
                for (const item of items) {
                    html += `
                        <div class="flex items-center justify-between py-2 border-b last:border-0 cursor-pointer hover:bg-gray-50 -mx-2 px-2 rounded" onclick="searchSymbol('${item.symbol}')">
                            <div class="flex items-center">
                                <span class="font-medium text-gray-800">${item.symbol}</span>
                                <span class="ml-2 text-xs px-2 py-0.5 rounded ${item.asset_type === 'crypto' ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700'}">
                                    ${item.asset_type === 'crypto' ? '幣' : '股'}
                                </span>
                            </div>
                            <i class="fas fa-chevron-right text-gray-400 text-sm"></i>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (e) {
                console.error('載入追蹤清單失敗', e);
                container.innerHTML = '<p class="text-red-500 text-center py-4">載入失敗</p>';
            }
        }

        // ========== 股票查詢 ==========
        function searchStock() {
            const symbol = document.getElementById('searchSymbol').value.trim().toUpperCase();
            if (!symbol) {
                showToast('請輸入股票代號');
                return;
            }
            searchSymbol(symbol);
        }

        async function searchSymbol(symbol) {
            const container = document.getElementById('searchResult');
            container.classList.remove('hidden');
            container.innerHTML = '<div class="bg-white rounded-xl shadow p-6 text-center"><i class="fas fa-spinner fa-spin text-2xl text-blue-600"></i><p class="mt-2 text-gray-500 text-sm">查詢中...（首次查詢可能需要 10-30 秒）</p></div>';
            
            showSection('search');
            document.getElementById('searchSymbol').value = symbol;

            try {
                const isCrypto = ['BTC', 'ETH'].includes(symbol);
                const endpoint = isCrypto ? `/api/crypto/${symbol}` : `/api/stock/${symbol}`;
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);
                
                const res = await fetch(`${API_BASE}${endpoint}`, { signal: controller.signal });
                clearTimeout(timeoutId);
                
                const data = await res.json();
                
                if (!res.ok) {
                    container.innerHTML = `<div class="bg-white rounded-xl shadow p-6 text-center text-red-500">HTTP ${res.status}: ${data.detail || '查詢失敗'}</div>`;
                    return;
                }
                
                if (!data.success) {
                    container.innerHTML = `<div class="bg-white rounded-xl shadow p-6 text-center text-red-500">${data.detail || '查詢失敗'}</div>`;
                    return;
                }

                currentChartData = data.chart_data;
                renderStockResult(data, isCrypto);
                
            } catch (e) {
                console.error('Search error:', e);
                if (e.name === 'AbortError') {
                    container.innerHTML = '<div class="bg-white rounded-xl shadow p-6 text-center text-red-500">查詢超時，請稍後再試</div>';
                } else {
                    container.innerHTML = `<div class="bg-white rounded-xl shadow p-6 text-center text-red-500">查詢失敗: ${e.message}</div>`;
                }
            }
        }

        function renderStockResult(stock, isCrypto) {
            const container = document.getElementById('searchResult');
            const indicators = stock.indicators || {};
            const ma = indicators.ma || {};
            const rsi = indicators.rsi || {};
            const macd = indicators.macd || {};
            
            const priceChange = stock.change?.day || 0;
            const priceChangeClass = priceChange >= 0 ? 'text-green-600' : 'text-red-600';
            const priceChangeIcon = priceChange >= 0 ? '📈' : '📉';
            
            const alignmentClass = ma.alignment === 'bullish' ? 'text-green-600' : ma.alignment === 'bearish' ? 'text-red-600' : 'text-gray-600';
            const alignmentText = ma.alignment === 'bullish' ? '多頭 🟢' : ma.alignment === 'bearish' ? '空頭 🔴' : '中性';
            
            const rsiStatus = rsi.status === 'overbought' ? '超買 ⚠️' : rsi.status === 'oversold' ? '超賣 🟢' : '中性';
            const macdStatus = macd.status === 'bullish' ? '偏多 🟢' : '偏空 🔴';
            
            const html = `
                <div class="bg-white rounded-xl shadow overflow-hidden">
                    <!-- 價格區塊 -->
                    <div class="p-4 md:p-6 border-b">
                        <div class="flex items-start justify-between mb-2">
                            <div>
                                <h3 class="text-xl md:text-2xl font-bold text-gray-800">${stock.symbol}</h3>
                                <p class="text-gray-500 text-sm">${stock.name || (isCrypto ? '加密貨幣' : '股票')}</p>
                            </div>
                            <span class="px-2 py-1 rounded text-xs ${isCrypto ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700'}">
                                ${isCrypto ? '加密貨幣' : '美股'}
                            </span>
                        </div>
                        <div class="mt-3">
                            <span class="text-3xl md:text-4xl font-bold text-gray-800">$${stock.price?.current?.toLocaleString() || '--'}</span>
                            <span class="ml-2 ${priceChangeClass} text-lg">
                                ${priceChange >= 0 ? '+' : ''}${priceChange?.toFixed(2)}% ${priceChangeIcon}
                            </span>
                        </div>
                    </div>
                    
                    <!-- 快速總覽 -->
                    <div class="p-4 md:p-6 border-b bg-gray-50">
                        <h4 class="font-semibold text-gray-700 mb-3 text-sm">📊 快速總覽</h4>
                        <div class="grid grid-cols-2 gap-3 text-sm">
                            <div class="flex justify-between">
                                <span class="text-gray-500">均線排列</span>
                                <span class="${alignmentClass} font-medium">${alignmentText}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-500">RSI</span>
                                <span class="font-medium">${rsi.value?.toFixed(0) || '--'} ${rsiStatus}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-500">MACD</span>
                                <span class="font-medium">${macdStatus}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-500">評分</span>
                                <span class="font-medium">${stock.score?.rating === 'bullish' ? '偏多' : stock.score?.rating === 'bearish' ? '偏空' : '中性'} (${stock.score?.buy || 0}/${stock.score?.sell || 0})</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 詳細指標 (可摺疊) -->
                    <div class="border-b">
                        <button onclick="toggleCollapsible(this)" class="w-full p-4 flex items-center justify-between text-left hover:bg-gray-50 touch-target">
                            <span class="font-medium text-gray-700">▼ 展開詳細指標</span>
                            <i class="fas fa-chevron-down text-gray-400 transition-transform"></i>
                        </button>
                        <div class="collapsible-content">
                            <div class="px-4 pb-4 space-y-3">
                                <!-- MA 詳細 -->
                                <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
                                    <div class="p-3 rounded-lg ${ma.price_vs_ma20 === 'above' ? 'bg-green-50' : 'bg-red-50'}">
                                        <p class="text-gray-500 text-xs">MA20</p>
                                        <p class="font-semibold">${ma.ma20?.toFixed(2) || '--'}</p>
                                        <p class="text-xs ${ma.price_vs_ma20 === 'above' ? 'text-green-600' : 'text-red-600'}">
                                            ${ma.price_vs_ma20 === 'above' ? '價格在上 ✓' : '價格在下'}
                                        </p>
                                    </div>
                                    <div class="p-3 rounded-lg ${ma.price_vs_ma50 === 'above' ? 'bg-green-50' : 'bg-red-50'}">
                                        <p class="text-gray-500 text-xs">MA50</p>
                                        <p class="font-semibold">${ma.ma50?.toFixed(2) || '--'}</p>
                                        <p class="text-xs ${ma.price_vs_ma50 === 'above' ? 'text-green-600' : 'text-red-600'}">
                                            ${ma.price_vs_ma50 === 'above' ? '價格在上 ✓' : '價格在下'}
                                        </p>
                                    </div>
                                    <div class="p-3 rounded-lg ${ma.price_vs_ma200 === 'above' ? 'bg-green-50' : 'bg-red-50'}">
                                        <p class="text-gray-500 text-xs">MA200</p>
                                        <p class="font-semibold">${ma.ma200?.toFixed(2) || '--'}</p>
                                        <p class="text-xs ${ma.price_vs_ma200 === 'above' ? 'text-green-600' : 'text-red-600'}">
                                            ${ma.price_vs_ma200 === 'above' ? '價格在上 ✓' : '價格在下'}
                                        </p>
                                    </div>
                                </div>
                                
                                <!-- RSI & MACD 詳細 -->
                                <div class="grid grid-cols-2 gap-2 text-sm">
                                    <div class="p-3 bg-gray-50 rounded-lg">
                                        <p class="text-gray-500 text-xs">RSI (${rsi.period || 14})</p>
                                        <p class="font-semibold">${rsi.value?.toFixed(2) || '--'}</p>
                                    </div>
                                    <div class="p-3 bg-gray-50 rounded-lg">
                                        <p class="text-gray-500 text-xs">MACD DIF</p>
                                        <p class="font-semibold">${macd.dif?.toFixed(2) || '--'}</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 操作按鈕 -->
                    <div class="p-4 space-y-3">
                        ${stock.chart_data ? `
                        <button onclick="openChartFullscreen('${stock.symbol}', ${stock.price?.current || 0})" 
                            class="w-full py-3 bg-blue-600 text-white rounded-lg font-medium flex items-center justify-center touch-target hover:bg-blue-700">
                            <i class="fas fa-chart-line mr-2"></i>
                            查看完整圖表
                        </button>
                        ` : ''}
                        <button onclick="quickAddToWatchlist('${stock.symbol}', '${isCrypto ? 'crypto' : 'stock'}')" 
                            class="w-full py-3 border-2 border-orange-500 text-orange-600 rounded-lg font-medium flex items-center justify-center touch-target hover:bg-orange-50">
                            <i class="fas fa-star mr-2"></i>
                            加入追蹤清單
                        </button>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        function toggleCollapsible(btn) {
            const content = btn.nextElementSibling;
            const icon = btn.querySelector('i');
            content.classList.toggle('open');
            icon.style.transform = content.classList.contains('open') ? 'rotate(180deg)' : '';
            btn.querySelector('span').textContent = content.classList.contains('open') ? '▲ 收合詳細指標' : '▼ 展開詳細指標';
        }

        // ========== 全螢幕圖表 ==========
        function openChartFullscreen(symbol, price) {
            if (!currentChartData) {
                showToast('沒有圖表資料');
                return;
            }
            
            document.getElementById('chartFullscreenTitle').textContent = `${symbol}  $${price.toLocaleString()}`;
            document.getElementById('chartFullscreen').classList.add('open');
            document.body.style.overflow = 'hidden';
            
            // 延遲渲染圖表
            setTimeout(() => {
                renderFullscreenChart(currentChartData, 90);
            }, 100);
        }
        
        function closeChartFullscreen() {
            document.getElementById('chartFullscreen').classList.remove('open');
            document.body.style.overflow = '';
            
            if (fullscreenChartInstance) {
                fullscreenChartInstance.destroy();
                fullscreenChartInstance = null;
            }
        }
        
        function setChartRange(days) {
            // 更新按鈕樣式
            document.querySelectorAll('.chart-range-btn').forEach(btn => {
                btn.classList.remove('bg-blue-50', 'border-blue-500', 'text-blue-600');
            });
            event.target.classList.add('bg-blue-50', 'border-blue-500', 'text-blue-600');
            
            renderFullscreenChart(currentChartData, days);
        }
        
        function renderFullscreenChart(chartData, days) {
            const canvas = document.getElementById('fullscreenChart');
            if (!canvas) return;
            
            if (fullscreenChartInstance) {
                fullscreenChartInstance.destroy();
            }
            
            const ctx = canvas.getContext('2d');
            const dataLength = chartData.dates.length;
            const startIdx = Math.max(0, dataLength - days);
            
            const labels = chartData.dates.slice(startIdx).map((d, i) => {
                if (i % Math.ceil(days / 6) === 0) return d.slice(5);
                return '';
            });
            
            fullscreenChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: '收盤價',
                            data: chartData.prices.slice(startIdx),
                            borderColor: '#3B82F6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1,
                            pointRadius: 0,
                        },
                        {
                            label: 'MA20',
                            data: chartData.ma20.slice(startIdx),
                            borderColor: '#10B981',
                            borderWidth: 1.5,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                        },
                        {
                            label: 'MA50',
                            data: chartData.ma50.slice(startIdx),
                            borderColor: '#F59E0B',
                            borderWidth: 1.5,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                        },
                        {
                            label: 'MA200',
                            data: chartData.ma200.slice(startIdx),
                            borderColor: '#EF4444',
                            borderWidth: 1.5,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                        },
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index',
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: { usePointStyle: true, padding: 10 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.raw === null) return null;
                                    return `${context.dataset.label}: $${context.raw.toFixed(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false } },
                        y: { grid: { color: 'rgba(0,0,0,0.05)' } }
                    }
                }
            });
        }

        // ========== 追蹤清單 (卡片式) ==========
        async function loadWatchlist() {
            const container = document.getElementById('watchlistContent');
            
            try {
                const res = await fetch(`${API_BASE}/api/watchlist`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await res.json();
                
                if (!data.success || !data.data || data.data.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-12">
                            <i class="fas fa-star text-gray-300 text-4xl mb-3"></i>
                            <p class="text-gray-500 mb-4">尚無追蹤的股票</p>
                            <button onclick="showAddWatchlistModal()" class="px-6 py-2 bg-blue-600 text-white rounded-lg">
                                <i class="fas fa-plus mr-2"></i>新增追蹤
                            </button>
                        </div>
                    `;
                    return;
                }
                
                let html = '<div class="space-y-3">';
                
                for (const item of data.data) {
                    const typeClass = item.asset_type === 'crypto' ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700';
                    const typeText = item.asset_type === 'crypto' ? '幣' : '股';
                    
                    html += `
                        <div class="stock-card bg-white rounded-xl shadow-sm p-4">
                            <div class="flex items-start justify-between mb-2">
                                <div class="flex items-center">
                                    <span class="font-bold text-lg text-gray-800">${item.symbol}</span>
                                    <span class="ml-2 px-2 py-0.5 rounded text-xs ${typeClass}">${typeText}</span>
                                </div>
                                <button onclick="removeFromWatchlist(${item.id})" class="p-2 text-gray-400 hover:text-red-500 touch-target">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                            ${item.note ? `<p class="text-gray-500 text-sm mb-2">${item.note}</p>` : ''}
                            <div class="flex items-center justify-between mt-3">
                                <span class="text-gray-400 text-xs">加入於 ${new Date(item.added_at).toLocaleDateString()}</span>
                                <button onclick="searchSymbol('${item.symbol}')" class="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg text-sm hover:bg-gray-200 touch-target">
                                    查看詳情
                                </button>
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (e) {
                console.error('載入追蹤清單失敗', e);
                container.innerHTML = '<p class="text-red-500 text-center py-4">載入失敗</p>';
            }
        }
        
        function showAddWatchlistModal() {
            document.getElementById('addWatchlistModal').classList.remove('hidden');
            document.getElementById('addWatchlistModal').classList.add('flex');
        }
        
        function hideAddWatchlistModal() {
            document.getElementById('addWatchlistModal').classList.add('hidden');
            document.getElementById('addWatchlistModal').classList.remove('flex');
            document.getElementById('addSymbol').value = '';
            document.getElementById('addNote').value = '';
        }
        
        async function addToWatchlist() {
            const symbol = document.getElementById('addSymbol').value.trim().toUpperCase();
            const assetType = document.getElementById('addAssetType').value;
            const note = document.getElementById('addNote').value.trim();
            
            if (!symbol) {
                showToast('請輸入股票代號');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/api/watchlist`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol, asset_type: assetType, note })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast('已加入追蹤清單');
                    hideAddWatchlistModal();
                    loadWatchlist();
                    loadWatchlistOverview();
                } else {
                    showToast(data.detail || '新增失敗');
                }
            } catch (e) {
                showToast('新增失敗');
            }
        }
        
        async function quickAddToWatchlist(symbol, assetType) {
            try {
                const res = await fetch(`${API_BASE}/api/watchlist`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol, asset_type: assetType, note: '' })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast(`${symbol} 已加入追蹤清單`);
                    loadWatchlistOverview();
                } else {
                    showToast(data.detail || '新增失敗');
                }
            } catch (e) {
                showToast('新增失敗');
            }
        }
        
        async function removeFromWatchlist(id) {
            if (!confirm('確定要移除此追蹤？')) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/watchlist/${id}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast('已移除');
                    loadWatchlist();
                    loadWatchlistOverview();
                } else {
                    showToast('移除失敗');
                }
            } catch (e) {
                showToast('移除失敗');
            }
        }

        // ========== 設定 ==========
        async function loadSettings() {
            const container = document.getElementById('settingsContent');
            container.innerHTML = `
                <div class="space-y-6">
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-3">帳號資訊</h3>
                        <div class="flex items-center p-4 bg-gray-50 rounded-lg">
                            <img id="settingsAvatar" class="w-12 h-12 rounded-full mr-4" src="${currentUser?.picture_url || ''}" alt="">
                            <div>
                                <p class="font-medium text-gray-800">${currentUser?.display_name || ''}</p>
                                <p class="text-gray-500 text-sm">LINE 登入</p>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-3">關於</h3>
                        <div class="p-4 bg-gray-50 rounded-lg text-sm text-gray-600">
                            <p>SELA 自動選股系統 v0.3.2</p>
                            <p class="mt-1">技術指標分析 · 智能預警通知</p>
                        </div>
                    </div>
                    
                    <button onclick="logout()" class="w-full py-3 border border-red-500 text-red-500 rounded-lg font-medium hover:bg-red-50 touch-target">
                        <i class="fas fa-sign-out-alt mr-2"></i>登出
                    </button>
                </div>
            `;
        }
        
        async function loadSentimentDetail() {
            const container = document.getElementById('sentimentContent');
            container.innerHTML = `
                <div class="space-y-4">
                    <div class="bg-white rounded-xl shadow p-6">
                        <h3 class="font-semibold text-gray-700 mb-4">市場情緒解讀</h3>
                        <div class="space-y-4 text-sm text-gray-600">
                            <div class="flex items-start">
                                <span class="w-24 flex-shrink-0 font-medium">0-25</span>
                                <span class="px-2 py-1 bg-red-100 text-red-700 rounded mr-2">極度恐懼</span>
                                <span>市場恐慌，可能是買入機會</span>
                            </div>
                            <div class="flex items-start">
                                <span class="w-24 flex-shrink-0 font-medium">26-45</span>
                                <span class="px-2 py-1 bg-orange-100 text-orange-700 rounded mr-2">恐懼</span>
                                <span>市場偏謹慎</span>
                            </div>
                            <div class="flex items-start">
                                <span class="w-24 flex-shrink-0 font-medium">46-55</span>
                                <span class="px-2 py-1 bg-gray-100 text-gray-700 rounded mr-2">中性</span>
                                <span>觀望為主</span>
                            </div>
                            <div class="flex items-start">
                                <span class="w-24 flex-shrink-0 font-medium">56-75</span>
                                <span class="px-2 py-1 bg-green-100 text-green-700 rounded mr-2">貪婪</span>
                                <span>市場偏樂觀</span>
                            </div>
                            <div class="flex items-start">
                                <span class="w-24 flex-shrink-0 font-medium">76-100</span>
                                <span class="px-2 py-1 bg-emerald-100 text-emerald-700 rounded mr-2">極度貪婪</span>
                                <span>市場過熱，留意風險</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // ========== Toast ==========
        function showToast(message) {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.classList.remove('hidden');
            setTimeout(() => {
                toast.classList.add('hidden');
            }, 3000);
        }

        // ========== 初始化 ==========
        document.addEventListener('DOMContentLoaded', checkAuth);
        
        // 監聽視窗大小變化
        window.addEventListener('resize', () => {
            deviceInfo.isMobile = window.innerWidth < 768;
        });
    </script>
</body>
</html>
```

──────────────────────────────────────────────────────────────────────
### 📄 static/dashboard.html  ⭐
──────────────────────────────────────────────────────────────────────

⚠️ 檔案過大（254.5 KB > 200 KB）
📁 已複製: static--dashboard.html

──────────────────────────────────────────────────────────────────────
### 📄 static/index.html  ⭐
──────────────────────────────────────────────────────────────────────

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SELA 自動選股系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .brand-orange { background-color: #FA7A35; }
        .brand-orange:hover { background-color: #e86a25; }
        .brand-text { color: #FA7A35; }
        .line-btn { background-color: #06C755; }
        .line-btn:hover { background-color: #05b34c; }
        .touch-target { min-height: 48px; }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 min-h-screen flex items-center justify-center p-4">
    <div class="bg-white rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-md">
        <!-- Logo -->
        <div class="text-center mb-6 md:mb-8">
            <img src="/static/logo.png" alt="SELA Logo" class="w-20 h-20 md:w-24 md:h-24 mx-auto mb-3 md:mb-4 rounded-xl">
            <h1 class="text-xl md:text-2xl font-bold text-gray-800">SELA 自動選股系統</h1>
            <p class="text-gray-500 mt-2 text-sm md:text-base">技術指標分析 · 智能預警通知</p>
        </div>

        <!-- 功能介紹 -->
        <div class="space-y-2 md:space-y-3 mb-6 md:mb-8">
            <div class="flex items-center text-gray-600 text-sm md:text-base">
                <i class="fas fa-check-circle brand-text mr-3 flex-shrink-0"></i>
                <span>美股即時報價與技術分析</span>
            </div>
            <div class="flex items-center text-gray-600 text-sm md:text-base">
                <i class="fas fa-check-circle brand-text mr-3 flex-shrink-0"></i>
                <span>比特幣、以太幣價格追蹤</span>
            </div>
            <div class="flex items-center text-gray-600 text-sm md:text-base">
                <i class="fas fa-check-circle brand-text mr-3 flex-shrink-0"></i>
                <span>個人化追蹤清單</span>
            </div>
            <div class="flex items-center text-gray-600 text-sm md:text-base">
                <i class="fas fa-check-circle brand-text mr-3 flex-shrink-0"></i>
                <span>LINE 推播智能預警</span>
            </div>
        </div>

        <!-- LINE 登入按鈕 -->
        <a href="/auth/line" class="line-btn w-full py-3 md:py-4 px-4 rounded-lg text-white font-semibold flex items-center justify-center space-x-2 transition-colors touch-target">
            <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor">
                <path d="M19.365 9.863c.349 0 .63.285.63.631 0 .345-.281.63-.63.63H17.61v1.125h1.755c.349 0 .63.283.63.63 0 .344-.281.629-.63.629h-2.386c-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63h2.386c.346 0 .627.285.627.63 0 .349-.281.63-.63.63H17.61v1.125h1.755zm-3.855 3.016c0 .27-.174.51-.432.596-.064.021-.133.031-.199.031-.211 0-.391-.09-.51-.25l-2.443-3.317v2.94c0 .344-.279.629-.631.629-.346 0-.626-.285-.626-.629V8.108c0-.27.173-.51.43-.595.06-.023.136-.033.194-.033.195 0 .375.104.495.254l2.462 3.33V8.108c0-.345.282-.63.63-.63.345 0 .63.285.63.63v4.771zm-5.741 0c0 .344-.282.629-.631.629-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63.346 0 .628.285.628.63v4.771zm-2.466.629H4.917c-.345 0-.63-.285-.63-.629V8.108c0-.345.285-.63.63-.63.348 0 .63.285.63.63v4.141h1.756c.348 0 .629.283.629.63 0 .344-.282.629-.629.629M24 10.314C24 4.943 18.615.572 12 .572S0 4.943 0 10.314c0 4.811 4.27 8.842 10.035 9.608.391.082.923.258 1.058.59.12.301.079.766.038 1.08l-.164 1.02c-.045.301-.24 1.186 1.049.645 1.291-.539 6.916-4.078 9.436-6.975C23.176 14.393 24 12.458 24 10.314"/>
            </svg>
            <span>使用 LINE 帳號登入</span>
        </a>

        <!-- 版權 -->
        <p class="text-center text-gray-400 text-xs md:text-sm mt-6 md:mt-8">
            © 2025 SELA · 自動選股系統 v0.3.2
        </p>
    </div>

    <script>
        // 檢查是否已登入
        const token = localStorage.getItem('token');
        if (token) {
            window.location.href = '/static/dashboard.html';
        }
    </script>
</body>
</html>
```

──────────────────────────────────────────────────────────────────────
### 📄 static/js/settings.js  ⭐
> *
──────────────────────────────────────────────────────────────────────

```js
/**
 * SELA 設定頁面 JavaScript
 * 版本: 1.0.0
 * 日期: 2026-01-12
 */

const INDICATOR_LABELS = {
    show_ma: { name: '均線', icon: 'fas fa-wave-square', color: 'text-blue-500' },
    show_rsi: { name: 'RSI', icon: 'fas fa-tachometer-alt', color: 'text-green-500' },
    show_macd: { name: 'MACD', icon: 'fas fa-signal', color: 'text-purple-500' },
    show_kd: { name: 'KD', icon: 'fas fa-chart-pie', color: 'text-pink-500' },
    show_bollinger: { name: '布林通道', icon: 'fas fa-road', color: 'text-indigo-500' },
    show_obv: { name: 'OBV', icon: 'fas fa-database', color: 'text-teal-500' },
    show_volume: { name: '成交量', icon: 'fas fa-chart-bar', color: 'text-orange-500' },
};

const ALERT_LABELS = {
    alert_ma_cross: { name: '均線交叉', icon: 'fas fa-times', color: 'text-blue-500' },
    alert_ma_breakout: { name: '均線突破', icon: 'fas fa-arrow-up', color: 'text-green-500' },
    alert_rsi: { name: 'RSI 超買/超賣', icon: 'fas fa-exclamation-triangle', color: 'text-yellow-500' },
    alert_macd: { name: 'MACD 交叉', icon: 'fas fa-exchange-alt', color: 'text-purple-500' },
    alert_kd: { name: 'KD 交叉', icon: 'fas fa-random', color: 'text-pink-500' },
    alert_bollinger: { name: '布林突破', icon: 'fas fa-expand-arrows-alt', color: 'text-indigo-500' },
    alert_volume: { name: '量能異常', icon: 'fas fa-volume-up', color: 'text-red-500' },
    alert_sentiment: { name: '情緒極端', icon: 'fas fa-smile', color: 'text-orange-500' },
};

const TEMPLATE_NAMES = { minimal: '極簡', standard: '標準', full: '完整', short_term: '短線' };

const PARAM_RANGES = {
    ma_short: { min: 5, max: 50, step: 1 },
    ma_mid: { min: 20, max: 100, step: 1 },
    ma_long: { min: 100, max: 300, step: 1 },
    rsi_period: { min: 5, max: 30, step: 1 },
    rsi_overbought: { min: 60, max: 90, step: 1 },
    rsi_oversold: { min: 10, max: 40, step: 1 },
    macd_fast: { min: 5, max: 20, step: 1 },
    macd_slow: { min: 15, max: 40, step: 1 },
    macd_signal: { min: 5, max: 15, step: 1 },
    kd_period: { min: 5, max: 20, step: 1 },
    bollinger_period: { min: 10, max: 30, step: 1 },
    bollinger_std: { min: 1, max: 3, step: 0.1 },
    breakout_threshold: { min: 0.5, max: 5, step: 0.1 },
    volume_alert_ratio: { min: 1, max: 5, step: 0.1 },
};

let settingsState = {
    indicators: {},
    alerts: {},
    params: {},
    hasUnsavedChanges: false,
    isLoading: false,
    currentTemplate: null
};

async function initSettingsPage() {
    console.log('[Settings] 初始化設定頁面');
    updateSettingsUserInfo();
    await loadAllSettings();
}

async function loadAllSettings() {
    settingsState.isLoading = true;
    showSettingsLoading(true);
    
    try {
        const [indRes, alertRes, paramRes] = await Promise.all([
            apiRequest('/api/settings/indicators'),
            apiRequest('/api/settings/alerts'),
            apiRequest('/api/settings/params'),
        ]);
        
        settingsState.indicators = indRes.data || {};
        settingsState.alerts = alertRes.data || {};
        settingsState.params = paramRes.data || {};
        settingsState.hasUnsavedChanges = false;
        
        renderIndicatorToggles();
        renderAlertToggles();
        renderParamInputs();
        detectCurrentTemplate();
        updateSaveButton();
    } catch (error) {
        console.error('[Settings] 載入設定失敗:', error);
        showSettingsMessage('載入設定失敗，請重新整理頁面', 'error');
    } finally {
        settingsState.isLoading = false;
        showSettingsLoading(false);
    }
}

async function saveAllSettings() {
    const btn = document.getElementById('settings-save-btn');
    if (!btn || settingsState.isLoading) return;
    
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 儲存中...';
    
    try {
        const params = collectParamValues();
        
        await Promise.all([
            apiRequest('/api/settings/indicators', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(settingsState.indicators) }),
            apiRequest('/api/settings/alerts', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(settingsState.alerts) }),
            apiRequest('/api/settings/params', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(params) }),
        ]);
        
        settingsState.params = params;
        settingsState.hasUnsavedChanges = false;
        showSettingsMessage('設定已成功儲存！', 'success');
        btn.innerHTML = '<i class="fas fa-check"></i> 已儲存';
        setTimeout(() => updateSaveButton(), 2000);
    } catch (error) {
        console.error('[Settings] 儲存失敗:', error);
        showSettingsMessage('儲存失敗，請重試', 'error');
        btn.innerHTML = '<i class="fas fa-save"></i> 儲存設定';
        btn.disabled = false;
    }
}

async function applyTemplate(templateName) {
    if (settingsState.isLoading) return;
    
    try {
        const res = await apiRequest(`/api/settings/template/${templateName}`, { method: 'POST' });
        if (res.success) {
            showSettingsMessage(`已套用「${TEMPLATE_NAMES[templateName]}」模板`, 'success');
            settingsState.currentTemplate = templateName;
            updateTemplateButtons();
            await loadAllSettings();
        }
    } catch (error) {
        console.error('[Settings] 套用模板失敗:', error);
        showSettingsMessage('套用模板失敗', 'error');
    }
}

function renderIndicatorToggles() {
    const grid = document.getElementById('indicators-grid');
    if (!grid) return;
    grid.innerHTML = '';
    
    for (const [key, config] of Object.entries(INDICATOR_LABELS)) {
        const isActive = settingsState.indicators[key] === true;
        const div = document.createElement('div');
        div.className = `toggle-switch ${isActive ? 'active' : ''}`;
        div.onclick = () => toggleIndicator(key);
        div.innerHTML = `<div class="toggle-label"><i class="${config.icon} ${isActive ? config.color : ''}"></i><span>${config.name}</span></div><div class="toggle-dot"></div>`;
        grid.appendChild(div);
    }
}

function renderAlertToggles() {
    const grid = document.getElementById('alerts-grid');
    if (!grid) return;
    grid.innerHTML = '';
    
    for (const [key, config] of Object.entries(ALERT_LABELS)) {
        const isActive = settingsState.alerts[key] === true;
        const div = document.createElement('div');
        div.className = `toggle-switch ${isActive ? 'active' : ''}`;
        div.onclick = () => toggleAlert(key);
        div.innerHTML = `<div class="toggle-label"><i class="${config.icon} ${isActive ? config.color : ''}"></i><span>${config.name}</span></div><div class="toggle-dot"></div>`;
        grid.appendChild(div);
    }
}

function renderParamInputs() {
    for (const [key, value] of Object.entries(settingsState.params)) {
        const input = document.getElementById(`param-${key}`);
        if (input) {
            input.value = value;
            const range = PARAM_RANGES[key];
            if (range) { input.min = range.min; input.max = range.max; input.step = range.step; }
        }
    }
}

function toggleIndicator(key) {
    settingsState.indicators[key] = !settingsState.indicators[key];
    markUnsaved();
    renderIndicatorToggles();
    detectCurrentTemplate();
}

function toggleAlert(key) {
    settingsState.alerts[key] = !settingsState.alerts[key];
    markUnsaved();
    renderAlertToggles();
}

function toggleParamsPanel() {
    const content = document.getElementById('params-collapse-content');
    const arrow = document.getElementById('params-collapse-arrow');
    if (content && arrow) { content.classList.toggle('expanded'); arrow.classList.toggle('rotated'); }
}

function collectParamValues() {
    const params = {};
    for (const key of Object.keys(PARAM_RANGES)) {
        const input = document.getElementById(`param-${key}`);
        if (input) { const value = parseFloat(input.value); if (!isNaN(value)) params[key] = value; }
    }
    return params;
}

function onParamChange() { markUnsaved(); }
function markUnsaved() { settingsState.hasUnsavedChanges = true; updateSaveButton(); }

function updateSaveButton() {
    const btn = document.getElementById('settings-save-btn');
    if (!btn) return;
    btn.disabled = false;
    btn.innerHTML = settingsState.hasUnsavedChanges 
        ? '<i class="fas fa-save"></i> 儲存設定 <span class="unsaved-badge">未儲存</span>'
        : '<i class="fas fa-save"></i> 儲存設定';
}

function updateTemplateButtons() {
    document.querySelectorAll('.template-btn').forEach(btn => {
        const template = btn.getAttribute('data-template');
        btn.classList.toggle('active', template === settingsState.currentTemplate);
    });
}

function detectCurrentTemplate() {
    const ind = settingsState.indicators;
    if (ind.show_ma && ind.show_volume && !ind.show_rsi && !ind.show_macd && !ind.show_kd && !ind.show_bollinger && !ind.show_obv) {
        settingsState.currentTemplate = 'minimal';
    } else if (ind.show_ma && ind.show_rsi && ind.show_macd && ind.show_kd && ind.show_bollinger && ind.show_obv && ind.show_volume) {
        settingsState.currentTemplate = 'full';
    } else {
        settingsState.currentTemplate = null;
    }
    updateTemplateButtons();
}

function showSettingsLoading(show) {
    const loading = document.getElementById('settings-loading');
    const content = document.getElementById('settings-content');
    if (loading) loading.classList.toggle('hidden', !show);
    if (content) content.classList.toggle('hidden', show);
}

function showSettingsMessage(text, type) {
    const msg = document.getElementById('settings-message');
    if (!msg) return;
    msg.className = `settings-message ${type}`;
    msg.textContent = text;
    msg.classList.remove('hidden');
    setTimeout(() => msg.classList.add('hidden'), 3000);
}

function updateSettingsUserInfo() {
    try {
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        const avatar = document.getElementById('settings-user-avatar');
        const name = document.getElementById('settings-user-name');
        const level = document.getElementById('settings-user-level');
        if (avatar && user.avatar_url) avatar.src = user.avatar_url;
        if (name) name.textContent = user.display_name || '用戶';
        if (level) level.textContent = user.is_admin ? '管理員' : '免費會員';
    } catch (e) { console.error('更新用戶資訊失敗:', e); }
}

// 導出
window.initSettingsPage = initSettingsPage;
window.saveAllSettings = saveAllSettings;
window.applyTemplate = applyTemplate;
window.toggleIndicator = toggleIndicator;
window.toggleAlert = toggleAlert;
window.toggleParamsPanel = toggleParamsPanel;
window.onParamChange = onParamChange;
```

──────────────────────────────────────────────────────────────────────
### 📄 static/js/watchlist-enhanced.js  ⭐
> *
──────────────────────────────────────────────────────────────────────

```js
/**
 * 追蹤清單功能模組（含到價提醒）
 * 
 * 使用方式：
 * 1. 在 dashboard.html 的 <script> 區塊中加入這些函數
 * 2. 或作為獨立 JS 檔案引入
 */

// ============================================================
// 追蹤清單（含價格和到價提醒）
// ============================================================

async function loadWatchlist() {
    const container = document.getElementById('watchlistContent');

    try {
        // 使用 with-prices API 取得含價格的追蹤清單
        const res = await fetch(`${API_BASE}/api/watchlist/with-prices`, {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        const data = await res.json();

        if (!data.success || !data.data || data.data.length === 0) {
            container.innerHTML = `
                <div class="text-center py-12">
                    <i class="fas fa-star text-gray-300 text-4xl mb-3"></i>
                    <p class="text-gray-500 mb-4">尚無追蹤的股票</p>
                    <button onclick="showAddWatchlistModal()" class="px-6 py-2 bg-blue-600 text-white rounded-lg">
                        <i class="fas fa-plus mr-2"></i>新增追蹤
                    </button>
                </div>
            `;
            return;
        }

        let html = '<div class="space-y-3">';

        for (const item of data.data) {
            const typeClass = item.asset_type === 'crypto' ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700';
            const typeText = item.asset_type === 'crypto' ? '幣' : '股';

            // 價格變動顏色
            const changeClass = item.change_pct >= 0 ? 'text-green-600' : 'text-red-600';
            const changeIcon = item.change_pct >= 0 ? '▲' : '▼';

            // 🆕 到價提醒變色
            const targetReached = item.target_reached;
            const cardBorderClass = targetReached ? 'border-2 border-yellow-400 bg-yellow-50' : 'bg-white';
            const targetBadge = targetReached ? '<span class="ml-2 px-2 py-0.5 bg-yellow-400 text-yellow-900 text-xs rounded-full animate-pulse">🎯 達標!</span>' : '';

            html += `
                <div class="stock-card ${cardBorderClass} rounded-xl shadow-sm p-4">
                    <div class="flex items-start justify-between mb-2">
                        <div class="flex items-center flex-wrap">
                            <span class="font-bold text-lg text-gray-800">${item.symbol}</span>
                            <span class="ml-2 px-2 py-0.5 rounded text-xs ${typeClass}">${typeText}</span>
                            ${targetBadge}
                        </div>
                        <div class="flex items-center space-x-1">
                            <button onclick="showTargetPriceModal(${item.id}, '${item.symbol}', ${item.target_price || 'null'})" 
                                class="p-2 text-gray-400 hover:text-yellow-500 touch-target" title="設定目標價">
                                <i class="fas fa-crosshairs"></i>
                            </button>
                            <button onclick="removeFromWatchlist(${item.id})" 
                                class="p-2 text-gray-400 hover:text-red-500 touch-target" title="移除">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    
                    ${item.name ? `<p class="text-gray-500 text-sm mb-2">${item.name}</p>` : ''}
                    
                    <!-- 價格資訊 -->
                    <div class="flex items-center justify-between mt-3">
                        <div>
                            ${item.price ? `
                                <span class="text-xl font-bold text-gray-800">$${item.price.toLocaleString()}</span>
                                <span class="ml-2 ${changeClass} text-sm">
                                    ${changeIcon} ${Math.abs(item.change_pct || 0).toFixed(2)}%
                                </span>
                            ` : '<span class="text-gray-400">價格載入中...</span>'}
                        </div>
                        <button onclick="searchSymbol('${item.symbol}')" 
                            class="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg text-sm hover:bg-gray-200 touch-target">
                            詳情
                        </button>
                    </div>
                    
                    <!-- 目標價顯示 -->
                    ${item.target_price ? `
                        <div class="mt-2 pt-2 border-t border-gray-100 flex items-center justify-between text-sm">
                            <span class="text-gray-500">
                                <i class="fas fa-crosshairs mr-1"></i>目標價
                            </span>
                            <span class="${targetReached ? 'text-yellow-600 font-bold' : 'text-gray-700'}">
                                $${item.target_price.toLocaleString()}
                            </span>
                        </div>
                    ` : ''}
                    
                    ${item.note ? `<p class="text-gray-400 text-xs mt-2">${item.note}</p>` : ''}
                </div>
            `;
        }

        html += '</div>';
        container.innerHTML = html;

    } catch (e) {
        console.error('載入追蹤清單失敗', e);
        container.innerHTML = '<p class="text-red-500 text-center py-4">載入失敗</p>';
    }
}


// ============================================================
// 目標價 Modal
// ============================================================

let currentTargetItem = null;

function showTargetPriceModal(itemId, symbol, currentTarget) {
    currentTargetItem = { id: itemId, symbol: symbol };
    
    // 如果 Modal 不存在，動態建立
    let modal = document.getElementById('targetPriceModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'targetPriceModal';
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4';
        modal.innerHTML = `
            <div class="bg-white rounded-xl w-full max-w-sm p-6">
                <h3 class="text-lg font-bold text-gray-800 mb-4">
                    <i class="fas fa-crosshairs mr-2 text-yellow-500"></i>
                    設定目標價
                </h3>
                <p id="targetSymbolDisplay" class="text-gray-600 mb-4"></p>
                <div class="mb-4">
                    <label class="block text-gray-700 mb-2 text-sm">目標價格</label>
                    <input type="number" id="targetPriceInput" step="0.01" placeholder="輸入目標價格" 
                        class="w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-yellow-500 text-base">
                    <p class="text-gray-400 text-xs mt-1">當現價達到或超過此價格時會變色提醒</p>
                </div>
                <div class="flex gap-3">
                    <button onclick="hideTargetPriceModal()" 
                        class="flex-1 px-4 py-3 border rounded-lg hover:bg-gray-50 touch-target">取消</button>
                    <button onclick="clearTargetPrice()" 
                        class="px-4 py-3 border border-red-300 text-red-500 rounded-lg hover:bg-red-50 touch-target">清除</button>
                    <button onclick="saveTargetPrice()" 
                        class="flex-1 px-4 py-3 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 touch-target">儲存</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    // 設定 Modal 內容
    document.getElementById('targetSymbolDisplay').textContent = `標的：${symbol}`;
    document.getElementById('targetPriceInput').value = currentTarget || '';
    
    // 顯示 Modal
    modal.classList.remove('hidden');
    modal.classList.add('flex');
}

function hideTargetPriceModal() {
    const modal = document.getElementById('targetPriceModal');
    if (modal) {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
    }
    currentTargetItem = null;
}

async function saveTargetPrice() {
    if (!currentTargetItem) return;
    
    const input = document.getElementById('targetPriceInput');
    const targetPrice = input.value ? parseFloat(input.value) : null;
    
    if (targetPrice !== null && (isNaN(targetPrice) || targetPrice <= 0)) {
        showToast('請輸入有效的目標價格');
        return;
    }
    
    try {
        const res = await fetch(`${API_BASE}/api/watchlist/${currentTargetItem.id}/target-price`, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ target_price: targetPrice })
        });
        
        const data = await res.json();
        
        if (data.success) {
            showToast(targetPrice ? `目標價已設定為 $${targetPrice}` : '目標價已清除');
            hideTargetPriceModal();
            loadWatchlist();  // 重新載入列表
        } else {
            showToast(data.detail || '設定失敗');
        }
    } catch (e) {
        console.error('設定目標價失敗', e);
        showToast('設定失敗');
    }
}

async function clearTargetPrice() {
    if (!currentTargetItem) return;
    
    try {
        const res = await fetch(`${API_BASE}/api/watchlist/${currentTargetItem.id}/target-price`, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ target_price: null })
        });
        
        const data = await res.json();
        
        if (data.success) {
            showToast('目標價已清除');
            hideTargetPriceModal();
            loadWatchlist();
        } else {
            showToast('清除失敗');
        }
    } catch (e) {
        showToast('清除失敗');
    }
}


// ============================================================
// 追蹤清單快覽（儀表板用，含到價提醒）
// ============================================================

async function loadWatchlistOverview() {
    const container = document.getElementById('dashboardWatchlist');

    try {
        const res = await fetch(`${API_BASE}/api/watchlist/with-prices`, {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        const data = await res.json();

        if (!data.success || !data.data || data.data.length === 0) {
            container.innerHTML = `
                <div class="text-center py-6">
                    <i class="fas fa-star text-gray-300 text-3xl mb-2"></i>
                    <p class="text-gray-500 text-sm">尚無追蹤清單</p>
                    <button onclick="showSection('search')" class="mt-2 text-blue-600 text-sm">前往查詢股票</button>
                </div>
            `;
            return;
        }

        // 只顯示前 5 筆，優先顯示達標的
        const sortedItems = [...data.data].sort((a, b) => {
            // 達標的排前面
            if (a.target_reached && !b.target_reached) return -1;
            if (!a.target_reached && b.target_reached) return 1;
            return 0;
        });
        
        const items = sortedItems.slice(0, 5);
        let html = '<div class="space-y-2">';

        for (const item of items) {
            const changeClass = item.change_pct >= 0 ? 'text-green-600' : 'text-red-600';
            const targetClass = item.target_reached ? 'bg-yellow-50 border-l-4 border-yellow-400' : '';
            
            html += `
                <div class="flex items-center justify-between py-2 px-2 -mx-2 rounded cursor-pointer hover:bg-gray-50 ${targetClass}" 
                     onclick="searchSymbol('${item.symbol}')">
                    <div class="flex items-center">
                        <span class="font-medium text-gray-800">${item.symbol}</span>
                        ${item.target_reached ? '<span class="ml-2 text-yellow-500 text-xs">🎯</span>' : ''}
                        <span class="ml-2 text-xs px-2 py-0.5 rounded ${item.asset_type === 'crypto' ? 'bg-purple-100 text-purple-700' : 'bg-blue-100 text-blue-700'}">
                            ${item.asset_type === 'crypto' ? '幣' : '股'}
                        </span>
                    </div>
                    <div class="text-right">
                        ${item.price ? `
                            <span class="text-gray-800 font-medium">$${item.price.toLocaleString()}</span>
                            <span class="${changeClass} text-xs ml-1">${item.change_pct >= 0 ? '+' : ''}${(item.change_pct || 0).toFixed(2)}%</span>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        html += '</div>';
        
        // 如果有達標的，顯示提示
        const reachedCount = data.data.filter(i => i.target_reached).length;
        if (reachedCount > 0) {
            html = `
                <div class="mb-3 p-2 bg-yellow-100 text-yellow-800 rounded-lg text-sm text-center">
                    🎯 有 ${reachedCount} 檔達到目標價！
                </div>
            ` + html;
        }
        
        container.innerHTML = html;

    } catch (e) {
        console.error('載入追蹤清單失敗', e);
        container.innerHTML = '<p class="text-red-500 text-center py-4">載入失敗</p>';
    }
}
```

──────────────────────────────────────────────────────────────────────
### 📄 static/settings-section.html  ⭐
──────────────────────────────────────────────────────────────────────

```html
<!-- SELA 設定頁面 HTML 片段 - 插入到 dashboard.html 的其他 section 之後 -->

<section id="section-settings" class="section hidden">
    <div class="max-w-2xl mx-auto p-4">
        
        <div id="settings-loading" class="settings-loading hidden">
            <i class="fas fa-spinner fa-spin"></i>
            <span>載入設定中...</span>
        </div>
        
        <div id="settings-content">
            
            <!-- 用戶資訊 -->
            <div class="user-info-card">
                <div class="flex items-center gap-4">
                    <img id="settings-user-avatar" src="" alt="頭像" class="user-avatar"
                         onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23666%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2255%22 text-anchor=%22middle%22 fill=%22white%22 font-size=%2240%22>👤</text></svg>'">
                    <div>
                        <div class="user-name" id="settings-user-name">載入中...</div>
                        <div class="user-level">
                            <i class="fas fa-crown text-yellow-400"></i>
                            <span id="settings-user-level">免費會員</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 快速模板 -->
            <div class="settings-card">
                <div class="settings-card-header">
                    <i class="fas fa-palette text-orange-500"></i>
                    <h3>快速模板</h3>
                </div>
                <div class="grid grid-cols-4 gap-2">
                    <button onclick="applyTemplate('minimal')" class="template-btn" data-template="minimal">
                        <i class="fas fa-feather-alt"></i><span>極簡</span>
                    </button>
                    <button onclick="applyTemplate('standard')" class="template-btn" data-template="standard">
                        <i class="fas fa-balance-scale"></i><span>標準</span>
                    </button>
                    <button onclick="applyTemplate('full')" class="template-btn" data-template="full">
                        <i class="fas fa-layer-group"></i><span>完整</span>
                    </button>
                    <button onclick="applyTemplate('short_term')" class="template-btn" data-template="short_term">
                        <i class="fas fa-bolt"></i><span>短線</span>
                    </button>
                </div>
                <p class="text-xs text-gray-500 mt-3 text-center">選擇預設組合，快速套用指標和通知設定</p>
            </div>
            
            <!-- 指標顯示 -->
            <div class="settings-card">
                <div class="settings-card-header">
                    <i class="fas fa-chart-line text-blue-500"></i>
                    <h3>指標顯示</h3>
                </div>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-3" id="indicators-grid"></div>
            </div>
            
            <!-- 通知設定 -->
            <div class="settings-card">
                <div class="settings-card-header">
                    <i class="fas fa-bell text-yellow-500"></i>
                    <h3>通知設定</h3>
                </div>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-3" id="alerts-grid"></div>
                <p class="text-xs text-gray-500 mt-3"><i class="fas fa-info-circle mr-1"></i>開啟的通知將透過 LINE 推播</p>
            </div>
            
            <!-- 進階參數 -->
            <div class="settings-card" style="padding: 0; overflow: hidden;">
                <button onclick="toggleParamsPanel()" class="collapse-header">
                    <div class="flex items-center gap-2">
                        <i class="fas fa-sliders-h text-purple-500"></i>
                        <h3 class="text-base font-bold text-gray-800">進階參數</h3>
                    </div>
                    <i class="fas fa-chevron-down collapse-arrow" id="params-collapse-arrow"></i>
                </button>
                
                <div id="params-collapse-content" class="collapse-content">
                    <div class="collapse-content-inner pt-4">
                        
                        <!-- 均線參數 -->
                        <div class="mb-5">
                            <div class="param-section-title"><i class="fas fa-wave-square text-blue-500"></i>均線週期</div>
                            <div class="grid grid-cols-3 gap-3">
                                <div><label class="param-label">短期</label><input type="number" id="param-ma_short" class="param-input" onchange="onParamChange()"></div>
                                <div><label class="param-label">中期</label><input type="number" id="param-ma_mid" class="param-input" onchange="onParamChange()"></div>
                                <div><label class="param-label">長期</label><input type="number" id="param-ma_long" class="param-input" onchange="onParamChange()"></div>
                            </div>
                        </div>
                        
                        <!-- RSI 參數 -->
                        <div class="mb-5">
                            <div class="param-section-title"><i class="fas fa-tachometer-alt text-green-500"></i>RSI 參數</div>
                            <div class="grid grid-cols-3 gap-3">
                                <div><label class="param-label">週期</label><input type="number" id="param-rsi_period" class="param-input" onchange="onParamChange()"></div>
                                <div><label class="param-label">超買</label><input type="number" id="param-rsi_overbought" class="param-input" onchange="onParamChange()"></div>
                                <div><label class="param-label">超賣</label><input type="number" id="param-rsi_oversold" class="param-input" onchange="onParamChange()"></div>
                            </div>
                        </div>
                        
                        <!-- MACD 參數 -->
                        <div class="mb-5">
                            <div class="param-section-title"><i class="fas fa-signal text-purple-500"></i>MACD 參數</div>
                            <div class="grid grid-cols-3 gap-3">
                                <div><label class="param-label">快線</label><input type="number" id="param-macd_fast" class="param-input" onchange="onParamChange()"></div>
                                <div><label class="param-label">慢線</label><input type="number" id="param-macd_slow" class="param-input" onchange="onParamChange()"></div>
                                <div><label class="param-label">訊號</label><input type="number" id="param-macd_signal" class="param-input" onchange="onParamChange()"></div>
                            </div>
                        </div>
                        
                        <!-- 其他參數 -->
                        <div>
                            <div class="param-section-title"><i class="fas fa-cog text-gray-500"></i>其他參數</div>
                            <div class="grid grid-cols-2 gap-3">
                                <div><label class="param-label">KD 週期</label><input type="number" id="param-kd_period" class="param-input" onchange="onParamChange()"></div>
                                <div><label class="param-label">布林週期</label><input type="number" id="param-bollinger_period" class="param-input" onchange="onParamChange()"></div>
                                <div><label class="param-label">突破門檻(%)</label><input type="number" id="param-breakout_threshold" class="param-input" step="0.1" onchange="onParamChange()"></div>
                                <div><label class="param-label">量比倍數</label><input type="number" id="param-volume_alert_ratio" class="param-input" step="0.1" onchange="onParamChange()"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 儲存按鈕 -->
            <button onclick="saveAllSettings()" id="settings-save-btn" class="save-btn">
                <i class="fas fa-save"></i>儲存設定
            </button>
            
            <div id="settings-message" class="settings-message hidden"></div>
            
            <div class="text-center text-xs text-gray-400 mt-6">SELA 自動選股系統 v0.9.1</div>
        </div>
    </div>
</section>
```

======================================================================
## 📁 其他檔案
======================================================================

──────────────────────────────────────────────────────────────────────
### 📄 app/__init__.py  ⭐
> Stock Analysis System
──────────────────────────────────────────────────────────────────────

```py
"""
Stock Analysis System
多用戶股票與加密貨幣技術分析平台
"""
__version__ = "0.1.0"
```

──────────────────────────────────────────────────────────────────────
### 📄 app/cli.py  ⭐
> 股票分析系統 CLI
──────────────────────────────────────────────────────────────────────

```py
#!/usr/bin/env python3
"""
股票分析系統 CLI
命令列查詢介面
"""
import sys
import argparse
from datetime import datetime
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
from rich import box

from app.database import init_db_sync, get_sync_session
from app.services.stock_service import StockService
from app.services.crypto_service import CryptoService
from app.services.chart_service import chart_service
from app.data_sources.coingecko import CRYPTO_MAP
from app.config import settings

console = Console()

# 支援的加密貨幣代號
SUPPORTED_CRYPTO = set(k for k in CRYPTO_MAP.keys() if k not in ("BITCOIN", "ETHEREUM"))


def print_header():
    """顯示標題"""
    console.print()
    console.print(Panel.fit(
        "[bold orange1]📈 股票技術分析系統[/bold orange1]\n"
        f"[dim]版本 {settings.APP_VERSION}[/dim]",
        border_style="orange1",
    ))
    console.print()


def is_crypto(symbol: str) -> bool:
    """判斷是否為加密貨幣"""
    return symbol.upper() in SUPPORTED_CRYPTO


def print_stock_analysis(analysis: dict):
    """顯示股票分析報告"""
    symbol = analysis["symbol"]
    name = analysis["name"]
    price_info = analysis["price"]
    change_info = analysis["change"]
    volume_info = analysis.get("volume", {})
    indicators = analysis["indicators"]
    signals = analysis["signals"]
    score = analysis["score"]
    
    # 標題
    console.print(Panel(
        f"[bold]{symbol}[/bold] - {name}",
        border_style="blue",
    ))
    
    # 價格資訊
    price_table = Table(title="💰 價格資訊", box=box.ROUNDED, show_header=False)
    price_table.add_column("項目", style="cyan")
    price_table.add_column("數值", justify="right")
    
    current_price = price_info["current"]
    price_table.add_row("現價", f"[bold green]${current_price:,.2f}[/bold green]")
    
    if price_info.get("high_52w"):
        price_table.add_row("52週最高", f"${price_info['high_52w']:,.2f}")
    if price_info.get("low_52w"):
        price_table.add_row("52週最低", f"${price_info['low_52w']:,.2f}")
    if price_info.get("from_high_pct"):
        pct = price_info["from_high_pct"]
        color = "red" if pct < 0 else "green"
        price_table.add_row("距高點", f"[{color}]{pct:+.2f}%[/{color}]")
    if price_info.get("from_low_pct"):
        pct = price_info["from_low_pct"]
        color = "green" if pct > 0 else "red"
        price_table.add_row("距低點", f"[{color}]{pct:+.2f}%[/{color}]")
    
    console.print(price_table)
    console.print()
    
    # 漲跌幅
    change_table = Table(title="📊 漲跌幅", box=box.ROUNDED)
    change_table.add_column("日", justify="center")
    change_table.add_column("週", justify="center")
    change_table.add_column("月", justify="center")
    change_table.add_column("季", justify="center")
    change_table.add_column("年", justify="center")
    
    def format_change(val):
        if val is None:
            return "-"
        color = "green" if val >= 0 else "red"
        return f"[{color}]{val:+.2f}%[/{color}]"
    
    change_table.add_row(
        format_change(change_info.get("day")),
        format_change(change_info.get("week")),
        format_change(change_info.get("month")),
        format_change(change_info.get("quarter")),
        format_change(change_info.get("year")),
    )
    
    console.print(change_table)
    console.print()
    
    # 成交量
    if volume_info:
        vol_table = Table(title="📈 成交量", box=box.ROUNDED, show_header=False)
        vol_table.add_column("項目", style="cyan")
        vol_table.add_column("數值", justify="right")
        
        vol_table.add_row("今日成交量", f"{volume_info.get('today', 0):,}")
        if volume_info.get("avg_20d"):
            vol_table.add_row("20日均量", f"{volume_info['avg_20d']:,}")
        if volume_info.get("ratio"):
            ratio = volume_info["ratio"]
            color = "yellow" if ratio >= 2.0 else ("green" if ratio >= 1.0 else "dim")
            vol_table.add_row("量比", f"[{color}]{ratio:.2f}[/{color}]")
        
        console.print(vol_table)
        console.print()
    
    # 技術指標
    _print_indicators(indicators)
    
    # 訊號
    if signals:
        signal_panel = Panel(
            "\n".join([f"• {s['description']}" for s in signals]),
            title="⚡ 最新訊號",
            border_style="yellow",
        )
        console.print(signal_panel)
        console.print()
    
    # 綜合評分
    _print_score(score)
    
    # 更新時間
    console.print()
    console.print(f"[dim]更新時間: {analysis.get('updated_at', '-')}[/dim]")


def print_crypto_analysis(analysis: dict):
    """顯示加密貨幣分析報告"""
    symbol = analysis["symbol"]
    name = analysis["name"]
    price_info = analysis["price"]
    change_info = analysis["change"]
    market_info = analysis.get("market", {})
    indicators = analysis["indicators"]
    signals = analysis["signals"]
    score = analysis["score"]
    
    # 標題
    console.print(Panel(
        f"[bold]{symbol}[/bold] - {name} [dim](加密貨幣)[/dim]",
        border_style="yellow",
    ))
    
    # 價格資訊
    price_table = Table(title="💰 價格資訊", box=box.ROUNDED, show_header=False)
    price_table.add_column("項目", style="cyan")
    price_table.add_column("數值", justify="right")
    
    current_price = price_info["current"]
    if current_price >= 1000:
        price_table.add_row("現價", f"[bold green]${current_price:,.2f}[/bold green]")
    else:
        price_table.add_row("現價", f"[bold green]${current_price:,.4f}[/bold green]")
    
    if price_info.get("ath"):
        price_table.add_row("歷史最高 (ATH)", f"${price_info['ath']:,.2f}")
    if price_info.get("from_ath_pct"):
        pct = price_info["from_ath_pct"]
        color = "red" if pct < 0 else "green"
        price_table.add_row("距 ATH", f"[{color}]{pct:+.2f}%[/{color}]")
    if price_info.get("high_24h"):
        price_table.add_row("24H 最高", f"${price_info['high_24h']:,.2f}")
    if price_info.get("low_24h"):
        price_table.add_row("24H 最低", f"${price_info['low_24h']:,.2f}")
    
    console.print(price_table)
    console.print()
    
    # 市場資訊
    if market_info:
        market_table = Table(title="🌐 市場資訊", box=box.ROUNDED, show_header=False)
        market_table.add_column("項目", style="cyan")
        market_table.add_column("數值", justify="right")
        
        if market_info.get("market_cap"):
            market_table.add_row("市值", f"${market_info['market_cap']:,.0f}")
        if market_info.get("market_cap_rank"):
            market_table.add_row("市值排名", f"#{market_info['market_cap_rank']}")
        if market_info.get("volume_24h"):
            market_table.add_row("24H 成交量", f"${market_info['volume_24h']:,.0f}")
        
        console.print(market_table)
        console.print()
    
    # 漲跌幅
    change_table = Table(title="📊 漲跌幅", box=box.ROUNDED)
    change_table.add_column("24H", justify="center")
    change_table.add_column("7D", justify="center")
    change_table.add_column("30D", justify="center")
    change_table.add_column("1Y", justify="center")
    
    def format_change(val):
        if val is None:
            return "-"
        color = "green" if val >= 0 else "red"
        return f"[{color}]{val:+.2f}%[/{color}]"
    
    change_table.add_row(
        format_change(change_info.get("day")),
        format_change(change_info.get("week")),
        format_change(change_info.get("month")),
        format_change(change_info.get("year")),
    )
    
    console.print(change_table)
    console.print()
    
    # 技術指標
    _print_crypto_indicators(indicators)
    
    # 訊號
    if signals:
        signal_panel = Panel(
            "\n".join([f"• {s['description']}" for s in signals]),
            title="⚡ 最新訊號",
            border_style="yellow",
        )
        console.print(signal_panel)
        console.print()
    
    # 綜合評分
    _print_score(score)
    
    # 更新時間
    console.print()
    console.print(f"[dim]更新時間: {analysis.get('updated_at', '-')}[/dim]")


def _print_indicators(indicators: dict):
    """列印技術指標（股票版）"""
    ind_table = Table(title="📐 技術指標", box=box.ROUNDED)
    ind_table.add_column("指標", style="cyan")
    ind_table.add_column("數值", justify="right")
    ind_table.add_column("狀態", justify="center")
    
    # MA
    ma = indicators.get("ma", {})
    alignment = ma.get("alignment", "neutral")
    alignment_text = {
        "bullish": "[green]多頭排列[/green]",
        "bearish": "[red]空頭排列[/red]",
        "neutral": "[yellow]盤整[/yellow]",
    }.get(alignment, alignment)
    
    for ma_key in [f"ma{settings.MA_SHORT}", f"ma{settings.MA_MID}", f"ma{settings.MA_LONG}"]:
        val = ma.get(ma_key)
        pos = ma.get(f"price_vs_{ma_key}")
        pos_text = "[green]▲[/green]" if pos == "above" else "[red]▼[/red]" if pos == "below" else ""
        ind_table.add_row(
            ma_key.upper(),
            f"${val:,.2f}" if val else "-",
            pos_text,
        )
    
    ind_table.add_row("排列", "", alignment_text)
    
    # RSI
    rsi = indicators.get("rsi", {})
    rsi_val = rsi.get("value")
    rsi_status = rsi.get("status", "")
    rsi_color = "red" if rsi_status == "overbought" else "green" if rsi_status == "oversold" else "white"
    rsi_status_text = {
        "overbought": "[red]超買[/red]",
        "oversold": "[green]超賣[/green]",
        "neutral": "中性",
    }.get(rsi_status, rsi_status)
    
    ind_table.add_row(
        "RSI",
        f"[{rsi_color}]{rsi_val:.1f}[/{rsi_color}]" if rsi_val else "-",
        rsi_status_text,
    )
    
    # MACD
    macd = indicators.get("macd", {})
    macd_hist = macd.get("histogram")
    macd_status = macd.get("status", "")
    macd_color = "green" if macd_status == "bullish" else "red"
    
    ind_table.add_row(
        "MACD 柱",
        f"[{macd_color}]{macd_hist:.4f}[/{macd_color}]" if macd_hist is not None else "-",
        f"[{macd_color}]{'多' if macd_status == 'bullish' else '空'}[/{macd_color}]",
    )
    
    # Bollinger
    bb = indicators.get("bollinger", {})
    bb_pos = bb.get("position", "")
    bb_pos_text = {
        "above_upper": "[red]超出上軌[/red]",
        "below_lower": "[green]跌破下軌[/green]",
        "upper_half": "通道上半",
        "lower_half": "通道下半",
    }.get(bb_pos, bb_pos)
    
    ind_table.add_row(
        "布林",
        f"↑{bb.get('upper'):.2f} ↓{bb.get('lower'):.2f}" if bb.get("upper") else "-",
        bb_pos_text,
    )
    
    console.print(ind_table)
    console.print()


def _print_crypto_indicators(indicators: dict):
    """列印技術指標（加密貨幣版）"""
    ind_table = Table(title="📐 技術指標", box=box.ROUNDED)
    ind_table.add_column("指標", style="cyan")
    ind_table.add_column("數值", justify="right")
    ind_table.add_column("狀態", justify="center")
    
    # MA（幣圈週期）
    ma = indicators.get("ma", {})
    alignment = ma.get("alignment", "neutral")
    alignment_text = {
        "bullish": "[green]多頭排列[/green]",
        "bearish": "[red]空頭排列[/red]",
        "neutral": "[yellow]盤整[/yellow]",
    }.get(alignment, alignment)
    
    for ma_key in ["ma7", "ma25", "ma99"]:
        val = ma.get(ma_key)
        ind_table.add_row(
            ma_key.upper(),
            f"${val:,.2f}" if val else "-",
            "",
        )
    
    ind_table.add_row("排列", "", alignment_text)
    
    # RSI
    rsi = indicators.get("rsi", {})
    rsi_val = rsi.get("value")
    rsi_status = rsi.get("status", "")
    rsi_color = "red" if rsi_status == "overbought" else "green" if rsi_status == "oversold" else "white"
    rsi_status_text = {
        "overbought": "[red]超買[/red]",
        "oversold": "[green]超賣[/green]",
        "neutral": "中性",
    }.get(rsi_status, rsi_status)
    
    ind_table.add_row(
        "RSI",
        f"[{rsi_color}]{rsi_val:.1f}[/{rsi_color}]" if rsi_val else "-",
        rsi_status_text,
    )
    
    # MACD
    macd = indicators.get("macd", {})
    macd_hist = macd.get("histogram")
    macd_status = macd.get("status", "")
    macd_color = "green" if macd_status == "bullish" else "red"
    
    ind_table.add_row(
        "MACD",
        f"[{macd_color}]{macd_hist:.2f}[/{macd_color}]" if macd_hist is not None else "-",
        f"[{macd_color}]{'多' if macd_status == 'bullish' else '空'}[/{macd_color}]",
    )
    
    console.print(ind_table)
    console.print()


def _print_score(score: dict):
    """列印綜合評分"""
    buy_score = score.get("buy_score", 0)
    sell_score = score.get("sell_score", 0)
    rating = score.get("rating", "neutral")
    details = score.get("details", [])
    
    rating_text = {
        "strong_buy": "[bold green]強烈買進 ⭐⭐⭐⭐⭐[/bold green]",
        "buy": "[green]買進 ⭐⭐⭐⭐[/green]",
        "neutral": "[yellow]中性 ⭐⭐⭐[/yellow]",
        "sell": "[red]賣出 ⭐⭐[/red]",
        "strong_sell": "[bold red]強烈賣出 ⭐[/bold red]",
        "insufficient_data": "[dim]資料不足[/dim]",
    }.get(rating, rating)
    
    score_content = f"買進訊號: {buy_score} / 賣出訊號: {sell_score}\n"
    score_content += f"綜合評等: {rating_text}\n\n"
    if details:
        score_content += "\n".join(details)
    
    console.print(Panel(
        score_content,
        title="🎯 綜合評分",
        border_style="magenta",
    ))


def print_sentiment(sentiment: dict):
    """顯示市場情緒"""
    console.print(Panel.fit(
        "[bold]📊 市場情緒指數[/bold]",
        border_style="cyan",
    ))
    
    sent_table = Table(box=box.ROUNDED)
    sent_table.add_column("市場", style="cyan")
    sent_table.add_column("指數", justify="center")
    sent_table.add_column("狀態", justify="center")
    sent_table.add_column("建議", justify="left")
    
    from app.data_sources.fear_greed import fear_greed as fg_client
    
    for market, data in sentiment.items():
        if not data:
            continue
        
        value = data.get("value", 0)
        classification_zh = data.get("classification_zh", "")
        
        # 根據數值決定顏色
        if value <= 25:
            color = "green"
            emoji = "😱"
        elif value <= 45:
            color = "cyan"
            emoji = "😟"
        elif value <= 55:
            color = "yellow"
            emoji = "😐"
        elif value <= 75:
            color = "orange1"
            emoji = "😊"
        else:
            color = "red"
            emoji = "🤑"
        
        market_name = "美股" if market == "stock" else "加密貨幣"
        advice = fg_client.get_sentiment_advice(value)
        
        sent_table.add_row(
            market_name,
            f"[{color}]{value}[/{color}] {emoji}",
            f"[{color}]{classification_zh}[/{color}]",
            advice[:30] + "..." if len(advice) > 30 else advice,
        )
    
    console.print(sent_table)


def cmd_query(args):
    """查詢股票或加密貨幣"""
    symbol = args.symbol.upper()
    
    db = get_sync_session()
    try:
        if is_crypto(symbol):
            # 加密貨幣
            with console.status(f"[bold green]正在分析 {symbol} (加密貨幣)..."):
                service = CryptoService(db)
                analysis = service.get_crypto_analysis(symbol, force_refresh=args.refresh)
                
                if analysis is None:
                    console.print(f"[red]❌ 找不到加密貨幣: {symbol}[/red]")
                    return 1
                
                print_crypto_analysis(analysis)
        else:
            # 股票
            with console.status(f"[bold green]正在分析 {symbol}..."):
                service = StockService(db)
                analysis = service.get_stock_analysis(symbol, force_refresh=args.refresh)
                
                if analysis is None:
                    console.print(f"[red]❌ 找不到股票: {symbol}[/red]")
                    return 1
                
                print_stock_analysis(analysis)
        
        return 0
    finally:
        db.close()


def cmd_sentiment(args):
    """查詢市場情緒"""
    with console.status("[bold green]正在取得市場情緒..."):
        db = get_sync_session()
        try:
            service = CryptoService(db)
            sentiment = service.get_market_sentiment("all")
            
            if not sentiment:
                console.print("[yellow]⚠️ 無法取得市場情緒資料[/yellow]")
                return 1
            
            print_sentiment(sentiment)
            return 0
        finally:
            db.close()


def cmd_chart(args):
    """生成圖表"""
    symbol = args.symbol.upper()
    
    db = get_sync_session()
    try:
        if is_crypto(symbol):
            service = CryptoService(db)
            with console.status(f"[bold green]正在生成 {symbol} 圖表..."):
                df = service.get_crypto_data(symbol)
        else:
            service = StockService(db)
            with console.status(f"[bold green]正在生成 {symbol} 圖表..."):
                df = service.get_stock_data(symbol)
        
        if df is None:
            console.print(f"[red]❌ 無法取得資料: {symbol}[/red]")
            return 1
        
        # 生成圖表
        chart_path = chart_service.plot_stock_analysis(
            df,
            symbol,
            days=args.days,
            show_kd=args.kd,
        )
        
        console.print(f"[green]✅ 圖表已儲存: {chart_path}[/green]")
        return 0
        
    finally:
        db.close()


def cmd_refresh(args):
    """更新資料"""
    symbol = args.symbol.upper()
    
    db = get_sync_session()
    try:
        if is_crypto(symbol):
            with console.status(f"[bold green]正在更新 {symbol}..."):
                service = CryptoService(db)
                success = service.fetch_and_cache_crypto(symbol)
        else:
            with console.status(f"[bold green]正在更新 {symbol}..."):
                service = StockService(db)
                success = service.fetch_and_cache_stock(symbol)
        
        if success:
            console.print(f"[green]✅ 已更新 {symbol} 資料[/green]")
            return 0
        else:
            console.print(f"[red]❌ 更新失敗: {symbol}[/red]")
            return 1
    finally:
        db.close()


def cmd_init(args):
    """初始化資料庫"""
    with console.status("[bold green]正在初始化資料庫..."):
        init_db_sync()
    console.print("[green]✅ 資料庫初始化完成[/green]")
    return 0


def main():
    """主程式"""
    parser = argparse.ArgumentParser(
        description="股票技術分析系統",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    
    subparsers = parser.add_subparsers(dest="command", help="可用指令")
    
    # init 指令
    init_parser = subparsers.add_parser("init", help="初始化資料庫")
    init_parser.set_defaults(func=cmd_init)
    
    # query 指令
    query_parser = subparsers.add_parser("query", help="查詢股票或加密貨幣")
    query_parser.add_argument("symbol", help="代號 (股票如 AAPL, 加密貨幣如 BTC)")
    query_parser.add_argument("-r", "--refresh", action="store_true", help="強制更新資料")
    query_parser.set_defaults(func=cmd_query)
    
    # sentiment 指令
    sentiment_parser = subparsers.add_parser("sentiment", help="查詢市場情緒")
    sentiment_parser.set_defaults(func=cmd_sentiment)
    
    # chart 指令
    chart_parser = subparsers.add_parser("chart", help="生成技術分析圖表")
    chart_parser.add_argument("symbol", help="代號")
    chart_parser.add_argument("-d", "--days", type=int, default=120, help="顯示天數 (預設 120)")
    chart_parser.add_argument("--kd", action="store_true", help="顯示 KD 指標")
    chart_parser.set_defaults(func=cmd_chart)
    
    # refresh 指令
    refresh_parser = subparsers.add_parser("refresh", help="更新資料")
    refresh_parser.add_argument("symbol", help="代號")
    refresh_parser.set_defaults(func=cmd_refresh)
    
    # 解析參數
    args = parser.parse_args()
    
    print_header()
    
    if not args.command:
        # 互動模式
        console.print("[cyan]輸入代號進行查詢 (股票如 AAPL，加密貨幣如 BTC)[/cyan]")
        console.print("[cyan]輸入 'sentiment' 查看市場情緒，'q' 離開[/cyan]")
        console.print()
        
        init_db_sync()
        db = get_sync_session()
        stock_service = StockService(db)
        crypto_service = CryptoService(db)
        
        try:
            while True:
                try:
                    user_input = console.input("[bold]代號> [/bold]").strip().upper()
                    
                    if user_input in ("Q", "QUIT", "EXIT"):
                        console.print("[yellow]再見！[/yellow]")
                        break
                    
                    if not user_input:
                        continue
                    
                    if user_input == "SENTIMENT":
                        sentiment = crypto_service.get_market_sentiment("all")
                        if sentiment:
                            print_sentiment(sentiment)
                        else:
                            console.print("[yellow]⚠️ 無法取得市場情緒[/yellow]")
                        console.print()
                        continue
                    
                    # 查詢股票或加密貨幣
                    if is_crypto(user_input):
                        with console.status(f"[bold green]正在分析 {user_input}..."):
                            analysis = crypto_service.get_crypto_analysis(user_input)
                        if analysis:
                            print_crypto_analysis(analysis)
                        else:
                            console.print(f"[red]❌ 找不到: {user_input}[/red]")
                    else:
                        with console.status(f"[bold green]正在分析 {user_input}..."):
                            analysis = stock_service.get_stock_analysis(user_input)
                        if analysis:
                            print_stock_analysis(analysis)
                        else:
                            console.print(f"[red]❌ 找不到: {user_input}[/red]")
                    
                    console.print()
                    
                except KeyboardInterrupt:
                    console.print("\n[yellow]再見！[/yellow]")
                    break
        finally:
            db.close()
        
        return 0
    
    # 執行指令
    return args.func(args)


if __name__ == "__main__":
    sys.exit(main())
```

──────────────────────────────────────────────────────────────────────
### 📄 app/data_sources/__init__.py  ⭐
> 外部資料來源模組
──────────────────────────────────────────────────────────────────────

```py
"""
外部資料來源模組
"""
from app.data_sources.yahoo_finance import yahoo_finance
from app.data_sources.coingecko import coingecko
from app.data_sources.fear_greed import fear_greed

__all__ = [
    "yahoo_finance",
    "coingecko",
    "fear_greed",
]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/data_sources/coingecko.py  ⭐
> CoinGecko API 資料來源
──────────────────────────────────────────────────────────────────────

```py
"""
CoinGecko API 資料來源
抓取加密貨幣價格資料
"""
import requests
import pandas as pd
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
import logging
import time

logger = logging.getLogger(__name__)

# CoinGecko API 基礎 URL
BASE_URL = "https://api.coingecko.com/api/v3"

# 支援的加密貨幣對應
CRYPTO_MAP = {
    "BTC": "bitcoin",
    "ETH": "ethereum",
    "BITCOIN": "bitcoin",
    "ETHEREUM": "ethereum",
}


class CoinGeckoClient:
    """CoinGecko API 客戶端"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "Accept": "application/json",
        })
        self._last_request_time = 0
        self._min_request_interval = 1.5  # 免費 API 限制：~30 次/分鐘
    
    def _rate_limit(self):
        """速率限制"""
        elapsed = time.time() - self._last_request_time
        if elapsed < self._min_request_interval:
            time.sleep(self._min_request_interval - elapsed)
        self._last_request_time = time.time()
    
    def _get(self, endpoint: str, params: dict = None) -> Optional[Dict]:
        """發送 GET 請求"""
        self._rate_limit()
        
        try:
            url = f"{BASE_URL}/{endpoint}"
            logger.info(f"CoinGecko API 請求: {url}")
            response = self.session.get(url, params=params, timeout=15)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.Timeout as e:
            logger.error(f"CoinGecko API 請求超時: {e}")
            return None
        except requests.exceptions.ConnectionError as e:
            logger.error(f"CoinGecko API 連線失敗 (可能被網路限制): {e}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"CoinGecko API 請求失敗: {e}")
            return None
    
    def get_coin_id(self, symbol: str) -> Optional[str]:
        """將代號轉換為 CoinGecko ID"""
        symbol = symbol.upper()
        return CRYPTO_MAP.get(symbol)
    
    def get_current_price(self, symbols: List[str]) -> Optional[Dict[str, Any]]:
        """
        取得即時價格
        
        Args:
            symbols: 代號列表 (如 ["BTC", "ETH"])
            
        Returns:
            {
                "BTC": {"price": 67850, "change_24h": 2.35, ...},
                "ETH": {"price": 3450, "change_24h": 1.82, ...}
            }
        """
        # 轉換代號
        coin_ids = []
        symbol_map = {}
        for symbol in symbols:
            coin_id = self.get_coin_id(symbol)
            if coin_id:
                coin_ids.append(coin_id)
                symbol_map[coin_id] = symbol.upper()
        
        if not coin_ids:
            return None
        
        params = {
            "ids": ",".join(coin_ids),
            "vs_currencies": "usd",
            "include_24hr_change": "true",
            "include_24hr_vol": "true",
            "include_market_cap": "true",
        }
        
        data = self._get("simple/price", params)
        if not data:
            return None
        
        result = {}
        for coin_id, values in data.items():
            symbol = symbol_map.get(coin_id, coin_id.upper())
            result[symbol] = {
                "price": values.get("usd"),
                "change_24h": values.get("usd_24h_change"),
                "volume_24h": values.get("usd_24h_vol"),
                "market_cap": values.get("usd_market_cap"),
            }
        
        return result
    
    def get_coin_info(self, symbol: str) -> Optional[Dict[str, Any]]:
        """
        取得加密貨幣詳細資訊
        
        Args:
            symbol: 代號 (如 BTC, ETH)
            
        Returns:
            包含價格、市值、歷史高點等資訊
        """
        coin_id = self.get_coin_id(symbol)
        if not coin_id:
            logger.warning(f"不支援的加密貨幣: {symbol}")
            return None
        
        params = {
            "localization": "false",
            "tickers": "false",
            "community_data": "false",
            "developer_data": "false",
        }
        
        data = self._get(f"coins/{coin_id}", params)
        if not data:
            return None
        
        market_data = data.get("market_data", {})
        
        return {
            "symbol": symbol.upper(),
            "name": data.get("name"),
            "current_price": market_data.get("current_price", {}).get("usd"),
            "market_cap": market_data.get("market_cap", {}).get("usd"),
            "market_cap_rank": market_data.get("market_cap_rank"),
            "total_volume": market_data.get("total_volume", {}).get("usd"),
            "high_24h": market_data.get("high_24h", {}).get("usd"),
            "low_24h": market_data.get("low_24h", {}).get("usd"),
            "price_change_24h": market_data.get("price_change_24h"),
            "price_change_percentage_24h": market_data.get("price_change_percentage_24h"),
            "price_change_percentage_7d": market_data.get("price_change_percentage_7d"),
            "price_change_percentage_30d": market_data.get("price_change_percentage_30d"),
            "price_change_percentage_1y": market_data.get("price_change_percentage_1y"),
            "ath": market_data.get("ath", {}).get("usd"),
            "ath_date": market_data.get("ath_date", {}).get("usd"),
            "ath_change_percentage": market_data.get("ath_change_percentage", {}).get("usd"),
            "atl": market_data.get("atl", {}).get("usd"),
            "atl_date": market_data.get("atl_date", {}).get("usd"),
            "circulating_supply": market_data.get("circulating_supply"),
            "total_supply": market_data.get("total_supply"),
            "last_updated": data.get("last_updated"),
        }
    
    def get_market_chart(
        self,
        symbol: str,
        days: int = 365,
    ) -> Optional[pd.DataFrame]:
        """
        取得歷史價格資料
        
        Args:
            symbol: 代號 (如 BTC, ETH)
            days: 天數 (最多 365 天，免費 API 限制)
            
        Returns:
            DataFrame with columns: date, price, volume, market_cap
        """
        coin_id = self.get_coin_id(symbol)
        if not coin_id:
            return None
        
        params = {
            "vs_currency": "usd",
            "days": min(days, 365),  # 免費 API 限制
            "interval": "daily",
        }
        
        data = self._get(f"coins/{coin_id}/market_chart", params)
        if not data:
            return None
        
        # 解析資料
        prices = data.get("prices", [])
        volumes = data.get("total_volumes", [])
        market_caps = data.get("market_caps", [])
        
        if not prices:
            return None
        
        records = []
        for i, (timestamp, price) in enumerate(prices):
            record = {
                "date": datetime.fromtimestamp(timestamp / 1000).date(),
                "price": price,
                "volume_24h": volumes[i][1] if i < len(volumes) else None,
                "market_cap": market_caps[i][1] if i < len(market_caps) else None,
            }
            records.append(record)
        
        df = pd.DataFrame(records)
        df["symbol"] = symbol.upper()
        
        # 移除重複日期（保留最後一筆）
        df = df.drop_duplicates(subset=["date"], keep="last")
        df = df.sort_values("date").reset_index(drop=True)
        
        return df
    
    def get_ohlc(
        self,
        symbol: str,
        days: int = 365,
    ) -> Optional[pd.DataFrame]:
        """
        取得 OHLC 資料（K線資料）
        
        Args:
            symbol: 代號
            days: 天數 (1/7/14/30/90/180/365/max)
            
        Returns:
            DataFrame with columns: date, open, high, low, close
        """
        coin_id = self.get_coin_id(symbol)
        if not coin_id:
            return None
        
        # CoinGecko OHLC 只支援特定天數
        valid_days = [1, 7, 14, 30, 90, 180, 365]
        days = min(valid_days, key=lambda x: abs(x - days))
        
        params = {
            "vs_currency": "usd",
            "days": days,
        }
        
        data = self._get(f"coins/{coin_id}/ohlc", params)
        if not data:
            return None
        
        records = []
        for item in data:
            timestamp, open_p, high, low, close = item
            records.append({
                "date": datetime.fromtimestamp(timestamp / 1000).date(),
                "open": open_p,
                "high": high,
                "low": low,
                "close": close,
            })
        
        df = pd.DataFrame(records)
        df["symbol"] = symbol.upper()
        
        # 移除重複日期
        df = df.drop_duplicates(subset=["date"], keep="last")
        df = df.sort_values("date").reset_index(drop=True)
        
        return df
    
    def validate_symbol(self, symbol: str) -> bool:
        """驗證代號是否支援"""
        return self.get_coin_id(symbol) is not None


# 建立全域客戶端實例
coingecko = CoinGeckoClient()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/data_sources/fear_greed.py  ⭐
> 市場情緒指數資料來源
──────────────────────────────────────────────────────────────────────

```py
"""
市場情緒指數資料來源
- CNN Fear & Greed Index (美股)
- Alternative.me (加密貨幣)
"""
import requests
from datetime import datetime, date
from typing import Optional, Dict, Any, List
import logging
import re

logger = logging.getLogger(__name__)


class FearGreedClient:
    """市場情緒指數客戶端"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        })
    
    # ==================== 加密貨幣情緒 (Alternative.me) ====================
    
    def get_crypto_fear_greed(self, limit: int = 1) -> Optional[Dict[str, Any]]:
        """
        取得加密貨幣 Fear & Greed 指數
        來源: Alternative.me
        
        Args:
            limit: 取得天數 (1 = 只取今天)
            
        Returns:
            {
                "value": 45,
                "classification": "fear",
                "classification_zh": "恐懼",
                "timestamp": "2025-01-05",
                "history": [...]  # 如果 limit > 1
            }
        """
        try:
            url = "https://api.alternative.me/fng/"
            params = {"limit": limit}
            
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            if not data.get("data"):
                return self._get_fallback_crypto()
            
            latest = data["data"][0]
            value = int(latest["value"])
            
            result = {
                "value": value,
                "classification": latest.get("value_classification", "").lower().replace(" ", "_"),
                "classification_zh": self._get_classification_zh(value),
                "timestamp": datetime.fromtimestamp(int(latest["timestamp"])).strftime("%Y-%m-%d"),
                "market": "crypto",
            }
            
            # 如果需要歷史資料
            if limit > 1:
                result["history"] = [
                    {
                        "value": int(item["value"]),
                        "classification": item.get("value_classification", "").lower().replace(" ", "_"),
                        "timestamp": datetime.fromtimestamp(int(item["timestamp"])).strftime("%Y-%m-%d"),
                    }
                    for item in data["data"]
                ]
            
            return result
            
        except Exception as e:
            logger.error(f"取得加密貨幣情緒指數失敗: {e}")
            return self._get_fallback_crypto()
    
    def _get_fallback_crypto(self) -> Dict[str, Any]:
        """加密貨幣情緒的備用值"""
        return {
            "value": 50,
            "classification": "neutral",
            "classification_zh": "中性",
            "timestamp": date.today().strftime("%Y-%m-%d"),
            "market": "crypto",
            "is_fallback": True,
        }
    
    # ==================== 美股情緒 (CNN Fear & Greed) ====================
    
    def get_stock_fear_greed(self) -> Optional[Dict[str, Any]]:
        """
        取得美股 Fear & Greed 指數
        來源: CNN Business (透過第三方 API 或爬蟲)
        
        Returns:
            {
                "value": 55,
                "classification": "neutral",
                "classification_zh": "中性",
                "timestamp": "2025-01-05",
            }
        """
        # 方法 1: 使用 CNN 的非官方 API
        result = self._get_cnn_fear_greed_api()
        if result:
            return result
        
        # 方法 2: 使用備用資料來源
        result = self._get_fear_greed_alternative()
        if result:
            return result
        
        logger.warning("無法取得美股情緒指數，使用備用值")
        # 返回備用值而非 None
        return {
            "value": 50,
            "classification": "neutral",
            "classification_zh": "中性",
            "timestamp": date.today().strftime("%Y-%m-%d"),
            "market": "stock",
            "is_fallback": True,
        }
    
    def _get_cnn_fear_greed_api(self) -> Optional[Dict[str, Any]]:
        """從 CNN API 取得 Fear & Greed"""
        try:
            # CNN 的非官方 API 端點
            url = "https://production.dataviz.cnn.io/index/fearandgreed/graphdata"
            
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            if not data.get("fear_and_greed"):
                return None
            
            fg_data = data["fear_and_greed"]
            value = int(round(fg_data.get("score", 0)))
            
            return {
                "value": value,
                "classification": self._get_classification(value),
                "classification_zh": self._get_classification_zh(value),
                "timestamp": date.today().strftime("%Y-%m-%d"),
                "market": "stock",
                "rating": fg_data.get("rating", ""),
            }
            
        except Exception as e:
            logger.debug(f"CNN API 取得失敗: {e}")
            return None
    
    def _get_fear_greed_alternative(self) -> Optional[Dict[str, Any]]:
        """備用方法：使用其他資料來源"""
        try:
            # 可以使用其他公開 API 或爬蟲
            # 這裡提供一個模擬的備用方案
            
            # 例如從 rapidapi 或其他來源取得
            # 目前返回 None，表示無法取得
            return None
            
        except Exception as e:
            logger.debug(f"備用來源取得失敗: {e}")
            return None
    
    # ==================== 通用方法 ====================
    
    def get_all_sentiment(self) -> Dict[str, Any]:
        """
        取得所有市場情緒
        
        Returns:
            {
                "stock": {...},
                "crypto": {...}
            }
        """
        result = {}
        
        # 美股情緒
        stock_sentiment = self.get_stock_fear_greed()
        if stock_sentiment:
            result["stock"] = stock_sentiment
        
        # 加密貨幣情緒
        crypto_sentiment = self.get_crypto_fear_greed()
        if crypto_sentiment:
            result["crypto"] = crypto_sentiment
        
        return result
    
    def _get_classification(self, value: int) -> str:
        """取得英文分類"""
        if value <= 25:
            return "extreme_fear"
        elif value <= 45:
            return "fear"
        elif value <= 55:
            return "neutral"
        elif value <= 75:
            return "greed"
        else:
            return "extreme_greed"
    
    def _get_classification_zh(self, value: int) -> str:
        """取得中文分類"""
        if value <= 25:
            return "極度恐懼"
        elif value <= 45:
            return "恐懼"
        elif value <= 55:
            return "中性"
        elif value <= 75:
            return "貪婪"
        else:
            return "極度貪婪"
    
    def get_sentiment_advice(self, value: int) -> str:
        """根據情緒值取得建議"""
        if value <= 25:
            return "市場極度恐懼，可能是買入機會，但需謹慎"
        elif value <= 45:
            return "市場偏恐懼，留意潛在機會"
        elif value <= 55:
            return "市場中性，觀望為主"
        elif value <= 75:
            return "市場偏樂觀，留意風險"
        else:
            return "市場極度貪婪，可能是獲利了結時機"
    
    def get_crypto_fear_greed_history(self, days: int = 365) -> List[Dict[str, Any]]:
        """
        取得加密貨幣 Fear & Greed 歷史資料
        
        Args:
            days: 取得天數（最多 365 天）
            
        Returns:
            歷史資料列表
        """
        try:
            url = "https://api.alternative.me/fng/"
            params = {"limit": min(days, 365)}
            
            response = self.session.get(url, params=params, timeout=15)
            response.raise_for_status()
            data = response.json()
            
            if not data.get("data"):
                return []
            
            history = []
            for item in data["data"]:
                value = int(item["value"])
                history.append({
                    "date": datetime.fromtimestamp(int(item["timestamp"])).strftime("%Y-%m-%d"),
                    "value": value,
                    "classification": item.get("value_classification", "").lower().replace(" ", "_"),
                    "classification_zh": self._get_classification_zh(value),
                })
            
            # 反轉順序，讓最舊的在前面
            history.reverse()
            
            return history
            
        except Exception as e:
            logger.error(f"取得加密貨幣情緒歷史失敗: {e}")
            return []


# 建立全域客戶端實例
fear_greed = FearGreedClient()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/data_sources/taiwan_stocks.py  ⭐
> 台股名稱對照表
──────────────────────────────────────────────────────────────────────

```py
"""
台股名稱對照表
版本: 1.0.0
日期: 2026-01-12

解決 Yahoo Finance API 返回的台股名稱 UTF-8 編碼問題
"""

# 常見台股名稱對照表（正確 UTF-8 編碼）
TAIWAN_STOCK_NAMES = {
    # === ETF ===
    "0050": "元大台灣50",
    "0051": "元大中型100",
    "0052": "富邦科技",
    "0053": "元大電子",
    "0055": "元大MSCI金融",
    "0056": "元大高股息",
    "0057": "富邦摩台",
    "006205": "富邦上證",
    "006206": "元大上證50",
    "006208": "富邦台50",
    "00631L": "元大台灣50正2",
    "00632R": "元大台灣50反1",
    "00635U": "元大S&P黃金",
    "00636": "國泰中國A50",
    "00637L": "元大滬深300正2",
    "00639": "富邦深100",
    "00642U": "元大S&P石油",
    "00645": "富邦日本",
    "00646": "元大S&P500",
    "00647L": "元大S&P500正2",
    "00648R": "元大S&P500反1",
    "00650L": "復華香港正2",
    "00655L": "國泰中國A50正2",
    "00657": "國泰日經225",
    "00661": "元大日經225",
    "00662": "富邦NASDAQ",
    "00663L": "國泰臺灣加權正2",
    "00664R": "國泰臺灣加權反1",
    "00668": "國泰美國道瓊",
    "00669R": "國泰美國道瓊反1",
    "00670L": "富邦NASDAQ正2",
    "00675L": "富邦臺灣加權正2",
    "00676R": "富邦臺灣加權反1",
    "00677U": "富邦VIX",
    "00678": "群益NBI生技",
    "00680L": "元大美債20正2",
    "00681R": "元大美債20反1",
    "00682U": "元大美債20",
    "00683L": "元大美債反1",
    "00685L": "群益臺灣加權正2",
    "00686R": "群益臺灣加權反1",
    "00688L": "國泰20年美債正2",
    "00689R": "國泰20年美債反1",
    "00690": "兆豐藍籌30",
    "00692": "富邦公司治理",
    "00693U": "街口S&P黃金",
    "00696": "富邦遊戲娛樂",
    "00700": "富邦新興國企",
    "00701": "國泰股利精選30",
    "00703": "台新MSCI中國",
    "00706L": "元大美元指數正2",
    "00707R": "元大美元指數反1",
    "00708L": "元大歐洲50正2",
    "00709": "富邦歐洲",
    "00713": "元大台灣高息低波",
    "00714": "群益道瓊美國地產",
    "00715L": "街口投信布蘭特正2",
    "00717": "富邦美國特別股",
    "00730": "富邦臺灣優質高息",
    "00731": "復華富時高息低波",
    "00733": "富邦臺灣中小",
    "00735": "國泰臺韓科技",
    "00736": "國泰新興市場",
    "00737": "國泰AI+Robo",
    "00738U": "元大道瓊白銀",
    "00739": "元大MSCI A股",
    "00752": "中信中國高股息",
    "00753L": "中信中國50正2",
    "00757": "統一FANG+",
    "00762": "元大全球AI",
    "00763U": "街口道瓊銅",
    "00770": "國泰北美科技",
    "00771": "元大US高息特別股",
    "00850": "元大臺灣ESG永續",
    "00851": "台新全球AI",
    "00852L": "國泰美國費半正2",
    "00853": "統一MSCI韓國",
    "00861": "元大全球未來關鍵科技",
    "00865B": "國泰US短期公債",
    "00875": "國泰網路資安",
    "00876": "元大全球5G",
    "00878": "國泰永續高股息",
    "00881": "國泰台灣5G+",
    "00882": "中信中國高股息",
    "00885": "富邦越南",
    "00886": "元大全球雲端服務",
    "00887": "永豐台灣ESG",
    "00888": "永豐美國費半",
    "00889": "永豐台灣智能車",
    "00891": "中信關鍵半導體",
    "00892": "富邦台灣半導體",
    "00893": "國泰智能電動車",
    "00894": "中信台資高價30",
    "00895": "富邦未來車",
    "00896": "中信綠能電動車",
    "00897": "富邦基因免疫生技",
    "00898": "國泰基因免疫革命",
    "00899": "富邦美債20年",
    "00900": "富邦特選高股息30",
    "00901": "永豐智能車供應鏈",
    "00902": "中信電池及儲能",
    "00903": "富邦元宇宙",
    "00904": "新光臺灣半導體30",
    "00905": "FT臺灣Smart",
    "00907": "永豐優息存股",
    "00908": "富邦入息REITs+",
    "00909": "國泰數位支付服務",
    "00910": "第一金太空衛星",
    "00911": "兆豐洲際半導體",
    "00912": "中信臺灣智慧50",
    "00913": "兆豐台灣晶圓製造",
    "00915": "凱基優選高股息30",
    "00916": "國泰全球品牌50",
    "00917": "中信特選金融",
    "00918": "大華優利高填息30",
    "00919": "群益台灣精選高息",
    "00920": "富邦全球非投等債",
    "00921": "兆豐龍頭等權重",
    "00922": "國泰台灣領袖50",
    "00923": "群益半導體收益",
    "00926": "凱基半導體",
    "00927": "群益半導體收益",
    "00928": "中信上櫃ESG30",
    "00929": "復華台灣科技優息",
    "00930": "永豐ESG低碳高息",
    "00931": "統一台灣高息動能",
    "00932": "兆豐永續高息等權",
    "00933": "國泰10Y+金融債",
    "00934": "中信成長高股息",
    "00935": "野村台灣新科技50",
    "00936": "台新臺灣IC設計",
    "00939": "統一台灣高息優選",
    "00940": "元大台灣價值高息",
    
    # === 常見個股 ===
    "1101": "台泥",
    "1102": "亞泥",
    "1216": "統一",
    "1301": "台塑",
    "1303": "南亞",
    "1326": "台化",
    "1402": "遠東新",
    "1476": "儒鴻",
    "2002": "中鋼",
    "2105": "正新",
    "2207": "和泰車",
    "2227": "裕日車",
    "2301": "光寶科",
    "2303": "聯電",
    "2308": "台達電",
    "2317": "鴻海",
    "2324": "仁寶",
    "2327": "國巨",
    "2330": "台積電",
    "2337": "旺宏",
    "2344": "華邦電",
    "2345": "智邦",
    "2351": "順德",
    "2353": "宏碁",
    "2354": "鴻準",
    "2356": "英業達",
    "2357": "華碩",
    "2360": "致茂",
    "2376": "技嘉",
    "2377": "微星",
    "2379": "瑞昱",
    "2382": "廣達",
    "2383": "台光電",
    "2385": "群光",
    "2388": "威盛",
    "2392": "正崴",
    "2395": "研華",
    "2401": "凌陽",
    "2402": "毅嘉",
    "2408": "南亞科",
    "2409": "友達",
    "2412": "中華電",
    "2454": "聯發科",
    "2474": "可成",
    "2492": "華新科",
    "2498": "宏達電",
    "2603": "長榮",
    "2609": "陽明",
    "2610": "華航",
    "2615": "萬海",
    "2618": "長榮航",
    "2633": "台灣高鐵",
    "2801": "彰銀",
    "2809": "京城銀",
    "2812": "台中銀",
    "2816": "旺旺保",
    "2823": "中壽",
    "2834": "臺企銀",
    "2838": "聯邦銀",
    "2845": "遠東銀",
    "2867": "三商壽",
    "2880": "華南金",
    "2881": "富邦金",
    "2882": "國泰金",
    "2883": "開發金",
    "2884": "玉山金",
    "2885": "元大金",
    "2886": "兆豐金",
    "2887": "台新金",
    "2888": "新光金",
    "2889": "國票金",
    "2890": "永豐金",
    "2891": "中信金",
    "2892": "第一金",
    "2903": "遠百",
    "2912": "統一超",
    "3008": "大立光",
    "3017": "奇鋐",
    "3034": "聯詠",
    "3037": "欣興",
    "3044": "健鼎",
    "3045": "台灣大",
    "3231": "緯創",
    "3443": "創意",
    "3481": "群創",
    "3533": "嘉澤",
    "3661": "世芯-KY",
    "3665": "貿聯-KY",
    "3711": "日月光投控",
    "4904": "遠傳",
    "4938": "和碩",
    "5269": "祥碩",
    "5347": "世界",
    "5871": "中租-KY",
    "5876": "上海商銀",
    "5880": "合庫金",
    "6005": "群益證",
    "6116": "彩晶",
    "6176": "瑞儀",
    "6239": "力成",
    "6269": "台郡",
    "6285": "啟碁",
    "6409": "旭隼",
    "6415": "矽力-KY",
    "6446": "藥華藥",
    "6488": "環球晶",
    "6505": "台塑化",
    "6515": "穎崴",
    "6531": "愛普",
    "6533": "晶心科",
    "6547": "高端疫苗",
    "6552": "易華電",
    "6558": "興能高",
    "6669": "緯穎",
    "6670": "復盛應用",
    "6789": "采鈺",
    "8046": "南電",
    "8454": "富邦媒",
    "9910": "豐泰",
    "9921": "巨大",
    "9941": "裕融",
    "9945": "潤泰新",
}


def get_taiwan_stock_name(symbol: str) -> str:
    """
    取得台股名稱
    
    Args:
        symbol: 股票代碼 (例如 "2330" 或 "2330.TW")
    
    Returns:
        股票名稱，若找不到則返回代碼本身
    """
    stock_code = symbol.replace('.TW', '').replace('.TWO', '').strip()
    return TAIWAN_STOCK_NAMES.get(stock_code, symbol)


def is_taiwan_stock(symbol: str) -> bool:
    """判斷是否為台股"""
    symbol = symbol.upper().strip()
    
    if symbol.endswith('.TW') or symbol.endswith('.TWO'):
        return True
    
    if symbol.isdigit() and 4 <= len(symbol) <= 6:
        return True
    
    return False
```

──────────────────────────────────────────────────────────────────────
### 📄 app/data_sources/yahoo_finance.py  ⭐
> Yahoo Finance Ã¨Â³â€¡Ã¦â€“â„¢Ã¤Â¾â€ Ã¦ÂºÂ
──────────────────────────────────────────────────────────────────────

```py
"""
Yahoo Finance Ã¨Â³â€¡Ã¦â€“â„¢Ã¤Â¾â€ Ã¦ÂºÂ
Ã¤Â½Â¿Ã§â€Â¨ yfinance Ã¥Â¥â€”Ã¤Â»Â¶Ã¦Å â€œÃ¥Ââ€“Ã§Â¾Å½Ã¨â€šÂ¡Ã¨Â³â€¡Ã¦â€“â„¢
"""
import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
import logging

logger = logging.getLogger(__name__)

# Ã¥Â¸Â¸Ã§â€Â¨Ã¥ÂÂ°Ã¨â€šÂ¡Ã¤Â¸Â­Ã¦â€“â€¡Ã¥ÂÂÃ§Â¨Â±Ã¥Â°ÂÃ§â€¦Â§Ã¨Â¡Â¨
TAIWAN_STOCK_NAMES = {
    # ===== 權值股 =====
    "2330": "台積電",
    "2317": "鴻海",
    "2454": "聯發科",
    "2308": "台達電",
    "2412": "中華電",
    "2303": "聯電",
    "2002": "中鋼",
    "1301": "台塑",
    "1303": "南亞",
    "1326": "台化",
    "6505": "台塑化",
    "1101": "台泥",
    "1102": "亞泥",
    "1216": "統一",
    "2207": "和泰車",
    # ===== 金融股 =====
    "2881": "富邦金",
    "2882": "國泰金",
    "2884": "玉山金",
    "2886": "兆豐金",
    "2891": "中信金",
    "2892": "第一金",
    "2880": "華南金",
    "2883": "開發金",
    "2885": "元大金",
    "2887": "台新金",
    "2888": "新光金",
    "2890": "永豐金",
    "5880": "合庫金",
    "5876": "上海商銀",
    # ===== 電子股 =====
    "2912": "統一超",
    "2357": "華碩",
    "2382": "廣達",
    "2395": "研華",
    "3008": "大立光",
    "3711": "日月光投控",
    "2345": "智邦",
    "2379": "瑞昱",
    "2327": "國巨",
    "3034": "聯詠",
    "2301": "光寶科",
    "2408": "南亞科",
    "2474": "可成",
    "3045": "台灣大",
    "4904": "遠傳",
    "3231": "緯創",
    "2356": "英業達",
    "2353": "宏碁",
    "2324": "仁寶",
    "2377": "微星",
    "2376": "技嘉",
    "4938": "和碩",
    "2409": "友達",
    "3481": "群創",
    "6669": "緯穎",
    "3037": "欣興",
    "2344": "華邦電",
    "2337": "旺宏",
    "3443": "創意",
    "6488": "環球晶",
    "5269": "祥碩",
    "6415": "矽力-KY",
    "3661": "世芯-KY",
    "6239": "力成",
    "8046": "南電",
    "3017": "奇鋐",
    "6176": "瑞儀",
    "6285": "啟碁",
    "2492": "華新科",
    "3533": "嘉澤",
    "6531": "愛普",
    "3665": "貿聯-KY",
    "8454": "富邦媒",
    "2383": "台光電",
    "2351": "順德",
    "2354": "鴻準",
    "2360": "致茂",
    "2385": "群光",
    "2388": "威盛",
    "2392": "正崴",
    "2401": "凌陽",
    "2402": "毅嘉",
    # ===== 航運/傳產 =====
    "2603": "長榮",
    "2609": "陽明",
    "2615": "萬海",
    "2618": "長榮航",
    "2610": "華航",
    "2633": "台灣高鐵",
    "9910": "豐泰",
    "9921": "巨大",
    "5871": "中租-KY",
    "9941": "裕融",
    # ===== 生技 =====
    "6446": "藥華藥",
    "6547": "高端疫苗",
    # ===== ETF =====
    "0050": "元大台灣50",
    "0051": "元大中型100",
    "0052": "富邦科技",
    "0053": "元大電子",
    "0055": "元大MSCI金融",
    "0056": "元大高股息",
    "0057": "富邦摩台",
    "006205": "富邦上證",
    "006206": "元大上證50",
    "006208": "富邦台50",
    "00631L": "元大台灣50正2",
    "00632R": "元大台灣50反1",
    "00635U": "元大S&P黃金",
    "00636": "國泰中國A50",
    "00637L": "元大滬深300正2",
    "00639": "富邦深100",
    "00642U": "元大S&P石油",
    "00645": "富邦日本",
    "00646": "元大S&P500",
    "00647L": "元大S&P500正2",
    "00648R": "元大S&P500反1",
    "00650L": "復華香港正2",
    "00655L": "國泰中國A50正2",
    "00657": "國泰日經225",
    "00661": "元大日經225",
    "00662": "富邦NASDAQ",
    "00663L": "國泰臺灣加權正2",
    "00664R": "國泰臺灣加權反1",
    "00668": "國泰美國道瓊",
    "00669R": "國泰美國道瓊反1",
    "00670L": "富邦NASDAQ正2",
    "00675L": "富邦臺灣加權正2",
    "00676R": "富邦臺灣加權反1",
    "00677U": "富邦VIX",
    "00678": "群益NBI生技",
    "00680L": "元大美債20正2",
    "00681R": "元大美債20反1",
    "00682U": "元大美債20年",
    "00690": "兆豐藍籌30",
    "00692": "富邦公司治理",
    "00701": "國泰股利精選30",
    "00713": "元大台灣高息低波",
    "00730": "富邦臺灣優質高息",
    "00733": "富邦臺灣中小",
    "00757": "統一FANG+",
    "00762": "元大全球AI",
    "00770": "國泰北美科技",
    "00850": "元大臺灣ESG永續",
    "00851": "台新全球AI",
    "00852L": "國泰美國費半正2",
    "00875": "國泰網路資安",
    "00876": "元大全球5G",
    "00878": "國泰永續高股息",
    "00881": "國泰台灣5G+",
    "00882": "中信中國高股息",
    "00885": "富邦越南",
    "00886": "元大全球雲端服務",
    "00887": "永豐台灣ESG",
    "00888": "永豐美國費半",
    "00889": "永豐台灣智能車",
    "00891": "中信關鍵半導體",
    "00892": "富邦台灣半導體",
    "00893": "國泰智能電動車",
    "00894": "中信小資高價30",
    "00895": "富邦未來車",
    "00896": "中信綠能電動車",
    "00900": "富邦特選高股息30",
    "00901": "永豐智能車供應鏈",
    "00904": "新光臺灣半導體30",
    "00905": "FT臺灣Smart",
    "00907": "永豐優息存股",
    "00912": "中信臺灣智慧50",
    "00915": "凱基優選高股息30",
    "00916": "國泰全球品牌50",
    "00918": "大華優利高填息30",
    "00919": "群益台灣精選高息",
    "00921": "兆豐龍頭等權重",
    "00922": "國泰台灣領袖50",
    "00923": "群益半導體收益",
    "00929": "復華台灣科技優息",
    "00930": "永豐ESG低碳高息",
    "00931": "統一台灣高息動能",
    "00932": "兆豐永續高息等權",
    "00934": "中信成長高股息",
    "00935": "野村台灣新科技50",
    "00936": "台新臺灣IC設計",
    "00939": "統一台灣高息優選",
    "00940": "元大台灣價值高息",
}



class YahooFinanceClient:
    """Yahoo Finance Ã¨Â³â€¡Ã¦â€“â„¢Ã¦â€œÂ·Ã¥Ââ€“Ã¥Â®Â¢Ã¦Ë†Â¶Ã§Â«Â¯"""
    
    def __init__(self):
        pass
    
    def get_stock_info(self, symbol: str) -> Optional[Dict[str, Any]]:
        """
        Ã¥Ââ€“Ã¥Â¾â€”Ã¨â€šÂ¡Ã§Â¥Â¨Ã¥Å¸ÂºÃ¦Å“Â¬Ã¨Â³â€¡Ã¨Â¨Å 
        
        Args:
            symbol: Ã¨â€šÂ¡Ã§Â¥Â¨Ã¤Â»Â£Ã¨â„¢Å¸ (Ã¥Â¦â€š AAPL, TSLA, 2330.TW)
            
        Returns:
            Ã¨â€šÂ¡Ã§Â¥Â¨Ã¨Â³â€¡Ã¨Â¨Å Ã¥Â­â€”Ã¥â€¦Â¸Ã¯Â¼Å’Ã¥Å’â€¦Ã¥ÂÂ«Ã¥ÂÂÃ§Â¨Â±Ã£â‚¬ÂÃ¥Â¸â€šÃ¥â‚¬Â¼Ã§Â­â€°
        """
        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info or {}
            
            # Ã¥Ââ€“Ã¥Â¾â€”Ã¥ÂÂÃ§Â¨Â±Ã¯Â¼Å¡Ã¥â€žÂªÃ¥â€¦Ë†Ã¤Â½Â¿Ã§â€Â¨ longNameÃ¯Â¼Å’Ã§â€žÂ¶Ã¥Â¾Å’ shortName
            name = info.get("longName") or info.get("shortName") or symbol
            
            # Ã¥Â°ÂÃ¦â€“Â¼Ã¥ÂÂ°Ã¨â€šÂ¡Ã¯Â¼Å’Ã¥â€žÂªÃ¥â€¦Ë†Ã¤Â½Â¿Ã§â€Â¨Ã¦Å“Â¬Ã¥Å“Â°Ã¦ËœÂ Ã¥Â°â€žÃ¨Â¡Â¨Ã§Å¡â€žÃ¤Â¸Â­Ã¦â€“â€¡Ã¥ÂÂÃ§Â¨Â±
            if symbol.endswith(".TW") or symbol.endswith(".TWO"):
                # Ã¦ÂÂÃ¥Ââ€“Ã¨â€šÂ¡Ã§Â¥Â¨Ã¤Â»Â£Ã¨â„¢Å¸ (Ã¥Å½Â»Ã¦Å½â€° .TW Ã¦Ë†â€“ .TWO)
                stock_code = symbol.replace(".TW", "").replace(".TWO", "")
                # Ã¥â€žÂªÃ¥â€¦Ë†Ã¤Â½Â¿Ã§â€Â¨Ã¦Å“Â¬Ã¥Å“Â°Ã¦ËœÂ Ã¥Â°â€žÃ¨Â¡Â¨
                if stock_code in TAIWAN_STOCK_NAMES:
                    name = TAIWAN_STOCK_NAMES[stock_code]
                else:
                    # Ã¥Ëœâ€”Ã¨Â©Â¦Ã¥Â¾Å¾ Yahoo Finance Ã¥Ââ€“Ã¥Â¾â€”Ã¤Â¸Â­Ã¦â€“â€¡Ã¥ÂÂ
                    display_name = info.get("displayName")
                    if display_name:
                        name = display_name
            
            # Ã¥ÂÂ³Ã¤Â½Â¿ info Ã¤Â¸ÂÃ¥Â®Å’Ã¦â€¢Â´Ã¯Â¼Å’Ã¤Â¹Å¸Ã¨Â¿â€Ã¥â€ºÅ¾Ã¥Å¸ÂºÃ¦Å“Â¬Ã¨Â³â€¡Ã¨Â¨Å 
            return {
                "symbol": info.get("symbol", symbol),
                "name": name,
                "shortName": info.get("shortName", ""),
                "longName": info.get("longName", ""),
                "currency": info.get("currency", "TWD" if symbol.endswith((".TW", ".TWO")) else "USD"),
                "market_cap": info.get("marketCap"),
                "sector": info.get("sector"),
                "industry": info.get("industry"),
                "fifty_two_week_high": info.get("fiftyTwoWeekHigh"),
                "fifty_two_week_low": info.get("fiftyTwoWeekLow"),
            }
        except Exception as e:
            logger.error(f"Ã¥Ââ€“Ã¥Â¾â€”Ã¨â€šÂ¡Ã§Â¥Â¨Ã¨Â³â€¡Ã¨Â¨Å Ã¥Â¤Â±Ã¦â€¢â€” {symbol}: {e}")
            # Ã¥ÂÂ³Ã¤Â½Â¿Ã¥â€¡ÂºÃ©Å’Â¯Ã¯Â¼Å’Ã¥Â°ÂÃ¦â€“Â¼Ã¥ÂÂ°Ã¨â€šÂ¡Ã¤Â¹Å¸Ã¥Ëœâ€”Ã¨Â©Â¦Ã¨Â¿â€Ã¥â€ºÅ¾Ã¦Å“Â¬Ã¥Å“Â°Ã¥ÂÂÃ§Â¨Â±
            if symbol.endswith(".TW") or symbol.endswith(".TWO"):
                stock_code = symbol.replace(".TW", "").replace(".TWO", "")
                name = TAIWAN_STOCK_NAMES.get(stock_code, symbol)
                return {
                    "symbol": symbol,
                    "name": name,
                    "shortName": "",
                    "longName": "",
                    "currency": "TWD",
                    "market_cap": None,
                    "sector": None,
                    "industry": None,
                    "fifty_two_week_high": None,
                    "fifty_two_week_low": None,
                }
            return None
    
    def get_stock_history(
        self,
        symbol: str,
        period: str = "1y",
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
    ) -> Optional[pd.DataFrame]:
        """
        Ã¥Ââ€“Ã¥Â¾â€”Ã¨â€šÂ¡Ã§Â¥Â¨Ã¦Â­Â·Ã¥ÂÂ²Ã¥Æ’Â¹Ã¦Â Â¼Ã¨Â³â€¡Ã¦â€“â„¢
        
        Args:
            symbol: Ã¨â€šÂ¡Ã§Â¥Â¨Ã¤Â»Â£Ã¨â„¢Å¸
            period: Ã¨Â³â€¡Ã¦â€“â„¢Ã¦Å“Å¸Ã©â€“â€œ (1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, 10y, ytd, max)
            start: Ã©â€“â€¹Ã¥Â§â€¹Ã¦â€”Â¥Ã¦Å“Å¸Ã¯Â¼Ë†Ã¨Ë†â€¡ end Ã¦ÂÂ­Ã©â€¦ÂÃ¤Â½Â¿Ã§â€Â¨Ã¦â„¢â€šÃ¯Â¼Å’period Ã¦Å“Æ’Ã¨Â¢Â«Ã¥Â¿Â½Ã§â€¢Â¥Ã¯Â¼â€°
            end: Ã§ÂµÂÃ¦ÂÅ¸Ã¦â€”Â¥Ã¦Å“Å¸
            
        Returns:
            Ã¥Å’â€¦Ã¥ÂÂ« OHLCV Ã§Å¡â€ž DataFrameÃ¯Â¼Å’Ã¥â€¦Â¶Ã¤Â¸Â­Ã¯Â¼Å¡
            - close: Ã¥Å½Å¸Ã¥Â§â€¹Ã¦â€Â¶Ã§â€ºÂ¤Ã¥Æ’Â¹Ã¯Â¼Ë†Ã§â€Â¨Ã¦â€“Â¼Ã©Â¡Â¯Ã§Â¤ÂºÃ¯Â¼â€°
            - adj_close: Ã¥Ë†â€ Ã¥â€°Â²Ã¨ÂªÂ¿Ã¦â€¢Â´Ã¥Â¾Å’Ã¥Æ’Â¹Ã¦Â Â¼Ã¯Â¼Ë†Ã§â€Â¨Ã¦â€“Â¼Ã¥Å“â€“Ã¨Â¡Â¨Ã¯Â¼Å’Ã¤Â¸ÂÃ¥ÂÂ«Ã©â€¦ÂÃ¦ÂÂ¯Ã¯Â¼â€°
        """
        try:
            ticker = yf.Ticker(symbol)
            
            # Ã¥Ââ€“Ã¥Â¾â€”Ã¥Å½Å¸Ã¥Â§â€¹Ã¥Æ’Â¹Ã¦Â Â¼
            if start and end:
                df_raw = ticker.history(start=start, end=end, auto_adjust=False)
            else:
                df_raw = ticker.history(period=period, auto_adjust=False)
            
            if df_raw.empty:
                logger.warning(f"Ã§â€žÂ¡Ã¦Â­Â·Ã¥ÂÂ²Ã¨Â³â€¡Ã¦â€“â„¢: {symbol}")
                return None
            
            df_raw = df_raw.reset_index()
            
            # Ã¦Â¨â„¢Ã¦Âºâ€“Ã¥Å’â€“Ã¦â€”Â¥Ã¦Å“Å¸Ã¦Â¬â€žÃ¤Â½Â
            date_col = "Date" if "Date" in df_raw.columns else "Datetime"
            
            # Ã¥Â»ÂºÃ§Â«â€¹Ã§ÂµÂÃ¦Å¾Å“ DataFrame
            df = pd.DataFrame()
            df["date"] = pd.to_datetime(df_raw[date_col]).dt.date
            df["open"] = df_raw["Open"].values
            df["high"] = df_raw["High"].values
            df["low"] = df_raw["Low"].values
            df["close"] = df_raw["Close"].values
            df["volume"] = df_raw["Volume"].values if "Volume" in df_raw.columns else 0
            
            # Ã¥ÂÂµÃ¦Â¸Â¬Ã¤Â¸Â¦Ã¨ÂªÂ¿Ã¦â€¢Â´Ã¥Ë†â€ Ã¥â€°Â²Ã¯Â¼Ë†Ã¤Â¸ÂÃ¥ÂÂ«Ã©â€¦ÂÃ¦ÂÂ¯Ã¯Â¼â€°
            df = self._detect_and_adjust_splits(df, symbol)
            
            # Ã¥Å Â Ã¥â€¦Â¥Ã¨â€šÂ¡Ã§Â¥Â¨Ã¤Â»Â£Ã¨â„¢Å¸
            df["symbol"] = symbol.upper()
            
            return df
            
        except Exception as e:
            logger.error(f"Ã¥Ââ€“Ã¥Â¾â€”Ã¦Â­Â·Ã¥ÂÂ²Ã¨Â³â€¡Ã¦â€“â„¢Ã¥Â¤Â±Ã¦â€¢â€” {symbol}: {e}")
            return None
    
    def _detect_and_adjust_splits(self, df: pd.DataFrame, symbol: str) -> pd.DataFrame:
        """
        Ã¥ÂÂµÃ¦Â¸Â¬Ã¥Æ’Â¹Ã¦Â Â¼Ã¦â€“Â·Ã¥Â´â€“Ã¤Â¸Â¦Ã¨ÂªÂ¿Ã¦â€¢Â´Ã¦Â­Â·Ã¥ÂÂ²Ã¥Æ’Â¹Ã¦Â Â¼Ã¯Â¼Ë†Ã¥ÂÂªÃ¨â„¢â€¢Ã§Ââ€ Ã¥Ë†â€ Ã¥â€°Â²Ã¯Â¼Å’Ã¤Â¸ÂÃ¥ÂÂ«Ã©â€¦ÂÃ¦ÂÂ¯Ã¯Â¼â€°
        
        Ã§â€¢Â¶Ã¥ÂÂµÃ¦Â¸Â¬Ã¥Ë†Â°Ã¥Æ’Â¹Ã¦Â Â¼Ã§ÂªÂÃ§â€žÂ¶Ã¤Â¸â€¹Ã¨Â·Å’Ã¨Â¶â€¦Ã©ÂÅ½ 40%Ã¯Â¼Ë†Ã¥ÂÂ¯Ã¨Æ’Â½Ã¦ËœÂ¯Ã¥Ë†â€ Ã¥â€°Â²Ã¯Â¼â€°Ã¯Â¼Å’
        Ã¦Å“Æ’Ã¨â€¡ÂªÃ¥â€¹â€¢Ã¨ÂªÂ¿Ã¦â€¢Â´Ã¥Ë†â€ Ã¥â€°Â²Ã¥â€°ÂÃ§Å¡â€žÃ¥Æ’Â¹Ã¦Â Â¼Ã¯Â¼Å’Ã¤Â½Â¿Ã¦â€¢Â´Ã¥â‚¬â€¹Ã¥ÂºÂÃ¥Ë†â€”Ã©â‚¬Â£Ã§ÂºÅ’Ã£â‚¬â€š
        """
        if len(df) < 2:
            df['adj_close'] = df['close'].copy()
            return df
        
        df = df.copy()
        df = df.sort_values('date').reset_index(drop=True)
        
        # Ã¨Â¨Ë†Ã§Â®â€”Ã¦Â¯ÂÃ¦â€”Â¥Ã¦Â¼Â²Ã¨Â·Å’Ã¥Â¹â€¦
        df['pct_change'] = df['close'].pct_change()
        
        # Ã¥ÂÂµÃ¦Â¸Â¬Ã¥Ë†â€ Ã¥â€°Â²Ã©Â»Å¾Ã¯Â¼Ë†Ã¥Æ’Â¹Ã¦Â Â¼Ã¤Â¸â€¹Ã¨Â·Å’Ã¨Â¶â€¦Ã©ÂÅ½ 40%Ã¯Â¼â€°
        split_indices = []
        for i in range(1, len(df)):
            pct = df.loc[i, 'pct_change']
            if pd.notna(pct) and pct < -0.40:
                prev_close = float(df.loc[i-1, 'close'])
                curr_close = float(df.loc[i, 'close'])
                if curr_close > 0:
                    ratio = prev_close / curr_close
                    rounded_ratio = round(ratio)
                    # Ã¥ÂÂªÃ¦Å“â€°Ã¦Â¯â€Ã§Å½â€¡Ã¦Å½Â¥Ã¨Â¿â€˜Ã¦â€¢Â´Ã¦â€¢Â¸Ã¦â„¢â€šÃ¦â€°ÂÃ¨ÂªÂÃ§â€šÂºÃ¦ËœÂ¯Ã¥Ë†â€ Ã¥â€°Â²Ã¯Â¼Ë†2, 3, 4, 5, 10 Ã§Â­â€°Ã¯Â¼â€°
                    if rounded_ratio >= 2 and abs(ratio - rounded_ratio) < 0.3:
                        split_indices.append({
                            'index': i,
                            'date': df.loc[i, 'date'],
                            'ratio': rounded_ratio,
                            'prev_close': prev_close,
                            'curr_close': curr_close
                        })
                        logger.info(f"{symbol} Ã¥ÂÂµÃ¦Â¸Â¬Ã¥Ë†Â°Ã¥Ë†â€ Ã¥â€°Â²: {df.loc[i, 'date']}, Ã¦Â¯â€Ã§Å½â€¡ 1:{rounded_ratio}, Ã¥â€°ÂÃ¦â€Â¶ {prev_close:.2f} -> Ã§ÂÂ¾Ã¦â€Â¶ {curr_close:.2f}")
        
        # Ã¥Ë†ÂÃ¥Â§â€¹Ã¥Å’â€“Ã¨ÂªÂ¿Ã¦â€¢Â´Ã¥Â¾Å’Ã¥Æ’Â¹Ã¦Â Â¼
        df['adj_close'] = df['close'].astype(float)
        
        # Ã¥Â¾Å¾Ã¦Å“â‚¬Ã¨Â¿â€˜Ã§Å¡â€žÃ¥Ë†â€ Ã¥â€°Â²Ã©â€“â€¹Ã¥Â§â€¹Ã¥Â¾â‚¬Ã¥â€°ÂÃ¨ÂªÂ¿Ã¦â€¢Â´Ã¯Â¼Ë†Ã¤Â½Â¿Ã§â€Â¨Ã§Â´Â¯Ã§Â©ÂÃ¥â€ºÂ Ã¥Â­ÂÃ¯Â¼â€°
        if split_indices:
            cumulative_factor = 1.0
            
            for split in reversed(split_indices):
                idx = split['index']
                ratio = split['ratio']
                cumulative_factor *= ratio
                
                # Ã¨ÂªÂ¿Ã¦â€¢Â´Ã¥Ë†â€ Ã¥â€°Â²Ã©Â»Å¾Ã¤Â¹â€¹Ã¥â€°ÂÃ§Å¡â€žÃ¦â€°â‚¬Ã¦Å“â€°Ã¥Æ’Â¹Ã¦Â Â¼Ã¯Â¼Ë†Ã§â€Â¨Ã¥Å½Å¸Ã¥Â§â€¹ close Ã©â„¢Â¤Ã¤Â»Â¥Ã§Â´Â¯Ã§Â©ÂÃ¥â€ºÂ Ã¥Â­ÂÃ¯Â¼â€°
                df.loc[:idx-1, 'adj_close'] = df.loc[:idx-1, 'close'].astype(float) / cumulative_factor
            
            logger.info(f"{symbol} Ã¥Â·Â²Ã¨ÂªÂ¿Ã¦â€¢Â´ {len(split_indices)} Ã¦Â¬Â¡Ã¥Ë†â€ Ã¥â€°Â²Ã¯Â¼Å’Ã§Â¸Â½Ã¨ÂªÂ¿Ã¦â€¢Â´Ã¥â€ºÂ Ã¥Â­Â: {cumulative_factor}")
        
        # Ã§Â§Â»Ã©â„¢Â¤Ã¨â€¡Â¨Ã¦â„¢â€šÃ¦Â¬â€žÃ¤Â½Â
        df = df.drop(columns=['pct_change'], errors='ignore')
        
        return df
    
    def get_current_price(self, symbol: str) -> Optional[Dict[str, Any]]:
        """
        Ã¥Ââ€“Ã¥Â¾â€”Ã¨â€šÂ¡Ã§Â¥Â¨Ã¥ÂÂ³Ã¦â„¢â€šÃ¯Â¼Ë†Ã¥Â»Â¶Ã©ÂÂ²Ã¯Â¼â€°Ã¥Â Â±Ã¥Æ’Â¹
        
        Args:
            symbol: Ã¨â€šÂ¡Ã§Â¥Â¨Ã¤Â»Â£Ã¨â„¢Å¸
            
        Returns:
            Ã¥Å’â€¦Ã¥ÂÂ«Ã§â€¢Â¶Ã¥â€°ÂÃ¥Æ’Â¹Ã¦Â Â¼Ã¥â€™Å’Ã¦Â¼Â²Ã¨Â·Å’Ã¨Â³â€¡Ã¨Â¨Å Ã§Å¡â€žÃ¥Â­â€”Ã¥â€¦Â¸
        """
        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info
            
            if not info:
                return None
            
            # Ã¥Ëœâ€”Ã¨Â©Â¦Ã¥Ââ€“Ã¥Â¾â€”Ã¥ÂÂ³Ã¦â„¢â€šÃ¥Æ’Â¹Ã¦Â Â¼
            current_price = info.get("currentPrice") or info.get("regularMarketPrice")
            previous_close = info.get("previousClose") or info.get("regularMarketPreviousClose")
            
            if not current_price:
                # Ã¥Â¾Å¾Ã¦Â­Â·Ã¥ÂÂ²Ã¨Â³â€¡Ã¦â€“â„¢Ã¥Ââ€“Ã¥Â¾â€”Ã¦Å“â‚¬Ã¦â€“Â°Ã¦â€Â¶Ã§â€ºÂ¤Ã¥Æ’Â¹Ã¯Â¼Ë†Ã¤Â½Â¿Ã§â€Â¨Ã¥Å½Å¸Ã¥Â§â€¹Ã¥Æ’Â¹Ã¦Â Â¼Ã¯Â¼â€°
                hist = ticker.history(period="5d", auto_adjust=False)
                if not hist.empty:
                    current_price = hist["Close"].iloc[-1]
                    if len(hist) >= 2:
                        previous_close = hist["Close"].iloc[-2]
            
            if not current_price:
                return None
            
            change = current_price - previous_close if previous_close else 0
            change_pct = (change / previous_close * 100) if previous_close else 0
            
            return {
                "symbol": symbol.upper(),
                "price": round(current_price, 2),
                "previous_close": round(previous_close, 2) if previous_close else None,
                "change": round(change, 2),
                "change_pct": round(change_pct, 2),
                "volume": info.get("volume") or info.get("regularMarketVolume"),
            }
            
        except Exception as e:
            logger.error(f"Ã¥Ââ€“Ã¥Â¾â€”Ã¥ÂÂ³Ã¦â„¢â€šÃ¥Â Â±Ã¥Æ’Â¹Ã¥Â¤Â±Ã¦â€¢â€” {symbol}: {e}")
            return None
    
    def validate_symbol(self, symbol: str) -> bool:
        """
        å¿«é€Ÿé©—è­‰è‚¡ç¥¨ä»£è™Ÿæ˜¯å¦æœ‰æ•ˆ
        
        ä½¿ç”¨ history API è€Œéž infoï¼Œé€Ÿåº¦å¿« 5-10 å€
        
        Args:
            symbol: è‚¡ç¥¨ä»£è™Ÿ
            
        Returns:
            æ˜¯å¦ç‚ºæœ‰æ•ˆä»£è™Ÿ
        """
        try:
            ticker = yf.Ticker(symbol)
            # åªæŠ“ 1 å¤©è³‡æ–™ï¼Œæ¯” info å¿«å¾ˆå¤š
            hist = ticker.history(period="1d")
            return not hist.empty
        except Exception:
            return False
    
    def get_dividends(
        self,
        symbol: str,
        period: str = "10y",
    ) -> Optional[pd.DataFrame]:
        """
        Ã¥Ââ€“Ã¥Â¾â€”Ã¨â€šÂ¡Ã§Â¥Â¨Ã©â€¦ÂÃ¦ÂÂ¯Ã¦Â­Â·Ã¥ÂÂ²
        
        Args:
            symbol: Ã¨â€šÂ¡Ã§Â¥Â¨Ã¤Â»Â£Ã¨â„¢Å¸
            period: Ã¨Â³â€¡Ã¦â€“â„¢Ã¦Å“Å¸Ã©â€“â€œ (1y, 5y, 10y, max)
            
        Returns:
            Ã¥Å’â€¦Ã¥ÂÂ«Ã©â€¦ÂÃ¦ÂÂ¯Ã¨Â¨ËœÃ©Å’â€žÃ§Å¡â€ž DataFrame
        """
        try:
            ticker = yf.Ticker(symbol)
            dividends = ticker.dividends
            
            if dividends.empty:
                logger.info(f"{symbol} Ã§â€žÂ¡Ã©â€¦ÂÃ¦ÂÂ¯Ã¨Â¨ËœÃ©Å’â€ž")
                return None
            
            # Ã¨Â½â€°Ã¦Ââ€ºÃ¦Ë†Â DataFrame
            df = dividends.reset_index()
            df.columns = ["date", "amount"]
            df["date"] = pd.to_datetime(df["date"]).dt.date
            df["symbol"] = symbol.upper()
            
            # Ã¦Â Â¹Ã¦â€œÅ¡ period Ã©ÂÅ½Ã¦Â¿Â¾
            if period != "max":
                years = int(period.replace("y", ""))
                cutoff_date = datetime.now().date() - timedelta(days=years * 365)
                df = df[df["date"] >= cutoff_date]
            
            return df
            
        except Exception as e:
            logger.error(f"Ã¥Ââ€“Ã¥Â¾â€”Ã©â€¦ÂÃ¦ÂÂ¯Ã¨Â³â€¡Ã¦â€“â„¢Ã¥Â¤Â±Ã¦â€¢â€” {symbol}: {e}")
            return None
    
    def get_index_data(
        self,
        symbol: str,
        period: str = "10y",
    ) -> Optional[pd.DataFrame]:
        """
        Ã¥Ââ€“Ã¥Â¾â€”Ã¥Â¸â€šÃ¥Â Â´Ã¦Å’â€¡Ã¦â€¢Â¸Ã¦Â­Â·Ã¥ÂÂ²Ã¨Â³â€¡Ã¦â€“â„¢
        
        Args:
            symbol: Ã¦Å’â€¡Ã¦â€¢Â¸Ã¤Â»Â£Ã¨â„¢Å¸ (^GSPC, ^DJI, ^IXIC)
            period: Ã¨Â³â€¡Ã¦â€“â„¢Ã¦Å“Å¸Ã©â€“â€œ
            
        Returns:
            Ã¥Å’â€¦Ã¥ÂÂ« OHLCV Ã§Å¡â€ž DataFrame
        """
        try:
            ticker = yf.Ticker(symbol)
            df = ticker.history(period=period, auto_adjust=False)
            
            if df.empty:
                logger.warning(f"Ã§â€žÂ¡Ã¦Å’â€¡Ã¦â€¢Â¸Ã¨Â³â€¡Ã¦â€“â„¢: {symbol}")
                return None
            
            # Ã©â€¡ÂÃ¨Â¨Â­Ã§Â´Â¢Ã¥Â¼â€¢
            df = df.reset_index()
            
            # Ã¦Â¨â„¢Ã¦Âºâ€“Ã¥Å’â€“Ã¦Â¬â€žÃ¤Â½ÂÃ¥ÂÂÃ§Â¨Â±
            column_mapping = {
                "Date": "date",
                "Datetime": "date",
                "Open": "open",
                "High": "high",
                "Low": "low",
                "Close": "close",
                "Volume": "volume",
            }
            existing_columns = {k: v for k, v in column_mapping.items() if k in df.columns}
            df = df.rename(columns=existing_columns)
            
            # Ã§Â¢ÂºÃ¤Â¿ÂÃ¦â€”Â¥Ã¦Å“Å¸Ã¦ËœÂ¯ date Ã©Â¡Å¾Ã¥Å¾â€¹
            df["date"] = pd.to_datetime(df["date"]).dt.date
            
            # Ã¨Â¨Ë†Ã§Â®â€”Ã¦Â¼Â²Ã¨Â·Å’
            df["change"] = df["close"].diff()
            df["change_pct"] = df["close"].pct_change() * 100
            
            # Ã¥Å Â Ã¥â€¦Â¥Ã¤Â»Â£Ã¨â„¢Å¸
            df["symbol"] = symbol
            
            # Ã¥ÂÂªÃ¤Â¿ÂÃ§â€¢â„¢Ã©Å“â‚¬Ã¨Â¦ÂÃ§Å¡â€žÃ¦Â¬â€žÃ¤Â½Â
            keep_columns = ["symbol", "date", "open", "high", "low", "close", "volume", "change", "change_pct"]
            df = df[[c for c in keep_columns if c in df.columns]]
            
            return df
            
        except Exception as e:
            logger.error(f"Ã¥Ââ€“Ã¥Â¾â€”Ã¦Å’â€¡Ã¦â€¢Â¸Ã¨Â³â€¡Ã¦â€“â„¢Ã¥Â¤Â±Ã¦â€¢â€” {symbol}: {e}")
            return None
    
    def get_all_indices(self, period: str = "10y") -> Dict[str, pd.DataFrame]:
        """
        Ã¥Ââ€“Ã¥Â¾â€”Ã¦â€°â‚¬Ã¦Å“â€°Ã¤Â¸â€°Ã¥Â¤Â§Ã¦Å’â€¡Ã¦â€¢Â¸Ã¨Â³â€¡Ã¦â€“â„¢
        
        Returns:
            {symbol: DataFrame}
        """
        indices = ["^GSPC", "^DJI", "^IXIC"]
        result = {}
        
        for symbol in indices:
            df = self.get_index_data(symbol, period)
            if df is not None:
                result[symbol] = df
        
        return result
    
    def get_stock_history_extended(
        self,
        symbol: str,
        years: int = 10,
    ) -> Optional[pd.DataFrame]:
        """
        Ã¥Ââ€“Ã¥Â¾â€”Ã¨â€šÂ¡Ã§Â¥Â¨Ã¥Â»Â¶Ã¤Â¼Â¸Ã¦Â­Â·Ã¥ÂÂ²Ã¨Â³â€¡Ã¦â€“â„¢Ã¯Â¼Ë†Ã¦â€Â¯Ã¦ÂÂ´Ã¦â€ºÂ´Ã©â€¢Â·Ã¦â„¢â€šÃ©â€“â€œÃ¯Â¼â€°
        
        Args:
            symbol: Ã¨â€šÂ¡Ã§Â¥Â¨Ã¤Â»Â£Ã¨â„¢Å¸
            years: Ã¥Â¹Â´Ã¦â€¢Â¸ (1, 3, 5, 10)
            
        Returns:
            Ã¥Å’â€¦Ã¥ÂÂ« OHLCV Ã§Å¡â€ž DataFrame
        """
        period_map = {
            1: "1y",
            2: "2y",
            3: "3y",  # yfinance Ã¤Â¸ÂÃ¦â€Â¯Ã¦ÂÂ´ 3yÃ¯Â¼Å’Ã§â€Â¨ 5y Ã¤Â»Â£Ã¦â€ºÂ¿
            5: "5y",
            10: "10y",
        }
        
        period = period_map.get(years, "10y")
        if years == 3:
            period = "5y"  # Ã§â€žÂ¶Ã¥Â¾Å’Ã¥Å“Â¨Ã§Â¨â€¹Ã¥Â¼ÂÃ¤Â¸Â­Ã©ÂÅ½Ã¦Â¿Â¾
        
        df = self.get_stock_history(symbol, period=period)
        
        if df is None:
            return None
        
        # Ã¥Â¦â€šÃ¦Å¾Å“Ã¦ËœÂ¯ 3 Ã¥Â¹Â´Ã¯Â¼Å’Ã©Å“â‚¬Ã¨Â¦ÂÃ©ÂÅ½Ã¦Â¿Â¾
        if years == 3:
            cutoff_date = datetime.now().date() - timedelta(days=3 * 365)
            df = df[df["date"] >= cutoff_date]
        
        return df


# Ã¥Â»ÂºÃ§Â«â€¹Ã¥â€¦Â¨Ã¥Å¸Å¸Ã¥Â®Â¢Ã¦Ë†Â¶Ã§Â«Â¯Ã¥Â¯Â¦Ã¤Â¾â€¹
yahoo_finance = YahooFinanceClient()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/logging_config.py  ⭐
> 日誌設定
──────────────────────────────────────────────────────────────────────

```py
"""
日誌設定
確保所有重要操作都有記錄
"""
import logging
import sys
from datetime import datetime
from pathlib import Path


def setup_logging(log_level: str = "INFO", log_to_file: bool = True):
    """
    設定日誌系統
    
    Args:
        log_level: 日誌等級 (DEBUG, INFO, WARNING, ERROR)
        log_to_file: 是否寫入檔案
    """
    # 建立 logs 目錄
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)
    
    # 日誌格式
    log_format = "%(asctime)s | %(levelname)-8s | %(name)s | %(message)s"
    date_format = "%Y-%m-%d %H:%M:%S"
    
    # 建立 formatter
    formatter = logging.Formatter(log_format, datefmt=date_format)
    
    # 取得 root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, log_level.upper(), logging.INFO))
    
    # 清除現有的 handlers
    root_logger.handlers.clear()
    
    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    console_handler.setLevel(logging.INFO)
    root_logger.addHandler(console_handler)
    
    if log_to_file:
        # 主要日誌檔（所有日誌）
        today = datetime.now().strftime("%Y-%m-%d")
        main_log_file = log_dir / f"app_{today}.log"
        file_handler = logging.FileHandler(main_log_file, encoding="utf-8")
        file_handler.setFormatter(formatter)
        file_handler.setLevel(logging.DEBUG)
        root_logger.addHandler(file_handler)
        
        # 認證日誌檔（登入/登出）
        auth_logger = logging.getLogger("app.services.auth_service")
        auth_log_file = log_dir / f"auth_{today}.log"
        auth_handler = logging.FileHandler(auth_log_file, encoding="utf-8")
        auth_handler.setFormatter(formatter)
        auth_handler.setLevel(logging.INFO)
        auth_logger.addHandler(auth_handler)
        
        # Watchlist 日誌檔
        watchlist_logger = logging.getLogger("app.services.watchlist_service")
        watchlist_log_file = log_dir / f"watchlist_{today}.log"
        watchlist_handler = logging.FileHandler(watchlist_log_file, encoding="utf-8")
        watchlist_handler.setFormatter(formatter)
        watchlist_handler.setLevel(logging.INFO)
        watchlist_logger.addHandler(watchlist_handler)
    
    # 設定第三方套件的日誌等級
    logging.getLogger("httpx").setLevel(logging.WARNING)
    logging.getLogger("httpcore").setLevel(logging.WARNING)
    logging.getLogger("sqlalchemy.engine").setLevel(logging.WARNING)
    logging.getLogger("uvicorn").setLevel(logging.INFO)
    
    root_logger.info("日誌系統初始化完成")
    if log_to_file:
        root_logger.info(f"日誌檔案: {log_dir.absolute()}")


def get_logger(name: str) -> logging.Logger:
    """取得 logger"""
    return logging.getLogger(name)
```

──────────────────────────────────────────────────────────────────────
### 📄 app/tasks/__init__.py  ⭐
> 排程任務模組
──────────────────────────────────────────────────────────────────────

```py
"""
排程任務模組
"""
from app.tasks.scheduler import scheduler_service, SchedulerService

__all__ = [
    "scheduler_service",
    "SchedulerService",
]
```

──────────────────────────────────────────────────────────────────────
### 📄 app/tasks/price_cache_task.py  ⭐
> 價格快取排程任務
──────────────────────────────────────────────────────────────────────

```py
"""
價格快取排程任務

排程邏輯：
1. 每 10 分鐘執行 run_update()
   - 自動判斷哪些市場開盤
   - 只更新開盤中的市場
   
2. 收盤後各執行一次（確保有最終收盤價）
   - 台股：13:35
   - 美股：05:05
"""
import logging
from datetime import datetime
from typing import Dict, Any

from app.database import SyncSessionLocal
from app.services.price_cache_service import PriceCacheService, get_market_status

logger = logging.getLogger(__name__)


class PriceCacheScheduler:
    """價格快取排程器"""
    
    def __init__(self):
        self.last_run: datetime = None
        self.last_result: Dict[str, Any] = {}
    
    def run_update(self) -> Dict[str, Any]:
        """
        執行價格快取更新（每 10 分鐘）
        
        自動判斷：
        - 台股開盤 (09:00-13:30) → 更新台股
        - 美股開盤 (21:30-05:00) → 更新美股
        - 加密貨幣 → 24 小時更新
        """
        market_status = get_market_status()
        
        # 如果所有股市都收盤，只更新加密貨幣
        if not market_status["tw_open"] and not market_status["us_open"]:
            logger.info("台股美股皆收盤，只更新加密貨幣")
        
        return self._do_update(force=False)
    
    def run_force_update(self) -> Dict[str, Any]:
        """
        強制更新所有市場（用於收盤後或手動觸發）
        """
        logger.info("強制更新所有市場")
        return self._do_update(force=True)
    
    def run_tw_close_update(self) -> Dict[str, Any]:
        """
        台股收盤後更新（13:35 執行）
        確保有最終收盤價
        """
        logger.info("台股收盤，執行最終更新")
        
        db = SyncSessionLocal()
        try:
            service = PriceCacheService(db)
            tracked = service.get_all_tracked_symbols()
            
            if tracked["tw_stocks"]:
                result = service.batch_update_stock_prices(tracked["tw_stocks"])
                logger.info(f"台股收盤更新完成: {result['updated']} 支")
                return result
            return {"updated": 0, "message": "無台股追蹤"}
            
        except Exception as e:
            logger.error(f"台股收盤更新失敗: {e}")
            return {"error": str(e)}
        finally:
            db.close()
    
    def run_us_close_update(self) -> Dict[str, Any]:
        """
        美股收盤後更新（05:05 執行）
        確保有最終收盤價
        """
        logger.info("美股收盤，執行最終更新")
        
        db = SyncSessionLocal()
        try:
            service = PriceCacheService(db)
            tracked = service.get_all_tracked_symbols()
            
            if tracked["us_stocks"]:
                result = service.batch_update_stock_prices(tracked["us_stocks"])
                logger.info(f"美股收盤更新完成: {result['updated']} 支")
                return result
            return {"updated": 0, "message": "無美股追蹤"}
            
        except Exception as e:
            logger.error(f"美股收盤更新失敗: {e}")
            return {"error": str(e)}
        finally:
            db.close()
    
    def _do_update(self, force: bool = False) -> Dict[str, Any]:
        """執行更新"""
        logger.info("=" * 50)
        logger.info(f"排程: 開始更新價格快取 (force={force})")
        logger.info(f"時間: {datetime.now()}")
        logger.info("=" * 50)
        
        db = SyncSessionLocal()
        
        try:
            service = PriceCacheService(db)
            result = service.update_all_tracked_prices(force=force)
            
            self.last_run = datetime.now()
            self.last_result = result
            
            logger.info(f"排程: 價格快取更新完成, 共 {result['total_updated']} 筆")
            
            return result
            
        except Exception as e:
            logger.error(f"排程: 價格快取更新失敗: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.now().isoformat(),
            }
        finally:
            db.close()
    
    def get_status(self) -> Dict[str, Any]:
        """取得排程狀態"""
        return {
            "last_run": self.last_run.isoformat() if self.last_run else None,
            "last_result": self.last_result,
            "market_status": get_market_status(),
        }


# 全域實例
price_cache_scheduler = PriceCacheScheduler()


# ============================================================
# APScheduler 設定範例（加到 main.py）
# ============================================================

"""
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from app.tasks.price_cache_task import price_cache_scheduler

scheduler = AsyncIOScheduler()

# 1. 每 10 分鐘執行（自動判斷開盤時間）
scheduler.add_job(
    price_cache_scheduler.run_update,
    'interval',
    minutes=10,
    id='price_cache_interval',
    name='價格快取更新(每10分鐘)',
)

# 2. 台股收盤後執行一次（週一到週五 13:35）
scheduler.add_job(
    price_cache_scheduler.run_tw_close_update,
    CronTrigger(day_of_week='mon-fri', hour=13, minute=35),
    id='price_cache_tw_close',
    name='台股收盤更新',
)

# 3. 美股收盤後執行一次（週二到週六 05:05，對應美股週一到週五）
scheduler.add_job(
    price_cache_scheduler.run_us_close_update,
    CronTrigger(day_of_week='tue-sat', hour=5, minute=5),
    id='price_cache_us_close',
    name='美股收盤更新',
)

# 啟動排程
@app.on_event("startup")
async def startup_event():
    scheduler.start()
    # 啟動時執行一次（強制更新所有）
    price_cache_scheduler.run_force_update()

@app.on_event("shutdown")
async def shutdown_event():
    scheduler.shutdown()
"""
```

──────────────────────────────────────────────────────────────────────
### 📄 app/tasks/scheduler.py  ⭐
> 排程任務服務
──────────────────────────────────────────────────────────────────────

```py
"""
排程任務服務
每日自動更新股價、指數、情緒資料，並發送訊號通知
"""
import asyncio
from datetime import datetime, date, timedelta
from typing import Dict, Any, List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import select, distinct, and_
import logging

from app.database import SyncSessionLocal, AsyncSessionLocal
from app.models.watchlist import Watchlist
from app.models.stock_price import StockPrice
from app.models.index_price import IndexPrice, INDEX_SYMBOLS
from app.models.market_sentiment import MarketSentiment
from app.models.notification import Notification
from app.models.user import User
from app.models.user_settings import UserAlertSettings
from app.services.market_service import MarketService
from app.services.signal_service import signal_service, SignalType
from app.data_sources.yahoo_finance import yahoo_finance

logger = logging.getLogger(__name__)


class SchedulerService:
    """排程任務服務"""
    
    # 重要訊號類型（只通知這些）
    IMPORTANT_SIGNAL_TYPES = [
        # 交叉訊號
        SignalType.MA_GOLDEN_CROSS,
        SignalType.MA_DEATH_CROSS,
        SignalType.MACD_GOLDEN_CROSS,
        SignalType.MACD_DEATH_CROSS,
        SignalType.KD_GOLDEN_CROSS,
        SignalType.KD_DEATH_CROSS,
        # RSI 極端值
        SignalType.RSI_OVERBOUGHT,
        SignalType.RSI_OVERSOLD,
    ]
    
    def __init__(self):
        self.last_run: Optional[datetime] = None
        self.last_result: Dict[str, Any] = {}
    
    def _get_db(self) -> Session:
        """取得資料庫 session"""
        return SyncSessionLocal()
    
    def run_daily_update(self) -> Dict[str, Any]:
        """
        執行每日更新任務
        
        包含：
        1. 更新所有追蹤股票的價格
        2. 更新三大指數
        3. 更新市場情緒
        4. 偵測訊號並發送通知
        
        Returns:
            執行結果摘要
        """
        logger.info("=" * 50)
        logger.info("開始執行每日更新任務")
        logger.info(f"執行時間: {datetime.now()}")
        logger.info("=" * 50)
        
        result = {
            "start_time": datetime.now().isoformat(),
            "stocks_updated": 0,
            "indices_updated": {},
            "sentiment_updated": {},
            "signals_detected": 0,
            "notifications_sent": 0,
            "errors": [],
        }
        
        db = self._get_db()
        
        try:
            # 1. 更新追蹤股票
            stocks_result = self._update_watchlist_stocks(db)
            result["stocks_updated"] = stocks_result["count"]
            if stocks_result.get("errors"):
                result["errors"].extend(stocks_result["errors"])
            
            # 2. 更新三大指數
            market_service = MarketService(db)
            indices_result = self._update_indices(market_service)
            result["indices_updated"] = indices_result
            
            # 3. 更新市場情緒
            sentiment_result = market_service.update_today_sentiment()
            result["sentiment_updated"] = sentiment_result
            
            # 4. 偵測訊號並發送通知
            signal_result = self._detect_and_notify(db)
            result["signals_detected"] = signal_result.get("signals_count", 0)
            result["notifications_sent"] = signal_result.get("notifications_sent", 0)
            if signal_result.get("errors"):
                result["errors"].extend(signal_result["errors"])
            
            result["end_time"] = datetime.now().isoformat()
            result["success"] = True
            
            logger.info("=" * 50)
            logger.info("每日更新任務完成")
            logger.info(f"股票更新: {result['stocks_updated']} 檔")
            logger.info(f"指數更新: {result['indices_updated']}")
            logger.info(f"情緒更新: {result['sentiment_updated']}")
            logger.info(f"訊號偵測: {result['signals_detected']} 個")
            logger.info(f"通知發送: {result['notifications_sent']} 人")
            logger.info("=" * 50)
            
        except Exception as e:
            logger.error(f"每日更新任務失敗: {e}")
            result["errors"].append(str(e))
            result["success"] = False
        finally:
            db.close()
        
        self.last_run = datetime.now()
        self.last_result = result
        
        return result
    
    def _detect_and_notify(self, db: Session) -> Dict[str, Any]:
        """
        偵測訊號並發送通知
        
        流程：
        1. 取得所有用戶的追蹤清單（聯集）
        2. 對每支股票計算指標並偵測訊號
        3. 根據用戶設定發送通知
        """
        result = {
            "signals_count": 0,
            "notifications_sent": 0,
            "errors": [],
        }
        
        logger.info("開始偵測訊號...")
        
        try:
            # 1. 取得所有追蹤的股票
            stmt = select(distinct(Watchlist.symbol)).where(Watchlist.asset_type == "stock")
            symbols = db.execute(stmt).scalars().all()
            logger.info(f"需要偵測的股票: {len(symbols)} 檔")
            
            # 2. 對每支股票偵測訊號
            all_signals = {}  # {symbol: [signals]}
            
            for symbol in symbols:
                try:
                    signals = self._detect_signals_for_symbol(symbol)
                    
                    # 只保留交叉訊號
                    cross_signals = [s for s in signals if s.signal_type in self.IMPORTANT_SIGNAL_TYPES]
                    
                    if cross_signals:
                        all_signals[symbol] = cross_signals
                        result["signals_count"] += len(cross_signals)
                        logger.info(f"{symbol}: 偵測到 {len(cross_signals)} 個交叉訊號")
                
                except Exception as e:
                    logger.error(f"偵測 {symbol} 訊號失敗: {e}")
                    result["errors"].append(f"{symbol}: {str(e)}")
            
            logger.info(f"共偵測到 {result['signals_count']} 個交叉訊號")
            
            if not all_signals:
                logger.info("今日無交叉訊號，不發送通知")
                return result
            
            # 3. 取得需要通知的用戶
            users_to_notify = self._get_users_to_notify(db, all_signals)
            logger.info(f"需要通知的用戶: {len(users_to_notify)} 人")
            
            # 4. 發送通知
            for user_id, user_data in users_to_notify.items():
                try:
                    success = self._send_notification(db, user_data)
                    if success:
                        result["notifications_sent"] += 1
                except Exception as e:
                    logger.error(f"發送通知給用戶 {user_id} 失敗: {e}")
                    result["errors"].append(f"notify user {user_id}: {str(e)}")
            
        except Exception as e:
            logger.error(f"訊號偵測失敗: {e}")
            result["errors"].append(str(e))
        
        return result
    
    def _detect_signals_for_symbol(self, symbol: str) -> List:
        """對單一股票偵測訊號"""
        from app.services.indicator_service import indicator_service, SignalType as IndicatorSignalType
        
        # 取得股票資料
        df = yahoo_finance.get_stock_history(symbol, period="3mo")
        
        if df is None or df.empty:
            return []
        
        # 計算指標
        df = indicator_service.calculate_all_indicators(df)
        
        if df is None or df.empty:
            return []
        
        # 取得訊號
        indicator_signals = indicator_service.get_all_signals(df)
        
        if not indicator_signals:
            return []
        
        # 轉換訊號格式（從 indicator_service.Signal 到 signal_service.Signal）
        from app.services.signal_service import Signal, SignalType
        
        signals = []
        current_price = float(df.iloc[-1]['close']) if 'close' in df.columns else 0
        
        # 訊號類型對照
        type_mapping = {
            IndicatorSignalType.GOLDEN_CROSS: SignalType.MA_GOLDEN_CROSS,
            IndicatorSignalType.DEATH_CROSS: SignalType.MA_DEATH_CROSS,
            IndicatorSignalType.RSI_OVERBOUGHT: SignalType.RSI_OVERBOUGHT,
            IndicatorSignalType.RSI_OVERSOLD: SignalType.RSI_OVERSOLD,
            IndicatorSignalType.MACD_GOLDEN_CROSS: SignalType.MACD_GOLDEN_CROSS,
            IndicatorSignalType.MACD_DEATH_CROSS: SignalType.MACD_DEATH_CROSS,
            IndicatorSignalType.KD_GOLDEN_CROSS: SignalType.KD_GOLDEN_CROSS,
            IndicatorSignalType.KD_DEATH_CROSS: SignalType.KD_DEATH_CROSS,
            IndicatorSignalType.APPROACHING_BREAKOUT: SignalType.APPROACHING_BREAKOUT,
            IndicatorSignalType.APPROACHING_BREAKDOWN: SignalType.APPROACHING_BREAKDOWN,
        }
        
        for ind_sig in indicator_signals:
            sig_type = type_mapping.get(ind_sig.type)
            if sig_type:
                signals.append(Signal(
                    symbol=symbol,
                    asset_type="stock",
                    signal_type=sig_type,
                    indicator=ind_sig.indicator,
                    message=ind_sig.description,
                    price=current_price,
                    details={},
                    timestamp=datetime.now(),
                ))
        
        return signals
    
    def _get_users_to_notify(self, db: Session, all_signals: Dict) -> Dict:
        """
        取得需要通知的用戶
        
        Returns:
            {user_id: {
                "line_user_id": "xxx",
                "display_name": "xxx",
                "signals": [...]
            }}
        """
        users_to_notify = {}
        
        # 取得所有用戶和他們的追蹤清單
        stmt = select(User).where(User.is_active == True, User.is_blocked == False)
        users = db.execute(stmt).scalars().all()
        
        for user in users:
            # 取得用戶的追蹤清單
            watchlist_stmt = select(Watchlist.symbol).where(
                Watchlist.user_id == user.id,
                Watchlist.asset_type == "stock"
            )
            user_symbols = set(db.execute(watchlist_stmt).scalars().all())
            
            # 取得用戶的通知設定（檢查是否開啟交叉通知）
            alert_stmt = select(UserAlertSettings).where(UserAlertSettings.user_id == user.id)
            alert_settings = db.execute(alert_stmt).scalar_one_or_none()
            
            # 預設開啟 MA 和 MACD 交叉通知
            alert_ma = True
            alert_macd = True
            alert_kd = False
            alert_rsi = True  # 預設開啟 RSI
            
            if alert_settings:
                alert_ma = alert_settings.alert_ma_cross
                alert_macd = alert_settings.alert_macd
                alert_kd = alert_settings.alert_kd
                alert_rsi = alert_settings.alert_rsi
            
            # 找出用戶追蹤中有訊號的股票
            user_signals = []
            for symbol, signals in all_signals.items():
                if symbol not in user_symbols:
                    continue
                
                for signal in signals:
                    # 檢查用戶是否開啟該類型的通知
                    if signal.signal_type in [SignalType.MA_GOLDEN_CROSS, SignalType.MA_DEATH_CROSS]:
                        if not alert_ma:
                            continue
                    elif signal.signal_type in [SignalType.MACD_GOLDEN_CROSS, SignalType.MACD_DEATH_CROSS]:
                        if not alert_macd:
                            continue
                    elif signal.signal_type in [SignalType.KD_GOLDEN_CROSS, SignalType.KD_DEATH_CROSS]:
                        if not alert_kd:
                            continue
                    elif signal.signal_type in [SignalType.RSI_OVERBOUGHT, SignalType.RSI_OVERSOLD]:
                        if not alert_rsi:
                            continue
                    
                    # 檢查 24 小時內是否已通知過
                    if self._has_recent_notification(db, user.id, symbol, signal.signal_type.value):
                        continue
                    
                    user_signals.append(signal)
            
            if user_signals:
                users_to_notify[user.id] = {
                    "user_id": user.id,
                    "line_user_id": user.line_user_id,
                    "display_name": user.display_name,
                    "signals": user_signals,
                }
        
        return users_to_notify
    
    def _has_recent_notification(self, db: Session, user_id: int, symbol: str, alert_type: str) -> bool:
        """檢查 24 小時內是否已發送過相同通知"""
        cutoff = datetime.now() - timedelta(hours=24)
        
        stmt = select(Notification).where(
            Notification.user_id == user_id,
            Notification.symbol == symbol,
            Notification.alert_type == alert_type,
            Notification.triggered_at >= cutoff,
        )
        
        existing = db.execute(stmt).scalar_one_or_none()
        return existing is not None
    
    def _send_notification(self, db: Session, user_data: Dict) -> bool:
        """發送通知給用戶"""
        from app.services.line_notify_service import line_notify_service
        
        line_user_id = user_data["line_user_id"]
        signals = user_data["signals"]
        
        if not line_user_id or not signals:
            return False
        
        # 分類訊號
        bullish = []
        bearish = []
        
        for signal in signals:
            signal_name = signal_service.SIGNAL_NAMES.get(signal.signal_type, str(signal.signal_type))
            item = {
                "symbol": signal.symbol,
                "signal": signal_name,
                "price": signal.price,
                "signal_type": signal.signal_type.value,
            }
            
            # 判斷多空
            if signal.signal_type in [
                SignalType.MA_GOLDEN_CROSS, 
                SignalType.MACD_GOLDEN_CROSS, 
                SignalType.KD_GOLDEN_CROSS,
                SignalType.RSI_OVERSOLD,
            ]:
                bullish.append(item)
            else:
                bearish.append(item)
        
        # 格式化訊息
        message = self._format_notification_message(bullish, bearish)
        
        # 發送訊息（使用 asyncio 執行）
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            success = loop.run_until_complete(
                line_notify_service.push_text_message(line_user_id, message)
            )
            loop.close()
        except Exception as e:
            logger.error(f"發送 LINE 訊息失敗: {e}")
            success = False
        
        # 記錄通知
        for signal in signals:
            notification = Notification(
                user_id=user_data.get("user_id"),
                symbol=signal.symbol,
                asset_type=signal.asset_type,
                alert_type=signal.signal_type.value,
                indicator=signal.indicator,
                message=signal.message,
                price_at_trigger=signal.price,
                sent=success,
                sent_at=datetime.now() if success else None,
            )
            db.add(notification)
        
        db.commit()
        
        return success
    
    def _format_notification_message(self, bullish: List[Dict], bearish: List[Dict]) -> str:
        """格式化每日訊號通知訊息"""
        lines = ["📊 SELA 選股系統 - 每日訊號", ""]
        
        if bullish:
            lines.append("🟢 偏多訊號")
            for item in bullish:
                price_str = f" @ ${item['price']:.2f}" if item['price'] > 0 else ""
                lines.append(f"  • {item['symbol']}{price_str}")
                lines.append(f"    {item['signal']}")
            lines.append("")
        
        if bearish:
            lines.append("🔴 偏空訊號")
            for item in bearish:
                price_str = f" @ ${item['price']:.2f}" if item['price'] > 0 else ""
                lines.append(f"  • {item['symbol']}{price_str}")
                lines.append(f"    {item['signal']}")
            lines.append("")
        
        if not bullish and not bearish:
            lines.append("今日您的追蹤清單無重要訊號 ✨")
            lines.append("")
        
        lines.append(f"⏰ {datetime.now().strftime('%Y-%m-%d %H:%M')}")
        
        return "\n".join(lines)
    
    def run_signal_detection_only(self) -> Dict[str, Any]:
        """
        只執行訊號偵測（不發送通知）
        用於測試
        """
        logger.info("開始訊號偵測（測試模式）...")
        
        result = {
            "signals": [],
            "by_symbol": {},
        }
        
        db = self._get_db()
        
        try:
            stmt = select(distinct(Watchlist.symbol)).where(Watchlist.asset_type == "stock")
            symbols = db.execute(stmt).scalars().all()
            
            for symbol in symbols:
                try:
                    signals = self._detect_signals_for_symbol(symbol)
                    cross_signals = [s for s in signals if s.signal_type in self.IMPORTANT_SIGNAL_TYPES]
                    
                    if cross_signals:
                        result["by_symbol"][symbol] = [
                            {
                                "type": s.signal_type.value,
                                "message": s.message,
                                "price": s.price,
                            }
                            for s in cross_signals
                        ]
                        result["signals"].extend(cross_signals)
                
                except Exception as e:
                    logger.error(f"{symbol} 偵測失敗: {e}")
        
        finally:
            db.close()
        
        return result

    def _update_watchlist_stocks(self, db: Session) -> Dict[str, Any]:
        """
        更新所有追蹤清單中的股票
        """
        result = {"count": 0, "errors": []}
        
        # 取得所有不重複的追蹤股票
        stmt = select(distinct(Watchlist.symbol)).where(Watchlist.asset_type == "stock")
        symbols = db.execute(stmt).scalars().all()
        
        logger.info(f"需要更新的股票: {len(symbols)} 檔")
        
        for symbol in symbols:
            try:
                # 從 Yahoo Finance 抓取最新資料
                df = yahoo_finance.get_stock_history(symbol, period="5d")
                
                if df is None or df.empty:
                    logger.warning(f"無法取得 {symbol} 的資料")
                    result["errors"].append(f"{symbol}: 無資料")
                    continue
                
                # 儲存到資料庫
                count = self._save_stock_prices(db, df)
                result["count"] += 1
                logger.debug(f"{symbol} 更新完成，新增 {count} 筆")
                
            except Exception as e:
                logger.error(f"更新 {symbol} 失敗: {e}")
                result["errors"].append(f"{symbol}: {str(e)}")
        
        return result
    
    def _save_stock_prices(self, db: Session, df) -> int:
        """儲存股票價格"""
        if df is None or df.empty:
            return 0
        
        count = 0
        for _, row in df.iterrows():
            stmt = select(StockPrice).where(
                and_(
                    StockPrice.symbol == row["symbol"],
                    StockPrice.date == row["date"],
                )
            )
            existing = db.execute(stmt).scalar_one_or_none()
            
            if existing:
                existing.open = row["open"]
                existing.high = row["high"]
                existing.low = row["low"]
                existing.close = row["close"]
                existing.volume = row["volume"]
            else:
                price = StockPrice(
                    symbol=row["symbol"],
                    date=row["date"],
                    open=row["open"],
                    high=row["high"],
                    low=row["low"],
                    close=row["close"],
                    volume=row["volume"],
                )
                db.add(price)
                count += 1
        
        db.commit()
        return count
    
    def _update_indices(self, market_service: MarketService) -> Dict[str, int]:
        """
        更新三大指數（只更新最近 5 天）
        """
        result = {}
        
        for symbol in INDEX_SYMBOLS.keys():
            try:
                df = yahoo_finance.get_index_data(symbol, period="5d")
                if df is not None:
                    count = market_service.save_index_data(df, symbol)
                    result[symbol] = count
                else:
                    result[symbol] = 0
            except Exception as e:
                logger.error(f"更新指數 {symbol} 失敗: {e}")
                result[symbol] = -1
        
        return result
    
    def initialize_historical_data(self, years: int = 10) -> Dict[str, Any]:
        """
        初始化歷史資料（首次執行時使用）
        
        包含：
        1. 三大指數 10 年歷史
        2. 幣圈情緒 365 天歷史
        
        Args:
            years: 指數歷史年數
            
        Returns:
            執行結果
        """
        logger.info("=" * 50)
        logger.info("開始初始化歷史資料")
        logger.info("=" * 50)
        
        result = {
            "start_time": datetime.now().isoformat(),
            "indices": {},
            "crypto_sentiment": 0,
            "errors": [],
        }
        
        db = self._get_db()
        
        try:
            market_service = MarketService(db)
            
            # 1. 初始化三大指數
            logger.info(f"初始化三大指數 ({years} 年資料)...")
            indices_result = market_service.fetch_and_save_all_indices(period=f"{years}y")
            result["indices"] = indices_result
            
            # 2. 初始化幣圈情緒歷史
            logger.info("初始化幣圈情緒歷史 (365 天)...")
            crypto_count = market_service.fetch_and_save_crypto_history(days=365)
            result["crypto_sentiment"] = crypto_count
            
            result["success"] = True
            result["end_time"] = datetime.now().isoformat()
            
            logger.info("=" * 50)
            logger.info("歷史資料初始化完成")
            logger.info(f"指數: {result['indices']}")
            logger.info(f"幣圈情緒: {result['crypto_sentiment']} 筆")
            logger.info("=" * 50)
            
        except Exception as e:
            logger.error(f"初始化失敗: {e}")
            result["errors"].append(str(e))
            result["success"] = False
        finally:
            db.close()
        
        return result
    
    def get_status(self) -> Dict[str, Any]:
        """取得排程狀態"""
        return {
            "last_run": self.last_run.isoformat() if self.last_run else None,
            "last_result": self.last_result,
        }


# 建立全域排程服務實例
scheduler_service = SchedulerService()
```

──────────────────────────────────────────────────────────────────────
### 📄 app/tasks/subscription_tasks.py  ⭐
> 訂閱精選排程任務
──────────────────────────────────────────────────────────────────────

```py
"""
訂閱精選排程任務
每小時抓取一次 RSS
"""
import logging
from datetime import datetime

from app.database import SessionLocal
from app.services.subscription_service import SubscriptionService

logger = logging.getLogger(__name__)


def scheduled_fetch_subscriptions():
    """
    排程任務：抓取所有訂閱源
    每小時執行一次
    """
    logger.info("=" * 40)
    logger.info(f"開始排程抓取訂閱源 - {datetime.now()}")
    logger.info("=" * 40)
    
    try:
        db = SessionLocal()
        service = SubscriptionService(db)
        
        # 抓取所有訂閱源（非回溯模式，只抓新的）
        result = service.fetch_all_sources(backfill=False)
        
        logger.info(f"抓取完成: 新增 {result['total_new']}, 更新 {result['total_updated']}")
        
        db.close()
        return result
        
    except Exception as e:
        logger.error(f"排程抓取失敗: {e}", exc_info=True)
        return None


def init_and_backfill():
    """
    初始化並回溯抓取
    首次部署時執行
    """
    logger.info("=" * 40)
    logger.info("初始化訂閱源並回溯抓取")
    logger.info("=" * 40)
    
    try:
        db = SessionLocal()
        service = SubscriptionService(db)
        
        # 初始化預設訂閱源
        service.init_default_sources()
        
        # 回溯抓取 30 天
        result = service.fetch_all_sources(backfill=True)
        
        logger.info(f"回溯完成: 新增 {result['total_new']}, 更新 {result['total_updated']}")
        
        db.close()
        return result
        
    except Exception as e:
        logger.error(f"初始化失敗: {e}", exc_info=True)
        return None
```

──────────────────────────────────────────────────────────────────────
### 📄 fixes/taiwan_stock_names_fix.py  ⭐
> ============================================================
──────────────────────────────────────────────────────────────────────

```py
# ============================================================
# 修復: TAIWAN_STOCK_NAMES 亂碼問題
# 位置: app/data_sources/yahoo_finance.py
# 
# 問題: Bundle 文件中的中文名稱已經是亂碼
# 解決: 用以下正確的字典替換
# ============================================================

# 找到 yahoo_finance.py 中的 TAIWAN_STOCK_NAMES = { ... }
# 整個替換為以下內容:

TAIWAN_STOCK_NAMES = {
    # 權值股
    "2330": "台積電",
    "2317": "鴻海",
    "2454": "聯發科",
    "2308": "台達電",
    "2412": "中華電",
    "2303": "聯電",
    "2002": "中鋼",
    "1301": "台塑",
    "1303": "南亞",
    "1326": "台化",
    "6505": "台塑化",
    "1101": "台泥",
    "1102": "亞泥",
    # 金融股
    "2881": "富邦金",
    "2882": "國泰金",
    "2884": "玉山金",
    "2886": "兆豐金",
    "2891": "中信金",
    "2892": "第一金",
    "2880": "華南金",
    "2883": "開發金",
    "2885": "元大金",
    "2887": "台新金",
    "2888": "新光金",
    "2890": "永豐金",
    "5880": "合庫金",
    # 電子股
    "2912": "統一超",
    "2357": "華碩",
    "2382": "廣達",
    "2395": "研華",
    "3008": "大立光",
    "3711": "日月光投控",
    "2345": "智邦",
    "2379": "瑞昱",
    "2327": "國巨",
    "3034": "聯詠",
    "2301": "光寶科",
    "2408": "南亞科",
    "2474": "可成",
    "3045": "台灣大",
    "4904": "遠傳",
    "3231": "緯創",
    "2356": "英業達",
    "2353": "宏碁",
    "2324": "仁寶",
    "2377": "微星",
    "2376": "技嘉",
    "4938": "和碩",
    "2409": "友達",
    "3481": "群創",
    "6669": "緯穎",
    "3037": "欣興",
    "2344": "華邦電",
    "2337": "旺宏",
    "3443": "創意",
    "6488": "環球晶",
    "5269": "祥碩",
    "6415": "矽力-KY",
    "3661": "世芯-KY",
    "2603": "長榮",
    "2609": "陽明",
    "2615": "萬海",
    "2618": "長榮航",
    "2610": "華航",
    "2633": "台灣高鐵",
    "9910": "豐泰",
    "9921": "巨大",
    "1216": "統一",
    "2207": "和泰車",
    "5871": "中租-KY",
    "9941": "裕融",
    "5876": "上海商銀",
    "6239": "力成",
    "8046": "南電",
    "3017": "奇鋐",
    "6176": "瑞儀",
    "6285": "啟碁",
    "2492": "華新科",
    "3533": "嘉澤",
    "6531": "愛普",
    "3665": "貿聯-KY",
    "8454": "富邦媒",
    "2383": "台光電",
    "6446": "藥華藥",
    "6547": "高端疫苗",
    # ETF
    "0050": "元大台灣50",
    "0051": "元大中型100",
    "0052": "富邦科技",
    "0053": "元大電子",
    "0055": "元大MSCI金融",
    "0056": "元大高股息",
    "006208": "富邦台50",
    "00646": "元大S&P500",
    "00662": "富邦NASDAQ",
    "00713": "元大台灣高息低波",
    "00850": "元大臺灣ESG永續",
    "00878": "國泰永續高股息",
    "00881": "國泰台灣5G+",
    "00891": "中信關鍵半導體",
    "00892": "富邦台灣半導體",
    "00893": "國泰智能電動車",
    "00895": "富邦未來車",
    "00900": "富邦特選高股息30",
    "00919": "群益台灣精選高息",
    "00929": "復華台灣科技優息",
    "00939": "統一台灣高息優選",
    "00940": "元大台灣價值高息",
}


# ============================================================
# 同樣需要修復 price_cache_service.py 中的 TAIWAN_STOCK_NAMES
# 位置: app/services/price_cache_service.py
# 用相同的字典替換
# ============================================================
```

──────────────────────────────────────────────────────────────────────
### 📄 migrations/add_target_price.sql  ⭐
──────────────────────────────────────────────────────────────────────

```sql
-- 添加 target_price 欄位到 watchlists 表
-- 執行時間: 部署後自動執行

ALTER TABLE watchlists 
ADD COLUMN IF NOT EXISTS target_price NUMERIC(12, 4) DEFAULT NULL;

-- 添加註解
COMMENT ON COLUMN watchlists.target_price IS '目標價格，用於到價提醒';
```

──────────────────────────────────────────────────────────────────────
### 📄 railway.json  ⭐
──────────────────────────────────────────────────────────────────────

```json
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "uvicorn app.main:app --host 0.0.0.0 --port $PORT",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}
```

──────────────────────────────────────────────────────────────────────
### 📄 RAILWAY_SETUP.md  ⭐
> Railway PostgreSQL 設定指南
──────────────────────────────────────────────────────────────────────

```md
# Railway PostgreSQL 設定指南

## 步驟 1：在 Railway 添加 PostgreSQL

1. 進入你的 Railway 專案
2. 點擊 **New** → **Database** → **Add PostgreSQL**
3. 等待資料庫建立完成

## 步驟 2：取得資料庫連線字串

1. 點擊新建立的 PostgreSQL 服務
2. 進入 **Variables** 標籤
3. 複製 `DATABASE_URL` 的值

格式類似：
```
postgres://username:password@host:port/database
```

## 步驟 3：設定環境變數

在你的 **Web Service** (不是 PostgreSQL) 中設定：

1. 點擊 Web Service → **Variables**
2. 添加以下變數：

```bash
# 資料庫 (從 PostgreSQL 服務複製)
DATABASE_URL=${{Postgres.DATABASE_URL}}

# 或直接貼上完整的連線字串
# DATABASE_URL=postgres://username:password@host:port/database

# 應用程式
APP_ENV=production
DEBUG=false

# LINE Login
LINE_LOGIN_CHANNEL_ID=你的_channel_id
LINE_LOGIN_CHANNEL_SECRET=你的_channel_secret
LINE_LOGIN_CALLBACK_URL=https://你的網域/auth/line/callback

# JWT
JWT_SECRET_KEY=你的隨機密鑰
JWT_EXPIRE_DAYS=7
```

### 使用 Railway 的變數引用（推薦）

Railway 支援在同一專案內引用其他服務的變數：

```bash
DATABASE_URL=${{Postgres.DATABASE_URL}}
```

這樣當資料庫連線資訊變更時，會自動更新。

## 步驟 4：部署

```bash
# 更新代碼
git add .
git commit -m "feat: add PostgreSQL support"
git push
```

Railway 會自動偵測到變更並重新部署。

## 步驟 5：驗證

1. 等待部署完成
2. 檢查日誌，應該看到：
   ```
   Starting SELA 自動選股系統 v0.3.x
   Database initialized
   ```

3. 訪問你的網站測試功能

## 資料庫表格

系統會自動建立以下表格：

| 表格 | 說明 |
|------|------|
| users | 用戶資料 (LINE Login) |
| watchlists | 追蹤清單 |
| stock_prices | 股價快取 |
| crypto_prices | 幣價快取 |
| market_sentiment | 市場情緒 |
| user_indicator_settings | 用戶指標設定 |
| user_alert_settings | 用戶通知設定 |
| user_indicator_params | 用戶參數設定 |
| notifications | 通知記錄 |

## 注意事項

1. **首次部署**：表格會自動建立，不需要手動執行 migration

2. **postgres:// vs postgresql://**：
   - Railway 使用 `postgres://`
   - SQLAlchemy 需要 `postgresql://`
   - 程式已自動處理轉換

3. **連線池**：
   - 使用 `NullPool` 避免連線問題
   - 適合 Railway 的 serverless 環境

## 故障排除

### 連線失敗
- 確認 DATABASE_URL 正確
- 確認 PostgreSQL 服務正在運行

### 表格不存在
- 檢查日誌確認 "Database initialized" 訊息
- 嘗試重新部署

### SSL 錯誤
如果遇到 SSL 錯誤，在 DATABASE_URL 後面加上：
```
?sslmode=require
```
```

──────────────────────────────────────────────────────────────────────
### 📄 runtime.txt  ⭐
──────────────────────────────────────────────────────────────────────

```text
python-3.11.0
```

──────────────────────────────────────────────────────────────────────
### 📄 scripts/匯整子程式.py  ⭐
> 專案整合工具 - 把資料夾結構和程式碼整合成單一檔案
──────────────────────────────────────────────────────────────────────

```py
#!/usr/bin/env python3
"""
專案整合工具 - 把資料夾結構和程式碼整合成單一檔案
用途：上傳到 Claude 專案作為 context
"""

import os
from pathlib import Path
from datetime import datetime

# ===== 設定 =====
IGNORE_DIRS = {'.git', '__pycache__', '.venv', 'venv', 'node_modules', '.idea', '.vscode', 'dist', 'build', '__MACOSX'}
IGNORE_FILES = {'.DS_Store', 'Thumbs.db', '.gitignore', '*.pyc', '*.pyo'}
CODE_EXTENSIONS = {'.py', '.js', '.ts', '.html', '.css', '.json', '.yaml', '.yml', '.md', '.txt', '.sql', '.sh', '.env.example'}
MAX_FILE_SIZE = 100 * 1024  # 100KB，超過的檔案只顯示路徑不顯示內容


def should_ignore(path: Path) -> bool:
    """判斷是否要忽略此路徑"""
    if path.name in IGNORE_DIRS or path.name in IGNORE_FILES:
        return True
    if path.name.startswith('.') and path.name not in {'.env.example'}:
        return True
    return False


def generate_tree(root: Path, prefix: str = "") -> list[str]:
    """產生目錄樹狀圖"""
    lines = []
    items = sorted(root.iterdir(), key=lambda x: (x.is_file(), x.name.lower()))
    items = [x for x in items if not should_ignore(x)]
    
    for i, item in enumerate(items):
        is_last = i == len(items) - 1
        connector = "└── " if is_last else "├── "
        
        if item.is_dir():
            lines.append(f"{prefix}{connector}{item.name}/")
            extension = "    " if is_last else "│   "
            lines.extend(generate_tree(item, prefix + extension))
        else:
            lines.append(f"{prefix}{connector}{item.name}")
    
    return lines


def collect_files(root: Path) -> list[Path]:
    """收集所有程式碼檔案"""
    files = []
    for path in root.rglob('*'):
        if path.is_file() and not should_ignore(path):
            # 檢查父目錄是否在忽略清單
            if any(p.name in IGNORE_DIRS for p in path.parents):
                continue
            if path.suffix.lower() in CODE_EXTENSIONS or path.name in {'Dockerfile', 'Makefile', 'requirements.txt', 'Procfile'}:
                files.append(path)
    return sorted(files, key=lambda x: str(x).lower())


def bundle_project(target_dir: str, output_file: str = None):
    """主程式：整合專案"""
    root = Path(target_dir).resolve()
    
    if not root.exists():
        print(f"❌ 找不到資料夾: {root}")
        return
    
    if output_file is None:
        output_file = f"{root.name}_bundle.txt"
    
    output_path = Path(output_file).resolve()
    
    with open(output_path, 'w', encoding='utf-8') as out:
        # 標題
        out.write(f"{'='*70}\n")
        out.write(f"專案名稱: {root.name}\n")
        out.write(f"整合時間: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        out.write(f"{'='*70}\n\n")
        
        # 目錄結構
        out.write("## 目錄結構\n\n")
        out.write("```\n")
        out.write(f"{root.name}/\n")
        for line in generate_tree(root):
            out.write(f"{line}\n")
        out.write("```\n\n")
        
        # 檔案內容
        out.write(f"{'='*70}\n")
        out.write("## 檔案內容\n")
        out.write(f"{'='*70}\n\n")
        
        files = collect_files(root)
        
        for filepath in files:
            rel_path = filepath.relative_to(root)
            out.write(f"\n{'─'*70}\n")
            out.write(f"### {rel_path}\n")
            out.write(f"{'─'*70}\n\n")
            
            # 檢查檔案大小
            if filepath.stat().st_size > MAX_FILE_SIZE:
                out.write(f"（檔案過大，略過內容：{filepath.stat().st_size / 1024:.1f} KB）\n")
                continue
            
            try:
                content = filepath.read_text(encoding='utf-8')
                # 根據副檔名加上 code block
                lang = filepath.suffix.lstrip('.') or 'text'
                if lang == 'txt':
                    lang = 'text'
                out.write(f"```{lang}\n")
                out.write(content)
                if not content.endswith('\n'):
                    out.write('\n')
                out.write("```\n")
            except UnicodeDecodeError:
                out.write("（二進位檔案，略過）\n")
            except Exception as e:
                out.write(f"（讀取錯誤：{e}）\n")
        
        # 統計
        out.write(f"\n{'='*70}\n")
        out.write(f"## 統計\n")
        out.write(f"共 {len(files)} 個檔案\n")
        out.write(f"{'='*70}\n")
    
    print(f"✅ 完成！輸出檔案: {output_path}")
    print(f"   共整合 {len(files)} 個檔案")


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        # 預設使用目前目錄
        target = "."
    else:
        target = sys.argv[1]
    
    output = sys.argv[2] if len(sys.argv) > 2 else None
    bundle_project(target, output)
```

──────────────────────────────────────────────────────────────────────
### 📄 匯整專案 V3.py  ⭐
> 專案整合工具 v2 - 智能分層整理
──────────────────────────────────────────────────────────────────────

```py
#!/usr/bin/env python3
"""
專案整合工具 v2 - 智能分層整理
用途：上傳到 Claude 專案作為 context，結構化便於閱讀
"""

import os
import re
import shutil
from pathlib import Path
from datetime import datetime
from collections import defaultdict

# ===== 設定 =====
IGNORE_DIRS = {'.git', '__pycache__', '.venv', 'venv', 'node_modules', '.idea', '.vscode', 'dist', 'build', '__MACOSX', '.pytest_cache', 'htmlcov'}
IGNORE_FILES = {'.DS_Store', 'Thumbs.db', '*.pyc', '*.pyo', '*.so', '*.egg-info'}
CODE_EXTENSIONS = {'.py', '.js', '.ts', '.jsx', '.tsx', '.html', '.css', '.json', '.yaml', '.yml', '.md', '.txt', '.sql', '.sh', '.env.example', '.toml'}

# ===== 檔案大小與截斷規則 =====
FILE_RULES = {
    # 完整保留（不限大小）
    'full': {
        'extensions': {'.md', '.txt', '.toml', '.yaml', '.yml', '.env.example'},
        'files': {'requirements.txt', 'dockerfile', 'makefile', 'procfile'},
    },
    # 程式碼（上限 200KB）
    'code': {
        'extensions': {'.py', '.js', '.ts', '.jsx', '.tsx', '.html', '.sql', '.sh'},
        'max_size': 200 * 1024,
    },
    # 樣式（只取前 150 行）
    'style': {
        'extensions': {'.css', '.scss', '.less'},
        'max_lines': 150,
    },
    # 資料檔（只取前 50 行 + 結構說明）
    'data': {
        'extensions': {'.json', '.csv', '.tsv'},
        'max_lines': 50,
    },
}

# 重要檔案（被跳過時要複製出來）
IMPORTANT_PATTERNS = {
    'extensions': {'.py', '.js', '.ts', '.md', '.html'},
    'files': {'main.py', 'app.py', 'index.py', 'config.py', 'settings.py'},
    'layers': {'entry', 'api', 'core', 'overview'},
}

# ===== 分層定義 =====
# 優先順序：數字越小越前面
LAYER_RULES = {
    # 第 1 層：專案概述
    'overview': {
        'order': 1,
        'title': '📋 專案概述',
        'patterns': ['README*', 'CHANGELOG*', 'LICENSE*', 'docs/*', 'doc/*'],
        'files': {
            # 基本
            'readme.md', 'readme.txt', 'changelog.md', 'license', 'license.md',
            # 開發文檔
            'troubleshooting.md', 'trouble_shooting.md', 'faq.md',
            'architecture.md', 'design.md', 'structure.md',
            'setup.md', 'install.md', 'installation.md',
            'development.md', 'dev.md', 'dev_notes.md', 'notes.md',
            'deployment.md', 'deploy.md',
            'contributing.md', 'contribute.md',
            'api.md', 'api_docs.md', 'endpoints.md',
            'todo.md', 'roadmap.md', 'plan.md',
            'guide.md', 'usage.md', 'manual.md',
            # 中文常見
            '說明.md', '開發筆記.md', '問題排解.md', '架構.md',
        },
    },
    # 第 2 層：設定檔
    'config': {
        'order': 2,
        'title': '⚙️ 設定檔',
        'patterns': ['*.toml', '*.yaml', '*.yml', '.env*', 'config/*', 'settings/*'],
        'files': {'pyproject.toml', 'package.json', 'requirements.txt', 'dockerfile', 'docker-compose.yml', 'makefile', 'procfile', '.env.example', 'config.py', 'settings.py'},
    },
    # 第 3 層：進入點
    'entry': {
        'order': 3,
        'title': '🚀 程式進入點',
        'patterns': [],
        'files': {'main.py', 'app.py', 'index.py', 'server.py', 'run.py', 'index.js', 'index.ts', 'app.js', 'server.js'},
    },
    # 第 4 層：路由/API
    'api': {
        'order': 4,
        'title': '🌐 API / 路由',
        'patterns': ['routes/*', 'routers/*', 'api/*', 'endpoints/*', 'views/*'],
        'files': {'routes.py', 'router.py', 'api.py', 'urls.py'},
    },
    # 第 5 層：資料模型
    'models': {
        'order': 5,
        'title': '📦 資料模型',
        'patterns': ['models/*', 'schemas/*', 'entities/*', 'types/*'],
        'files': {'models.py', 'schemas.py', 'database.py', 'db.py'},
    },
    # 第 6 層：核心邏輯
    'core': {
        'order': 6,
        'title': '🧠 核心邏輯',
        'patterns': ['core/*', 'services/*', 'handlers/*', 'controllers/*', 'lib/*'],
        'files': {'service.py', 'services.py', 'handler.py', 'controller.py'},
    },
    # 第 7 層：工具/輔助
    'utils': {
        'order': 7,
        'title': '🔧 工具 / 輔助',
        'patterns': ['utils/*', 'helpers/*', 'common/*', 'shared/*'],
        'files': {'utils.py', 'helpers.py', 'common.py', 'tools.py'},
    },
    # 第 8 層：前端/靜態
    'frontend': {
        'order': 8,
        'title': '🎨 前端 / 靜態資源',
        'patterns': ['static/*', 'public/*', 'templates/*', 'assets/*', 'frontend/*', 'src/*'],
        'files': set(),
        'extensions': {'.html', '.css', '.js', '.jsx', '.tsx', '.vue', '.svelte'},
    },
    # 第 9 層：測試
    'tests': {
        'order': 9,
        'title': '🧪 測試',
        'patterns': ['tests/*', 'test/*', '__tests__/*', 'spec/*'],
        'files': set(),
    },
    # 第 10 層：其他
    'other': {
        'order': 99,
        'title': '📁 其他檔案',
        'patterns': [],
        'files': set(),
    },
}


def should_ignore(path: Path) -> bool:
    """判斷是否要忽略此路徑"""
    name = path.name
    if name in IGNORE_DIRS or name in IGNORE_FILES:
        return True
    if name.startswith('.') and name not in {'.env.example', '.gitignore'}:
        return True
    for pattern in IGNORE_FILES:
        if '*' in pattern and name.endswith(pattern.replace('*', '')):
            return True
    return False


def match_pattern(rel_path: str, patterns: list) -> bool:
    """檢查路徑是否符合 pattern"""
    rel_lower = rel_path.lower()
    for pattern in patterns:
        pattern_lower = pattern.lower()
        if pattern_lower.endswith('/*'):
            # 資料夾 pattern
            folder = pattern_lower[:-2]
            if rel_lower.startswith(folder + '/') or ('/' + folder + '/') in rel_lower:
                return True
        elif '*' in pattern_lower:
            # 萬用字元
            regex = pattern_lower.replace('*', '.*')
            if re.match(regex, rel_lower):
                return True
        else:
            if rel_lower == pattern_lower:
                return True
    return False


def classify_file(filepath: Path, root: Path) -> str:
    """分類檔案到對應層級"""
    rel_path = str(filepath.relative_to(root))
    filename = filepath.name.lower()
    ext = filepath.suffix.lower()
    
    for layer_id, layer in LAYER_RULES.items():
        # 1. 檢查檔名
        if filename in layer['files']:
            return layer_id
        
        # 2. 檢查路徑 pattern
        if match_pattern(rel_path, layer['patterns']):
            return layer_id
        
        # 3. 檢查副檔名（僅 frontend 層）
        if layer_id == 'frontend' and ext in layer.get('extensions', set()):
            # 但要排除已經被其他規則匹配的
            if '/static/' in rel_path.lower() or '/templates/' in rel_path.lower() or '/public/' in rel_path.lower():
                return layer_id
    
    # 特殊判斷：test 檔案
    if 'test' in filename or filename.startswith('test_') or filename.endswith('_test.py'):
        return 'tests'
    
    return 'other'


def generate_tree(root: Path, prefix: str = "") -> list[str]:
    """產生目錄樹狀圖"""
    lines = []
    try:
        items = sorted(root.iterdir(), key=lambda x: (x.is_file(), x.name.lower()))
    except PermissionError:
        return lines
    
    items = [x for x in items if not should_ignore(x)]
    
    for i, item in enumerate(items):
        is_last = i == len(items) - 1
        connector = "└── " if is_last else "├── "
        
        if item.is_dir():
            lines.append(f"{prefix}{connector}{item.name}/")
            extension = "    " if is_last else "│   "
            lines.extend(generate_tree(item, prefix + extension))
        else:
            lines.append(f"{prefix}{connector}{item.name}")
    
    return lines


def collect_files(root: Path) -> list[Path]:
    """收集所有程式碼檔案"""
    files = []
    for path in root.rglob('*'):
        if path.is_file() and not should_ignore(path):
            if any(p.name in IGNORE_DIRS for p in path.parents):
                continue
            if path.suffix.lower() in CODE_EXTENSIONS or path.name.lower() in {'dockerfile', 'makefile', 'requirements.txt', 'procfile', 'license'}:
                files.append(path)
    return files


def estimate_importance(filepath: Path, layer: str) -> str:
    """估算檔案重要度"""
    filename = filepath.name.lower()
    
    # 高重要度
    if layer in ('entry', 'overview'):
        return '⭐⭐⭐'
    if layer == 'config' and filename in {'pyproject.toml', 'package.json', 'requirements.txt'}:
        return '⭐⭐⭐'
    if layer == 'api':
        return '⭐⭐⭐'
    if layer == 'models':
        return '⭐⭐'
    if layer == 'core':
        return '⭐⭐⭐'
    
    # 中重要度
    if layer in ('config', 'models'):
        return '⭐⭐'
    
    # 低重要度
    if layer in ('utils', 'tests', 'other'):
        return '⭐'
    if layer == 'frontend':
        return '⭐'
    
    return '⭐'


def get_file_description(filepath: Path) -> str:
    """嘗試從檔案取得描述（docstring 或第一行註解）"""
    try:
        content = filepath.read_text(encoding='utf-8')
        lines = content.split('\n')
        
        # Python docstring
        if filepath.suffix == '.py':
            for i, line in enumerate(lines[:10]):
                if '"""' in line or "'''" in line:
                    # 單行 docstring
                    match = re.search(r'["\'\s]{3}(.+?)["\'\s]{3}', line)
                    if match:
                        return match.group(1).strip()[:60]
                    # 多行 docstring
                    for j in range(i+1, min(i+5, len(lines))):
                        if lines[j].strip() and not lines[j].strip().startswith(('"""', "'''")):
                            return lines[j].strip()[:60]
                    break
        
        # 第一行註解
        for line in lines[:5]:
            line = line.strip()
            if line.startswith('#') and len(line) > 2:
                return line[1:].strip()[:60]
            if line.startswith('//') and len(line) > 3:
                return line[2:].strip()[:60]
            if line.startswith('/*'):
                return line[2:].replace('*/', '').strip()[:60]
    except:
        pass
    return ''


def get_file_handling(filepath: Path) -> dict:
    """決定檔案的處理方式"""
    ext = filepath.suffix.lower()
    filename = filepath.name.lower()
    
    # 完整保留
    if ext in FILE_RULES['full']['extensions'] or filename in FILE_RULES['full']['files']:
        return {'type': 'full'}
    
    # 樣式檔
    if ext in FILE_RULES['style']['extensions']:
        return {'type': 'truncate_lines', 'max_lines': FILE_RULES['style']['max_lines']}
    
    # 資料檔
    if ext in FILE_RULES['data']['extensions']:
        return {'type': 'truncate_lines', 'max_lines': FILE_RULES['data']['max_lines'], 'show_structure': True}
    
    # 程式碼
    if ext in FILE_RULES['code']['extensions']:
        return {'type': 'size_limit', 'max_size': FILE_RULES['code']['max_size']}
    
    # 預設
    return {'type': 'size_limit', 'max_size': 100 * 1024}


def is_important_file(filepath: Path, layer: str) -> bool:
    """判斷是否為重要檔案"""
    ext = filepath.suffix.lower()
    filename = filepath.name.lower()
    
    if ext in IMPORTANT_PATTERNS['extensions']:
        return True
    if filename in IMPORTANT_PATTERNS['files']:
        return True
    if layer in IMPORTANT_PATTERNS['layers']:
        return True
    return False


def read_file_content(filepath: Path, handling: dict) -> tuple[str, bool, str]:
    """
    讀取檔案內容
    回傳: (內容, 是否被截斷, 截斷原因)
    """
    try:
        file_size = filepath.stat().st_size
        
        if handling['type'] == 'full':
            content = filepath.read_text(encoding='utf-8')
            return content, False, ''
        
        elif handling['type'] == 'size_limit':
            max_size = handling['max_size']
            if file_size > max_size:
                return '', True, f'檔案過大（{file_size/1024:.1f} KB > {max_size/1024:.0f} KB）'
            content = filepath.read_text(encoding='utf-8')
            return content, False, ''
        
        elif handling['type'] == 'truncate_lines':
            max_lines = handling['max_lines']
            content = filepath.read_text(encoding='utf-8')
            lines = content.split('\n')
            
            if len(lines) <= max_lines:
                return content, False, ''
            
            truncated = '\n'.join(lines[:max_lines])
            note = f'\n\n# ... 已截斷（顯示前 {max_lines} 行，共 {len(lines)} 行）...\n'
            
            # JSON 顯示結構
            if handling.get('show_structure') and filepath.suffix.lower() == '.json':
                note += '# 這是資料檔，僅顯示開頭結構供參考\n'
            
            return truncated + note, True, f'僅顯示前 {max_lines} 行'
        
        return '', True, '未知處理類型'
        
    except UnicodeDecodeError:
        return '', True, '二進位檔案'
    except Exception as e:
        return '', True, f'讀取錯誤: {e}'


def bundle_project(target_dir: str, output_file: str = None, split_output: bool = False):
    """主程式：整合專案"""
    root = Path(target_dir).resolve()
    
    if not root.exists():
        print(f"❌ 找不到資料夾: {root}")
        return
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M')
    
    # 建立輸出資料夾（扁平結構）
    output_dir = root / f"for_Claude_{timestamp}"
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # bundle 檔案放在輸出資料夾內
    bundle_filename = f"{root.name}_bundle_{timestamp}.txt"
    output_path = output_dir / bundle_filename
    
    skipped_files = []  # [(原始相對路徑, 新檔名), ...]
    
    # 收集並分類檔案
    all_files = collect_files(root)
    layers = defaultdict(list)
    
    for f in all_files:
        layer = classify_file(f, root)
        layers[layer].append(f)
    
    # 排序每層內的檔案
    for layer in layers:
        layers[layer].sort(key=lambda x: str(x).lower())
    
    # 開始輸出
    with open(output_path, 'w', encoding='utf-8') as out:
        # ===== 標題 =====
        out.write(f"{'='*70}\n")
        out.write(f"# 專案：{root.name}\n")
        out.write(f"# 整合時間：{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        out.write(f"# 檔案數量：{len(all_files)}\n")
        out.write(f"{'='*70}\n\n")
        
        # ===== 目錄結構 =====
        out.write("## 📂 目錄結構\n\n")
        out.write("```\n")
        out.write(f"{root.name}/\n")
        for line in generate_tree(root):
            out.write(f"{line}\n")
        out.write("```\n\n")
        
        # ===== 檔案索引 =====
        out.write(f"{'='*70}\n")
        out.write("## 📑 檔案索引\n\n")
        out.write("| 層級 | 檔案 | 說明 | 重要度 |\n")
        out.write("|------|------|------|--------|\n")
        
        sorted_layers = sorted(LAYER_RULES.items(), key=lambda x: x[1]['order'])
        for layer_id, layer_info in sorted_layers:
            if layer_id not in layers:
                continue
            for f in layers[layer_id]:
                rel = f.relative_to(root)
                desc = get_file_description(f)
                importance = estimate_importance(f, layer_id)
                layer_emoji = layer_info['title'].split()[0]
                out.write(f"| {layer_emoji} | `{rel}` | {desc} | {importance} |\n")
        out.write("\n")
        
        # ===== 分層內容 =====
        for layer_id, layer_info in sorted_layers:
            if layer_id not in layers:
                continue
            
            out.write(f"\n{'='*70}\n")
            out.write(f"## {layer_info['title']}\n")
            out.write(f"{'='*70}\n")
            
            for filepath in layers[layer_id]:
                rel_path = filepath.relative_to(root)
                importance = estimate_importance(filepath, layer_id)
                desc = get_file_description(filepath)
                handling = get_file_handling(filepath)
                
                out.write(f"\n{'─'*70}\n")
                out.write(f"### 📄 {rel_path}  {importance}\n")
                if desc:
                    out.write(f"> {desc}\n")
                out.write(f"{'─'*70}\n\n")
                
                # 讀取內容
                content, was_skipped, skip_reason = read_file_content(filepath, handling)
                
                if was_skipped:
                    out.write(f"⚠️ {skip_reason}\n")
                    
                    # 重要檔案複製到輸出資料夾（扁平化，用 -- 取代 /）
                    if is_important_file(filepath, layer_id):
                        # 把路徑轉成檔名：api/routes/auth.py → api--routes--auth.py
                        flat_name = str(rel_path).replace('/', '--').replace('\\', '--')
                        dest = output_dir / flat_name
                        shutil.copy2(filepath, dest)
                        skipped_files.append((rel_path, flat_name))
                        out.write(f"📁 已複製: {flat_name}\n")
                else:
                    lang = filepath.suffix.lstrip('.') or 'text'
                    lang_map = {'txt': 'text', 'yml': 'yaml'}
                    lang = lang_map.get(lang, lang)
                    
                    out.write(f"```{lang}\n")
                    out.write(content)
                    if not content.endswith('\n'):
                        out.write('\n')
                    out.write("```\n")
        
        # ===== 統計 =====
        out.write(f"\n{'='*70}\n")
        out.write("## 📊 統計\n\n")
        for layer_id, layer_info in sorted_layers:
            if layer_id in layers:
                out.write(f"- {layer_info['title']}：{len(layers[layer_id])} 個檔案\n")
        out.write(f"\n**總計：{len(all_files)} 個檔案**\n")
        
        if skipped_files:
            out.write(f"\n### ⚠️ 被跳過的重要檔案（已複製到此資料夾）\n\n")
            out.write("| 原始路徑 | 檔名 |\n")
            out.write("|----------|------|\n")
            for orig, flat in skipped_files:
                out.write(f"| `{orig}` | `{flat}` |\n")
        
        out.write(f"{'='*70}\n")
    
    # 列出資料夾內容
    all_output_files = list(output_dir.iterdir())
    
    print(f"\n{'='*50}")
    print(f"✅ 完成！")
    print(f"{'='*50}")
    print(f"\n📁 輸出資料夾: {output_dir}")
    print(f"\n   請全選以下 {len(all_output_files)} 個檔案上傳到 Claude:")
    for f in sorted(all_output_files, key=lambda x: (not x.name.endswith('.txt'), x.name)):
        print(f"   • {f.name}")
    
    if skipped_files:
        print(f"\n   💡 檔名中的 '--' 代表原本的資料夾層級")
        print(f"      例如: api--routes--auth.py = api/routes/auth.py")
    
    print(f"\n📊 分層統計:")
    for layer_id, layer_info in sorted_layers:
        if layer_id in layers:
            print(f"   {layer_info['title']}：{len(layers[layer_id])} 個")


if __name__ == "__main__":
    import sys
    
    print("=" * 50)
    print("📦 專案整合工具 v2")
    print("=" * 50)
    
    if len(sys.argv) < 2:
        target = "."
        print(f"使用目前目錄: {Path(target).resolve()}")
    else:
        target = sys.argv[1]
    
    output = sys.argv[2] if len(sys.argv) > 2 else None
    bundle_project(target, output)
```

======================================================================
## 📊 統計

- 📋 專案概述：14 個檔案
- ⚙️ 設定檔：4 個檔案
- 🚀 程式進入點：1 個檔案
- 🌐 API / 路由：10 個檔案
- 📦 資料模型：17 個檔案
- 🧠 核心邏輯：19 個檔案
- 🔧 工具 / 輔助：1 個檔案
- 🎨 前端 / 靜態資源：11 個檔案
- 📁 其他檔案：19 個檔案

**總計：96 個檔案**

### ⚠️ 被跳過的重要檔案（已複製到此資料夾）

| 原始路徑 | 檔名 |
|----------|------|
| `static/dashboard.html` | `static--dashboard.html` |
======================================================================
